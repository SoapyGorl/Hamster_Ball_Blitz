import math
import random
import numpy as np
from numpy import array
import pygame
from PIL import Image
import os
from pathlib import Path
import sys
import time
import statistics
import threading
from pygame.locals import *
from OpenGL.GL import *
from OpenGL.GL import glClear, GL_COLOR_BUFFER_BIT, glBegin, GL_QUADS, glEnd, glColor3f, glVertex2f, glFlush, glClearColor
import cv2
#sys.setswitchinterval(0.001)
#sys.maxsize = (2**31) â€“ 1


path = str(os.getcwd()) + '\data'
save_data_path = path + '\Saves\Save1.txt'
save_data_paths = [path + '\Saves\Save1.txt', path + '\Saves\Save2.txt', path + '\Saves\Save3.txt']
default_save_data_path = path + '\Saves\Default_save_data.txt'


def loadTexture(texture):
  text = Image.open(texture)
  textData = np.array(text)
  textID = glGenTextures(1)
  glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
  glBindTexture(GL_TEXTURE_2D, textID)
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER)
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER)
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0)
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0)
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA2, text.size[0], text.size[1], 0, GL_RGBA, GL_UNSIGNED_BYTE, textData)
  text.close()
  del textData
  return (text.size[0], text.size[1]), textID


def make_opengl_rect(image_sizes, cur_ID, offsets, rotate, flip, ltwh):
  adjusted_ltwh = [ltwh[0]/image_sizes[0], ltwh[1]/image_sizes[1], ltwh[2]/image_sizes[0], ltwh[3]/image_sizes[1]]
  if flip:
    rotate = rotate%360
    texts = [(1-adjusted_ltwh[0], 0+adjusted_ltwh[1]), (1-adjusted_ltwh[0], adjusted_ltwh[3]), (1 - adjusted_ltwh[2], adjusted_ltwh[3]), (1 - adjusted_ltwh[2], 0+adjusted_ltwh[1])]
  if not flip:
    rotate = -rotate%360
    texts = [(adjusted_ltwh[2], 0+adjusted_ltwh[1]), (adjusted_ltwh[2], adjusted_ltwh[3]), (adjusted_ltwh[0], adjusted_ltwh[3]), (adjusted_ltwh[0], 0+adjusted_ltwh[1])]
  x_ratio = image_sizes[0]/screen_width
  y_ratio = image_sizes[1]/screen_height
  offset_x = 2*((offsets[0]*aspect)/screen_width)
  offset_y = 2*(offsets[1]/screen_height)
  x_changer1, y_changer1 = abs(adjusted_ltwh[2]-adjusted_ltwh[0]), abs(adjusted_ltwh[3]-adjusted_ltwh[1])
  x_changer2, y_changer2 = -aspect + offset_x, -1 + offset_y
  verts = [((2*aspect*x_changer1*x_ratio)+x_changer2, -y_changer2), ((2*aspect*x_changer1*x_ratio)+x_changer2, -((2*y_changer1*y_ratio)+y_changer2)), (x_changer2, -((2*y_changer1*y_ratio)+y_changer2)), (x_changer2, -y_changer2)]
  if rotate != 0:
    glPushMatrix()
    x_vals = [x for (x, y) in verts]
    y_vals = [y for (x, y) in verts]
    center_x = statistics.mean(x_vals)
    center_y = statistics.mean(y_vals)
    try:
      cur_rot = abs(math.degrees(math.atan((center_y - verts[0][1]) / (center_x - verts[0][0]))))
    except:
      glPopMatrix()
      return
    cur_rots = [cur_rot, 180-cur_rot, 180+cur_rot, 360-cur_rot]
    cur_radius = math.sqrt((center_x - verts[0][0])**2 + (center_y - verts[0][1])**2)
    new_rots = [x + rotate for x in cur_rots]
    new_verts = [0,0,0,0]
    vert_dif = []
    for i in range(4):
      new_verts[i] = (center_x + cur_radius*math.cos(math.radians(new_rots[i])), center_y + cur_radius*math.sin(math.radians(new_rots[i])))
      vert_dif.append((new_verts[i][0] - verts[i][0], new_verts[i][1] - verts[i][1]))
    verts = [new_verts[1], new_verts[2], new_verts[3], new_verts[0]]
    move_image_to_corner_x = min(x_vals) - min([x for (x,y) in verts])
    move_image_to_corner_y = max(y_vals) - max([y for (x,y) in verts])
    verts = [(x+move_image_to_corner_x, y+move_image_to_corner_y) for (x, y) in verts]
    verts = [(verts[2][0], verts[0][1]), (verts[3][0], verts[1][1]), (verts[0][0], verts[2][1]), (verts[1][0], verts[3][1])]
  if flip:
    verts = [(verts[2][0], verts[0][1]), (verts[3][0], verts[1][1]), (verts[0][0], verts[2][1]), (verts[1][0], verts[3][1])]
  #
  inside_of_draw_region = True
  minx, maxx = min([x for (x,y) in verts]), max([x for (x,y) in verts])
  miny, maxy = min([y for (x,y) in verts]), max([y for (x,y) in verts])
  if aspect < minx:
    inside_of_draw_region = False
  if -aspect > maxx:
    inside_of_draw_region = False
  if 1 < miny:
    inside_of_draw_region = False
  if -1 > maxy:
    inside_of_draw_region = False
  if inside_of_draw_region:
    glEnable(GL_TEXTURE_2D)
    glBindTexture(GL_TEXTURE_2D, cur_ID)
    glBegin(GL_QUADS)
    for i in range(4):
      glTexCoord2f(texts[i][0], texts[i][1])
      glVertex2f(verts[i][0], verts[i][1])
    glEnd()
    if rotate != 0:
      glPopMatrix()
    glDisable(GL_TEXTURE_2D)
  else:
    if rotate != 0:
      glPopMatrix()


def start_a_new_save():
  with open(default_save_data_path, 'r') as file:
    current_save_data = file.readlines()
  #
  with open(save_data_path, 'w') as file:
    file.writelines(current_save_data)

#start_a_new_save()


def start_a_new_save_with_path(current_path):
  with open(default_save_data_path, 'r') as file:
    current_save_data = file.readlines()
  #
  with open(current_path, 'w') as file:
    file.writelines(current_save_data)


def everything_save_data(make_changes, change_which_line, new_line_data):
    with open(save_data_path, 'r') as file:
      current_save_data = file.readlines()
      if not make_changes:
        return current_save_data
    #
      if make_changes:
        current_save_data[change_which_line] = new_line_data + '\n'
        with open(save_data_path, 'w') as file:
          file.writelines(current_save_data)
          return current_save_data


def multiple_everything_save_data(make_changes, new_line_data, change_which_line):
    with open(save_data_path, 'r') as file:
      current_save_data = file.readlines()
      if not make_changes:
        return current_save_data
    #
      if make_changes:
        for i in range(len(change_which_line)):
          current_save_data[change_which_line[i]] = new_line_data[i] + '\n'
        with open(save_data_path, 'w') as file:
          file.writelines(current_save_data)
          return current_save_data


def everything_save_data_with_path(make_changes, change_which_line, new_line_data, current_path):
    with open(current_path, 'r') as file:
      current_save_data = file.readlines()
      if not make_changes:
        return current_save_data
    #
      if make_changes:
        current_save_data[change_which_line] = new_line_data + '\n'
        with open(current_path, 'w') as file:
          file.writelines(current_save_data)
          return current_save_data


def read_save_file(save_file_path):
  with open(save_file_path, 'r') as file:
    current_save_data = file.readlines()
  return current_save_data


 #######################
###  INITIALIZE GAME  ###
 #######################


pygame.init()

try:
  import ctypes
  from ctypes import windll
except:
  pass

try:
  user32 = ctypes.windll.user32
  screensize = user32.GetSystemMetrics(0), user32.GetSystemMetrics(1)
  monitor_width, monitor_height = screensize[0], screensize[1]
except:
  monitor_width = pygame.display.Info().current_w
  monitor_height = pygame.display.Info().current_h


monitor_string = str(monitor_width) + 'x' + str(monitor_height)
available_screen_resolutions = [(800, 600), (1024, 768), (1152, 864), (1280, 720), (1280, 768), (1280, 800), (1280, 960), (1280, 1024), (1360, 768), (1366, 768), (1400, 1050), (1440, 900), (1680, 1050), (1920, 1080)]
current_screen_resolution_index = 8


title = 'Hamster Ball Blitz'
os.environ['SDL_VIDEO_CENTERED'] = '1'


found_a_good_screen_size = False

monitor_scaling_factor = 1

for _ in range(1):
  for i, single_available_screen_resolution in enumerate(available_screen_resolutions):
    if (single_available_screen_resolution[0] == monitor_width) and (single_available_screen_resolution[1] == monitor_height):
      screen_width = single_available_screen_resolution[0]
      screen_height = single_available_screen_resolution[1]
      current_screen_resolution_index = i
      found_a_good_screen_size = True
  if found_a_good_screen_size:
    break
  #
  best_screen_size_multiplier_difference = 999999
  best_screen_size_index = 666
  for i, single_available_screen_resolution in enumerate(available_screen_resolutions):
    screen_size_multiplier_x = monitor_width / single_available_screen_resolution[0]
    screen_size_multiplier_y = monitor_height / single_available_screen_resolution[1]
    current_screen_size_multiplier_difference = abs(screen_size_multiplier_x - screen_size_multiplier_y)
    if current_screen_size_multiplier_difference <= best_screen_size_multiplier_difference:
      best_screen_size_multiplier_difference = current_screen_size_multiplier_difference
      current_screen_resolution_index = i
      screen_width = single_available_screen_resolution[0]
      screen_height = single_available_screen_resolution[1]
      monitor_scaling_factor_x = single_available_screen_resolution[0] / monitor_width
      monitor_scaling_factor_y = single_available_screen_resolution[1] / monitor_height
      if (monitor_scaling_factor_y - 0.02 <= monitor_scaling_factor_x <= monitor_scaling_factor_y + 0.02) and (monitor_scaling_factor_x != 1) and (monitor_width <= 1920) and (monitor_height <= 1080):
        if monitor_scaling_factor_x == monitor_scaling_factor_y:
          monitor_scaling_factor = monitor_scaling_factor_x
        if monitor_scaling_factor_x < monitor_scaling_factor_y:
          monitor_scaling_factor = monitor_scaling_factor_y
        if monitor_scaling_factor_x > monitor_scaling_factor_y:
          monitor_scaling_factor = monitor_scaling_factor_x
        screen_width = int(single_available_screen_resolution[0] / monitor_scaling_factor)
        screen_height = int(single_available_screen_resolution[1] / monitor_scaling_factor)

try:
  Screen = pygame.display.set_mode((screen_width, screen_height), pygame.HWSURFACE | pygame.DOUBLEBUF | pygame.OPENGL, vsync=1)
  vsync_is_working = True
except:
  Screen = pygame.display.set_mode((screen_width, screen_height), pygame.HWSURFACE | pygame.DOUBLEBUF | pygame.OPENGL)
  vsync_is_working = False

#Screen = pygame.display.set_mode((screen_width, screen_height), pygame.HWSURFACE | pygame.DOUBLEBUF | pygame.OPENGL, vsync=1)

pygame.display.toggle_fullscreen()
logo_img = pygame.image.load(path + '\Images/Logo.png')
pygame.display.set_icon(logo_img)
pygame.display.set_caption(title)
screen_width, screen_height = Screen.get_size()
aspect = screen_width / screen_height
pygame.mouse.set_visible(False)


glEnable(GL_BLEND)
glBlendEquation(GL_FUNC_ADD)
glMatrixMode(GL_PROJECTION)
glLoadIdentity()
glOrtho(-aspect, aspect, -1, 1, -1, 1)
glMatrixMode(GL_MODELVIEW)
glLoadIdentity()


import pygame.freetype
pygame.font.init()
my_font = pygame.font.SysFont('Comic Sans MS', 30)

for event in pygame.event.get():
  break

LOADING_HAMSTER_FACE_IMAGE = loadTexture(path + '\Images/LoadingHamsterFace.png')
time.sleep(0.25)
make_opengl_rect((screen_width, screen_height), LOADING_HAMSTER_FACE_IMAGE[1], (0, 0), 0, False, (0, 0, screen_width, screen_height))
pygame.display.flip()

#pygame.event.set_grab(True)



 ###############
###  CLASSES  ###
 ###############


def find_hypotnuse(scalar_x, scalar_y):
  return math.hypot(scalar_x, scalar_y)


class PlayerClass():
  def __init__(self, mass, x_pos, y_pos, x_vel, y_vel, x_accel, y_accel, Fx, Fy, Fgx, Fgy, movement_Fx, movement_Fy, piston_Fx, piston_Fy, water_Fx, water_Fy, FNx, FNy, piston1_type, piston2_type, prev_slope_angle, blit_change_x, blit_change_y, x_dif, y_dif, erroring, region):
    super().__init__()
    self.outline_every = 2
    self.mass        = mass
    self.x_pos       = x_pos
    self.y_pos       = y_pos
    self.prev_x_pos  = [x_pos for x in range(20)]
    self.prev_y_pos  = [y_pos for x in range(20)]
    self.x_vel       = x_vel
    self.y_vel       = y_vel
    self.x_accel     = x_accel
    self.y_accel     = y_accel
    self.Fx          = Fx
    self.Fy          = Fy
    #
    self.Fgx         = Fgx
    self.Fgy         = Fgy
    self.movement_Fx = movement_Fx
    self.movement_Fy = movement_Fy
    self.piston_Fx   = piston_Fx
    self.piston_Fy   = piston_Fy
    self.water_Fx = water_Fx
    self.water_Fy = water_Fy
    self.forces_for_next_frame_x = 0
    self.forces_for_next_frame_y = 0
    self.how_submerged = 0
    self.max_number_of_bubbles = 5
    self.current_number_of_bubbles = self.max_number_of_bubbles
    self.milliseconds_until_next_bubble = 500 # for physics
    self.milliseconds_since_last_bubble = 0
    self.milliseconds_before_creating_bubble_particle = 600 # pretty particle
    self.current_milliseconds_before_creating_bubble_particle = 0
    self.in_a_pipe = False
    self.in_which_pipe = 666
    self.last_step_in_pipe_path = 0
    self.step_in_pipe_path = 0
    self.got_centered_in_pipe = False
    self.initial_pipe_adjustment_to_center_x = 0
    self.initial_pipe_adjustment_to_center_y = 0
    self.initial_player_position_when_touching_pipe_x = 0
    self.initial_player_position_when_touching_pipe_y = 0
    self.final_desired_pipe_position_x = 0
    self.final_desired_pipe_position_y = 0
    self.in_pipe_wind = False
    self.on_a_surf_board = False
    self.not_yet_on_the_board = False
    self.on_which_surf_board = 666
    self.riding_a_wave = False
    self.riding_a_wave_last_few_frames = [False for x in range(20)]
    self.how_long_riding_a_wave = 0
    self.on_which_bucket = 666
    #
    self.carrying_food = False
    self.carrying_which_food = 666
    self.talked_to_eating_rat_before = False
    #
    self.surfing_check_points = False
    self.surfing_wipeout = False
    self.surfing_catch_the_board = False
    self.time_since_leaving_board = 0
    self.allow_catch_the_board_points = False
    self.surfing_spin = False
    self.surfing_starting_spin_rotation = 0
    self.surfing_spin_checkpoints = [False, False, False, False]
    self.on_a_cloud_prev_frames = [False, False, False, False, False, False, False, False]
    self.surfing_riding_wave = False
    self.wave_size_multiplier = 1
    self.surfing_going_really_high = False
    self.height_needed_to_start_going_really_high = 1840
    self.surfing_high_points_to_add = 0
    self.surfing_continue_adding_points_above_head = False
    self.milliseconds_since_last_adding_points = 0
    self.milliseconds_allowed_before_making_a_new_number = 200
    #
    self.FNx         = FNx
    self.FNy         = FNy
    #
    self.blit_change_x = blit_change_x
    self.blit_change_y = blit_change_y
    self.x_dif = x_dif
    self.y_dif = y_dif
    self.piston1_type = piston1_type
    self.piston2_type = piston2_type
    self.prev_slope_angle = prev_slope_angle
    self.erroring = erroring
    self.region = region
    self.skip_the_rest_of_the_water = False
    self.changed_region_last_frame = True
    self.solid_ball_points = []
    self.flipped = False
    self.current_activity = ''
    #
    self.image = PyGameTextures['PLAYER_BALL']
    self.GPU_image = OpenGLTextures['PLAYER_BALL']
    self.current_image = self.image
    self.GPU_current_image = self.GPU_image
    self.rect  = self.image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.image)
    #
    self.change_in_x_pos = 0
    self.change_in_y_pos = 0
    self.cloud_change_in_x_pos = 0
    self.circumference = 2*(math.pi)*34.5
    self.Hamster_image_rotation = 0
    self.ball_image_rotation = 0
    self.previous_ball_image_rotation = 0
    self.ball_image_rotation_getting_on_surf_board = 0
    self.GPU_THE_BALL_FRONT = OpenGLTextures['THE_BALL_FRONT']
    self.GPU_THE_BALL_BACK = OpenGLTextures['THE_BALL_BACK']
    #
    self.Hamster_activities_during_frame = []
    self.Hamster_forced_spin = False
    self.Hamster_activities_during_previous_frames = [[] for x in range(10)]
    self.started_rolling_frame = 0
    self.adjust_x_pos = 0
    self.adjust_y_pos = 0
    #
    self.connected_to_door_with_knob = False
    self.connected_to_which_door_with_knob = 666
    self.connected_to_which_knob = 666
    #
    self.milliseconds_before_next_float_animation = ((96 / ((1 / 13) * 1000)) / 4) * 1000
    self.milliseconds_before_next_walk_animation = ((44 / ((1 / 13) * 1000)) / 4) * 1000
    self.current_milliseconds_before_next_float_animation = 0
    self.current_milliseconds_before_next_walk_animation = 0
    self.current_float_image_index = 0
    self.current_walk_image_index = 0
    #
    self.GPU_current_Hamster_image = OpenGLTextures['HAMSTER_STANDING_RIGHT']
    self.GPU_HamsterStandingRight = OpenGLTextures['HAMSTER_STANDING_RIGHT']
    self.GPU_HamsterWalkingRight = OpenGLTextures['HAMSTER_WALKING_RIGHT']
    self.GPU_RollingClockwise = OpenGLTextures['ROLLING_CLOCKWISE']
    self.GPU_HamsterFloatRight = OpenGLTextures['HAMSTER_FLOAT_RIGHT']
    self.GPU_HamsterFallingRight = OpenGLTextures['HAMSTER_FALLING_RIGHT']
    self.GPU_HamsterFlyingRight = OpenGLTextures['HAMSTER_FLYING_RIGHT']
    self.current_Hamster_image = self.GPU_current_Hamster_image
    #
    self.CollectedUpgrades = [False for x in range(12)]
    self.changed_region_last_frame = False
    #
    self.collected_screw_driver = False
    self.collected_wire_cutter = False
    self.collected_wrench = False
    self.able_to_insert_into_machine = False
    #
    self.dialogue_millisecond_counter = 0
    self.which_dialogue = 0
    #
    self.allowed_door_privileges = False
    self.intro_data = [0, 0, 0, 0, 0, 0]
    self.post_tutorial_data = [0, 0]
    self.hamster_thinks_her_goal = False
    self.talked_fast_travel = False
    #
    self.has_piston1 = False
    self.has_piston2 = False
    self.have_detached_before = False
    #
  def update(self, x_pos, y_pos):
    self.rect.center = (x_pos, y_pos)


class BubbleParticle():
  def __init__(self, x_pos, y_pos, starting_submersion, png_name):
    super().__init__()
    self.images = OpenGLTextures[png_name]
    self.GPU_current_image = self.images[0]
    self.ltwh = [0, 0, self.images[0][0][0], self.images[0][0][1]]
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.x_vel = 0
    self.y_vel = 0
    self.y_accel = -190
    self.starting_submersion = starting_submersion
    self.current_submersion = starting_submersion
    self.milliseconds_per_update = 16
    self.current_milliseconds_before_update = 0
    self.will_destruct = False


class Universal():
  def __init__(self):
    self.current_main_menu_frame = 0

my_universal_info = Universal()

class CachedInfo():
  def __init__(self):
    super().__init__()
    all_current_save_data = everything_save_data(False, 0, '')
    self.number_of_textures_to_delete = 0
    self.texture_IDs_to_delete = []
    self.target_fps_over_fps = 1
    self.fake_frame_counter_float = 0
    self.fake_frame_counter = 0
    self.number_of_frames_happening_this_frame = 0
    self.whole_number_of_frames_this_frame = 0
    self.remainder_number_of_frames_for_next_frame = 0
    self.milliseconds_needed_to_make_new_wave = 3000
    self.current_milliseconds_needed_to_make_new_wave = self.milliseconds_needed_to_make_new_wave - 100
    self.milliseconds_needed_to_complete_surfing_challenge = 60000
    self.current_milliseconds_in_surfing_challenge = 0
    self.points_needed_to_win_surfing_challenge = 1000
    self.current_surfing_points = 0
    self.on_a_loading_screen = False
    self.loaded_in_last_frame = False
    self.allow_pause_change = True
    self.currently_pausing = False
    self.pause_happened_this_frame = False
    self.close_the_game = False
    self.playing_upgrade_sequence = False
    self.milliseconds_into_upgrade_sequence = 0
    self.milliseconds_to_complete_upgrade_sequence = 3500
    self.milliseconds_into_upgrade_flying_around_player = 0
    self.milliseconds_to_complete_upgrade_flying_around_player = 2000
    self.upgrade_finished_flying_around_player = False
    self.bubble_flying_number_of_pixels_to_move = 0
    self.play_tool_sequence = False
    self.milliseconds_into_tool_flying_around_player = 0
    self.milliseconds_to_complete_tool_flying_around_player = 2000
    self.leaving_the_door5 = False
    self.won_the_game = False
    self.time_since_winning_game = 0
    self.play_intro_sequence = False
    self.played_intro_sequence_last_frame = False
    self.stage_in_intro = 0
    self.frame_in_intro = 0
    self.milliseconds_in_intro_stage = 0
    self.intro_x = 2347 + (114 / 2)
    self.intro_y = 769 + (250 / 2)
    self.last_intro_x = 2347 + (114 / 2)
    self.last_intro_y = 769 + (250 / 2)
    self.first_frame_in_intro_step = True
    self.intro_hamster_rotation = 0
    self.saved_hamster_x = 0
    self.saved_hamster_y = 0
    self.intro_screen_centers = [(2638, 960), (947, 1387), (616 + (246/2), 2583 + (202 / 2))]
    self.intro_screen_times = [1144+169+312+1573+755+546+1607, 2600]
    self.intro_ahhh_timer = 0
    self.leaving_intro = False
    self.windowed = True
    #
    self.ForestThemePath = path + '\Music\Forest\Forest_Theme.mp3'
    self.SewerThemePath = path + '\Music\Sewer\Sewer_Theme.mp3'
    self.PlayingForestTheme = False
    self.PlayingSewerTheme = False
    self.current_music_loudness = float(everything_sound_data(False, 666, 0)[0])
    self.current_sound_loudness = float(everything_sound_data(False, 666, 0)[1])
    self.playing_quiet_water_jet = False
    self.playing_loud_water_jet = False
    self.playing_extend_grapple = False
    self.play_retract_grapple = False
    self.play_special_collision_sound = False
    self.play_teetertotter_collision = False
    self.play_cloud_collision = False
    self.milliseconds_before_playing_cloud_collision_again = 0
    self.number_of_ant_sounds_being_played = 0
    self.playing_door_sound = False
    self.load_from_previous_location = False
    self.last_map_region = all_current_save_data[59][0:-1]
    self.desired_last_map_region = all_current_save_data[59][0:-1]
    self.teleported = True
    self.index_for_changing_regions = 0
    self.last_submersion = 0
    if all_current_save_data[84][0] == '0':
      self.show_play_time = False
    if all_current_save_data[84][0] == '1':
      self.show_play_time = True
    self.play_time = int(all_current_save_data[83])
    self.loading_time = 0
    self.return_to_main_menu = False
    self.milliseconds_can_go_back_in_transport_pipe = 0
    self.can_go_back_in_transport_pipe = True
    self.milliseconds_dont_show_trash_sublevel_difficulty = 0
    self.milliseconds_leaving_cloud = 0
    self.allow_glowing_green_button = False
    self.can_play_human_walking_sound_during_intro = True
    self.playing_transport_pipe_suck = False
    self.playing_irregular_surfing_water = False
    self.closest_transport_pipe_distance = 10000
    self.play_intro_machine_sound = True
    self.doing_the_back = True
    self.fast_travel_dialogue_milliseconds = 0
    self.got_boost = False
    self.got_boost_milliseconds = 0
    self.grass_updates_this_frame = 0
    self.food_that_exists = [False, False, False, False]
    self.playing_irregularly_shaped_water_sound = False
    self.early_last_intro_x = 2294 + (114 / 2)
    self.early_last_intro_y = 745 + (250 / 2)
    self.playing_wave_sound = False

#My_cached_info = CachedInfo()

class MyMap(pygame.sprite.Sprite):
  def __init__(self, x_pos, y_pos, change_region_points, new_regions, spawn_location, region, forced_exit, forced_exit_points, forced_exit_next_map, png_name):
    super().__init__()
    self.png_name = png_name
    self.x_pos = x_pos
    self.y_pos = y_pos
    #
    self.change_region_points = change_region_points # [low_x, high_x, low_y, high_y]
    self.new_regions = new_regions
    self.spawn_location = spawn_location # a number
    self.region = region
    self.forced_exit = forced_exit
    self.forced_exit_points = forced_exit_points
    self.forced_exit_next_map = forced_exit_next_map
    #
    path_str = path + '\Images/' + png_name
    self.image = pygame.image.load(MAP_images[png_name])
    self.current_image = self.image
    self.GPU_image = loadTexture_only_img_data(MAP_images[png_name])
    self.rect  = self.image.get_rect(center = (x_pos, y_pos))
    self.mask  = pygame.mask.from_surface(self.image)


class Background():
  def __init__(self, scroll_leftright, scroll_updown, iteration_speed, scroll_speed_x, scroll_speed_y, scale, scale_size, permanent_add_x, permanent_add_y, use_convert_alpha, special_directions, png_name):
    super().__init__()
    self.special_directions = special_directions
    self.permanent_add_x = permanent_add_x
    self.permanent_add_y = permanent_add_y
    self.scroll_leftright = scroll_leftright
    self.scroll_updown = scroll_updown
    self.iteration_speed = (iteration_speed / ((1 / 13) * 1000)) * 1000
    self.number_of_milliseconds_since_updating_image = 0
    self.current_image_number = 0
    self.scroll_speed_x = scroll_speed_x
    self.scroll_speed_y = scroll_speed_y
    self.scale = scale
    self.scale_size = scale_size
    self.left = 0
    self.top = 0
    self.num_wide = 0
    self.num_tall = 0
    self.x_pos = 0
    self.y_pos = 0
    self.width = screen_width
    self.height = screen_height
    #
    #self.images = PyGameTextures[png_name]
    self.GPU_images = OpenGLTextures[png_name]
    #self.image = self.images[0]
    self.GPU_image = self.GPU_images[0]
    self.current_x_poses = [0]
    self.current_y_poses = [0]
    #self.current_images = [self.image]
    self.GPU_current_images = [self.GPU_image]
    #self.rect  = self.image.get_rect(center = (self.x_pos, self.y_pos))
    #self.mask  = pygame.mask.from_surface(self.image)
    if special_directions == 1:
      self.x_pos = random.randint(0, screen_width)
      self.y_pos = random.randint(0, screen_width)
    if special_directions == 2:
      self.x_pos = random.randint(-9000, -2000)
      self.y_pos = random.randint(0, screen_width)


class TheMarker(pygame.sprite.Sprite):
  def __init__(self, x_pos, y_pos, prev_x_pos, prev_y_pos, png_name):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos


class BallCollision():
  def __init__(self, x_pos, y_pos, offset_x, offset_y, png_name):
    super().__init__()
    self.outline_every = 2
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.offset_x = offset_x
    self.offset_y = offset_y
    self.png_name = png_name
    #
    self.image = pygame.image.load(path + '\Images\Ball Collision' + '/' + self.png_name).convert_alpha()
    self.current_image = self.image
    self.rect  = self.image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.image)


class PistonSheath():
  def __init__(self, rotation, x_pos, y_pos):
    super().__init__()
    #
    self.rotation = rotation
    self.x_pos = x_pos
    self.y_pos = y_pos
    #
    self.image = PyGameTextures['SHEATH']
    self.GPU_image = OpenGLTextures['SHEATH']
    self.current_image = self.image
    self.rect  = self.image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.image)


class PushPiston():
  def __init__(self, extension, prev_extension, maximum_extension, x_pos, y_pos):
    super().__init__()
    self.outline_every = 3
    self.extension = extension
    self.extension_float = extension
    self.extension_float_added = extension
    self.prev_extension = prev_extension
    self.maximum_extension = maximum_extension
    #
    self.x_pos = x_pos
    self.y_pos = y_pos
    #
    #self.all_images = PyGameTextures['PUSH_PISTON']
    #self.image = PyGameTextures['PUSH_PISTON'][0]
    #
    self.Cover_x_pos = x_pos
    self.Cover_y_pos = y_pos
    self.cropped_region = [0, 0, self.extension, 9]
    self.segment_of_piston_showing = [0, 0]
    self.CoverImage = PyGameTextures['PUSH_PISTON_COVER']
    self.GPU_CoverImage = OpenGLTextures['PUSH_PISTON_COVER']
    self.cropped_current_CoverImage = self.CoverImage
    self.current_CoverImage = self.CoverImage
    self.CoverRect = self.CoverImage.get_rect(center = (self.x_pos, self.y_pos))
    self.CoverMask = pygame.mask.from_surface(self.CoverImage)
    #
    self.cropped_current_CoverImage = self.CoverImage.subsurface((self.cropped_region[0], self.cropped_region[1], self.cropped_region[2], self.cropped_region[3]))
    self.current_image, self.CoverRect = rotate_rectangular_image(self.cropped_current_CoverImage, self.CoverRect, 0)
    self.rect  = self.current_image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.current_image)
    #
    self.cur_offset_x = 0
    self.cur_offset_y = 0
    #
    self.number_of_pixels_to_move = 0
    #
    self.Splash_x_pos = x_pos
    self.Splash_y_pos = y_pos
    self.number_of_milliseconds_before_new_splash = 4*13
    self.current_splash_image_index = 0
    self.current_number_of_splash_milliseconds = 0
    self.SplashRotation = 0
    self.SplashImages = PyGameTextures['SPLASH']
    self.GPU_SplashImages = OpenGLTextures['SPLASH']
    self.current_Splash = self.SplashImages[0]
    self.GPU_current_Splash = self.GPU_SplashImages[0]
    self.SplashRect = self.current_Splash.get_rect(center = (self.x_pos, self.y_pos))
    self.SplashMask = pygame.mask.from_surface(self.current_Splash)
    self.is_touching_wall = [False for x in range(6)]


class GrapplePiston():
  def __init__(self, extension, maximum_extension, x_pos, y_pos, is_closed, is_currently_grappling, grapple_claw_x_pos, grapple_claw_y_pos, connected_to_map, connected_to_vine, connected_to_cloud):
    super().__init__()
    self.outline_every = 3
    self.extension = extension
    self.extension_float = extension
    self.extension_float_added = extension
    self.maximum_extension = maximum_extension
    self.last_extension = extension
    self.last_five_extensions = [extension for x in range(5)]
    #
    self.x_pos = x_pos
    self.y_pos = y_pos
    #
    self.is_closed = is_closed
    self.is_currently_grappling = is_currently_grappling
    self.grapple_claw_x_pos = grapple_claw_x_pos
    self.grapple_claw_y_pos = grapple_claw_y_pos
    self.last_grapple_claw_x = grapple_claw_x_pos
    self.last_grapple_claw_y = grapple_claw_y_pos
    self.cur_offset_x = 0
    self.cur_offset_y = 0
    #
    #self.all_images = PyGameTextures['GRAPPLE_PISTON']
    #self.image = PyGameTextures['GRAPPLE_PISTON'][0]
    #self.current_image = self.image
    #self.rect  = self.image.get_rect(center = (self.x_pos, self.y_pos))
    #self.mask  = pygame.mask.from_surface(self.image)
    #
    self.Cover_x_pos = x_pos
    self.Cover_y_pos = y_pos
    self.cropped_region = [0, 0, self.extension, 26]
    self.segment_of_piston_showing = [0, 0]
    self.CoverImage = PyGameTextures['GRAPPLE_PISTON_COVER']
    self.GPU_CoverImage = OpenGLTextures['GRAPPLE_PISTON_COVER']
    self.ClosedCoverImage = PyGameTextures['GRAPPLE_PISTON_CLOSED_COVER']
    self.GPU_ClosedCoverImage = OpenGLTextures['GRAPPLE_PISTON_CLOSED_COVER']
    self.cropped_current_CoverImage = self.CoverImage
    self.current_CoverImage = self.CoverImage
    self.GPU_current_CoverImage = self.GPU_CoverImage
    self.CoverRect = self.CoverImage.get_rect(center = (self.x_pos, self.y_pos))
    self.CoverMask = pygame.mask.from_surface(self.CoverImage)
    #
    self.cropped_current_CoverImage = self.CoverImage.subsurface((self.cropped_region[0], self.cropped_region[1], self.cropped_region[2], self.cropped_region[3]))
    self.current_image, self.CoverRect = rotate_rectangular_image(self.cropped_current_CoverImage, self.CoverRect, 0)
    self.rect  = self.current_image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.current_image)
    #
    self.connected_to_map = connected_to_map
    self.connected_to_vine = connected_to_vine
    self.connected_to_cloud = connected_to_cloud
    self.connected_to_lever = False
    self.connected_to_which_lever = 666
    #
    self.radius_from_center_of_vine_segment = 0
    #
    self.letgo_timer = 0


class Vine():
  def __init__(self, x_pos, y_pos, vine_length, vine_segment_length, rotation, angular_accel, angular_vel, is_the_player_swinging, connected_segment_of_vine, max_angular_accel, png_name, vine_type):
    super().__init__()
    self.vine_type = vine_type
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.orig_rotation = rotation
    self.orig_angular_vel = angular_vel
    self.allow_reset = False
    self.time_since_resetting = 0
    self.reached_pos = False
    self.reached_neg = False
    self.vine_length = vine_length
    self.vine_segment_length = vine_segment_length
    self.rotation = rotation
    self.angular_accel = angular_accel
    self.angular_vel = angular_vel
    self.is_the_player_swinging = is_the_player_swinging
    self.connnected_segment_of_vine = connected_segment_of_vine
    self.max_angular_accel = max_angular_accel
    self.grapple_added_x_pos = 0
    self.grapple_added_y_pos = 0
    self.my_sound = pygame.mixer.Sound(path + '\Sounds\Forest\Vines\WholeVine.wav')
    self.in_sound_range = False
    self.allow_another_sound_to_play = True
    self.png_name = png_name
    #
    self.image = PyGameTextures[png_name]
    self.GPU_image = OpenGLTextures[png_name]
    self.GPU_current_image = self.GPU_image
    self.rect  = self.image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.image)
    try:
      self.current_image = rotate_square_image(self.image, self.rotation)
    except:
        self.current_image, self.rect = rotate_rectangular_image(self.image, self.rect, self.rotation)
    #
    self.x_poss = []
    self.y_poss = []
    self.images = []
    self.current_images = []
    self.GPU_images = []
    self.GPU_current_images = []
    self.rects = []
    self.masks = []
    self.rotations = []
    for i in range(vine_length):
      self.x_poss.append(self.x_pos)
      self.y_poss.append(self.y_pos + (self.vine_segment_length * i))
      self.images.append(self.image)
      self.current_images.append(self.current_image)
      self.GPU_images.append(self.GPU_image)
      self.GPU_current_images.append(self.GPU_current_image)
      self.rects.append(self.images[i].get_rect(center = (self.x_poss[i], self.y_poss[i])))
      self.masks.append(pygame.mask.from_surface(self.images[i]))
      self.rotations.append(self.rotation)
    self.radius = find_hypotnuse(abs(self.x_poss[0] - self.x_poss[-1]) + self.rect[2], abs(self.y_poss[0] - self.y_poss[-1]) + self.rect[3])


class Cloud():
  def __init__(self, x_pos, y_pos, x_vel, y_vel, x_accel, y_accel, is_the_player_swinging, standing_on_cloud, png_name, png_name2, fall_off_left, fall_off_right):
    super().__init__()
    self.fall_off_left = fall_off_left
    self.fall_off_right = fall_off_right
    self.center_x = x_pos
    self.center_y = y_pos
    self.prev_x_pos = x_pos
    self.prev_y_pos = y_pos
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.max_x_vel = 0
    self.max_y_vel = 0
    self.x_vel = x_vel
    self.y_vel = y_vel
    self.orig_x_vel = x_vel
    self.orig_y_vel = y_vel
    self.x_accel = x_accel
    self.y_accel = y_accel
    self.is_the_player_swinging = is_the_player_swinging
    self.standing_on_cloud = standing_on_cloud
    self.time_existing = 0
    #
    self.shown_image = PyGameTextures[png_name2]
    self.image = PyGameTextures[png_name]
    self.current_image = self.image
    self.GPU_shown_image = OpenGLTextures[png_name2]
    self.GPU_image = OpenGLTextures[png_name]
    self.GPU_current_image = self.GPU_image
    self.rect  = self.image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.image)
    self.radius = find_hypotnuse(self.rect[2]/2, self.rect[3]/2)


class TeeterTotter():
  def __init__(self, x_pos, y_pos, collision_circle_x, collision_circle_y, collision_circle_radius, pivot_x, rotation, angular_vel, angular_accel, is_the_player_on, is_the_push_piston_pushing, png_name):
    super().__init__()
    self.outline_every = 5
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.original_x_pos = x_pos
    self.original_y_pos = y_pos
    self.collision_circle_x = collision_circle_x
    self.collision_circle_y = collision_circle_y
    self.collision_circle_radius = collision_circle_radius
    self.pivot_x = pivot_x
    self.rotation = rotation
    self.angular_vel = angular_vel
    self.angular_accel = angular_accel
    self.is_the_player_on = is_the_player_on
    self.is_the_push_piston_pushing = is_the_push_piston_pushing
    #
    self.image = PyGameTextures[png_name]
    self.current_image = self.image
    self.GPU_image = OpenGLTextures[png_name]
    self.GPU_current_image = self.GPU_image
    self.rect  = self.image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.image)
    self.cur_rect = self.rect


class SubLevelDifficulty():
  def __init__(self, center_of_door_x, center_of_door_y, difficulty):
    self.player_has_been_close_before = False
    if 0 <= difficulty <= 3:
      self.center_of_door_x = center_of_door_x + 1
      self.center_of_door_y = center_of_door_y
      self.difficulty = difficulty
      #
      self.player_is_close = False
      self.milliseconds_player_started_being_close = 0
      self.milliseconds_player_stopped_being_close = 0
      self.millisecond_counter = 0
      self.milliseconds_to_completion = 300
      #
      self.GPU_image = OpenGLTextures['DIFFICULTY_SLIDER'][difficulty]
      self.x_pos = self.center_of_door_x - 89
      self.y_pos = self.center_of_door_y - 215
      self.allowed_to_display = True
    #
    if difficulty == 4:
      self.center_of_door_x = center_of_door_x + 1
      self.center_of_door_y = center_of_door_y
      self.difficulty = difficulty
      #
      self.player_is_close = False
      self.milliseconds_player_started_being_close = 0
      self.milliseconds_player_stopped_being_close = 0
      self.millisecond_counter = 0
      self.milliseconds_to_completion = 300
      #
      self.GPU_image = OpenGLTextures['BLANK_DIFFICULTY_SLIDER']
      self.x_pos = self.center_of_door_x - 89
      self.y_pos = self.center_of_door_y - 215 + 79
      self.allowed_to_display = True
    #
    if difficulty == 5:
      self.center_of_door_x = center_of_door_x + 1
      self.center_of_door_y = center_of_door_y
      self.difficulty = difficulty
      #
      self.player_is_close = False
      self.milliseconds_player_started_being_close = 0
      self.milliseconds_player_stopped_being_close = 0
      self.millisecond_counter = 0
      self.milliseconds_to_completion = 300
      #
      self.GPU_image = OpenGLTextures['TO_SEARCH_TRASH']
      self.x_pos = self.center_of_door_x - 89
      self.y_pos = self.center_of_door_y - 215 + 64
      self.allowed_to_display = True


class Trash():
  def __init__(self, x_pos, y_pos, png_collectable, which_index):
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.trash_has_been_collected = False
    self.player_is_close_enough_to_collect = False
    self.which_index = which_index
    self.GPU_trash_image = OpenGLTextures['TRASH']
    self.GPU_collectable = OpenGLTextures[png_collectable]


class SimplySprite():
  def __init__(self, x_pos, y_pos, png_name):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos
    path_str = path + '\Images/' + png_name
    #
    self.GPU_image = OpenGLTextures[png_name]
    self.GPU_current_image = self.GPU_image


class Grass():
  def __init__(self, x_pos, y_pos, flipped, milliseconds_to_next_image, in_the_back, png_name):
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.flipped = flipped
    self.png_name = png_name
    self.current_image_index = 0
    self.milliseconds_to_next_image = milliseconds_to_next_image
    self.current_milliseconds_to_next_image = 0
    self.in_the_back = in_the_back


class WaterCover():
  def __init__(self, x_pos, y_pos, png_name):
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.GPU_image = OpenGLTextures[png_name]


class SimplySpriteDeleteLater():
  def __init__(self, x_pos, y_pos, png_name):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos
    path_str = path + '\Images/' + png_name
    #
    self.GPU_image = OpenGLTextures[png_name]
    self.GPU_current_image = self.GPU_image
    My_cached_info.number_of_textures_to_delete += 1
    My_cached_info.texture_IDs_to_delete.append(self.GPU_image[1])


class MapSimplySprite():
  def __init__(self, x_pos, y_pos, png_name):
    super().__init__()
    self.png_name = png_name
    self.x_pos = x_pos
    self.y_pos = y_pos
    path_str = path + '\Images/' + png_name
    #
    self.GPU_image = loadTexture_only_img_data(MAP_images[png_name])
    self.GPU_current_image = self.GPU_image


class TV_class():
  def __init__(self, x_pos, y_pos):
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.GPU_image = OpenGLTextures['TV']
    self.GPU_marker = OpenGLTextures['TV_MARKER']
    self.xy_poses = [(29, 77), (473, 114), (59, 248), (324, 248)]
    self.active_dots = [True, False, False, False]


class Propeller():
  def __init__(self, x_pos, y_pos, flipped, collision_box_width, bubbles_png, propeller_type):
    self.propeller_type = propeller_type
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.flipped = flipped
    self.collision_box_width = collision_box_width
    self.is_on = True
    self.current_image_index = 0
    if propeller_type == 1 or propeller_type == 3 or propeller_type == 4:
      self.GPU_images = OpenGLTextures['PROPELLER']
      self.GPU_current_image = self.GPU_images[0]
    if propeller_type == 2 or propeller_type == 7:
      self.GPU_images = OpenGLTextures['PROPELLER_DOWN']
      self.GPU_current_image = self.GPU_images[0]
    if propeller_type == 5 or propeller_type == 6:
      self.GPU_images = OpenGLTextures['PROPELLER_UP']
      self.GPU_current_image = self.GPU_images[0]
      if propeller_type == 6:
        self.extend_the_whole_way = False
    #
    self.milliseconds_per_image_update = (5 / ((1 / 13) * 1000)) * 1000
    self.milliseconds_since_image_update = 0
    #
    self.current_bubbles_x = random.randint(0, collision_box_width)
    self.GPU_bubbles_png = OpenGLTextures[bubbles_png]


class Lever():
  def __init__(self, x_pos, y_pos, flipped, time_added_from_charge, lever_index):
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.flipped = flipped
    self.time_added_from_charge = time_added_from_charge*13
    #
    self.GPU_block_image = OpenGLTextures['BLOCK']
    #
    self.current_bolt_index = 0
    self.last_bolt_index = 0
    if not flipped:
      self.bolt_added_x_pos = 70-21
      self.bolt_added_y_pos = 48
    if flipped:
      self.bolt_added_x_pos = 16
      self.bolt_added_y_pos = 48
    self.GPU_bolt_images = OpenGLTextures['BOLT']
    self.GPU_current_bolt_image = self.GPU_bolt_images[0]
    self.allow_another_charge = True
    self.last_charge_time = 0
    #
    #
    self.current_lever_index = 0
    self.last_lever_index = 0
    if not flipped:
      self.lever_added_x_pos = -16-21
      self.lever_added_y_pos = 34
    if flipped:
      self.lever_added_x_pos = 74
      self.lever_added_y_pos = 34
    self.GPU_lever_images = OpenGLTextures['LEVER']
    self.GPU_current_lever_image = self.GPU_lever_images[0]
    self.images = PyGameTextures['LEVER']
    self.current_image = self.images[0]
    self.rect  = self.images[0].get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.images[0])
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])
    #
    if not flipped:
      self.lever_xy = [(23, 6), (15, 16), (10, 27), (10, 40), (11, 54), (16, 65), (23, 75)]
    if flipped:
      self.lever_xy = [(60-23, 6), (60-15, 16), (60-10, 27), (60-10, 40), (60-11, 54), (60-16, 65), (60-23, 75)]
    self.lever_index = lever_index
    self.going_down = True
    #
    self.milliseconds_before_moving_lever_up = (7 / ((1 / 13) * 1000)) * 1000
    self.current_milliseconds_before_moving_lever_up = 0
    self.milliseconds_before_updating_lever_in_do_everything_grapple_piston = (7 / ((1 / 13) * 1000)) * 1000
    self.current_milliseconds_before_updating_lever_in_do_everything_grapple_piston = 0


class MovingSprite():
  def __init__(self, x_pos, y_pos, number_of_frames, current_frame, frame_duration, png_name):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.number_of_frames = number_of_frames
    self.current_frame = current_frame
    self.current_time_before_frame_switch = 0
    self.time_needed_before_frame_switch = frame_duration*13
    self.frame_duration = frame_duration
    path_str = path + '\Images/' + png_name
    #
    self.GPU_image = OpenGLTextures[png_name]
    self.GPU_current_image = self.GPU_image


class Ant():
  def __init__(self, x_pos, y_pos, vel, vel_multiplier, check_x_range, check_y_range, frequency_of_key_check, rotation, frames_per_image_update, current_ant_frame, is_searching, found_a_misplaced_object, is_returning_object, ant_type, boundaries, png_name1, png_name2):
    super().__init__()
    self.outline_every = 10
    self.ant_type = ant_type
    self.sound = pygame.mixer.Sound(path + '\Sounds\AntHill\Ant.wav')
    self.currently_playing_sound = False
    if ant_type == 1 or ant_type == 2:
      self.x_pos = x_pos
      self.y_pos = y_pos
      self.orig_x_pos = x_pos
      self.orig_y_pos = y_pos
      self.vel = vel
      self.orig_vel = vel
      self.vel_multiplier = vel_multiplier
      self.check_x_range = check_x_range
      self.check_y_range = check_y_range
      self.search_radius = find_hypotnuse(check_x_range, check_y_range)
      self.frequency_of_key_check = frequency_of_key_check
      self.rotation = rotation
      self.frames_per_image_update = frames_per_image_update*13
      self.milliseconds_at_last_image_update = curr_time
      self.current_ant_frame = current_ant_frame
      self.time_since_last_image_update = 0
      self.time_since_last_search = 13
      self.random_image_update_time = random.randint(0, 30)
      self.returning_home = False
      self.is_searching = is_searching
      self.found_a_misplaced_object = found_a_misplaced_object
      self.misplaced_object_index = -1
      self.is_returning_object = is_returning_object
      self.boundaries = boundaries
      self.image1 = PyGameTextures[png_name1][0]
      self.image2 = PyGameTextures[png_name1][1]
      self.current_image = self.image1
      self.GPU_image1 = OpenGLTextures[png_name1][0]
      self.GPU_image2 = OpenGLTextures[png_name1][1]
      self.GPU_current_image = self.GPU_image1
      self.currently_displayed_image = self.image1
      self.rect = self.image1.get_rect(center = (self.x_pos, self.y_pos))
      self.mask = pygame.mask.from_surface(self.image1)


class AKey():
  def __init__(self, x_pos, y_pos, x_vel, y_vel, x_accel, y_accel, is_grabbed_by_player, is_grabbed_by_ant, is_inserted, is_inserted_coordinate_range, is_inserted_xy, key_type, vel, png_name1, png_name2):
    super().__init__()
    self.key_type = key_type
    self.outline_every = 4
    self.image_rotation = 0
    self.key_sound = pygame.mixer.Sound(path + '\Sounds\AntHill\Key.wav')
    self.can_play_sound = False
    if self.key_type == 1:
      self.x_pos = x_pos
      self.y_pos = y_pos
      self.original_x_pos = x_pos
      self.original_y_pos = y_pos
      self.x_vel = x_vel
      self.y_vel = y_vel
      self.x_accel = x_accel
      self.y_accel = y_accel
      self.is_grabbed_by_player = is_grabbed_by_player
      self.is_grabbed_by_ant = is_grabbed_by_ant
      self.is_grabbed_by_which_ant = -1
      self.cooldown_before_grabbing_again = 0
      self.is_inserted = is_inserted
      self.is_inserted_coordinate_range = is_inserted_coordinate_range
      self.is_inserted_xy = is_inserted_xy
      self.images = PyGameTextures[png_name1]
      self.image = self.images[0]
      self.current_image = self.image
      self.GPU_images = OpenGLTextures[png_name1]
      self.GPU_image = self.GPU_images[0]
      self.GPU_current_image = self.GPU_image
      self.rect = self.image.get_rect(center = (self.x_pos, self.y_pos))
      self.mask = pygame.mask.from_surface(self.image)
    if self.key_type == 2:
      self.allowed_to_move = True
      self.vel = vel
      self.flying_radius = 0
      self.rotation = 90
      self.orig_rotation = 90
      self.x_pos = x_pos
      self.y_pos = y_pos
      self.original_x_pos = x_pos
      self.original_y_pos = y_pos
      self.x_vel = x_vel
      self.y_vel = y_vel
      self.x_accel = x_accel
      self.y_accel = y_accel
      self.is_grabbed_by_player = is_grabbed_by_player
      self.is_grabbed_by_ant = is_grabbed_by_ant
      self.is_grabbed_by_which_ant = -1
      self.cooldown_before_grabbing_again = 0
      self.is_inserted = is_inserted
      self.is_inserted_coordinate_range = is_inserted_coordinate_range
      self.is_inserted_xy = is_inserted_xy
      self.images = PyGameTextures[png_name1]
      self.image = self.images[0]
      self.current_image = self.image
      self.GPU_images = OpenGLTextures[png_name1]
      self.GPU_image = self.GPU_images[0]
      self.GPU_current_image = self.GPU_image
      self.rect = self.image.get_rect(center = (self.x_pos, self.y_pos))
      self.mask = pygame.mask.from_surface(self.image)
    if self.key_type == 3:
      self.vel = 6
      self.xy_poses = [(5264+((1/2)*screen_width), 1616+((1/2)*screen_height)), (6176+((1/2)*screen_width), 1584+((1/2)*screen_height)), (6960+((1/2)*screen_width), 1504+((1/2)*screen_height)), (4944+((1/2)*screen_width), 2288+((1/2)*screen_height)), (6160+((1/2)*screen_width), 2416+((1/2)*screen_height)), (7024+((1/2)*screen_width), 2480+((1/2)*screen_height))]
      self.cur_xy_pos = 0
      self.x_pos = 4944+((1/2)*screen_width)
      self.y_pos = 1856+((1/2)*screen_height)
      self.original_x_pos = 4944+((1/2)*screen_width)
      self.original_y_pos = 1856+((1/2)*screen_height)
      self.x_vel = x_vel
      self.y_vel = y_vel
      self.x_accel = x_accel
      self.y_accel = y_accel
      self.is_grabbed_by_player = is_grabbed_by_player
      self.is_grabbed_by_ant = is_grabbed_by_ant
      self.is_grabbed_by_which_ant = -1
      self.cooldown_before_grabbing_again = 0
      self.is_inserted = is_inserted
      self.is_inserted_coordinate_range = is_inserted_coordinate_range
      self.is_inserted_xy = is_inserted_xy
      self.images = PyGameTextures[png_name1]
      self.image = self.images[0]
      self.current_image = self.image
      self.GPU_images = OpenGLTextures[png_name1]
      self.GPU_image = self.GPU_images[0]
      self.GPU_current_image = self.GPU_image
      self.rect = self.image.get_rect(center = (self.x_pos, self.y_pos))
      self.mask = pygame.mask.from_surface(self.image)


class Door():
  def __init__(self, x_pos, y_pos, is_open, is_open_x, is_open_y, door_type, png_name):
    super().__init__()
    self.door_type = door_type
    self.sound = pygame.mixer.Sound(path + '\Sounds\AntHill\Door.wav')
    self.playing_sound = False
    if door_type == 1 or door_type == 3:
      self.x_pos = x_pos
      self.y_pos = y_pos
      self.original_x_pos = x_pos
      self.original_y_pos = y_pos
      self.is_open = is_open
      self.is_open_x = is_open_x
      self.is_open_y = is_open_y
      self.image = PyGameTextures[png_name]
      self.current_image = self.image
      self.GPU_image = OpenGLTextures[png_name]
      self.GPU_current_image = self.GPU_image
      self.rect = self.image.get_rect(center = (self.x_pos, self.y_pos))
      self.mask = pygame.mask.from_surface(self.image)
      self.is_really_open = False
    #
    if door_type == 2:
      self.x_pos = x_pos
      self.y_pos = y_pos
      self.original_x_pos = x_pos
      self.original_y_pos = y_pos
      self.is_open = is_open
      self.is_open_x = is_open_x
      self.is_open_y = is_open_y
      self.rotation = 0
      self.WholeImage = PyGameTextures['WHOLE_FENCE_DOOR']
      self.current_WholeImage = self.WholeImage
      self.GPU_WholeImage = OpenGLTextures['WHOLE_FENCE_DOOR']
      self.GPU_current_WholeImage = self.GPU_WholeImage
      self.WholeRect = self.WholeImage.get_rect(center = (self.x_pos, self.y_pos))
      self.WholeMask = pygame.mask.from_surface(self.WholeImage)
      self.image = self.WholeImage
      self.current_image = self.WholeImage
      self.GPU_image = self.GPU_WholeImage
      self.GPU_current_image = self.GPU_image
      self.rect = self.WholeImage.get_rect(center = (self.x_pos, self.y_pos))
      self.mask = pygame.mask.from_surface(self.WholeImage)
      self.LeftImage_x_pos = x_pos
      self.LeftImage_y_pos = y_pos
      self.LeftImage = PyGameTextures['FENCE_DOOR_LEFT']
      self.current_LeftImage = self.LeftImage
      self.GPU_LeftImage = OpenGLTextures['FENCE_DOOR_LEFT']
      self.GPU_current_LeftImage = self.GPU_LeftImage
      self.LeftRect = self.LeftImage.get_rect(center = (self.x_pos, self.y_pos))
      self.LeftMask = pygame.mask.from_surface(self.LeftImage)
      self.RightImage_x_pos = x_pos
      self.RightImage_y_pos = y_pos
      self.RightImage = PyGameTextures['FENCE_DOOR_RIGHT']
      self.current_RightImage = self.RightImage
      self.GPU_RightImage = OpenGLTextures['FENCE_DOOR_RIGHT']
      self.GPU_current_RightImage = self.GPU_RightImage
      self.RightRect = self.RightImage.get_rect(center = (self.x_pos, self.y_pos))
      self.RightMask = pygame.mask.from_surface(self.RightImage)


class DoorWithKnob():
  def __init__(self, x_pos, y_pos, grapple_xy_poses1, grapple_xy_poses2, door_png_name, knob_png_name):
    super().__init__()
    self.door_png_name = door_png_name
    self.knob_png_name = knob_png_name
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.grapple_xy_poses1 = grapple_xy_poses1
    self.grapple_xy_poses2 = grapple_xy_poses2
    if self.door_png_name == 'DOOR_WITH_KNOB':
      self.current_door_opening = 4
    self.milliseconds_needed_to_get_next_door_image = 60
    self.current_milliseconds_needed_to_get_next_door_image = 0
    self.last_door_opening = 4
    #
    self.GPU_images = OpenGLTextures[door_png_name]
    self.GPU_current_image = self.GPU_images[self.current_door_opening]
    #
    self.whole_door_images = PyGameTextures[door_png_name]
    self.knob_image = PyGameTextures[knob_png_name]
    self.current_image = self.whole_door_images[self.current_door_opening]
    self.rect = self.current_image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask = pygame.mask.from_surface(self.current_image)
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])


class Squirrel():
  def __init__(self, x_pos, y_pos, vel, x1, y1, x2, y2, flip_squirrel, rotate_squirrel, png_name):
    super().__init__()
    self.update_image_at_milliseconds = curr_time
    self.flipped = flip_squirrel
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.vel = vel
    self.prev_x_pos = x_pos
    self.prev_y_pos = y_pos
    self.start_pos = (x1, y1)
    self.end_pos = (x2, y2)
    self.moving_to_xy1 = False
    self.moving_to_xy2 = True
    self.cooldown_before_moving_again = 180*13
    self.current_cooldown_counter = 0
    self.current_image_number = 0
    self.player_grappled_to_squirrel = False
    self.rotate_squirrel = rotate_squirrel
    self.currently_playing_sound = False
    self.sound_to_play = pygame.mixer.Sound(path + '\Sounds\Forest\SquirrelClimb.wav')
    if not flip_squirrel:
      self.images = PyGameTextures['SQUIRREL']
      self.GPU_images = OpenGLTextures['SQUIRREL']
    if flip_squirrel:
      self.images = PyGameTextures['SQUIRREL_FLIPPED']
      self.GPU_images = OpenGLTextures['SQUIRREL']
    self.current_image = self.images[0]
    self.GPU_current_image = self.GPU_images[0]
    self.rect = self.images[0].get_rect(center = (self.x_pos, self.y_pos))
    self.mask = pygame.mask.from_surface(self.images[0])
    self.radius = find_hypotnuse(self.rect[2]/2, self.rect[3]/2)


class BouncyObject():
  def __init__(self, x_pos, y_pos, elasticity_x, elasticity_y, max_x_vel, max_y_vel, collision_circle_x, collision_circle_y, collision_circle_radius, png_name):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.elasticity_x = elasticity_x
    self.elasticity_y = elasticity_y
    self.max_x_vel = max_x_vel
    self.max_y_vel = max_y_vel
    self.collision_circle_x = collision_circle_x
    self.collision_circle_y = collision_circle_y
    self.collision_circle_radius = collision_circle_radius
    self.image = PyGameTextures[png_name]
    self.current_image = self.image
    self.GPU_image = OpenGLTextures[png_name]
    self.GPU_current_image = self.GPU_image
    self.rect = self.image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask = pygame.mask.from_surface(self.image)


class MovingBouncyObject():
  def __init__(self, x_pos, y_pos, elasticity_x, elasticity_y, max_x_vel, max_y_vel, path_x, path_y, path_rotation, collision_circle_x, collision_circle_y, collision_circle_radius, png_name):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.elasticity_x = elasticity_x
    self.elasticity_y = elasticity_y
    self.max_x_vel = max_x_vel
    self.max_y_vel = max_y_vel
    self.orig_x_pos = x_pos
    self.orig_y_pos = y_pos
    self.orig_rotation = 0
    self.rotation = 0
    self.current_rotation = 0
    self.path_x = path_x
    self.path_y = path_y
    self.path_rotation = path_rotation
    self.which_iteration_in_path_x = 0
    self.which_iteration_in_path_y = 0
    self.which_iteration_in_path_rotation = 0
    self.collision_circle_x = collision_circle_x
    self.collision_circle_y = collision_circle_y
    self.collision_circle_radius = collision_circle_radius
    self.image = PyGameTextures[png_name]
    self.current_image = self.image
    self.GPU_image = OpenGLTextures[png_name]
    self.GPU_current_image = self.GPU_image
    self.rect = self.image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask = pygame.mask.from_surface(self.image)


class BossHawk():
  def __init__(self, x_pos, y_pos, next_location_x, next_location_y, current_frame, frame_of_arrival, my_step, total_distance_to_cover, delta_x, delta_y, nesting, png_name):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos
    #
    self.next_location_x = next_location_x
    self.next_location_y = next_location_y
    #
    self.current_frame = current_frame
    self.frame_of_arrival = frame_of_arrival
    self.my_step = my_step
    self.total_distance_to_cover = total_distance_to_cover
    self.delta_x = delta_x
    self.delta_y = delta_y
    self.nesting = nesting
    #
    path_str = path + '\Images/' + png_name
    self.images = PyGameTextures['HAWK']
    self.image = self.images[0]
    self.current_image = self.images[0]
    self.GPU_images = OpenGLTextures['HAWK']
    self.GPU_current_image = self.GPU_images[0]
    self.rect  = self.image.get_rect(center = (x_pos, y_pos))
    self.mask  = pygame.mask.from_surface(self.image)


class QueenAntClass():
  def __init__(self, x_pos, y_pos, png_name1, png_name2, mouth_png_name, butt_png_name):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.caught_player = False
    #
    self.images = []
    self.GPU_images = []
    self.images = PyGameTextures['QUEEN_ANT']
    self.GPU_images = OpenGLTextures['QUEEN_ANT']
    self.current_image = self.images[0]
    self.GPU_current_image = self.GPU_images[0]
    self.rect  = self.images[0].get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.images[0])
    #
    self.frames_since_entering = 0
    self.beetle_frames_since_entering = 0
    self.mouth_col = False
    self.mouth_image = PyGameTextures['QUEEN_ANT_MOUTH']
    self.mouth_current_image = self.mouth_image
    self.mouth_rect  = self.mouth_image.get_rect(center = (self.x_pos, self.y_pos))
    self.mouth_mask  = pygame.mask.from_surface(self.mouth_image)
    #
    self.frames_since_exiting = 0
    self.butt_col = False
    self.butt_image = PyGameTextures['QUEEN_ANT_BUTT']
    self.butt_current_image = self.butt_image
    self.butt_rect  = self.butt_image.get_rect(center = (self.x_pos, self.y_pos))
    self.butt_mask  = pygame.mask.from_surface(self.butt_image)
    #
    self.playing_sound1 = False
    self.playing_sound2 = False
    self.milliseconds_since_player_was_eaten = 0
    self.milliseconds_since_started_existing = 0
    self.allowed_to_poop = True


class PlayerMoverAnt():
  def __init__(self, x_pos, y_pos, x_dest, y_dest, vision_range_x, vision_range_y, ignore_pickup_range, vel, vel_multiplier, rotation, frames_per_image_update, current_ant_frame, is_searching, found_a_misplaced_object, is_returning_object, png_name1, png_name2):
    super().__init__()
    self.sound = pygame.mixer.Sound(path + '\Sounds\AntHill\Ant.wav')
    self.currently_playing_sound = False
    self.outline_every = 4
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.x_dest = x_dest
    self.y_dest = y_dest
    self.vision_range_x = vision_range_x
    self.vision_range_y = vision_range_y
    self.ignore_pickup_range = ignore_pickup_range
    self.vel = vel
    self.vel_multiplier = vel_multiplier
    self.rotation = rotation
    self.frames_per_image_update = frames_per_image_update
    self.current_ant_frame = current_ant_frame
    self.time_since_last_image_update = 0
    self.time_since_last_search = 13
    self.random_image_update_time = random.randint(0, 30)
    self.is_searching = is_searching
    self.found_a_misplaced_object = found_a_misplaced_object
    self.misplaced_object_index = -1
    self.is_returning_object = is_returning_object
    self.image1 = PyGameTextures[png_name1][0]
    self.image2 = PyGameTextures[png_name1][1]
    self.current_image = self.image1
    self.GPU_image1 = OpenGLTextures[png_name1][0]
    self.GPU_image2 = OpenGLTextures[png_name1][1]
    self.GPU_current_image = self.GPU_image1
    self.currently_displayed_image = self.image1
    self.rect = self.image1.get_rect(center = (self.x_pos, self.y_pos))
    self.mask = pygame.mask.from_surface(self.image1)


class Leaf():
  def __init__(self, x_pos, y_pos, accumulated_y_pos, respawn_x, respawn_y, expiry_y_pos, falling_speed, rotation, x_path, y_path, rot_path, wait_frames_before_beginning_to_disappear, frames_before_checking_for_collision, grapplable, flip_image, png_name):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.expiry_y_pos = expiry_y_pos
    self.accumulated_y_pos = accumulated_y_pos
    self.orig_x_pos = respawn_x # leaf respawn position
    self.orig_y_pos = respawn_y
    self.falling_speed = falling_speed
    self.rotation = rotation
    self.orig_rotation = rotation
    self.is_falling = True
    self.x_path = x_path
    self.y_path = y_path
    self.rot_path = rot_path
    self.cur_x_path = 0
    self.cur_y_path = 0
    self.cur_rot_path = 0
    self.frames_before_disappearing = 0
    self.wait_frames_before_beginning_to_disappear = wait_frames_before_beginning_to_disappear
    self.orig_wait_frames_before_beginning_to_disappear = wait_frames_before_beginning_to_disappear
    self.frames_before_checking_for_collision = frames_before_checking_for_collision
    self.grapplable = grapplable
    self.flip_image = flip_image
    self.player_grappled_to_leaf = False
    self.currently_grapplable = False
    #
    self.images = PyGameTextures[png_name]
    self.GPU_images = OpenGLTextures[png_name]
    self.current_image = self.images[0]
    self.GPU_current_image = self.GPU_images[0]
    self.rect  = self.images[0].get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.images[0])
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])


class Upgrade():
  def __init__(self, x_pos, y_pos, collected):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.orig_x_pos = x_pos
    self.orig_y_pos = y_pos
    self.collected = collected
    #
    self.BubbleImage = PyGameTextures['BUBBLE']
    self.GPU_BubbleImage = OpenGLTextures['BUBBLE']
    self.BubbleRect = self.BubbleImage.get_rect(center = (self.x_pos, self.y_pos))
    self.BubbleMask = pygame.mask.from_surface(self.BubbleImage)
    self.radius = find_hypotnuse(self.BubbleRect[2], self.BubbleRect[3])
    self.float_y_pos = [27*math.sin(math.radians(x)) for x in range(0, 360)]
    self.place_in_float_y_pos = 0
    #
    self.piston_x_pos = self.x_pos + 17
    self.piston_y_pos = self.y_pos + 14
    self.PistonImage = PyGameTextures['PUSH_PISTON_COVER']
    self.PistonImage_current = self.PistonImage
    self.GPU_PistonImage = OpenGLTextures['PUSH_PISTON_COVER']
    self.GPU_PistonImage_current = self.GPU_PistonImage
    self.PistonRect = self.PistonImage.get_rect(center = (self.piston_x_pos, self.piston_y_pos))
    self.PistonMask = pygame.mask.from_surface(self.PistonImage)
    self.push_piston_ltwh = [0,0,0,0]
    #
    self.grapple_x_pos = self.x_pos + 22
    self.grapple_y_pos = self.y_pos + 31
    self.GrappleImage = PyGameTextures['GRAPPLE_PISTON_COVER']
    self.GrappleImage_current = self.GrappleImage
    self.GPU_GrappleImage = OpenGLTextures['GRAPPLE_PISTON_COVER']
    self.GPU_GrappleImage_current = self.GPU_GrappleImage
    self.GrappleRect = self.GrappleImage.get_rect(center = (self.grapple_x_pos, self.grapple_y_pos))
    self.GrappleMask = pygame.mask.from_surface(self.GrappleImage)
    self.grapple_piston_ltwh = [0,0,0,0]
    #
    self.PlusPistonPowerImage = PyGameTextures['PLUS_PISTON_POWER']
    self.GPU_PlusPistonPowerImage = OpenGLTextures['PLUS_PISTON_POWER']
    #
    self.number_of_pixels_to_move = 0
    #
    self.initial_upgrade_angle_of_approach = 0
    self.current_angle_around_player = 0
    self.fly_clockwise = False
    self.fly_counter_clockwise = False


class Tools():
  def __init__(self, x_pos, y_pos, png_name):
    super().__init__()
    self.png_name = png_name
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.orig_x_pos = x_pos
    self.orig_y_pos = y_pos
    self.collected = False
    #
    self.BubbleImage = PyGameTextures['BUBBLE']
    self.GPU_BubbleImage = OpenGLTextures['BUBBLE']
    self.BubbleRect = self.BubbleImage.get_rect(center = (self.x_pos, self.y_pos))
    self.BubbleMask = pygame.mask.from_surface(self.BubbleImage)
    self.radius = find_hypotnuse(self.BubbleRect[2], self.BubbleRect[3])
    self.float_y_pos = [27*math.sin(math.radians(x)) for x in range(0, 360)]
    self.place_in_float_y_pos = 0
    #
    self.GPU_tool_image = OpenGLTextures[png_name]
    #
    self.initial_upgrade_angle_of_approach = 0
    self.current_angle_around_player = 0
    self.fly_clockwise = False
    self.fly_counter_clockwise = False



class Elevator():
  def __init__(self, x_pos, y_pos, vel, activated, number_of_floors, current_floor, open_right, open_left, left_door_open_at_bottom, right_door_open_at_bottom, left_door_open_at_top, right_door_open_at_top, x1, y1, x2, y2, wasted_left_space, wasted_right_space, wasted_top_space, wasted_bottom_space, number_of_frames, png_name):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.vel = vel
    self.activated = activated
    self.number_of_floors = number_of_floors
    self.current_floor = current_floor
    self.open_right = open_right
    if open_right:
      self.how_open_right = int((number_of_frames-1) / 2)
    else:
      self.how_open_right = 0
    self.open_left = open_left
    if open_left:
      self.how_open_left = int((number_of_frames-1) / 2)
    else:
      self.how_open_left = 0
    self.left_door_open_at_bottom = left_door_open_at_bottom
    self.right_door_open_at_bottom = right_door_open_at_bottom
    self.left_door_open_at_top = left_door_open_at_top
    self.right_door_open_at_top = right_door_open_at_top
    self.player_is_inside = False
    self.x1 = x1
    self.y1 = y1
    self.x2 = x2
    self.y2 = y2
    self.wasted_left_space = wasted_left_space
    self.wasted_right_space = wasted_right_space
    self.wasted_top_space = wasted_top_space
    self.wasted_bottom_space = wasted_bottom_space
    self.images = []
    self.GPU_images = []
    self.number_of_frames = number_of_frames
    self.images = PyGameTextures['ELEVATOR']
    self.GPU_images = OpenGLTextures['ELEVATOR']
    self.current_image = self.images[0]
    self.GPU_current_image = self.GPU_images[0]
    self.rect = self.images[0].get_rect(center = (self.x_pos, self.y_pos))
    self.mask = pygame.mask.from_surface(self.images[0])


class Root():
  def __init__(self, x_pos, y_pos, flipped, time_before_falling, time_to_start_regrowth, time_to_finish_regrowth, allowable_damage, png_name):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.is_solid = True
    self.currently_falling = False
    self.flipped = flipped
    self.time_of_contact = -time_to_finish_regrowth
    self.time_before_falling = time_before_falling
    self.time_to_start_regrowth = time_to_start_regrowth
    self.time_to_finish_regrowth = time_to_finish_regrowth
    self.grapple_connected = False
    self.accumulated_damage = 0
    self.last_accumulated_damage = 0
    self.allowable_damage = allowable_damage
    self.damaged_this_frame = False
    self.RootBase_images = []
    self.GPU_RootBase_images = []
    if not flipped:
      self.RootBase_images = PyGameTextures['ROOT_BASE']
      self.GPU_RootBase_images = OpenGLTextures['ROOT_BASE']
    if flipped:
      self.RootBase_images = PyGameTextures['ROOT_BASE_FLIPPED']
      self.GPU_RootBase_images = OpenGLTextures['ROOT_BASE']
    self.RootBase_image = self.RootBase_images[0]
    self.FadingRootAnimation = []
    self.RegrowthAnimation = []
    self.RegrowthCollision = []
    self.GPU_FadingRootAnimation = []
    self.GPU_RegrowthAnimation = []
    self.GPU_RegrowthCollision = []
    if not flipped:
      self.FadingRootAnimation = PyGameTextures['FADING_ROOT_ANIMATION']
      self.GPU_FadingRootAnimation = OpenGLTextures['FADING_ROOT_ANIMATION']
      self.RegrowthAnimation = PyGameTextures['REGROWTH_ANIMATION']
      self.GPU_RegrowthAnimation = OpenGLTextures['REGROWTH_ANIMATION']
      self.RegrowthCollision = PyGameTextures['REGROWTH_COLLISION']
      self.GPU_RegrowthCollision = OpenGLTextures['REGROWTH_COLLISION']
    if flipped:
      self.FadingRootAnimation = PyGameTextures['FADING_ROOT_ANIMATION_FLIPPED']
      self.GPU_FadingRootAnimation = OpenGLTextures['FADING_ROOT_ANIMATION']
      self.RegrowthAnimation = PyGameTextures['REGROWTH_ANIMATION_FLIPPED']
      self.GPU_RegrowthAnimation = OpenGLTextures['REGROWTH_ANIMATION']
      self.RegrowthCollision = PyGameTextures['REGROWTH_COLLISION_FLIPPED']
      self.GPU_RegrowthCollision = OpenGLTextures['REGROWTH_COLLISION']
    self.Shaky = []
    self.GPU_Shaky = []
    if not flipped:
      self.Shaky = PyGameTextures['SHAKY']
      self.GPU_Shaky = OpenGLTextures['SHAKY']
    if flipped:
      self.Shaky = PyGameTextures['SHAKY_FLIPPED']
      self.GPU_Shaky = OpenGLTextures['SHAKY']
    self.playing_shaky_sound = False
    self.playing_breaky_root_sound = False
    self.shaky_root_sound = pygame.mixer.Sound(path + '\Sounds\AntHill\ShakyRoot.wav')
    self.current_collision_image = self.RegrowthCollision[17]
    self.current_image = self.RegrowthCollision[17]
    self.actual_current_image = self.RegrowthAnimation[17]
    self.GPU_current_collision_image = self.GPU_RegrowthCollision[17]
    self.GPU_current_image = self.GPU_RegrowthCollision[17]
    self.GPU_actual_current_image = self.GPU_RegrowthAnimation[17]
    self.rect = self.RegrowthCollision[17].get_rect(center = (self.x_pos, self.y_pos))
    self.mask = pygame.mask.from_surface(self.RegrowthCollision[17])
    self.radius = find_hypotnuse(self.rect[2], self.rect[3]) / 2


class DripDrop():
  def __init__(self, x_pos, y_pos, start_vel, max_vel, end_y_pos, accel):
    super().__init__()
    self.stage_in_dripdrop = 0
    self.substep = 0
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.vel = start_vel
    self.accel = accel
    self.start_vel = start_vel
    self.max_vel = max_vel
    self.start_y_pos = y_pos
    self.end_y_pos = end_y_pos
    self.phantom_y_pos = y_pos
    self.phantom_vel = self.vel
    self.phantom_dropping = False
    self.allowed_to_make_sound = True
    #
    self.Collision_images = PyGameTextures['DRIPDROP_COLLISION']
    self.Animation_images = PyGameTextures['DRIPDROP_ANIMATION']
    self.GPU_Collision_images = OpenGLTextures['DRIPDROP_COLLISION']
    self.GPU_Animation_images = OpenGLTextures['DRIPDROP_ANIMATION']
    self.drip = PyGameTextures['DRIP']
    self.GPU_drip = OpenGLTextures['DRIP']
    self.drop = PyGameTextures['DROP']
    self.GPU_drop = OpenGLTextures['DROP']
    self.current_image = self.Collision_images[0]
    self.actual_current_image = self.Animation_images[0]
    self.GPU_current_image = self.GPU_Collision_images[0]
    self.GPU_actual_current_image = self.GPU_Animation_images[0]
    self.rect  = self.Collision_images[0].get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.Collision_images[0])
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])


class IrregularlyShapedWater():
  def __init__(self, x_pos, y_pos, water_Fx, water_Fy, png_name):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.water_Fx = water_Fx
    self.water_Fy = water_Fy
    self.image = PyGameTextures[png_name]
    self.current_image = self.image
    self.rect  = self.image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.image)
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])


class SpecialIrregularlyShapedWater(): # Irregularly shaped water in TheDoor11
  def __init__(self):
    Whole_pygame_image = PyGameTextures['THE_DOOR11_IRREGULAR_WATER']
    self.permanent_added_x, self.permanent_added_y = 8317, 1923
    self.subimage_height, self.subimage_width = 400, 400
    self.all_subimages = []
    self.all_positions = []
    self.all_masks = []
    for h in range(9):
      temporary_image_list = []
      temporary_position_list = []
      temporary_masks = []
      for w in range(4):
        current_image = Whole_pygame_image.subsurface((self.subimage_width * w, self.subimage_height * h, self.subimage_width, self.subimage_height))
        temporary_image_list.append(current_image)
        temporary_position_list.append((self.permanent_added_x + (w * self.subimage_width), self.permanent_added_y + (h * self.subimage_height)))
        temporary_masks.append(pygame.mask.from_surface(current_image))
      self.all_subimages.append(temporary_image_list)
      self.all_positions.append(temporary_position_list)
      self.all_masks.append(temporary_masks)
    #
    self.all_forces = [[(0, 1500), (-360, 1500), (360, 1500) , (0, 1500)  ],
                       [(0, 1500), (500, 1500) , (-500, 1500), (500, 1500)],
                       [(0, 1500), (-500, 1500), (500, 1500) , (0, 1500)  ],
                       [(0, 1500), (360, 1500) , (-360, 1500), (0, 1500)  ],
                       [(0, 1500), (150, 1500) , (-150, 1500), (0, 1500)  ],
                       [(0, 1500), (-300, 1500), (300, 1500) , (0, 1500)  ],
                       [(0, 1500), (300, 1500) , (-300, 1500), (0, 1500)  ],
                       [(0, 1500), (0, 1500)   , (0, 1500)   , (0, 1500)  ],
                       [(0, 1500), (0, 1500)   , (0, 1500)   , (0, 1500)  ]]


class SewerPumpWater():
  def __init__(self, x_pos, y_pos, vel, rotation, scale, maximum_length, sleeper_timer, top_timer, sewer_pump_type, attached_to_which_spinny_object, SPINNY_OBJECTS, png_name):
    super().__init__()
    self.sewer_pump_type = sewer_pump_type
    self.attached_to_which_spinny_object = attached_to_which_spinny_object
    self.stage_in_spout = 1
    self.sleeper_timer_start = 0
    self.sleeper_timer = sleeper_timer
    self.top_timer_start = 0
    self.top_timer = top_timer
    self.length = 0
    self.maximum_length = maximum_length
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.source_x = x_pos
    self.source_y = y_pos
    self.vel = vel
    self.rotation = rotation
    self.current_rotation = rotation
    self.scale = scale
    self.image = pygame.transform.scale(pygame.image.load(path + png_name), (scale[0], scale[1]))
    self.current_image = self.image
    self.current_images = []
    self.current_x_poses = []
    self.current_y_poses = []
    self.rect = self.image.get_rect(center = (self.x_pos, self.y_pos))
    self.current_rect = self.rect
    self.mask  = pygame.mask.from_surface(self.image)
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])
    self.cropped_region = [0, 0, self.length, self.rect[3]]
    if sewer_pump_type == 2:
      self.x_pos = SPINNY_OBJECTS[self.attached_to_which_spinny_object].x_pos + (SPINNY_OBJECTS[self.attached_to_which_spinny_object].rect[2]/2)
      self.y_pos = SPINNY_OBJECTS[self.attached_to_which_spinny_object].y_pos + (SPINNY_OBJECTS[self.attached_to_which_spinny_object].rect[3]/2)
      self.source_x = self.x_pos
      self.source_y = self.y_pos


class Leak():
  def __init__(self, x_pos, y_pos, rotation, extending_receding_speed, step0_time, step2_time, png_name):
    super().__init__()
    self.spray_step = 0
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.rotation = rotation
    self.current_random = 0
    self.extending_receding_speed = extending_receding_speed*13
    self.start_time = (9*(extending_receding_speed)*13 + step2_time + 9*(extending_receding_speed))*13
    self.current_time = 0
    self.step0_time = step0_time*13
    self.step2_time = step2_time*13
    self.whole_time = (step0_time + 9*(extending_receding_speed) + step2_time + 9*(extending_receding_speed))*13
    self.current_length = 0
    self.minimum_pos = 0
    self.images = PyGameTextures[png_name]
    self.GPU_images = OpenGLTextures[png_name]
    self.image = self.images[0]
    self.current_image = self.image
    self.GPU_image = self.GPU_images[0]
    self.rect = self.image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.image)
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])
    #
    self.milliseconds_to_pick_new_random_image = (6 / ((1 / 13) * 1000)) * 1000
    self.current_milliseconds_to_pick_new_random_image = 0


class GrateWater():
  def __init__(self, offset_x, offset_y, starting_times, expanding_receding_time, staying_time, waiting_time, which_map):
    super().__init__()
    # T = T-split
    # V = Vertical water
    # H = Horizontal water
    # A = Angle water
    # G = Grate
    # R = Reversed
    self.active_quads = [0, 0, 0, 0]
    self.offset_x = offset_x
    self.offset_y = offset_y
    self.current_frame = 0
    self.starting_times = starting_times
    self.expanding_receding_time = expanding_receding_time
    self.staying_time = staying_time
    self.waiting_time = waiting_time
    self.loop_periods = []
    for i in range(len(starting_times)):
      self.loop_periods.append((2*expanding_receding_time) + staying_time + waiting_time)
    if which_map == 'TheDoor10':
      self.TheDoor10_map=[['', ''   , '' , '' , '' , '' , '' , '' , '' , '' , '',  '',  '',  '', '' , '' , '' , '' , '' , '' , '' , '', '', '' , ''],
                          ['', 'GGR' , '' , '' , '' , '' , '' , '' , '' , '' , '',  '', 'GG',  '', '' , '' , '' , '' , '' , '' , '' , '', '', 'GG', ''],
                          ['', 'GVR' , '' , '' , '' , '' , '' , '' , '' , '' , '', 'GA', 'GT','GAR', '' , '' , '' , '' , '' , '' , '' , '', '', 'GV', ''],
                          ['', 'GVR' , '' , '' , '' , '' , '' , '' , '' , '' , '', 'GV', '' ,'GVR', '' , '' , '' , '' , '' , '' , '' , '', '', 'GV', ''],
                          ['', 'GVR' , '' , '' , '' , '' , '' , '' , '' , '' ,'GA', 'GT', '' ,'GTR','GAR', '' , '' , '' , '' , '' , '' , '', '', 'GV', ''],
                          ['', 'GVR' , '' , '' , '' , '' , '' , '' , '' , '' ,'GV', '' , '' , '' ,'GVR', '' , '' , '' , '' , '' , '' , '', '', 'GV', ''],
                          ['', 'GVR' , '' , '' , '' , '' , '' , '' , '' , '' ,'GV', '' , '' , '' ,'GVR', '' , '' , '' , '' , '' , '' , '', '', 'GV', ''],
                          ['', 'GVR' , '' , '' , '' , '' , '' , '' , '' ,'GA' ,'GT','GAR', '' , '' ,'GVR', '' , '' , '' , '' , '' , '' , '', '', 'GV', ''],
                          ['', 'GVR' , '' , '' , '' , '' , '' , '' ,'GA' ,'GT' ,'' ,'GVR', '' , 'GA','GTR','GAR', '' , '' , '' , '' , '' , '', '', 'GV', ''],
                          ['', 'GVR' , '' , '' , '' , '' , '' , '' ,'GV' , '' , '','GVR', '' , 'GV', '' ,'GTR','GAR', '' , '' , '' , '' , '', '', 'GV', ''],
                          ['', 'GVR' , '' , '' , '' , '' , '' , '' ,'GV' , '' , '','GVR', '' , 'GV', '' , '' ,'GVR', '' , '' , '' , '' , '', '', 'GV', ''],
                          ['', 'GVR' , '' , '' , '' , '' , '' ,'GA' ,'GT' , '' , '','GVR', '' , 'GV', '' , '' ,'GVR', '' , '' , '' , '' , '', '', 'GV', ''],
                          ['', 'GVR' , '' , '' , '' , '' , '' ,'GV' , '' , '' , '','GVR', '' , 'GV', '' , '' ,'GTR','GAR', '' , '' , '' , '', '', 'GV', ''],
                          ['', 'GVR' , '' , '' , '' , '' , '' ,'GV' , '' , '' , '','GVR', '' , 'GV', '' , '' , '' ,'GVR', '' , '' , '' , '', '', 'GV', ''],
                          ['', 'GVR' , '' , '' , '' , '' ,'GA' ,'GT' , '' , '' ,'GA','GTR', 'GH', 'GT','GAR', '' , '' ,'GVR', '' , '' , '' , '', '', 'GV', ''],
                          ['', 'GVR' , '' , '' , '' ,'GA' ,'GT' , '' , '' , '' ,'GV', '' , '' , '' ,'GVR', '' , '' ,'GTR','GAR', '' , '' , '', '', 'GV', ''],
                          ['', 'GVR' , '' , '' , '' ,'GV' , '' , '' , '' , '' ,'GV', '' , '' , '' ,'GVR', '' , '' , '' ,'GVR', '' , '' , '', '', 'GV', ''],
                          ['', 'GVR' , '' , '' ,'GA' ,'GT' ,'GAR', '' , '' , '' ,'GV', '' , '' , '' ,'GVR', '' , '' ,'GA' ,'GTR','GAR', '' , '', '', 'GV', ''],
                          ['', 'GVR' , '' ,'GA' ,'GT' , '' ,'GVR', '' , '' , '' ,'GV', '' , '' , '' ,'GVR', '' , '' ,'GV' , '' ,'GTR','GAR', '', '', 'GV', ''],
                          ['', 'GVR' , '' ,'GV' , '' , '' ,'GVR', '' , '' , '' ,'GV', '' , '' , '' ,'GVR', '' , '' ,'GV' , '' , '' ,'GVR', '', '', 'GV', ''],
                          ['', 'GVR' , '' ,'GV' , '' , '' ,'GVR', '' , '' , '' ,'GV', '' , '' , '' ,'GVR', '' , '' ,'GV' , '' , '' ,'GVR', '', '', 'GV', ''],
                          ['', 'GVR' , '' ,'GV' , '' , '' ,'GVR', '' , '' , '' ,'GV', '' , '' , '' ,'GVR', '' , '' ,'GV' , '' , '' ,'GVR', '', '', 'GV', ''],
                          ['', 'GTR' ,''  ,'GT' ,''  ,''  ,'GTR',''  ,''  ,''  ,'GT',''  , '' , '' ,'GTR',''  ,''  ,'GT' , '' , '' ,'GTR','' ,'' , 'GT', '']]
    #
      self.TheDoor10_map_timing=[['', ''     , '' , '' , '' , '' , '' , '' , '' , '' , '',  '',  '',  '', '' , '' , '' , '' , '' , '' , '' , '', '', ''    , ''],
                                ['', (0,0)  , '' , '' , '' , '' , '' , '' , '' , '' , '',  '', (1,0),  '', '' , '' , '' , '' , '' , '' , '' , '', '', (2,0) , ''],
                                ['', (0,1)  , '' , '' , '' , '' , '' , '' , '' , '' , '', (1,2), (1,1),(1,2), '' , '' , '' , '' , '' , '' , '' , '', '', (2,1) , ''],
                                ['', (0,2)  , '' , '' , '' , '' , '' , '' , '' , '' , '', (1,3), '' ,  (1,3), '' , '' , '' , '' , '' , '' , '' , '', '', (2,2) , ''],
                                ['', (0,3)  , '' , '' , '' , '' , '' , '' , '' , '' ,(1,5), (1,4), '' ,  (1,4),(1,5), '' , '' , '' , '' , '' , '' , '', '', (2,3) , ''],
                                ['', (0,4)  , '' , '' , '' , '' , '' , '' , '' , '' ,(1,6), '' , '' , '' ,   (1,6), '' , '' , '' , '' , '' , '' , '', '', (2,4) , ''],
                                ['', (0,5)  , '' , '' , '' , '' , '' , '' , '' , '' ,(1,7), '' , '' , '' ,   (1,7), '' , '' , '' , '' , '' , '' , '', '', (2,5) , ''],
                                ['', (0,6)  , '' , '' , '' , '' , '' , '' , '' ,(1,9) ,(1,8),(1,9), '' , '' ,   (1,8), '' , '' , '' , '' , '' , '' , '', '', (2,6) , ''],
                                ['', (0,7)  , '' , '' , '' , '' , '' , '' ,(1,11) ,(1,10) ,'' ,(1,10), '' , (1,10),   (1,9),(1,10), '' , '' , '' , '' , '' , '', '', (2,7) , ''],
                                ['', (0,8)  , '' , '' , '' , '' , '' , '' ,(1,12) , '' , '',(1,11), '' , (1,11), '' ,   (1,11),(1,12), '' , '' , '' , '' , '', '', (2,8) , ''],
                                ['', (0,9)  , '' , '' , '' , '' , '' , '' ,(1,13) , '' , '',(1,12), '' , (1,12), '' , '' ,   (1,13), '' , '' , '' , '' , '', '', (2,9) , ''],
                                ['', (0,10) , '' , '' , '' , '' , '' ,(1,15) ,(1,14) , '' , '',(1,13), '' , (1,13), '' , '' ,   (1,14), '' , '' , '' , '' , '', '', (2,10), ''],
                                ['', (0,11) , '' , '' , '' , '' , '' ,(1,16) , '' , '' , '',(1,14), '' , (1,14), '' , '' ,   (1,15),(1,16), '' , '' , '' , '', '', (2,11), ''],
                                ['', (0,12) , '' , '' , '' , '' , '' ,(1,17) , '' , '' , '',(1,15), '' , (1,15), '' , '' , '' ,   (1,17), '' , '' , '' , '', '', (2,12), ''],
                                ['', (0,13) , '' , '' , '' , '' ,(1,19) ,(1,18) , '' , '' ,(1,17),(1,16), (1,17), (1,16),(1,17), '' , '' ,   (1,18), '' , '' , '' , '', '', (2,13), ''],
                                ['', (0,14) , '' , '' , '' ,(1,21) ,(1,20) , '' , '' , '' ,(1,18), '' , '' , '' ,(1,18), '' , '' ,   (1,19),(1,20), '' , '' , '', '', (2,14), ''],
                                ['', (0,15) , '' , '' , '' ,(1,22) , '' , '' , '' , '' ,(1,19), '' , '' , '' ,(1,19), '' , '' , '' ,   (1,21), '' , '' , '', '', (2,15), ''],
                                ['', (0,16) , '' , '' ,(1,24) ,(1,23) ,(1,24), '' , '' , '' ,(1,20), '' , '' , '' ,(1,20), '' , '' ,(1,23) ,   (1,22),(1,23), '' , '', '', (2,16), ''],
                                ['', (0,17) , '' ,(1,26) ,(1,25) , '' ,(1,25), '' , '' , '' ,(1,21), '' , '' , '' ,(1,21), '' , '' ,(1,24) , '' ,   (1,24),(1,25), '', '', (2,17), ''],
                                ['', (0,18) , '' ,(1,27) , '' , '' ,(1,26), '' , '' , '' ,(1,22), '' , '' , '' ,(1,22), '' , '' ,(1,25) , '' , '' ,   (1,26), '', '', (2,18), ''],
                                ['', (0,19) , '' ,(1,28) , '' , '' ,(1,27), '' , '' , '' ,(1,23), '' , '' , '' ,(1,23), '' , '' ,(1,26) , '' , '' ,   (1,27), '', '', (2,19), ''],
                                ['', (0,20) , '' ,(1,29) , '' , '' ,(1,28), '' , '' , '' ,(1,24), '' , '' , '' ,(1,24), '' , '' ,(1,27) , '' , '' ,   (1,28), '', '', (2,20), ''],
                                ['', (0,21) ,'',(1,30) ,'','',(1,29),'','','',(1,25),'', '' , '',(1,25) ,'' ,'' ,(1,28) , '', '',   (1,29),'','', (2,21), '']]
    #
    if which_map == 'Sewer' or which_map == 'TheDoor12':
      self.TheDoor10_map = [['' , 'GG', ''  , '', '', '', ''  , 'GG', ''  , ''  , ''  , ''  , ''  , '' , '' , '' , '' , '' ],
                            ['' , 'GV', ''  , '', '', '', ''  , 'GV', ''  , ''  , ''  , ''  , ''  , '' , '' , '' , '' , '' ],
                            ['' , 'GV', ''  , '', '', '', ''  , 'GV', ''  , ''  , ''  , ''  , ''  , '' , '' , '' , '' , '' ],
                            ['' , 'GV', ''  , '', '', '', ''  , 'GV', ''  , ''  , ''  , ''  , ''  , '' , '' , '' , '' , 'GG'],
                            ['GA', 'GT', 'GAR', '', '', '', 'GA' , 'GT', 'GHR', 'GAR', ''  , ''  , ''  , '' , '' , '' , '' , 'GV'],
                            ['GV', '' , 'GVR', '', '', '', 'GV' , '' , ''  , 'GTR', 'GHR', 'GHR', 'GAR', '' , '' , '' , '' , 'GV'],
                            ['GV', '' , 'GVR', '', '', '', 'GV' , '' , ''  , ''  , ''  , ''  , 'GVR', '' , '' , '' , '' , 'GV'],
                            ['GV', '' , 'GVR', '', '', '', 'GV' , '' , ''  , ''  , ''  , ''  , 'GVR', '' , '' , '' , '' , 'GV'],
                            ['GV', '' , 'GVR', '', '', '', 'GV' , '' , ''  , ''  , ''  , ''  , 'GVR', 'GA', 'GH', 'GH', 'GH', 'GT'],
                            ['GV', '' , 'GVR', '', '', '', 'GV' , '' , 'GA' , 'GH' , 'GH' , 'GH' , 'GTR', 'GT', '' , '' , '' , '' ],
                            ['GV', '' , 'GVR', '', '', '', 'GV' , '' , 'GV' , ''  , ''  , ''  , ''  , '' , '' , '' , '' , '' ]]
    #
      self.TheDoor10_map_timing = [['' , (0,0), ''  , '', '', '', ''  , (1,0), ''  , ''  , ''  , ''  , ''  , '' , '' , '' , '' , '' ],
                                   ['' , (0,1), ''  , '', '', '', ''  , (1,1), ''  , ''  , ''  , ''  , ''  , '' , '' , '' , '' , '' ],
                                   ['' , (0,2), ''  , '', '', '', ''  , (1,2), ''  , ''  , ''  , ''  , ''  , '' , '' , '' , '' , '' ],
                                   ['' , (0,3), ''  , '', '', '', ''  , (1,3), ''  , ''  , ''  , ''  , ''  , '' , '' , '' , '' , (2,3)],
                                   [(0,5), (0,4), (0,5), '', '', '', (1,5) , (1,4), (1,5), (1,6), ''  , ''  , ''  , '' , '' , '' , '' , (2,4)],
                                   [(0,6), '' , (0,6), '', '', '', (1,6) , '' , ''  , (1,7), (1,8), (1,9), (1,10), '' , '' , '' , '' , (2,5)],
                                   [(0,7), '' , (0,7), '', '', '', (1,7) , '' , ''  , ''  , ''  , ''  , (1,11), '' , '' , '' , '' , (2,6)],
                                   [(0,8), '' , (0,8), '', '', '', (1,8) , '' , ''  , ''  , ''  , ''  , (1,12), '' , '' , '' , '' , (2,7)],
                                   [(0,9), '' , (0,9), '', '', '', (1,9) , '' , ''  , ''  , ''  , ''  , (1,13), (2,12), (2,11), (2,10), (2,9), (2,8)],
                                   [(0,10), '' , (0,10), '', '', '', (1,10) , '' , (1,18) , (1,17) , (1,16) , (1,15) , (1,14), (2,13), '' , '' , '' , '' ],
                                   [(0,11), '' , (0,11), '', '', '', (1,11) , '' , (1,19) , ''  , ''  , ''  , ''  , '' , '' , '' , '' , '' ]]
    #
    self.xy_poses = []
    for i in range(len(self.TheDoor10_map)):
      temp = []
      for j in range(len(self.TheDoor10_map[0])):
        temp.append([offset_x + j*256, offset_y + i*256])
      self.xy_poses.append(temp)


class TransportPipe():
  def __init__(self, x_pos, y_pos, blow_width, Fx, Fy, flipped, is_entrance, is_blowing, is_sucking, path_to_other_side, ejection_direction, png_name, wind_png_name, up, down):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.blow_width = blow_width
    self.Fx = Fx
    self.Fy = Fy
    self.flipped = flipped
    self.is_entrance = is_entrance
    self.is_blowing = is_blowing
    self.is_sucking = is_sucking
    self.current_wind_index = 0
    self.current_milliseconds_before_next_wind_index = 0
    self.milliseconds_before_next_wind_index = 13
    self.up = up
    self.down = down
    #
    self.path_to_other_side = path_to_other_side
    self.ejection_direction = ejection_direction
    #
    self.GPU_wind_images = OpenGLTextures[wind_png_name]
    self.GPU_current_wind_image = self.GPU_wind_images[0]
    #
    self.image = PyGameTextures[png_name]
    self.current_image = self.image
    self.rect = self.image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.image)
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])


class SurfBoard():
  def __init__(self, x_pos, y_pos, boundaries, water_surface_collision_indexes, png_name):
    super().__init__()
    self.outline_every = 1
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.boundaries = boundaries
    self.x_vel = 0
    self.y_vel = 0
    self.x_accel = 0
    self.y_accel = 0
    self.Fx = 0
    self.Fy = 0
    self.image_rotation = 0
    self.flipped = True
    self.currently_flipping_image = True
    self.went_under_last_frame = False
    self.went_over_last_frame = False
    self.touching_water = False
    self.touching_water_last_frame = False
    #
    self.water_surface_collision_indexes = water_surface_collision_indexes
    #
    self.previous_x = x_pos
    self.previous_y = y_pos
    self.current_x = x_pos
    self.current_y = y_pos
    #
    self.attach_x = 70
    self.attach_y = 111
    #
    self.GPU_image = OpenGLTextures[png_name]
    self.not_rotated_current_image = PyGameTextures['WHOLE_SURF_BOARD_COLLISION']
    self.current_image = self.not_rotated_current_image
    #
    self.not_rotated_left_collision_image = PyGameTextures['SURF_BOARD_LEFT_COLLISION']
    self.left_collision_image = self.not_rotated_left_collision_image
    #
    self.not_rotated_right_collision_image = PyGameTextures['SURF_BOARD_RIGHT_COLLISION']
    self.right_collision_image = self.not_rotated_right_collision_image
    #
    self.rect = self.current_image.get_rect(center = (self.x_pos, self.y_pos))
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])


class SurfingRat():
  def __init__(self, current_region):
    self.is_on_screen = False
    self.current_milliseconds_since_starting_rat_stage = 0
    if current_region != 'TheDoor12':
      self.stage_in_rat_activities = 0
      self.x_pos = 5267 + 5526 + ((1/2)*screen_width)
      self.y_pos = 2441 + 1869 + ((1/2)*screen_height)
    if current_region == 'TheDoor12':
      self.stage_in_rat_activities = 1
      self.x_pos = 5526 + ((1/2)*screen_width)
      self.y_pos = 1869 + ((1/2)*screen_height)
    #
    self.is_talking = False
    self.milliseconds_needed_before_next_rat_image = 150
    self.current_milliseconds_needed_before_next_rat_image = 0
    self.GPU_talking_images = OpenGLTextures['SURFING_RAT_TALKING']
    self.GPU_standing_images = OpenGLTextures['SURFING_RAT_STANDING']
    self.GPU_current_rat_image = self.GPU_standing_images[0]
    self.current_rat_image_index = 0
    self.allow_upgrade_to_spawn = '0'
    #
    # Introduction
    self.WassupHamsterDudette = OpenGLTextures['WassupHamsterDudette']
    self.DoYouSurfBro = OpenGLTextures['DoYouSurfBro']
    self.IfSoIdLoveToWatch = OpenGLTextures['IfSoIdLoveToWatch']
    self.YeahGetOutThereGirl = OpenGLTextures['YeahGetOutThereGirl']
    #
    # Failure
    self.YouWerePrettyCoolOutThere = OpenGLTextures['YouWerePrettyCoolOutThere']
    self.ButIThinkYouCouldBeBetter = OpenGLTextures['ButIThinkYouCouldBeBetter']
    self.YouShouldComeSurfAgain = OpenGLTextures['YouShouldComeSurfAgain']
    #
    # Conclusion
    self.ThatWasRadicalBro = OpenGLTextures['ThatWasRadicalBro']
    self.IWantYouToHaveThis = OpenGLTextures['IWantYouToHaveThis']
    #
    # Victory again
    self.ItsAPleasureSeeinYouSurf = OpenGLTextures['ItsAPleasureSeeinYouSurf']
    self.ComeBackAgainSometimeDudette = OpenGLTextures['ComeBackAgainSometimeDudette']
    #
    # Compliments
    EpicDudette = OpenGLTextures['EpicDudette']
    Gnarly = OpenGLTextures['Gnarly']
    Nice = OpenGLTextures['Nice']
    RideThatBarrelBrah = OpenGLTextures['RideThatBarrelBrah']
    Sick = OpenGLTextures['Sick']
    ThatWasRighteousBro = OpenGLTextures['ThatWasRighteousBro']
    TubularBrah = OpenGLTextures['TubularBrah']
    Wicked = OpenGLTextures['Wicked']
    Wild = OpenGLTextures['Wild']
    Woah = OpenGLTextures['Woah']
    self.Compliments = [EpicDudette, Gnarly, Nice, RideThatBarrelBrah, Sick, ThatWasRighteousBro, TubularBrah, Wicked, Wild, Woah]
    #
    # Wipeouts
    IHopeThatDidntHurt = OpenGLTextures['IHopeThatDidntHurt']
    ItsOkIfWipeoutsHappen = OpenGLTextures['ItsOkIfWipeoutsHappen']
    KeepGoinHamsterGirl = OpenGLTextures['KeepGoinHamsterGirl']
    OofYouOkBrah = OpenGLTextures['OofYouOkBrah']
    self.Wipeouts = [IHopeThatDidntHurt, ItsOkIfWipeoutsHappen, KeepGoinHamsterGirl, OofYouOkBrah]
    #
    self.show_dialogue = False
    self.GPU_current_dialogue = self.Compliments[0]


class EatingRat():
  def __init__(self):
    self.x_pos = 4236 + ((1/2)*screen_width)
    self.y_pos = 624 + ((1/2)*screen_height)
    self.eaten_how_much_food = 0
    self.how_much_food_is_there_left = 666
    self.can_say_hi = False
    #
    self.milliseconds_speaking_with_hamster = 0
    self.milliseconds_needed_before_next_rat_image = 150
    self.current_milliseconds_needed_before_next_rat_image = 0
    self.GPU_talking_images = OpenGLTextures['EATING_RAT_TALKING']
    self.GPU_standing_images = OpenGLTextures['EATING_RAT_STANDING']
    self.GPU_current_rat_image = self.GPU_standing_images[0]
    self.current_rat_image_index = 0
    #
    self.milliseconds_conclusion_talking = 0
    #
    self.is_talking = False
    self.show_dialogue = False
    self.currently_eating_food = False
    self.eating_which_food = 666
    #
    self.DoYouHappenToHaveAnyFood = OpenGLTextures['DoYouHappenToHaveAnyFood']
    self.IFeelSoSatisfiedNow = OpenGLTextures['IFeelSoSatisfiedNow']
    self.ItsBeenToughToFindFoodRecently = OpenGLTextures['ItsBeenToughToFindFoodRecently']
    self.OhHelloLittleHamster = OpenGLTextures['OhHelloLittleHamster']
    self.OhThankYouSoMuch = OpenGLTextures['OhThankYouSoMuch']
    self.SoYummy = OpenGLTextures['SoYummy']
    self.ThankYouForFeedingMe = OpenGLTextures['ThankYouForFeedingMe']
    self.ThisTastesWonderful = OpenGLTextures['ThisTastesWonderful']
    self.HiyaHamsterFriend = OpenGLTextures['HiyaHamsterFriend']
    self.GPU_current_dialogue = self.OhHelloLittleHamster
    #
    self.compliments = [self.OhThankYouSoMuch, self.SoYummy, self.ThankYouForFeedingMe, self.ThisTastesWonderful]
    self.playing_eating_sound = False


class SurfingClock():
  def __init__(self):
    self.GPU_SURFING_CLOCK = OpenGLTextures['SURFING_CLOCK']
    self.GPU_SURFING_CLOCK_HAND = OpenGLTextures['SURFING_CLOCK_HAND']
    self.surfing_clock_hand_rotation = 0
    self.is_showing = False


class SurfingProgressBar():
  def __init__(self):
    self.is_showing = False
    self.GPU_SURFING_PROGRESS_BAR_OUTSIDE = OpenGLTextures['SURFING_PROGRESS_BAR_OUTSIDE']
    self.GPU_SURFING_PROGRESS_BAR_INSIDE = OpenGLTextures['SURFING_PROGRESS_BAR_INSIDE']
    self.how_filled = 0
    self.zero = OpenGLTextures['ZERO']
    self.one = OpenGLTextures['ONE']
    self.two = OpenGLTextures['TWO']
    self.three = OpenGLTextures['THREE']
    self.four = OpenGLTextures['FOUR']
    self.five = OpenGLTextures['FIVE']
    self.six = OpenGLTextures['SIX']
    self.seven = OpenGLTextures['SEVEN']
    self.eight = OpenGLTextures['EIGHT']
    self.nine = OpenGLTextures['NINE']
    self.slash = OpenGLTextures['SLASH']
    self.fraction_string = ''
    self.current_GPU_numbers = []
    self.current_GPU_number_positions = []
    self.number_image_length = 0
    self.progress_bar_spacing_on_each_side = 0
    self.number_spacing_dict = {'0': 15,
                                '1': 12,
                                '2': 15,
                                '3': 15,
                                '4': 12,
                                '5': 15,
                                '6': 12,
                                '7': 12,
                                '8': 12,
                                '9': 12,
                                '/': 12}
    self.number_OpenGL_dict =  {'0': OpenGLTextures['ZERO'],
                                '1': OpenGLTextures['ONE'],
                                '2': OpenGLTextures['TWO'],
                                '3': OpenGLTextures['THREE'],
                                '4': OpenGLTextures['FOUR'],
                                '5': OpenGLTextures['FIVE'],
                                '6': OpenGLTextures['SIX'],
                                '7': OpenGLTextures['SEVEN'],
                                '8': OpenGLTextures['EIGHT'],
                                '9': OpenGLTextures['NINE'],
                                '/': OpenGLTextures['SLASH']}


class NumbersAboveHamster():
  def __init__(self, number_string):
    self.number_string = number_string
    self.running_tot_float = float(number_string)
    self.milliseconds_before_expiry = 500
    self.current_milliseconds_before_expiry = 0
    self.will_expire = False
    self.number_spacing_dict = {'0': 30,
                                '1': 24,
                                '2': 30,
                                '3': 30,
                                '4': 24,
                                '5': 30,
                                '6': 24,
                                '7': 24,
                                '8': 24,
                                '9': 24,
                                '/': 24,
                                '+': 24,
                                '-': 24,
                                '.': 12}
    self.number_OpenGL_dict =  {'0': OpenGLTextures['ZERO_ORANGE'],
                                '1': OpenGLTextures['ONE_ORANGE'],
                                '2': OpenGLTextures['TWO_ORANGE'],
                                '3': OpenGLTextures['THREE_ORANGE'],
                                '4': OpenGLTextures['FOUR_ORANGE'],
                                '5': OpenGLTextures['FIVE_ORANGE'],
                                '6': OpenGLTextures['SIX_ORANGE'],
                                '7': OpenGLTextures['SEVEN_ORANGE'],
                                '8': OpenGLTextures['EIGHT_ORANGE'],
                                '9': OpenGLTextures['NINE_ORANGE'],
                                '/': OpenGLTextures['SLASH_ORANGE'],
                                '+': OpenGLTextures['PLUS_ORANGE'],
                                '-': OpenGLTextures['MINUS_ORANGE'],
                                '.': OpenGLTextures['PERIOD_ORANGE']}
    self.current_GPU_numbers = []
    self.length_of_all_symbols = 0
    for SingleSymbol in self.number_string:
      self.current_GPU_numbers.append(self.number_OpenGL_dict[SingleSymbol])
      self.length_of_all_symbols += self.number_spacing_dict[SingleSymbol]


class Wave():
  def __init__(self, x_pos, y_pos, x_vel, png_name):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.x_vel = x_vel
    self.impending_deletion = False
    #
    if png_name == 'SMALL_WAVE':
      self.wave_size_multiplier = 1
    if png_name == 'MEDIUM_WAVE':
      self.wave_size_multiplier = 2
    if png_name == 'BIG_WAVE':
      self.wave_size_multiplier = 3
    #
    self.milliseconds_before_showing_next_image = 40
    self.current_milliseconds_before_showing_next_image = 0
    self.current_image_index = 0
    #
    self.GPU_images = OpenGLTextures[png_name]
    self.GPU_current_image = self.GPU_images[0]
    #
    self.images = PyGameTextures[png_name]
    self.current_image = self.images[0]
    self.rect = self.current_image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.current_image)
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])


class Bucket():
  def __init__(self, x_pos, y_pos, bottom_x, bottom_y, top_x, top_y, vel):
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.bottom_x = bottom_x
    self.bottom_y = bottom_y
    self.top_x = top_x
    self.top_y = top_y
    self.vel = vel
    self.stage_in_bucket_movement = 1 # 1 = bottom, 2 = moving up, 3 = top, 4 = moving down
    self.is_allowed_to_move_again = True
    self.water_region = [self.x_pos + 17 - ((1/2)*screen_width), self.x_pos + 233 - ((1/2)*screen_width), (self.y_pos + 38) - ((1/2)*screen_height), (self.y_pos + 420) - ((1/2)*screen_height)]
    self.time_since_last_in_bucket = 0
    #
    self.current_image = PyGameTextures['BUCKET']
    self.GPU_current_image = OpenGLTextures['BUCKET']
    self.rect = self.current_image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.current_image)
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])


class Food():
  def __init__(self, x_pos, y_pos, image_rotation, flipped, png_name, food_index):
    self.food_index = food_index
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.x_vel = 0
    self.y_vel = 0
    self.Fx = 0
    self.Fy = 0
    self.image_rotation = image_rotation
    self.originally_flipped = flipped
    self.flipped = flipped
    self.being_carried = False
    self.current_milliseconds_before_being_allowed_to_hold_food_again = 0
    #
    self.current_milliseconds_since_starting_being_eaten = 0
    self.milliseconds_to_be_completely_eaten = 3000
    self.being_eaten = False
    self.completely_eaten = False
    #
    self.image = PyGameTextures[png_name]
    self.current_image = self.image
    self.GPU_image = OpenGLTextures[png_name]
    self.rect = self.current_image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.current_image)
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])


class HamsterOs():
  def __init__(self):
    self.x_pos = 2054 + ((1 / 2) * screen_width)
    self.y_pos = 848 + ((1 / 2) * screen_height)
    self.x_vel = 0
    self.y_vel = 0
    self.Fx = 0
    self.Fy = 0
    self.rotation = 0
    #
    self.machine_x_pos = 2598 + ((1 / 2) * screen_width)
    self.machine_y_pos = 915 + ((1 / 2) * screen_height)
    self.boundaries_to_be_placed_in_machine = [2588 + ((1 / 2) * screen_width), 2687 + ((1 / 2) * screen_width)]
    self.in_themachine = False
    #
    self.held_by_player = False
    self.held_by_human = False
    self.boundaries = [1556 + ((1 / 2) * screen_width), 2770 + ((1 / 2) * screen_width), 550 + ((1 / 2) * screen_height), 1018 + ((1 / 2) * screen_height)]
    self.touching_which_edges = [False, False, False, False]
    self.angles = [math.degrees(math.atan2(40,30)), math.degrees(math.atan2(40,-30)), math.degrees(math.atan2(-40,-30))%360, math.degrees(math.atan2(-40,30))%360]
    self.allowable_angles = [0, 90, 180, 270]
    self.milliseconds_before_picking_up_again = 500
    self.current_milliseconds_before_picking_up_again = 500
    #
    self.image = PyGameTextures['HAMSTER_OS']
    self.current_image = self.image
    self.GPU_image = OpenGLTextures['HAMSTER_OS']
    self.rect = self.current_image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.current_image)
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])


class Human():
  def __init__(self):
    self.x_pos = 1973 + ((1 / 2) * screen_width)
    self.y_pos = 769 + ((1 / 2) * screen_height)
    self.orig_y_pos = self.y_pos
    self.flipped = False
    #
    self.machine_x_pos = 2585 + ((1 / 2) * screen_width)
    self.machine_y_pos = 745 + ((1 / 2) * screen_height)
    #
    self.GPU_STANDING = OpenGLTextures['HUMAN_STANDING']
    self.standing_index = 0
    self.current_milliseconds_standing = 0
    self.milliseconds_next_standing = 150
    self.GPU_EATING = OpenGLTextures['HUMAN_EATING']
    self.eating_index = 0
    self.current_milliseconds_eating = 0
    self.milliseconds_next_eating = 150
    self.GPU_WALKING = OpenGLTextures['HUMAN_WALKING']
    self.walking_index = 0
    self.current_milliseconds_walking = 0
    self.milliseconds_next_walking = 150
    self.GPU_current_image = self.GPU_STANDING[0]
    self.current_milliseconds_before_next_image = 0
    self.milliseconds_to_see_next_image = 150
    #
    self.moving_toward_HamsterOs = True
    self.eating_HamsterOs = False
    self.following_hamster = False
    self.in_themachine = False
    #
    self.image = PyGameTextures['HUMAN_STANDING']
    self.current_image = self.image
    self.rect = self.current_image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.current_image)
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])


class GarbageCan():
  def __init__(self, x_pos, y_pos):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.player_is_inside = False
    self.player_is_inside_boundaries = [22, 223, 51, 143]
    self.player_is_tentatively_inside = False
    self.player_is_tentatively_inside_boundaries = [22, 223, 0, 51]
    #
    self.current_image = PyGameTextures['GARBAGE_CAN_COLLISION']
    #
    self.whole_can = OpenGLTextures['WHOLE_GARBAGE_CAN']
    self.transparent_can = OpenGLTextures['TRANSPARENT_GARBAGE_CAN']
    #
    self.rect = self.current_image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.current_image)
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])


class TheMachine():
  def __init__(self):
    self.x_pos = 2256 + ((1/2)*screen_width)
    self.y_pos = 680 + ((1/2)*screen_height)
    self.placed_screw_driver = False
    self.placed_wire_cutter = False
    self.placed_wrench = False
    #
    self.collision_images = PyGameTextures['THE_MACHINE_COLLISION']
    self.current_image = self.collision_images[2]
    self.collision_image_index = 2
    self.player_in_left_side = False
    self.player_in_right_side = False
    self.collision_happened_last_frame = False
    self.rect = self.current_image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.current_image)
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])
    #
    self.GPU_images = OpenGLTextures['THE_MACHINE_DISREPAIR']
    self.GPU_current_machine_image = self.GPU_images[0]
    #
    self.GPU_door_images = OpenGLTextures['THE_MACHINE_DOOR']
    self.GPU_current_machine_door_image = self.GPU_door_images[0]
    #
    self.green_button_images = PyGameTextures['GREEN_BUTTON']
    self.red_button_images = PyGameTextures['RED_BUTTON']
    #
    self.GPU_green_button_images = OpenGLTextures['GREEN_BUTTON']
    self.GPU_red_button_images = OpenGLTextures['RED_BUTTON']
    self.GPU_current_green_button_image = self.GPU_green_button_images[0]
    self.GPU_current_red_button_image = self.GPU_red_button_images[0]
    #
    self.repair_screw_driver = False
    self.screw_driver_reached_themachine = False
    self.screw_driver_xy = []
    self.screw_destination_xy = [2430 + ((1/2)*screen_width), 656 + ((1/2)*screen_height)]
    self.milliseconds_since_screw_driver_repair = 0
    self.screw_stage = 0
    self.screw_rots = [-x*2 for x in range(360)]
    self.screw_cur_rot = 0
    self.screw_cur_milliseconds = 0
    self.smoke1_rots = [15*math.sin(math.radians(x)) for x in range(360)]
    self.smoke1_cur_rot = 0
    self.smoke1_cur_milliseconds = 0
    #
    self.repair_wire_cutter = False
    self.wire_cutter_reached_themachine = False
    self.wire_cutter_xy = []
    self.wire_cutter_destination_xy = [2600 + ((1/2)*screen_width), 724 + ((1/2)*screen_height)]
    self.milliseconds_since_wire_cutter_repair = 0
    self.wire_cutter_stage = 0
    self.wire_cutter_rots = [-x*2 for x in range(360)]
    self.wire_cutter_cur_rot = 0
    self.wire_cutter_cur_milliseconds = 0
    self.smoke2_rots = [15*math.sin(math.radians(x)) for x in range(360)]
    self.smoke2_cur_rot = 0
    self.smoke2_cur_milliseconds = 0
    self.smoke3_rots = [15*math.sin(math.radians(x)) for x in range(60, 360+60)]
    self.smoke3_cur_rot = 0
    self.smoke3_cur_milliseconds = 0
    #
    self.repair_wrench = False
    self.wrench_reached_themachine = False
    self.wrench_xy = []
    self.wrench_destination_xy = [2462 + ((1/2)*screen_width), 938 + ((1/2)*screen_height)]
    self.milliseconds_since_wrench_repair = 0
    self.wrench_stage = 0
    self.wrench_rots = [-x*2 for x in range(360)]
    self.wrench_cur_rot = 0
    self.wrench_cur_milliseconds = 0
    self.smoke4_rots = [15*math.sin(math.radians(x)) for x in range(360)]
    self.smoke4_cur_rot = 0
    self.smoke4_cur_milliseconds = 0
    #
    self.tool_speed = 3.2
    self.allow_the_player_to_place_another_tool = True
    self.milliseconds_for_smoke_to_appear = 500
    self.milliseconds_for_smoke_to_hangout = 3000
    self.milliseconds_for_smoke_to_disappear = 500
    self.milliseconds_to_update_smoke_image = 5
    self.milliseconds_to_update_tool_image = 5


class SpinnyObject():
  def __init__(self, x_pos, y_pos, rotation, angular_vel, list_of_rotation_values, permanent_sewer_pump_position_changer, droplet_frequency, droplet_speed, rotation_of_spouts, droplet_disappear_y_pos, png_name):
    super().__init__()
    self.permanent_sewer_pump_position_changer = permanent_sewer_pump_position_changer
    self.droplet_disappear_y_pos = droplet_disappear_y_pos
    self.droplet_frequency = droplet_frequency
    self.droplet_speed = droplet_speed
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.list_of_rotation_values = list_of_rotation_values
    self.current_rotation_val = 0
    self.rotation = rotation
    self.current_rotation = rotation
    self.rotation_of_spouts = rotation_of_spouts
    self.angular_vel = angular_vel
    self.image = PyGameTextures[png_name]
    self.current_image = self.image
    self.GPU_image = OpenGLTextures[png_name]
    self.GPU_current_image = self.GPU_image
    self.rect = self.image.get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.image)
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])


class SewerWaterDrops():
  def __init__(self, x_pos, y_pos, x_vel, y_vel, x_accel, y_accel, rotation, scale, droplet_disappear_y_pos, png_name):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.x_vel = x_vel
    self.y_vel = y_vel
    self.x_accel = x_accel
    self.y_accel = y_accel
    self.rotation = rotation
    self.scale = scale
    self.droplet_disappear_y_pos = droplet_disappear_y_pos
    self.images = []
    random_rot = random.randint(0, 359)
    for i in range(1):
      self.images.append(rotate_square_image(pygame.transform.scale(pygame.image.load(path + png_name + str(i+1) + '.png'), (scale[0], scale[1])), random_rot))
    self.current_image = self.images[0]
    self.rect = self.images[0].get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.images[0])
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])


class SewerJet():
  def __init__(self, x_pos, y_pos, x_vel, y_vel, x_accel, y_accel, droplet_disappear_y_pos, png_name):
    super().__init__()
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.x_vel = x_vel
    self.y_vel = y_vel
    self.x_accel = x_accel
    self.y_accel = y_accel
    self.rotation = 0
    self.droplet_disappear_y_pos = droplet_disappear_y_pos
    self.images = PyGameTextures[png_name]
    self.GPU_images = OpenGLTextures[png_name]
    self.current_image = self.images[0]
    self.current_GPU_image = self.GPU_images[0]
    self.rect = self.images[0].get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.images[0])
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])


class WaterSurface():
  def __init__(self, x_pos, y_pos, width, png_name, water_surface_type, connected_to_which_bucket):
    super().__init__()
    self.water_surface_type = water_surface_type
    self.connected_to_which_bucket = connected_to_which_bucket
    self.outline_every = 1
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.width = width
    self.current_image_index = 0
    self.milliseconds_before_updating_image = (7 / ((1 / 13) * 1000)) * 1000
    self.number_of_milliseconds_since_updating_image = 0
    #
    self.GPU_images = OpenGLTextures[png_name]
    self.GPU_current_image = self.GPU_images[0]
    self.GPU_image_covers = OpenGLTextures[png_name + '_COVER']
    self.GPU_current_image_cover = self.GPU_image_covers[0]
    #
    self.temporary_images = PyGameTextures[png_name]
    temp_rect = self.temporary_images[0].get_rect(center = (self.x_pos, self.y_pos))
    self.images = []
    for SingleImage in self.temporary_images:
      self.images.append(SingleImage.subsurface((0, 0, width, temp_rect[3])))
    self.current_image = self.images[0]
    self.rect = self.images[0].get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.images[0])
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])


class Goldfish():
  def __init__(self, x_pos, y_pos, vel, bounds, png_name):
    super().__init__()
    self.current_fish_step = 0
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.vel = vel
    self.bounds = bounds
    self.rotation = random.randint(0, 359)
    self.image_rotation = self.rotation
    self.flipped = False
    self.image_update_every_milliseconds = 6*13
    self.current_number_of_milliseconds = 0
    #
    self.current_image_index = 0
    self.GPU_images = OpenGLTextures[png_name]
    self.GPU_current_image = self.GPU_images[0]
    self.images = PyGameTextures[png_name]
    self.flipped_images = PyGameTextures[png_name]
    for i in range(len(self.flipped_images)):
      self.flipped_images[i] = pygame.transform.flip(self.flipped_images[i], True, False)
    self.current_image = self.images[0]
    self.rect = self.images[0].get_rect(center = (self.x_pos, self.y_pos))
    self.mask  = pygame.mask.from_surface(self.images[0])
    self.radius = find_hypotnuse(self.rect[2], self.rect[3])
    #
    self.bounds[1] = self.bounds[1] - self.rect[2]
    self.bounds[3] = self.bounds[3] - self.rect[3]


class Beetle():
  def __init__(self, x_pos, y_pos, rotation):
    super().__init__()
    self.eaten = 0
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.rotation = rotation
    self.flipped = False
    self.image_flipped = False
    self.red_door_opened_prematurely = False
    self.WalkRightImages = PyGameTextures['BEETLE_WALK_RIGHT']
    self.WalkLeftImages = self.WalkRightImages
    self.GPU_WalkRightImages = OpenGLTextures['BEETLE_WALK_RIGHT']
    self.GPU_WalkLeftImages = self.GPU_WalkRightImages
    self.StandRightImages = PyGameTextures['BEETLE_STAND_RIGHT']
    self.StandLeftImages = self.StandRightImages
    self.GPU_StandRightImages = OpenGLTextures['BEETLE_STAND_RIGHT']
    self.GPU_StandLeftImages = self.GPU_StandRightImages
    self.RightLookUp = PyGameTextures['RIGHT_LOOK_UP']
    self.LeftLookUp = self.RightLookUp
    self.GPU_RightLookUp = OpenGLTextures['RIGHT_LOOK_UP']
    self.GPU_LeftLookUp = self.GPU_RightLookUp
    self.RightJump = PyGameTextures['RIGHT_JUMP']
    self.LeftJump = self.RightJump
    self.GPU_RightJump = OpenGLTextures['RIGHT_JUMP']
    self.GPU_LeftJump = self.GPU_RightJump
    self.RightInTheAir = PyGameTextures['RIGHT_IN_THE_AIR']
    self.LeftInTheAir = self.RightInTheAir
    self.GPU_RightInTheAir = OpenGLTextures['RIGHT_IN_THE_AIR']
    self.GPU_LeftInTheAir = self.GPU_RightInTheAir
    self.WhichButton = 0
    self.Button = PyGameTextures['BUTTON']
    self.GPU_Button = OpenGLTextures['BUTTON']
    self.current_image = self.WalkRightImages[0]
    self.current_image_rotated = self.current_image
    self.GPU_current_image = self.GPU_WalkRightImages[0]
    self.GPU_current_image_rotated = self.GPU_current_image
    self.rect = self.current_image_rotated.get_rect(center = (self.x_pos, self.y_pos))
    self.mask = pygame.mask.from_surface(self.current_image_rotated)
    self.orig_height = 59
    self.orig_width = 165
    self.blit_change_x = 0
    self.blit_change_y = 0
    self.stage_in_movement = 1
    self.substep = 0
    self.frame_at_last_stage_in_movement = 0
    self.frame_at_last_substep = 0
    self.time_since_last_step = 0
    self.time_since_last_substep = -1
    #
    self.ShowingWhichDialogue = 0
    self.IWannaLeave = OpenGLTextures['IWannaLeave']
    self.OhThankYouThankYou = OpenGLTextures['OhThankYouThankYou']
    self.OohBigRoom = OpenGLTextures['OohBigRoom']
    self.NeatNeat = OpenGLTextures['NeatNeat']
    self.AnotherDoor = OpenGLTextures['AnotherDoor']
    self.WhoKnewAntsMadeDoors = OpenGLTextures['WhoKnewAntsMadeDoors']
    self.IDidnt = OpenGLTextures['IDidnt']
    self.Although = OpenGLTextures['Although']
    self.MostDontKnow = OpenGLTextures['MostDontKnow']
    self.BeetlesCanTalk = OpenGLTextures['BeetlesCanTalk']
    self.KekKekKek = OpenGLTextures['KekKekKek']
    self.HamsterFriend = OpenGLTextures['HamsterFriend']
    self.CanYouOpenTheDoor = OpenGLTextures['CanYouOpenTheDoor']
    self.YayThankYouThankYou = OpenGLTextures['YayThankYouThankYou']
    self.HamsterFriendHamsterFriend = OpenGLTextures['HamsterFriendHamsterFriend']
    self.ImGonnaPressThis = OpenGLTextures['ImGonnaPressThis']
    self.OpenDoorOpenDoor = OpenGLTextures['OpenDoorOpenDoor']
    self.ThanksHamsterFriend = OpenGLTextures['ThanksHamsterFriend']
    self.WereAGoodTeam = OpenGLTextures['WereAGoodTeam']
    self.IOpenDoors = OpenGLTextures['IOpenDoors']
    self.AndYouAlsoOpenDoors = OpenGLTextures['AndYouAlsoOpenDoors']
    self.YouKnow = OpenGLTextures['YouKnow']
    self.ThisKindaFeelsLikeAn = OpenGLTextures['ThisKindaFeelsLikeAn']
    self.EscortMission = OpenGLTextures['EscortMission']
    self.LikeFromAVideoGame = OpenGLTextures['LikeFromAVideoGame']
    self.Although2 = OpenGLTextures['Although2']
    self.IDontNeedProtection = OpenGLTextures['IDontNeedProtection']
    self.OhLook = OpenGLTextures['OhLook']
    self.WeFoundTheQueen = OpenGLTextures['WeFoundTheQueen']
    self.Wahhhh = OpenGLTextures['Wahhhh']
    self.HeavyButton = OpenGLTextures['HeavyButton']
    #
    self.wow1 = OpenGLTextures['WOW1']
    self.wow2 = OpenGLTextures['WOW2']
    self.wow3 = OpenGLTextures['WOW3']
    self.wow4 = OpenGLTextures['WOW4']
    self.ThatWasWild = OpenGLTextures['ThatWasWild']
    self.ThanksForComingInAfterMe = OpenGLTextures['ThanksForComingInAfterMe']
    self.IDontThinkICanFlyYouOut = OpenGLTextures['IDontThinkICanFlyYouOut']
    self.IllMeetYouPastThisAcid = OpenGLTextures['IllMeetYouPastThisAcid']
    self.ImSoGladYouMadeItOut = OpenGLTextures['ImSoGladYouMadeItOut']
    self.IThinkImJustGonnaHangoutForABit = OpenGLTextures['IThinkImJustGonnaHangoutForABit']
    self.HereIFoundThisEarlier = OpenGLTextures['HereIFoundThisEarlier']
    self.IllComeMeetYouOutsideSometime = OpenGLTextures['IllComeMeetYouOutsideSometime']
    #
    self.HeyaHamsterFriend = OpenGLTextures['HeyaHamsterFriend']
    self.ImSoHappyToSeeYouAgain = OpenGLTextures['ImSoHappyToSeeYouAgain']
    self.IHopeYoureDoinWell = OpenGLTextures['IHopeYoureDoinWell']
    #
    self.PleaseComeInAndSaveMe = OpenGLTextures['PleaseComeInAndSaveMe']
    self.HelpMeHamsterFriend = OpenGLTextures['HelpMeHamsterFriend']
    #
    self.beetle_position_in_ant_queen = 1
    self.milliseconds_talking_with_beetle_in_queen_ant = 0
    #
    self.milliseconds_yelling_outside_queen = 0
    self.milliseconds_yelling_next_dialogue = 2000
    self.milliseconds_wait_period = 200


class BigElevator():
  def __init__(self, x_pos, y_pos, vel, activated, number_of_floors, current_floor, open_right, open_left, left_door_open_at_bottom, right_door_open_at_bottom, left_door_open_at_top, right_door_open_at_top, x1, y1, x2, y2, wasted_left_space, wasted_right_space, wasted_top_space, wasted_bottom_space, number_of_frames, png_name):
    super().__init__()
    self.playing_sound = False
    self.x_pos = x_pos
    self.y_pos = y_pos
    self.vel = vel
    self.activated = activated
    self.number_of_floors = number_of_floors
    self.current_floor = current_floor
    self.open_right = open_right
    if open_right:
      self.how_open_right = int((number_of_frames-1) / 2)
    else:
      self.how_open_right = 0
    self.open_left = open_left
    if open_left:
      self.how_open_left = int((number_of_frames-1) / 2)
    else:
      self.how_open_left = 0
    self.left_door_open_at_bottom = left_door_open_at_bottom
    self.right_door_open_at_bottom = right_door_open_at_bottom
    self.left_door_open_at_top = left_door_open_at_top
    self.right_door_open_at_top = right_door_open_at_top
    self.player_is_inside = False
    self.x1 = x1
    self.y1 = y1
    self.x2 = x2
    self.y2 = y2
    self.wasted_left_space = wasted_left_space
    self.wasted_right_space = wasted_right_space
    self.wasted_top_space = wasted_top_space
    self.wasted_bottom_space = wasted_bottom_space
    self.images = []
    self.GPU_images = []
    self.number_of_frames = number_of_frames
    #
    self.PlatformLeftTop_x_pos = self.x_pos + 1
    self.PlatformLeftTop_y_pos = self.y_pos + 1
    self.PlatformLeftTop_image = PyGameTextures['PLATFORM_LEFT']
    self.PlatformLeftTop_current_image = self.PlatformLeftTop_image
    self.GPU_PlatformLeftTop_image = OpenGLTextures['PLATFORM_LEFT']
    self.GPU_PlatformLeftTop_current_image = self.GPU_PlatformLeftTop_image
    self.PlatformLeftTop_rect = self.PlatformLeftTop_image.get_rect(center = (self.PlatformLeftTop_x_pos, self.PlatformLeftTop_y_pos))
    self.PlatformLeftTop_mask = pygame.mask.from_surface(self.PlatformLeftTop_image)
    #
    self.PlatformMiddleTop_x_pos = self.x_pos + 600 + 1
    self.PlatformMiddleTop_y_pos = self.y_pos + 1
    self.PlatformMiddleTop_image = PyGameTextures['PLATFORM_MIDDLE']
    self.PlatformMiddleTop_current_image = self.PlatformMiddleTop_image
    self.GPU_PlatformMiddleTop_image = OpenGLTextures['PLATFORM_MIDDLE']
    self.GPU_PlatformMiddleTop_current_image = self.GPU_PlatformMiddleTop_image
    self.PlatformMiddleTop_rect = self.PlatformMiddleTop_image.get_rect(center = (self.PlatformMiddleTop_x_pos, self.PlatformMiddleTop_y_pos))
    self.PlatformMiddleTop_mask = pygame.mask.from_surface(self.PlatformMiddleTop_image)
    #
    self.PlatformRightTop_x_pos = self.x_pos + 1200 + 1
    self.PlatformRightTop_y_pos = self.y_pos + 1
    self.PlatformRightTop_image = PyGameTextures['PLATFORM_RIGHT']
    self.PlatformRightTop_current_image = self.PlatformRightTop_image
    self.GPU_PlatformRightTop_image = OpenGLTextures['PLATFORM_RIGHT']
    self.GPU_PlatformRightTop_current_image = self.GPU_PlatformRightTop_image
    self.PlatformRightTop_rect = self.PlatformRightTop_image.get_rect(center = (self.PlatformRightTop_x_pos, self.PlatformRightTop_y_pos))
    self.PlatformRightTop_mask = pygame.mask.from_surface(self.PlatformRightTop_image)
    #
    self.PlatformLeftBottom_x_pos = self.x_pos + 1
    self.PlatformLeftBottom_y_pos = self.y_pos + 494 + 1
    self.PlatformLeftBottom_image = PyGameTextures['PLATFORM_LEFT_BOTTOM']
    self.PlatformLeftBottom_current_image = self.PlatformLeftBottom_image
    self.GPU_PlatformLeftBottom_image = OpenGLTextures['PLATFORM_LEFT_BOTTOM']
    self.GPU_PlatformLeftBottom_current_image = self.GPU_PlatformLeftBottom_image
    self.PlatformLeftBottom_rect = self.PlatformLeftBottom_image.get_rect(center = (self.PlatformLeftBottom_x_pos, self.PlatformLeftBottom_y_pos))
    self.PlatformLeftBottom_mask = pygame.mask.from_surface(self.PlatformLeftBottom_image)
    #
    self.PlatformMiddleBottom_x_pos = self.x_pos + 600 + 1
    self.PlatformMiddleBottom_y_pos = self.y_pos + 494 + 1
    self.PlatformMiddleBottom_image = PyGameTextures['PLATFORM_MIDDLE_BOTTOM']
    self.PlatformMiddleBottom_current_image = self.PlatformMiddleBottom_image
    self.GPU_PlatformMiddleBottom_image = OpenGLTextures['PLATFORM_MIDDLE_BOTTOM']
    self.GPU_PlatformMiddleBottom_current_image = self.GPU_PlatformMiddleBottom_image
    self.PlatformMiddleBottom_rect = self.PlatformMiddleBottom_image.get_rect(center = (self.PlatformMiddleBottom_x_pos, self.PlatformMiddleBottom_y_pos))
    self.PlatformMiddleBottom_mask = pygame.mask.from_surface(self.PlatformMiddleBottom_image)
    #
    self.PlatformRightBottom_x_pos = self.x_pos + 1200 + 1
    self.PlatformRightBottom_y_pos = self.y_pos + 494 + 1
    self.PlatformRightBottom_image = PyGameTextures['PLATFORM_RIGHT_BOTTOM']
    self.PlatformRightBottom_current_image = self.PlatformRightBottom_image
    self.GPU_PlatformRightBottom_image = OpenGLTextures['PLATFORM_RIGHT_BOTTOM']
    self.GPU_PlatformRightBottom_current_image = self.GPU_PlatformRightBottom_image
    self.PlatformRightBottom_rect = self.PlatformRightBottom_image.get_rect(center = (self.PlatformRightBottom_x_pos, self.PlatformRightBottom_y_pos))
    self.PlatformRightBottom_mask = pygame.mask.from_surface(self.PlatformRightBottom_image)
    #
    self.LeftMiddlePlatform_x_pos = self.x_pos + 356 + 1
    self.LeftMiddlePlatform_y_pos = self.y_pos + 247 + 1
    self.LeftMiddlePlatform_image = PyGameTextures['LEFT_MIDDLE_PLATFORM']
    self.LeftMiddlePlatform_current_image = self.LeftMiddlePlatform_image
    self.GPU_LeftMiddlePlatform_image = OpenGLTextures['LEFT_MIDDLE_PLATFORM']
    self.GPU_LeftMiddlePlatform_current_image = self.GPU_LeftMiddlePlatform_image
    self.LeftMiddlePlatform_rect = self.LeftMiddlePlatform_image.get_rect(center = (self.LeftMiddlePlatform_x_pos, self.LeftMiddlePlatform_y_pos))
    self.LeftMiddlePlatform_mask = pygame.mask.from_surface(self.LeftMiddlePlatform_image)
    #
    self.RightMiddlePlatform_x_pos = self.x_pos + 966 + 1
    self.RightMiddlePlatform_y_pos = self.y_pos + 247 + 1
    self.RightMiddlePlatform_image = PyGameTextures['RIGHT_MIDDLE_PLATFORM']
    self.RightMiddlePlatform_current_image = self.RightMiddlePlatform_image
    self.GPU_RightMiddlePlatform_image = OpenGLTextures['RIGHT_MIDDLE_PLATFORM']
    self.GPU_RightMiddlePlatform_current_image = self.GPU_RightMiddlePlatform_image
    self.RightMiddlePlatform_rect = self.RightMiddlePlatform_image.get_rect(center = (self.RightMiddlePlatform_x_pos, self.RightMiddlePlatform_y_pos))
    self.RightMiddlePlatform_mask = pygame.mask.from_surface(self.RightMiddlePlatform_image)
    #
    #
    self.DownPeg1_x_pos = self.x_pos + 893 + 1
    self.DownPeg1_y_pos = self.y_pos + 47 + 1
    self.DownPeg1_image = PyGameTextures['DOWN_PEG']
    self.DownPeg1_current_image = self.DownPeg1_image
    self.GPU_DownPeg1_image = OpenGLTextures['DOWN_PEG']
    self.GPU_DownPeg1_current_image = self.GPU_DownPeg1_image
    self.DownPeg1_rect = self.DownPeg1_image.get_rect(center = (self.DownPeg1_x_pos, self.DownPeg1_y_pos))
    self.DownPeg1_mask = pygame.mask.from_surface(self.DownPeg1_image)
    #
    self.DownPeg2_x_pos = self.x_pos + 679 + 1
    self.DownPeg2_y_pos = self.y_pos + 294 + 1
    self.DownPeg2_image = PyGameTextures['DOWN_PEG']
    self.DownPeg2_current_image = self.DownPeg2_image
    self.GPU_DownPeg2_image = OpenGLTextures['DOWN_PEG']
    self.GPU_DownPeg2_current_image = self.GPU_DownPeg2_image
    self.DownPeg2_rect = self.DownPeg2_image.get_rect(center = (self.DownPeg2_x_pos, self.DownPeg2_y_pos))
    self.DownPeg2_mask = pygame.mask.from_surface(self.DownPeg2_image)
    #
    self.DownPeg3_x_pos = self.x_pos + 1107 + 1
    self.DownPeg3_y_pos = self.y_pos + 294 + 1
    self.DownPeg3_image = PyGameTextures['DOWN_PEG']
    self.DownPeg3_current_image = self.DownPeg3_image
    self.GPU_DownPeg3_image = OpenGLTextures['DOWN_PEG']
    self.GPU_DownPeg3_current_image = self.GPU_DownPeg3_image
    self.DownPeg3_rect = self.DownPeg3_image.get_rect(center = (self.DownPeg3_x_pos, self.DownPeg3_y_pos))
    self.DownPeg3_mask = pygame.mask.from_surface(self.DownPeg3_image)
    #
    self.UpPeg1_x_pos = self.x_pos + 496 + 1
    self.UpPeg1_y_pos = self.y_pos + 219 + 1 - 20
    self.UpPeg1_image = PyGameTextures['UP_PEG']
    self.UpPeg1_current_image = self.UpPeg1_image
    self.GPU_UpPeg1_image = OpenGLTextures['UP_PEG']
    self.GPU_UpPeg1_current_image = self.GPU_UpPeg1_image
    self.UpPeg1_rect = self.UpPeg1_image.get_rect(center = (self.UpPeg1_x_pos, self.UpPeg1_y_pos))
    self.UpPeg1_mask = pygame.mask.from_surface(self.UpPeg1_image)
    #
    self.UpPeg2_x_pos = self.x_pos + 1290 + 1
    self.UpPeg2_y_pos = self.y_pos + 219 + 1 - 20
    self.UpPeg2_image = PyGameTextures['UP_PEG']
    self.UpPeg2_current_image = self.UpPeg2_image
    self.GPU_UpPeg2_image = OpenGLTextures['UP_PEG']
    self.GPU_UpPeg2_current_image = self.GPU_UpPeg2_image
    self.UpPeg2_rect = self.UpPeg2_image.get_rect(center = (self.UpPeg2_x_pos, self.UpPeg2_y_pos))
    self.UpPeg2_mask = pygame.mask.from_surface(self.UpPeg2_image)
    #
    self.UpPeg3_x_pos = self.x_pos + 465 + 1
    self.UpPeg3_y_pos = self.y_pos + 466 + 1 - 20
    self.UpPeg3_image = PyGameTextures['UP_PEG']
    self.UpPeg3_current_image = self.UpPeg3_image
    self.GPU_UpPeg3_image = OpenGLTextures['UP_PEG']
    self.GPU_UpPeg3_current_image = self.GPU_UpPeg3_image
    self.UpPeg3_rect = self.UpPeg3_image.get_rect(center = (self.UpPeg3_x_pos, self.UpPeg3_y_pos))
    self.UpPeg3_mask = pygame.mask.from_surface(self.UpPeg3_image)
    #
    self.UpPeg4_x_pos = self.x_pos + 893 + 1
    self.UpPeg4_y_pos = self.y_pos + 466 + 1 - 20
    self.UpPeg4_image = PyGameTextures['UP_PEG']
    self.UpPeg4_current_image = self.UpPeg4_image
    self.GPU_UpPeg4_image = OpenGLTextures['UP_PEG']
    self.GPU_UpPeg4_current_image = self.GPU_UpPeg4_image
    self.UpPeg4_rect = self.UpPeg4_image.get_rect(center = (self.UpPeg4_x_pos, self.UpPeg4_y_pos))
    self.UpPeg4_mask = pygame.mask.from_surface(self.UpPeg4_image)
    #
    self.UpPeg5_x_pos = self.x_pos + 1321 + 1
    self.UpPeg5_y_pos = self.y_pos + 466 + 1 - 20
    self.UpPeg5_image = PyGameTextures['UP_PEG']
    self.UpPeg5_current_image = self.UpPeg5_image
    self.GPU_UpPeg5_image = OpenGLTextures['UP_PEG']
    self.GPU_UpPeg5_current_image = self.GPU_UpPeg5_image
    self.UpPeg5_rect = self.UpPeg5_image.get_rect(center = (self.UpPeg5_x_pos, self.UpPeg5_y_pos))
    self.UpPeg5_mask = pygame.mask.from_surface(self.UpPeg5_image)
    #
    #
    self.DoorImages = PyGameTextures['ELEVATOR_DOOR']
    self.GPU_DoorImages = OpenGLTextures['ELEVATOR_DOOR']
    #
    self.LeftDoor_x_pos = self.x_pos + 16 + 1
    self.LeftDoor_y_pos = self.y_pos + 47 + 1
    self.LeftDoor_current_image = self.DoorImages[0]
    self.GPU_LeftDoor_current_image = self.GPU_DoorImages[0]
    self.LeftDoor_rect = self.DoorImages[0].get_rect(center = (self.LeftDoor_x_pos, self.LeftDoor_y_pos))
    self.LeftDoor_mask = pygame.mask.from_surface(self.DoorImages[0])
    #
    self.RightDoor_x_pos = self.x_pos + 1749 + 1
    self.RightDoor_y_pos = self.y_pos + 47 + 1
    self.RightDoor_current_image = self.DoorImages[0]
    self.GPU_RightDoor_current_image = self.GPU_DoorImages[0]
    self.RightDoor_rect = self.DoorImages[0].get_rect(center = (self.RightDoor_x_pos, self.RightDoor_y_pos))
    self.RightDoor_mask = pygame.mask.from_surface(self.DoorImages[0])
    #
    self.background_image = PyGameTextures['ELEVATOR_BACKGROUND']
    self.current_background_image = self.background_image
    self.GPU_background_image = OpenGLTextures['ELEVATOR_BACKGROUND']
    self.GPU_current_background_image = self.GPU_background_image


 ###################
###  LoadTextures  ###
 ###################


def loadTexture_high_quality(texture):
  text = Image.open(texture)
  textData = np.array(text)
  textID = glGenTextures(1)
  glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
  glBindTexture(GL_TEXTURE_2D, textID)
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER)
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER)
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0)
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0)
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, text.size[0], text.size[1], 0, GL_RGBA, GL_UNSIGNED_BYTE, textData)
  text.close()
  del textData
  return (text.size[0], text.size[1]), textID


def loadTexture_only_img_data(texture):
  text = Image.open(texture)
  textData = np.array(text)
  text.close()
  return (text.size[0], text.size[1]), textData


def loadTexture_only_OpenGL_stuff(text_size0, text_size1, textData):
  textID = glGenTextures(1)
  glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
  glBindTexture(GL_TEXTURE_2D, textID)
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER)
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER)
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0)
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0)
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, text_size0, text_size1, 0, GL_RGBA, GL_UNSIGNED_BYTE, textData)
  return textID


def player_collision_sound(VIx, VIy, VFx, VFy):
  global maximum_velocity_overall
  speed_change_x = abs(VFx - VIx)
  speed_change_y = abs(VFy - VIy)
  speed_change = find_hypotnuse(speed_change_x, speed_change_y)
  velocity_partitions = [300, 600, 900]
  if SUPER_BOUNCY:
    MixerSounds['BOUNCY'].play()
    return
  #
  if not My_cached_info.play_special_collision_sound:
    if speed_change <= velocity_partitions[0]:
      return
    if velocity_partitions[0] <= speed_change <= velocity_partitions[1]:
      MixerSounds['QUIET_HIT'].play()
      return
    if velocity_partitions[1] <= speed_change <= velocity_partitions[2]:
      MixerSounds['MIDDLE_HIT'].play()
      return
    if velocity_partitions[2] <= speed_change:
      MixerSounds['LOUD_HIT'].play()
      return
  #
  else:
    if My_cached_info.play_teetertotter_collision:
      My_cached_info.play_teetertotter_collision = False
      if speed_change < 60:
        return
      teetertotter_volume_loudness = My_cached_info.current_sound_loudness * MixerSoundsLoudness['TEETER_TOTTER_CLANG'] * (speed_change / 800)
      if teetertotter_volume_loudness > My_cached_info.current_sound_loudness:
        teetertotter_volume_loudness = My_cached_info.current_sound_loudness
      MixerSounds['TEETER_TOTTER_CLANG'].set_volume(teetertotter_volume_loudness)
      MixerSounds['TEETER_TOTTER_CLANG'].play()
      return

MixerSounds = {# Hamster
               'QUIET_HIT': pygame.mixer.Sound(path + '\Sounds\Hamster\HittingWalls\Quiet.wav'),
               'MIDDLE_HIT': pygame.mixer.Sound(path + '\Sounds\Hamster\HittingWalls\Middle.wav'),
               'LOUD_HIT': pygame.mixer.Sound(path + '\Sounds\Hamster\HittingWalls\Loud.wav'),
               'SPLASH': pygame.mixer.Sound(path + '\Sounds\Hamster\Splash.wav'),
               #
               'QUIET_WATER_JET': pygame.mixer.Sound(path + '\Sounds\Hamster\WaterJet\Quiet.wav'),
               'LOUD_WATER_JET': pygame.mixer.Sound(path + '\Sounds\Hamster\WaterJet\Loud.wav'),
               #
               'ATTACH': pygame.mixer.Sound(path + '\Sounds\Hamster\Grapple\Attach.wav'),
               'EXTEND': pygame.mixer.Sound(path + '\Sounds\Hamster\Grapple\Extend.wav'),
               'RETRACT': pygame.mixer.Sound(path + '\Sounds\Hamster\Grapple\Retract.wav'),
               #
               # Forest
               'TEETER_TOTTER_CLANG': pygame.mixer.Sound(path + '\Sounds\Forest\TeetertotterClang.wav'),
               'SQUIRREL_CLIMB': pygame.mixer.Sound(path + '\Sounds\Forest\SquirrelClimb.wav'),
               'CLOUD_LANDING': pygame.mixer.Sound(path + '\Sounds\Forest\CloudLanding.wav'),
               'VINE_SWING': pygame.mixer.Sound(path + '\Sounds\Forest\Vines\WholeVine.wav'),
               'BOUNCY': pygame.mixer.Sound(path + '\Sounds\Forest\Bouncy.wav'),
               'HAWK': pygame.mixer.Sound(path + '\Sounds\Forest\Hawk.wav'),
               #
               # AntHill
               'SHAKY_ROOT': pygame.mixer.Sound(path + '\Sounds\AntHill\ShakyRoot.wav'),
               'BREAKY_ROOT': pygame.mixer.Sound(path + '\Sounds\AntHill\BreakyRoot.wav'),
               'ELEVATOR': pygame.mixer.Sound(path + '\Sounds\AntHill\Elevator.wav'),
               'KEY': pygame.mixer.Sound(path + '\Sounds\AntHill\Key.wav'),
               'ANT': pygame.mixer.Sound(path + '\Sounds\AntHill\Ant.wav'),
               'DOOR': pygame.mixer.Sound(path + '\Sounds\AntHill\Door.wav'),
               'QUEEN_ANT_CHOMP': pygame.mixer.Sound(path + '\Sounds\AntHill\QueenAntChomp.wav'),
               #
               # Sewer
               'LEVER': pygame.mixer.Sound(path + '\Sounds\Sewer\Lever.wav'),
               'EATING_RAT': pygame.mixer.Sound(path + '\Sounds\Sewer\Eating_rat.wav'),
               'TRANSPORT_PIPE_SUCK': pygame.mixer.Sound(path + '\Sounds\Sewer\Transport_pipe_suck.wav'),
               'IRREGULARLY_SHAPED_WATER': pygame.mixer.Sound(path + '\Sounds\Sewer\IrregularlyShapedWater.wav'),
               'IRREGULARLY_SHAPED_WATER2': pygame.mixer.Sound(path + '\Sounds\Sewer\IrregularlyShapedWater.wav'),
               'IRREGULARLY_SHAPED_WATER3': pygame.mixer.Sound(path + '\Sounds\Sewer\IrregularlyShapedWater.wav'),
               'SURF_BOARD_HITTING_WATER': pygame.mixer.Sound(path + '\Sounds\Sewer\Surf_board_hitting_water.wav'),
               'DRIP_DROP': pygame.mixer.Sound(path + '\Sounds\Sewer\DripDrop.wav'),
               #
               # Town
               'HAMSTEROS_CRUNCH': pygame.mixer.Sound(path + '\Sounds\Town\HamsterOs_crunch.wav'),
               'HUMAN_STEP': pygame.mixer.Sound(path + '\Sounds\Town\Human_step.wav'),
               'HUMAN_STEP2': pygame.mixer.Sound(path + '\Sounds\Town\Human_step.wav'),
               'THE_MACHINE1': pygame.mixer.Sound(path + '\Sounds\Town\TheMachine1.wav'),
               'THE_MACHINE2': pygame.mixer.Sound(path + '\Sounds\Town\TheMachine2.wav'),
               'THE_MACHINE3': pygame.mixer.Sound(path + '\Sounds\Town\TheMachine3.wav')}


MixerSoundsLoudness = {# Hamster
                       'QUIET_HIT': 1,
                       'MIDDLE_HIT': 1,
                       'LOUD_HIT': 1,
                       'SPLASH': 0.7,
                       #
                       'QUIET_WATER_JET': 0.12,
                       'LOUD_WATER_JET': 0.12,
                       #
                       'ATTACH': 0.35,
                       'EXTEND': 0.35,
                       'RETRACT': 0.35,
                       #
                       # Forest
                       'TEETER_TOTTER_CLANG': 0.7,
                       'SQUIRREL_CLIMB': 1,
                       'CLOUD_LANDING': 0.7,
                       'VINE_SWING': 0.6,
                       'BOUNCY': 1,
                       'HAWK': 0.35,
                       #
                       # AntHill
                       'SHAKY_ROOT': 1,
                       'BREAKY_ROOT': 0.8,
                       'ELEVATOR': 1,
                       'KEY': 0.5,
                       'ANT': 0.75,
                       'DOOR': 0.4,
                       'QUEEN_ANT_CHOMP': 0.7,
                       #
                       # Sewer
                       'LEVER': 0.6,
                       'EATING_RAT': 0.8,
                       'TRANSPORT_PIPE_SUCK': 0.21,
                       'IRREGULARLY_SHAPED_WATER': 0.3,
                       'IRREGULARLY_SHAPED_WATER2': 0.3,
                       'IRREGULARLY_SHAPED_WATER3': 0.3,
                       'SURF_BOARD_HITTING_WATER': 0.5,
                       'DRIP_DROP': 0.7,
                       #
                       # Town
                       'HAMSTEROS_CRUNCH': 0.13,
                       'HUMAN_STEP': 0.09,
                       'HUMAN_STEP2': 0.09,
                       'THE_MACHINE1': 0.4,
                       'THE_MACHINE2': 0.13,
                       'THE_MACHINE3': 0.4}


def everything_sound_data(make_changes, change_which_line, new_line_data):
    with open(sound_loudness_path, 'r') as file:
      current_save_data = file.readlines()
      if not make_changes:
        return current_save_data
    #
      if make_changes:
        current_save_data[change_which_line] = new_line_data + '\n'
        with open(sound_loudness_path, 'w') as file:
          file.writelines(current_save_data)
          return current_save_data

def update_music_loudness():
  pygame.mixer.music.set_volume(float(everything_sound_data(False, 666, 0)[0]))

def update_sound_loudness():
  for k, v in MixerSounds.items():
    v.set_volume(float(everything_sound_data(False, 666, 0)[1]) * MixerSoundsLoudness[k])


sound_loudness_path = path + '\Sounds\Sound_loudness.txt'
update_music_loudness()
update_sound_loudness()


for event in pygame.event.get():
  break

make_opengl_rect((screen_width, screen_height), LOADING_HAMSTER_FACE_IMAGE[1], (0, 0), 0, False, (0, 0, screen_width, screen_height))
pygame.display.flip()


PyGameTextures = {#PLAYER
                  'PLAYER_BALL': pygame.image.load(path + '\Images\MEDIUM_CIRCLE.png'),
                  'THE_BALL_FRONT': pygame.image.load(path + '\Images\THE_BALL_FRONT.png'),
                  'THE_BALL_BACK': pygame.image.load(path + '\Images\THE_BALL_BACK.png'),
                  'HAMSTER_STANDING_RIGHT': pygame.image.load(path + '\Images\Hamster\HamsterStandingRight\HamsterStandingRight.png'),
                  'HAMSTER_STANDING_LEFT': pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\HamsterStandingRight\HamsterStandingRight.png').convert_alpha(), True, False),
                  'HAMSTER_WALKING_RIGHT': [pygame.image.load(path + '\Images\Hamster\HamsterWalkingRight\HamsterWalkingRight1.png'), pygame.image.load(path + '\Images\Hamster\HamsterWalkingRight\HamsterWalkingRight2.png'), pygame.image.load(path + '\Images\Hamster\HamsterWalkingRight\HamsterWalkingRight3.png'), pygame.image.load(path + '\Images\Hamster\HamsterWalkingRight\HamsterWalkingRight4.png')],
                  'HAMSTER_WALKING_LEFT': [pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\HamsterWalkingRight\HamsterWalkingRight1.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\HamsterWalkingRight\HamsterWalkingRight2.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\HamsterWalkingRight\HamsterWalkingRight3.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\HamsterWalkingRight\HamsterWalkingRight4.png').convert_alpha(), True, False)],
                  'ROLLING_CLOCKWISE': [pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight1.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight2.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight3.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight4.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight5.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight6.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight7.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight8.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight9.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight10.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight11.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight12.png').convert_alpha()],
                  'ROLLING_COUNTERCLOCKWISE': [pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight1.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight2.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight3.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight4.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight5.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight6.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight7.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight8.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight9.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight10.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight11.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\RollingRight\RollingRight12.png').convert_alpha(), True, False)],
                  'HAMSTER_FLOAT_RIGHT': [pygame.image.load(path + '\Images\Hamster\FloatRight\FloatRight1.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\FloatRight\FloatRight2.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\FloatRight\FloatRight3.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\FloatRight\FloatRight4.png').convert_alpha()],
                  'HAMSTER_FLOAT_LEFT': [pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\FloatRight\FloatRight1.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\FloatRight\FloatRight2.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\FloatRight\FloatRight3.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\FloatRight\FloatRight4.png').convert_alpha(), True, False)],
                  'HAMSTER_FALLING_RIGHT': pygame.image.load(path + '\Images\Hamster\FallingRight\FallingRight.png').convert_alpha(),
                  'HAMSTER_FALLING_LEFT': pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\FallingRight\FallingRight.png').convert_alpha(), True, False),
                  'HAMSTER_FLYING_RIGHT': [pygame.image.load(path + '\Images\Hamster\FlyingRight\FlyingRight1.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\FlyingRight\FlyingRight2.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\FlyingRight\FlyingRight3.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\FlyingRight\FlyingRight4.png').convert_alpha(), pygame.image.load(path + '\Images\Hamster\FlyingRight\FlyingRight5.png').convert_alpha()],
                  'HAMSTER_FLYING_LEFT': [pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\FlyingRight\FlyingRight1.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\FlyingRight\FlyingRight2.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\FlyingRight\FlyingRight3.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\FlyingRight\FlyingRight4.png').convert_alpha(), True, False), pygame.transform.flip(pygame.image.load(path + '\Images\Hamster\FlyingRight\FlyingRight5.png').convert_alpha(), True, False)],
                  #
                  # Background
                  #'Forest_BG1': [pygame.image.load(path + '\Images/Forest/Background/Background1/Background1.png')],
                  #'Forest_BG3': [pygame.image.load(path + '\Images/Forest/Background/Background3/Background1.png')],
                  #'Forest_BG4': [pygame.image.load(path + '\Images/Forest/Background/Background4/Background1.png')],
                  #'Forest_BG5': [pygame.image.load(path + '\Images/Forest/Background/Background5/Background1.png')],
                  #'Forest_BG6': [pygame.image.load(path + '\Images/Forest/Background/Background6/Background1.png')],
                  #'Forest_BGDEER': [pygame.image.load(path + '\Images/Forest/Background/DEER/DEER1.png'), pygame.image.load(path + '\Images/Forest/Background/DEER/DEER2.png'), pygame.image.load(path + '\Images/Forest/Background/DEER/DEER3.png'), pygame.image.load(path + '\Images/Forest/Background/DEER/DEER4.png'), pygame.image.load(path + '\Images/Forest/Background/DEER/DEER5.png'), pygame.image.load(path + '\Images/Forest/Background/DEER/DEER6.png')],
                  #'Forest_BG7': [pygame.image.load(path + '\Images/Forest/Background/Background7/Background1.png')],
                  #'Forest_BG12': [pygame.image.load(path + '\Images/Forest/Background/Background12/Background1.png')],
                  #'AntHill_BG': [pygame.image.load(path + '\Images/AntHill/Background/Background1.png'), pygame.image.load(path + '\Images/AntHill/Background/Background2.png'), pygame.image.load(path + '\Images/AntHill/Background/Background3.png'), pygame.image.load(path + '\Images/AntHill/Background/Background4.png'), pygame.image.load(path + '\Images/AntHill/Background/Background5.png'), pygame.image.load(path + '\Images/AntHill/Background/Background6.png'), pygame.image.load(path + '\Images/AntHill/Background/Background7.png'), pygame.image.load(path + '\Images/AntHill/Background/Background8.png'), pygame.image.load(path + '\Images/AntHill/Background/Background9.png'), pygame.image.load(path + '\Images/AntHill/Background/Background10.png'), pygame.image.load(path + '\Images/AntHill/Background/Background11.png'), pygame.image.load(path + '\Images/AntHill/Background/Background12.png'), pygame.image.load(path + '\Images/AntHill/Background/Background13.png'), pygame.image.load(path + '\Images/AntHill/Background/Background14.png'), pygame.image.load(path + '\Images/AntHill/Background/Background15.png'), pygame.image.load(path + '\Images/AntHill/Background/Background16.png'), pygame.image.load(path + '\Images/AntHill/Background/Background17.png'), pygame.image.load(path + '\Images/AntHill/Background/Background18.png'), pygame.image.load(path + '\Images/AntHill/Background/Background19.png'), pygame.image.load(path + '\Images/AntHill/Background/Background20.png'), pygame.image.load(path + '\Images/AntHill/Background/Background21.png'), pygame.image.load(path + '\Images/AntHill/Background/Background22.png'), pygame.image.load(path + '\Images/AntHill/Background/Background23.png'), pygame.image.load(path + '\Images/AntHill/Background/Background24.png'), pygame.image.load(path + '\Images/AntHill/Background/Background25.png'), pygame.image.load(path + '\Images/AntHill/Background/Background26.png'), pygame.image.load(path + '\Images/AntHill/Background/Background27.png'), pygame.image.load(path + '\Images/AntHill/Background/Background28.png'), pygame.image.load(path + '\Images/AntHill/Background/Background29.png'), pygame.image.load(path + '\Images/AntHill/Background/Background30.png'), pygame.image.load(path + '\Images/AntHill/Background/Background31.png'), pygame.image.load(path + '\Images/AntHill/Background/Background32.png')],
                  #'SEWER_BG': [pygame.image.load(path + '\Images/Sewer/Background/Background.png')],
                  #'SEWER_GREEN_BG': [pygame.image.load(path + '\Images/Sewer/Background/BackgroundGreen/BackgroundGreen.png')],
                  #'ROOT_LEVEL_BG': [pygame.image.load(path + '\Images/TheDoor9-ClimbingRoots\Background.png')],
                  #
                  # Pistons
                  'SHEATH': pygame.image.load(path + '\Images\Piston_Sheath' + '2' + '.png').convert_alpha(),
                  #'PUSH_PISTON': [pygame.image.load(path + '\Images\PUSH_PISTON\PUSH_PISTON' + str(x + 1) + '.png').convert_alpha() for x in range(243)],
                  'PUSH_PISTON_COVER': pygame.image.load(path + '\Images\PUSH_PISTON\PushPistonCover\PushPistonCover2.png').convert_alpha(),
                  'SPLASH': [pygame.image.load(path + '\Images\PUSH_PISTON\Splash\Splash' + str(x+1) + '.png').convert_alpha() for x in range(4)],
                  #'GRAPPLE_PISTON': [pygame.image.load(path + '\Images\GRAPPLE_PISTON\GrapplePiston2\GRAPPLE_PISTON' + str(x + 1) + '.png').convert_alpha() for x in range(243)],
                  'GRAPPLE_PISTON_COVER': pygame.image.load(path + '\Images\GRAPPLE_PISTON\GrapplePiston5\GrapplePiston5.png').convert_alpha(),
                  'GRAPPLE_PISTON_CLOSED_COVER': pygame.image.load(path + '\Images\GRAPPLE_PISTON\ClosedGrapple5\ClosedGrapple5.png').convert_alpha(),
                  #
                  # Vines
                  'BUCKET_VINE': pygame.image.load(path + '\Images\Vines\BucketRope\Vine.png').convert_alpha(),
                  'LEAD9': pygame.image.load(path + '\Images\Vines\Lead9\Lead9.png').convert_alpha(),
                  'LONGLEAD1': pygame.image.load(path + '\Images\Vines\LongLead1/LongLead.png').convert_alpha(),
                  'LONGLEAD2': pygame.image.load(path + '\Images\Vines\LongLead2/LongLead.png').convert_alpha(),
                  'SEWERVINE1': pygame.image.load(path + '\Images\Vines\SewerVine1\Vine42.png').convert_alpha(),
                  'SEWERVINE2': pygame.image.load(path + '\Images\Vines\SewerVine2\LongVine.png').convert_alpha(),
                  'UVULAVINE': pygame.image.load(path + '\Images\Vines\\UvulaVine\\UvulaVine18.png').convert_alpha(),
                  'VINE9': pygame.image.load(path + '\Images\Vines\Vine9\Vine9.png').convert_alpha(),
                  'VINE18': pygame.image.load(path + '\Images\Vines\Vine18\Vine18.png').convert_alpha(),
                  'VINE18_SHADE': pygame.image.load(path + '\Images\Vines\Vine18\Vine18-shade.png').convert_alpha(),
                  'VINE42': pygame.image.load(path + '\Images\Vines\Vine42\Vine42.png').convert_alpha(),
                  'WELL_ROPE': pygame.image.load(path + '\Images\Vines\WellRope\Vine.png').convert_alpha(),
                  #
                  # Clouds
                  'FOREST_CLOUD_1': pygame.image.load(path + '\Images\Forest\Cloud2\Cloud2.png').convert_alpha(),
                  'FOREST_CLOUD_2': pygame.image.load(path + '\Images\Forest\Cloud2\Cloud1.png').convert_alpha(),
                  'CLOUD1_1': pygame.image.load(path + '\Images\TheDoor2-Clouds\Cloud1\Cloud2.png').convert_alpha(),
                  'CLOUD1_2': pygame.image.load(path + '\Images\TheDoor2-Clouds\Cloud1\Cloud1.png').convert_alpha(),
                  'CLOUD2_1': pygame.image.load(path + '\Images\TheDoor2-Clouds\Cloud2\Cloud4.png').convert_alpha(),
                  'CLOUD2_2': pygame.image.load(path + '\Images\TheDoor2-Clouds\Cloud2\Cloud3.png').convert_alpha(),
                  #
                  # TeeterTotters
                  'TEETERTOTTER1': pygame.image.load(path + '\Images\TheDoor1-MetalBars/TeeterTotter2/TeeterTotter2.png').convert_alpha(),
                  #'TEETERTOTTER2': pygame.image.load(path + '\Images\AntHill/WoodenTeeterTotter3/WoodenTeeterTotter.png').convert_alpha(),
                  #
                  # Ants
                  'ANT1': [pygame.image.load(path + '\Images\Ants\Ant\AllAnt2.png').convert_alpha(), pygame.image.load(path + '\Images\Ants\Ant\AllAnt3.png').convert_alpha()],
                  'ANT2': [pygame.image.load(path + '\Images\AntHill\PlayerMoverAnt\AllAnt2.png').convert_alpha(), pygame.image.load(path + '\Images\AntHill\PlayerMoverAnt\AllAnt3.png').convert_alpha()],
                  #
                  # Keys
                  'BLUE_KEY': [pygame.image.load(path + '\Images\Ants\Key\BlueKey\BlueKey1.png').convert_alpha(), pygame.image.load(path + '\Images\Ants\Key\BlueKey\BlueKey2.png').convert_alpha()],
                  'BROWN_KEY': [pygame.image.load(path + '\Images\Ants\Key\BrownKey\BrownKey1.png').convert_alpha(), pygame.image.load(path + '\Images\Ants\Key\BrownKey\BrownKey2.png').convert_alpha()],
                  'GREEN_KEY': [pygame.image.load(path + '\Images\Ants\Key\GreenKey\GreenKey1.png').convert_alpha(), pygame.image.load(path + '\Images\Ants\Key\GreenKey\GreenKey2.png').convert_alpha()],
                  'GREY_KEY': [pygame.image.load(path + '\Images\Ants\Key\GreyKey\GreyKey1.png').convert_alpha(), pygame.image.load(path + '\Images\Ants\Key\GreyKey\GreyKey2.png').convert_alpha()],
                  'ORANGE_KEY': [pygame.image.load(path + '\Images\Ants\Key\OrangeKey\OrangeKey1.png').convert_alpha(), pygame.image.load(path + '\Images\Ants\Key\OrangeKey\OrangeKey2.png').convert_alpha()],
                  'PINK_KEY': [pygame.image.load(path + '\Images\Ants\Key\PinkKey\PinkKey1.png').convert_alpha(), pygame.image.load(path + '\Images\Ants\Key\PinkKey\PinkKey2.png').convert_alpha()],
                  'PURPLE_KEY': [pygame.image.load(path + '\Images\Ants\Key\PurpleKey\PurpleKey1.png').convert_alpha(), pygame.image.load(path + '\Images\Ants\Key\PurpleKey\PurpleKey2.png').convert_alpha()],
                  'RED_KEY': [pygame.image.load(path + '\Images\Ants\Key\RedKey\RedKey1.png').convert_alpha(), pygame.image.load(path + '\Images\Ants\Key\RedKey\RedKey2.png').convert_alpha()],
                  'TEAL_KEY': [pygame.image.load(path + '\Images\Ants\Key\TealKey\TealKey1.png').convert_alpha(), pygame.image.load(path + '\Images\Ants\Key\TealKey\TealKey2.png').convert_alpha()],
                  'YELLOW_KEY': [pygame.image.load(path + '\Images\Ants\Key\YellowKey\YellowKey1.png').convert_alpha(), pygame.image.load(path + '\Images\Ants\Key\YellowKey\YellowKey2.png').convert_alpha()],
                  #
                  # Doors
                  'BLUE_DOOR': pygame.image.load(path + '\Images\Ants\Door\BlueDoor\BlueDoor.png').convert_alpha(),
                  'BROWN_DOOR': pygame.image.load(path + '\Images\Ants\Door\Door1.png').convert_alpha(),
                  'GREEN_DOOR': pygame.image.load(path + '\Images\Ants\Door\GreenDoor\GreenDoor.png').convert_alpha(),
                  'GREY_DOOR': pygame.image.load(path + '\Images\Ants\Door\GreyDoor\GreyDoor.png').convert_alpha(),
                  'ORANGE_DOOR': pygame.image.load(path + '\Images\Ants\Door\OrangeDoor\OrangeDoor.png').convert_alpha(),
                  'PINK_DOOR': pygame.image.load(path + '\Images\Ants\Door\PinkDoor\PinkDoor.png').convert_alpha(),
                  'PURPLE_DOOR': pygame.image.load(path + '\Images\Ants\Door\PurpleDoor\PurpleDoor.png').convert_alpha(),
                  'RED_DOOR': pygame.image.load(path + '\Images\Ants\Door\RedDoor\RedDoor.png').convert_alpha(),
                  'TEAL_DOOR': pygame.image.load(path + '\Images\Ants\Door\TealDoor\TealDoor.png').convert_alpha(),
                  'YELLOW_DOOR': pygame.image.load(path + '\Images\Ants\Door\YellowDoor\YellowDoor.png').convert_alpha(),
                  'WHOLE_FENCE_DOOR': pygame.image.load(path + '\Images\Ants\Door\Door2\WholeFenceDoor.png').convert_alpha(),
                  'FENCE_DOOR_RIGHT': pygame.image.load(path + '\Images\Ants\Door\Door2\FenceDoorRight.png').convert_alpha(),
                  'FENCE_DOOR_LEFT': pygame.image.load(path + '\Images\Ants\Door\Door2\FenceDoorLeft.png').convert_alpha(),
                  #
                  # Door with knob
                  'KNOB': pygame.image.load(path + '\Images\Town\DoorWithKnob\DOOR_KNOB.png').convert_alpha(),
                  'DOOR_WITH_KNOB': [pygame.image.load(path + '\Images\Town\DoorWithKnob\DoorWithKnob' + str(x+1) + '.png').convert_alpha() for x in range(9)],
                  #
                  # Squirrel
                  'SQUIRREL': [pygame.image.load(path + '\Images\TheDoor5-TopOfBossTree\Squirrel\Squirrel1.png').convert_alpha(), pygame.image.load(path + '\Images\TheDoor5-TopOfBossTree\Squirrel\Squirrel2.png').convert_alpha(), pygame.image.load(path + '\Images\TheDoor5-TopOfBossTree\Squirrel\Squirrel3.png').convert_alpha()],
                  'SQUIRREL_FLIPPED': [pygame.transform.flip(pygame.image.load(path + '\Images\TheDoor5-TopOfBossTree\Squirrel\Squirrel1.png'), True, False).convert_alpha(), pygame.transform.flip(pygame.image.load(path + '\Images\TheDoor5-TopOfBossTree\Squirrel\Squirrel2.png'), True, False).convert_alpha(), pygame.transform.flip(pygame.image.load(path + '\Images\TheDoor5-TopOfBossTree\Squirrel\Squirrel3.png'), True, False).convert_alpha()],
                  #
                  # Bouncy
                  'BOUNCY_MUSHROOM1': pygame.image.load(path + '\Images\TheDoor3-TreeTrunk\BouncyMushroom1\BouncyMushroom1.png').convert_alpha(),
                  'BOUNCY_MUSHROOM2': pygame.image.load(path + '\Images\TheDoor3-TreeTrunk\BouncyMushroom2\BouncyMushroom2-shrunk.png').convert_alpha(),
                  'BOUNCY_MUSHROOM_LEFT': pygame.image.load(path + '\Images\TheDoor3-TreeTrunk\BouncyMushroomLeft\BouncyMushroomLeft.png').convert_alpha(),
                  'BOUNCY_MUSHROOM_RIGHT': pygame.image.load(path + '\Images\TheDoor3-TreeTrunk\BouncyMushroomRight\BouncyMushroomRight.png').convert_alpha(),
                  'MEDIUM_MUSHY': pygame.image.load(path + '\Images\TheDoor3-TreeTrunk\MediumMushy\MediumMushy.png').convert_alpha(),
                  'SMALL_MUSHY': pygame.image.load(path + '\Images\TheDoor3-TreeTrunk\SmallMushy\SmallMushy.png').convert_alpha(),
                  'SQUARE_BOUNCY_MUSHROOM': pygame.image.load(path + '\Images\TheDoor6-InsideQueenAnt\SquareBouncyMushroom\SquareBouncyMushroom.png').convert_alpha(),
                  #
                  # Hawk
                  #'HAWK': [pygame.image.load(path + '\Images\Forest\BossHawk\BossHawk' + str(x+1) + '.png').convert_alpha() for x in range(8)],
                   'HAWK': [pygame.image.load(path + '\Images\Forest\BossHawk\\NEW_BossHawk' + str(x+1) + '.png').convert_alpha() for x in range(4)],
                  #
                  # Queen Ant
                  'QUEEN_ANT': [pygame.image.load(path + '\Images\AntHill\QueenAnt\\NewQueenAnt\QueenAntEating' + str(x+1) + '.png').convert_alpha() for x in range(12)],
                  'QUEEN_ANT_BUTT': pygame.image.load(path + '\Images\AntHill\QueenAnt\\NewQueenAnt\QueenAntButt.png').convert_alpha(),
                  'QUEEN_ANT_MOUTH': pygame.image.load(path + '\Images\AntHill\QueenAnt\\NewQueenAnt\QueenAntMouth.png').convert_alpha(),
                  #
                  # Leaves
                  'BIG_LEAF': [pygame.image.load(path + '\Images\LeafCutterAnt\Leaf\BigLeaf\FadingLeaf' + str(x+1) + '.png').convert_alpha() for x in range(26)],
                  'SMALL_LEAF': [pygame.image.load(path + '\Images\LeafCutterAnt\Leaf\SmallLeaf\Leaf' + str(x+1) + '.png').convert_alpha() for x in range(26)],
                  #
                  # Upgrade
                  'BUBBLE': pygame.image.load(path + '\Images\\Upgrade\Bubble\Bubble.png').convert_alpha(),
                  'PLUS_PISTON_POWER': pygame.image.load(path + '\Images\\Upgrade\PlusPistonPower\PlusPistonPower.png').convert_alpha(),
                  #
                  # Elevator
                  #'ELEVATOR': [pygame.image.load(path + '\Images\Elevator\Elevator1\Elevator' + str(x+1) + '.png').convert_alpha() for x in range(81)],
                  'DOWN_PEG': pygame.image.load(path + '\Images\Elevator\Elevator2InParts\DownPeg\DownPeg.png'),
                  'ELEVATOR_BACKGROUND': pygame.image.load(path + '\Images\Elevator\Elevator2InParts\ElevatorBackground\ElevatorBackground.png'),
                  'ELEVATOR_DOOR': [pygame.image.load(path + '\Images\Elevator\Elevator2InParts\ElevatorDoor\ElevatorDoor' + str(x+1) + '.png') for x in range(41)],
                  'LEFT_MIDDLE_PLATFORM': pygame.image.load(path + '\Images\Elevator\Elevator2InParts\LeftMiddlePlatform\LeftMiddlePlatform.png'),
                  'PLATFORM_LEFT': pygame.image.load(path + '\Images\Elevator\Elevator2InParts\PlatformLeft\PlatformLeft.png'),
                  'PLATFORM_LEFT_BOTTOM': pygame.image.load(path + '\Images\Elevator\Elevator2InParts\PlatformLeftBottom\PlatformLeftBottom.png'),
                  'PLATFORM_MIDDLE': pygame.image.load(path + '\Images\Elevator\Elevator2InParts\PlatformMiddle\PlatformMiddle.png'),
                  'PLATFORM_MIDDLE_BOTTOM': pygame.image.load(path + '\Images\Elevator\Elevator2InParts\PlatformMiddleBottom\PlatformMiddleBottom.png'),
                  'PLATFORM_RIGHT': pygame.image.load(path + '\Images\Elevator\Elevator2InParts\PlatformRight\PlatformRight.png'),
                  'PLATFORM_RIGHT_BOTTOM': pygame.image.load(path + '\Images\Elevator\Elevator2InParts\PlatformRightBottom\PlatformRightBottom.png'),
                  'RIGHT_MIDDLE_PLATFORM': pygame.image.load(path + '\Images\Elevator\Elevator2InParts\RightMiddlePlatform\RightMiddlePlatform.png'),
                  'UP_PEG': pygame.image.load(path + '\Images\Elevator\Elevator2InParts\\UpPeg\\UpPeg.png'),
                  #
                  # Root
                  'ROOT_BASE': [pygame.image.load(path + '\Images\AntHill\Root\Root1\RootBase\RootBase' + str(x+1) + '.png').convert_alpha() for x in range(5)],
                  'FADING_ROOT_ANIMATION': [pygame.image.load(path + '\Images\AntHill\Root\Root1\FadingRootAnimation\Root' + str(x+1) + '.png').convert_alpha() for x in range(14)],
                  'REGROWTH_ANIMATION': [pygame.image.load(path + '\Images\AntHill\Root\Root1\RegrowthAnimation\Root' + str(x+1) + '.png').convert_alpha() for x in range(18)],
                  'REGROWTH_COLLISION': [pygame.image.load(path + '\Images\AntHill\Root\Root1\RegrowthCollision\Root' + str(x+1) + '.png').convert_alpha() for x in range(18)],
                  'SHAKY': [pygame.image.load(path + '\Images\AntHill\Root\Root1\ShakyRoot\Root' + str(x+1) + '.png').convert_alpha() for x in range(4)],
                  'ROOT_BASE_FLIPPED': [pygame.transform.flip(pygame.image.load(path + '\Images\AntHill\Root\Root1\RootBase\RootBase' + str(x+1) + '.png').convert_alpha(), True, False) for x in range(5)],
                  'FADING_ROOT_ANIMATION_FLIPPED': [pygame.transform.flip(pygame.image.load(path + '\Images\AntHill\Root\Root1\FadingRootAnimation\Root' + str(x+1) + '.png').convert_alpha(), True, False) for x in range(14)],
                  'REGROWTH_ANIMATION_FLIPPED': [pygame.transform.flip(pygame.image.load(path + '\Images\AntHill\Root\Root1\RegrowthAnimation\Root' + str(x+1) + '.png').convert_alpha(), True, False) for x in range(18)],
                  'REGROWTH_COLLISION_FLIPPED': [pygame.transform.flip(pygame.image.load(path + '\Images\AntHill\Root\Root1\RegrowthCollision\Root' + str(x+1) + '.png').convert_alpha(), True, False) for x in range(18)],
                  'SHAKY_FLIPPED': [pygame.transform.flip(pygame.image.load(path + '\Images\AntHill\Root\Root1\ShakyRoot\Root' + str(x+1) + '.png').convert_alpha(), True, False) for x in range(4)],
                  #
                  # DripDrop
                  'DRIP': [pygame.image.load(path + '\Images\DripDrop\Drip\Drip' + str(x+1) + '.png').convert_alpha() for x in range(13)],
                  'DRIPDROP_ANIMATION': [pygame.image.load(path + '\Images\DripDrop\DripDropAnimation\DripDropAnimation' + str(x+1) + '.png').convert_alpha() for x in range(4)],
                  'DRIPDROP_COLLISION': [pygame.image.load(path + '\Images\DripDrop\DripDropCollision\DripDropCollision' + str(x+1) + '.png').convert_alpha() for x in range(4)],
                  'DROP': [pygame.image.load(path + '\Images\DripDrop\Drop\Drop' + str(x+1) + '.png').convert_alpha() for x in range(23)],
                  #
                  # Irregularly shaped water
                  'TOP_OF_WATER_FALL': pygame.image.load(path + '\Images\AntHill/SewerWater/TopOfWaterFall.png').convert_alpha(),
                  'WATER_BEGINNING_TO_FALL': pygame.image.load(path + '\Images\AntHill/SewerWater/WaterBeginningToFall.png').convert_alpha(),
                  'TOP_OF_FALLING_WATER': pygame.image.load(path + '\Images\AntHill/SewerWater/TopOfFallingWater.png').convert_alpha(),
                  'MIDDLE_OF_FALLING_WATER': pygame.image.load(path + '\Images\AntHill/SewerWater/MiddleOfFallingWater.png').convert_alpha(),
                  'BOTTOM_OF_FALLING_WATER': pygame.image.load(path + '\Images\AntHill/SewerWater/BottomOfFallingWater.png').convert_alpha(),
                  'BOTTOM_LAKE': pygame.image.load(path + '\Images\AntHill/SewerWater/BottomLake.png').convert_alpha(),
                  'FIRST_JOURNEY_DOWN_TUNNEL': pygame.image.load(path + '\Images\AntHill/SewerWater/FirstJourneyDownTunnel.png').convert_alpha(),
                  'SECOND_JOURNEY_DOWN_TUNNEL': pygame.image.load(path + '\Images\AntHill/SewerWater/SecondJourneyDownTunnel.png').convert_alpha(),
                  'THIRD_JOURNEY_DOWN_TUNNEL': pygame.image.load(path + '\Images\AntHill/SewerWater/ThirdJourneyDownTunnel.png').convert_alpha(),
                  'FOURTH_JOURNEY_DOWN_TUNNEL': pygame.image.load(path + '\Images\AntHill/SewerWater/FourthJourneyDownTunnel.png').convert_alpha(),
                  'FIFTH_JOURNEY_DOWN_TUNNEL': pygame.image.load(path + '\Images\AntHill/SewerWater/FifthJourneyDownTunnel.png').convert_alpha(),
                  'SIXTH_JOURNEY_DOWN_TUNNEL': pygame.image.load(path + '\Images\AntHill/SewerWater/SixthJourneyDownTunnel.png').convert_alpha(),
                  'SEVENTH_JOURNEY_DOWN_TUNNEL': pygame.image.load(path + '\Images\AntHill/SewerWater/SeventhJourneyDownTunnel.png').convert_alpha(),
                  'BOTTOM_OF_WATER_FALL': pygame.image.load(path + '\Images\AntHill/SewerWater/BottomOfWaterFall.png').convert_alpha(),
                  'THE_DOOR11_IRREGULAR_WATER': pygame.image.load(path + '\Images\TheDoor11-WaterRace\IrregularlyShapedWaterCollision\IrregularlyShapedWaterCollision.png').convert_alpha(),
                  #
                  # SewerJet
                  'SEWER_JET': [pygame.image.load(path + '\Images\Sewer\SewerJet\SewerJet' + str(x+1) + '.png') for x in range(1)],
                  #
                  # Spinny
                  #'SPINNY1': pygame.image.load(path + '\Images\Sewer\SpinnyObject\SpinnyObject.png'),
                  #'SPINNY2': pygame.image.load(path + '\Images\Sewer\SpinnyObject\SpinnyObject2.png'),
                  #'SPINNY3': pygame.image.load(path + '\Images\Sewer\SpinnyObject\SpinnyObject3.png'),
                  #'SPINNY4': pygame.image.load(path + '\Images\Sewer\SpinnyObject\SpinnyObject4.png'),
                  #
                  # Leak
                  #'LEAK': [pygame.image.load(path + '\Images\Sewer\WaterLeak\Leak' + str(x+1) + '.png') for x in range(21)],
                  #
                  # Grate
                  'GA': [pygame.image.load(path + '\Images\Sewer\WaterFall\Angle\Angle' + str(x+1) + '.png').convert_alpha() for x in range(8)],
                  'GG': [pygame.image.load(path + '\Images\Sewer\WaterFall\Grate\Grate' + str(x+1) + '.png').convert_alpha() for x in range(8)],
                  'GH': [pygame.image.load(path + '\Images\Sewer\WaterFall\Horizontal\WaterFallHorizontal' + str(x+1) + '.png').convert_alpha() for x in range(8)],
                  'GT': [pygame.image.load(path + '\Images\Sewer\WaterFall\T\T' + str(x+1) + '.png').convert_alpha() for x in range(8)],
                  'GV': [pygame.image.load(path + '\Images\Sewer\WaterFall\Vertical\Vertical' + str(x+1) + '.png').convert_alpha() for x in range(8)],
                  'GAR': [pygame.transform.flip(pygame.image.load(path + '\Images\Sewer\WaterFall\Angle\Angle' + str(x+1) + '.png'), True, False).convert_alpha() for x in range(8)],
                  'GGR': [pygame.transform.flip(pygame.image.load(path + '\Images\Sewer\WaterFall\Grate\Grate' + str(x+1) + '.png'), True, False).convert_alpha() for x in range(8)],
                  'GHR': [pygame.transform.flip(pygame.image.load(path + '\Images\Sewer\WaterFall\Horizontal\WaterFallHorizontal' + str(x+1) + '.png'), True, False).convert_alpha() for x in range(8)],
                  'GTR': [pygame.transform.flip(pygame.image.load(path + '\Images\Sewer\WaterFall\T\T' + str(x+1) + '.png'), True, False).convert_alpha() for x in range(8)],
                  'GVR': [pygame.transform.flip(pygame.image.load(path + '\Images\Sewer\WaterFall\Vertical\Vertical' + str(x+1) + '.png'), True, False).convert_alpha() for x in range(8)],
                  #
                  # Lever
                  'BLOCK': pygame.image.load(path + '\Images\Sewer\Lever\Block\Block.png'),
                  'BOLT': [pygame.image.load(path + '\Images\Sewer\Lever\Bolt\Bolt' + str(x+1) + '.png') for x in range(7)],
                  'LEVER': [pygame.image.load(path + '\Images\Sewer\Lever\Lever\Lever' + str(x+1) + '.png') for x in range(7)],
                  #
                  # Water surface
                  'WATER_SURFACE1': [pygame.image.load(path + '\Images\WaterSurface\WaterSurface1\WaterSurface' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE2': [pygame.image.load(path + '\Images\WaterSurface\WaterSurface2\WaterSurface' + str(x+1) + '.png') for x in range(1)],
                  'WATER_SURFACE_TUTORIAL': [pygame.image.load(path + '\Images\WaterSurface\WaterSurfaceTutorial\WaterSurfaceTutorial' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_FOREST1': [pygame.image.load(path + '\Images\WaterSurface\Forest_water1_surface\Forest_water1_surface' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_FOREST2': [pygame.image.load(path + '\Images\WaterSurface\Forest_water2_surface\Forest_water2_surface' + str(x+1) + '.png') for x in range(1)],
                  'WATER_SURFACE_CLOUD_LEFT': [pygame.image.load(path + '\Images\WaterSurface\CloudLevel\Left\Left' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_CLOUD_RIGHT': [pygame.image.load(path + '\Images\WaterSurface\CloudLevel\Right\Right' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_SURFING': [pygame.image.load(path + '\Images\WaterSurface\Surfing\Surfing' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE1': [pygame.image.load(path + '\Images\WaterSurface\Race\Race1\Race' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE2': [pygame.image.load(path + '\Images\WaterSurface\Race\Race2\Race' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE3': [pygame.image.load(path + '\Images\WaterSurface\Race\Race3\Race' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE4': [pygame.image.load(path + '\Images\WaterSurface\Race\Race4\Race' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE5': [pygame.image.load(path + '\Images\WaterSurface\Race\Race5\Race' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE6': [pygame.image.load(path + '\Images\WaterSurface\Race\Race6\Race' + str(x+1) + '.png') for x in range(20)],
                  #
                  # Goldfish
                  'GOLDFISH': [pygame.image.load(path + '\Images\Sewer\Goldfish\Goldfish' + str(x+1) + '.png') for x in range(4)],
                  #
                  # Transport pipe
                  'ONER_RIGHT': pygame.image.load(path + '\Images\Sewer\PipeTransport\Oners\EntranceRight.png'),
                  'ONER_LEFT': pygame.image.load(path + '\Images\Sewer\PipeTransport\Oners\EntranceLeft.png'),
                  'ONER_UP': pygame.image.load(path + '\Images\Sewer\PipeTransport\Oners\EntranceUp.png'),
                  'ONER_DOWN': pygame.image.load(path + '\Images\Sewer\PipeTransport\Oners\EntranceDown.png'),
                  #
                  # Surf board
                  'WHOLE_SURF_BOARD_COLLISION': pygame.image.load(path + '\Images\Sewer\SurfBoard\Surfboard.png'),
                  'SURF_BOARD_LEFT_COLLISION': pygame.image.load(path + '\Images\Sewer\SurfBoard\LeftBoardCollision.png'),
                  'SURF_BOARD_RIGHT_COLLISION': pygame.image.load(path + '\Images\Sewer\SurfBoard\RightBoardCollision.png'),
                  #
                  # Wave
                  'SMALL_WAVE': [pygame.image.load(path + '\Images\Sewer\Wave\SmallWave\Wave' + str(x+1) + '.png') for x in range(1)],
                  'MEDIUM_WAVE': [pygame.image.load(path + '\Images\Sewer\Wave\MediumWave\Wave' + str(x+1) + '.png') for x in range(1)],
                  'BIG_WAVE': [pygame.image.load(path + '\Images\Sewer\Wave\BigWave\Wave' + str(x+1) + '.png') for x in range(1)],
                  #
                  # Bucket
                  'BUCKET': pygame.image.load(path + '\Images\Sewer\Bucket\BucketCollision.png'),
                  #
                  # Food
                  'ALMOND': pygame.image.load(path + '\Images\Sewer\Food\Almond.png'),
                  'BANANA': pygame.image.load(path + '\Images\Sewer\Food\Banana.png'),
                  'BLACKBERRY': pygame.image.load(path + '\Images\Sewer\Food\Blackberry.png'),
                  'COCONUT': pygame.image.load(path + '\Images\Sewer\Food\Coconut.png'),
                  #
                  # Pause Menu
                  'MENU_OPTION_SIZING': pygame.image.load(path + '\Images/LoadingScreens\PauseMenu\Continue.png'),
                  #
                  # Mouses
                  'ACTUAL_MOUSE': pygame.image.load(path + '\Images\MouseReplacement\ActualMouse.png'),
                  #
                  # HamsterOs
                  'HAMSTER_OS': pygame.image.load(path + '\Images\Town\HamsterOs\HamsterOs.png'),
                  #'PELLET': pygame.image.load(path + '\Images\Town\HamsterOs\Pellet.png'),
                  #
                  # Human
                  'HUMAN_STANDING': pygame.image.load(path + '\Images\Town\Human\HumanStanding\HumanStanding1.png'),
                  #
                  # Garbage can
                  'GARBAGE_CAN_COLLISION': pygame.image.load(path + '\Images\Town\GarbageCan\GarbageCanCollision.png'),
                  #
                  # Beetle
                  'BEETLE_WALK_RIGHT': [pygame.image.load(path + '\Images/AntHill/Beetle/Beetle_WalkingRight/Beetle_WalkingRight' + str(x+1) + '.png') for x in range(24)],
                  'BEETLE_STAND_RIGHT': [pygame.image.load(path + '\Images/AntHill/Beetle/Beetle_StandingRight/Beetle_StandingRight' + str(x+1) + '.png') for x in range(12)],
                  'RIGHT_LOOK_UP': [pygame.image.load(path + '\Images/AntHill/Beetle/Beetle_RightLookUp/Beetle_RightLookUp' + str(x+1) + '.png') for x in range(6)],
                  'RIGHT_JUMP': [pygame.image.load(path + '\Images/AntHill/Beetle/Beetle_RightJump/Beetle_RightJump' + str(x+1) + '.png') for x in range(9)],
                  'RIGHT_IN_THE_AIR': [pygame.image.load(path + '\Images/AntHill/Beetle/Beetle_InTheAir/Beetle_InTheAir' + str(x+1) + '.png') for x in range(10)],
                  'BUTTON': [pygame.image.load(path + '\Images/AntHill/Beetle/YellowButton/YellowButton' + str(x+1) + '.png') for x in range(10)],
                  #
                  # The Machine
                  'THE_MACHINE_COLLISION': [pygame.image.load(path + '\Images/Town\TheMachine\TheMachineCollision\TheMachineCollision' + str(x+1) + '.png') for x in range(4)],
                  'GREEN_BUTTON': [pygame.image.load(path + '\Images/Town\TheMachine\GreenButton\GreenButton' + str(x+1) + '.png') for x in range(2)],
                  'RED_BUTTON': [pygame.image.load(path + '\Images/Town\TheMachine\RedButton\RedButton' + str(x+1) + '.png') for x in range(2)]
                  }


def load_OpenGLTextures():
  global OpenGLTextures
  OpenGLTextures = {#PLAYER
                  'PLAYER_BALL':loadTexture(path + '\Images\MEDIUM_CIRCLE.png'),
                  'THE_BALL_FRONT': loadTexture(path + '\Images\THE_BALL_FRONT.png'),
                  'THE_BALL_BACK': loadTexture(path + '\Images\THE_BALL_BACK.png'),
                  'HAMSTER_STANDING_RIGHT': loadTexture(path + '\Images\Hamster\HamsterStandingRight\HamsterStandingRight.png'),
                  'HAMSTER_STANDING_LEFT': loadTexture(path + '\Images\Hamster\HamsterStandingRight\HamsterStandingRight.png'),
                  'HAMSTER_WALKING_RIGHT': [loadTexture(path + '\Images\Hamster\HamsterWalkingRight\HamsterWalkingRight1.png'), loadTexture(path + '\Images\Hamster\HamsterWalkingRight\HamsterWalkingRight2.png'), loadTexture(path + '\Images\Hamster\HamsterWalkingRight\HamsterWalkingRight3.png'), loadTexture(path + '\Images\Hamster\HamsterWalkingRight\HamsterWalkingRight4.png')],
                  'HAMSTER_WALKING_LEFT': [loadTexture(path + '\Images\Hamster\HamsterWalkingRight\HamsterWalkingRight1.png'), loadTexture(path + '\Images\Hamster\HamsterWalkingRight\HamsterWalkingRight2.png'), loadTexture(path + '\Images\Hamster\HamsterWalkingRight\HamsterWalkingRight3.png'), loadTexture(path + '\Images\Hamster\HamsterWalkingRight\HamsterWalkingRight4.png')],
                  'ROLLING_CLOCKWISE': [loadTexture(path + '\Images\Hamster\RollingRight\RollingRight1.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight2.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight3.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight4.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight5.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight6.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight7.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight8.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight9.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight10.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight11.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight12.png')],
                  'ROLLING_COUNTERCLOCKWISE': [loadTexture(path + '\Images\Hamster\RollingRight\RollingRight1.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight2.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight3.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight4.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight5.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight6.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight7.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight8.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight9.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight10.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight11.png'), loadTexture(path + '\Images\Hamster\RollingRight\RollingRight12.png')],
                  'HAMSTER_FLOAT_RIGHT': [loadTexture(path + '\Images\Hamster\FloatRight\FloatRight1.png'), loadTexture(path + '\Images\Hamster\FloatRight\FloatRight2.png'), loadTexture(path + '\Images\Hamster\FloatRight\FloatRight3.png'), loadTexture(path + '\Images\Hamster\FloatRight\FloatRight4.png')],
                  'HAMSTER_FLOAT_LEFT': [loadTexture(path + '\Images\Hamster\FloatRight\FloatRight1.png'), loadTexture(path + '\Images\Hamster\FloatRight\FloatRight2.png'), loadTexture(path + '\Images\Hamster\FloatRight\FloatRight3.png'), loadTexture(path + '\Images\Hamster\FloatRight\FloatRight4.png')],
                  'HAMSTER_FALLING_RIGHT': loadTexture(path + '\Images\Hamster\FallingRight\FallingRight.png'),
                  'HAMSTER_FALLING_LEFT': loadTexture(path + '\Images\Hamster\FallingRight\FallingRight.png'),
                  'HAMSTER_FLYING_RIGHT': [loadTexture(path + '\Images\Hamster\FlyingRight\FlyingRight1.png'), loadTexture(path + '\Images\Hamster\FlyingRight\FlyingRight2.png'), loadTexture(path + '\Images\Hamster\FlyingRight\FlyingRight3.png'), loadTexture(path + '\Images\Hamster\FlyingRight\FlyingRight4.png'), loadTexture(path + '\Images\Hamster\FlyingRight\FlyingRight5.png')],
                  'HAMSTER_FLYING_LEFT': [loadTexture(path + '\Images\Hamster\FlyingRight\FlyingRight1.png'), loadTexture(path + '\Images\Hamster\FlyingRight\FlyingRight2.png'), loadTexture(path + '\Images\Hamster\FlyingRight\FlyingRight3.png'), loadTexture(path + '\Images\Hamster\FlyingRight\FlyingRight4.png'), loadTexture(path + '\Images\Hamster\FlyingRight\FlyingRight5.png')],
                  'AIR_BUBBLE': loadTexture(path + '\Images\AirBubbles\AirBubbles.png'),
                  'SINGLE_BUBBLE': [loadTexture(path + '\Images\AirBubbles\SingleBubble\SingleBubble' + str(x+1) + '.png') for x in range(4)],
                  #
                  # Background
                  'Forest_BG1': [loadTexture(path + '\Images/Forest/Background/Background1/Background1.png')],
                  'Forest_BG3': [loadTexture(path + '\Images/Forest/Background/Background3/Background1.png')],
                  'Forest_BG4': [loadTexture(path + '\Images/Forest/Background/Background4/Background1.png')],
                  'Forest_BG5': [loadTexture(path + '\Images/Forest/Background/Background5/Background1.png')],
                  'Forest_BG6': [loadTexture(path + '\Images/Forest/Background/Background6/Background1.png')],
                  'Forest_BGDEER': [loadTexture(path + '\Images/Forest/Background/DEER/DEER1.png'), loadTexture(path + '\Images/Forest/Background/DEER/DEER2.png'), loadTexture(path + '\Images/Forest/Background/DEER/DEER3.png'), loadTexture(path + '\Images/Forest/Background/DEER/DEER4.png'), loadTexture(path + '\Images/Forest/Background/DEER/DEER5.png'), loadTexture(path + '\Images/Forest/Background/DEER/DEER6.png')],
                  'Forest_BG7': [loadTexture(path + '\Images/Forest/Background/Background7/Background1.png')],
                  'Forest_BG12': [loadTexture(path + '\Images/Forest/Background/Background12/Background1.png')],
                  'AntHill_BG': [loadTexture(path + '\Images/AntHill/Background/Background1.png'), loadTexture(path + '\Images/AntHill/Background/Background2.png'), loadTexture(path + '\Images/AntHill/Background/Background3.png'), loadTexture(path + '\Images/AntHill/Background/Background4.png'), loadTexture(path + '\Images/AntHill/Background/Background5.png'), loadTexture(path + '\Images/AntHill/Background/Background6.png'), loadTexture(path + '\Images/AntHill/Background/Background7.png'), loadTexture(path + '\Images/AntHill/Background/Background8.png'), loadTexture(path + '\Images/AntHill/Background/Background9.png'), loadTexture(path + '\Images/AntHill/Background/Background10.png'), loadTexture(path + '\Images/AntHill/Background/Background11.png'), loadTexture(path + '\Images/AntHill/Background/Background12.png'), loadTexture(path + '\Images/AntHill/Background/Background13.png'), loadTexture(path + '\Images/AntHill/Background/Background14.png'), loadTexture(path + '\Images/AntHill/Background/Background15.png'), loadTexture(path + '\Images/AntHill/Background/Background16.png'), loadTexture(path + '\Images/AntHill/Background/Background17.png'), loadTexture(path + '\Images/AntHill/Background/Background18.png'), loadTexture(path + '\Images/AntHill/Background/Background19.png'), loadTexture(path + '\Images/AntHill/Background/Background20.png'), loadTexture(path + '\Images/AntHill/Background/Background21.png'), loadTexture(path + '\Images/AntHill/Background/Background22.png'), loadTexture(path + '\Images/AntHill/Background/Background23.png'), loadTexture(path + '\Images/AntHill/Background/Background24.png'), loadTexture(path + '\Images/AntHill/Background/Background25.png'), loadTexture(path + '\Images/AntHill/Background/Background26.png'), loadTexture(path + '\Images/AntHill/Background/Background27.png'), loadTexture(path + '\Images/AntHill/Background/Background28.png'), loadTexture(path + '\Images/AntHill/Background/Background29.png'), loadTexture(path + '\Images/AntHill/Background/Background30.png'), loadTexture(path + '\Images/AntHill/Background/Background31.png'), loadTexture(path + '\Images/AntHill/Background/Background32.png')],
                  'SEWER_BG': [loadTexture(path + '\Images/Sewer/Background/Background.png')],
                  'SEWER_GREEN_BG': [loadTexture_high_quality(path + '\Images/Sewer/Background/BackgroundGreen/BackgroundGreen.png')],
                  'ROOT_LEVEL_BG': [loadTexture(path + '\Images/TheDoor9-ClimbingRoots\Background.png')],
                  #
                  # Pistons
                  'SHEATH': loadTexture(path + '\Images\Piston_Sheath' + '2' + '.png'),
                  'PUSH_PISTON': 0,
                  'PUSH_PISTON_COVER': loadTexture(path + '\Images\PUSH_PISTON\PushPistonCover\PushPistonCover2.png'),
                  'ALPHA_PUSH_PISTON': [loadTexture(path + '\Images\PUSH_PISTON\PushPistonCover\AlphaPushPistonCover\AlphaPiston' + str(x+1) + '.png') for x in range(9)],
                  'RED_ALPHA_PUSH_PISTON': [loadTexture(path + '\Images\PUSH_PISTON\PushPistonCover\DiscoloredAlpha\RedPushPistonAlpha' + str(x+1) + '.png') for x in range(10)],
                  'SPLASH': [loadTexture(path + '\Images\PUSH_PISTON\Splash\Splash' + str(x+1) + '.png') for x in range(4)],
                  'GRAPPLE_PISTON': 0,
                  'GRAPPLE_PISTON_COVER': loadTexture(path + '\Images\GRAPPLE_PISTON\GrapplePiston5\GrapplePiston5.png'),
                  'ALPHA_GRAPPLE_PISTON': [loadTexture(path + '\Images\GRAPPLE_PISTON\GrapplePiston5\Alpha\GrappleAlpha' + str(x+1) + '.png') for x in range(9)],
                  'DISCOLORED_GRAPPLE': [loadTexture(path + '\Images\GRAPPLE_PISTON\GrapplePiston5\Discolored\Alpha' + str(x+1) + '.png') for x in range(10)],
                  'GRAPPLE_PISTON_CLOSED_COVER': loadTexture(path + '\Images\GRAPPLE_PISTON\ClosedGrapple5\ClosedGrapple5.png'),
                  #
                  # Vines
                  'BUCKET_VINE': loadTexture(path + '\Images\Vines\BucketRope\Vine.png'),
                  'LEAD9': loadTexture(path + '\Images\Vines\Lead9\Lead9.png'),
                  'LONGLEAD1': loadTexture(path + '\Images\Vines\LongLead1/LongLead.png'),
                  'LONGLEAD2': loadTexture(path + '\Images\Vines\LongLead2/LongLead.png'),
                  'SEWERVINE1': loadTexture(path + '\Images\Vines\SewerVine1\Vine42.png'),
                  'SEWERVINE2': loadTexture(path + '\Images\Vines\SewerVine2\LongVine.png'),
                  'UVULAVINE': loadTexture(path + '\Images\Vines\\UvulaVine\\UvulaVine18.png'),
                  'VINE9': loadTexture(path + '\Images\Vines\Vine9\Vine9.png'),
                  'VINE18': loadTexture(path + '\Images\Vines\Vine18\Vine18.png'),
                  'VINE18_SHADE': loadTexture(path + '\Images\Vines\Vine18\Vine18-shade.png'),
                  'VINE42': loadTexture(path + '\Images\Vines\Vine42\Vine42.png'),
                  'WELL_ROPE': loadTexture(path + '\Images\Vines\WellRope\Vine.png'),
                  #
                  # Clouds
                  'FOREST_CLOUD_1': loadTexture(path + '\Images\Forest\Cloud2\Cloud2.png'),
                  'FOREST_CLOUD_2': loadTexture(path + '\Images\Forest\Cloud2\Cloud1.png'),
                  'CLOUD1_1': loadTexture(path + '\Images\TheDoor2-Clouds\Cloud1\Cloud2.png'),
                  'CLOUD1_2': loadTexture(path + '\Images\TheDoor2-Clouds\Cloud1\Cloud1.png'),
                  'CLOUD2_1': loadTexture(path + '\Images\TheDoor2-Clouds\Cloud2\Cloud4.png'),
                  'CLOUD2_2': loadTexture(path + '\Images\TheDoor2-Clouds\Cloud2\Cloud3.png'),
                  #
                  # TeeterTotters
                  'TEETERTOTTER1': loadTexture(path + '\Images\TheDoor1-MetalBars/TeeterTotter2/TeeterTotter2.png'),
                  #'TEETERTOTTER2': loadTexture(path + '\Images\AntHill/WoodenTeeterTotter3/WoodenTeeterTotter.png'),
                  #
                  # SimplySprite
                  'WATER1': loadTexture(path + '\Images\Water1.png'),
                  #'FENCE_RIGHT': loadTexture(path + '\Images\Forest/Fence_right/Fence_right.png'),
                  'TOP_OF_TREE': loadTexture(path + '\Images\Forest/TopOfTree/TopOfTree.png'),
                  'MOUSE1': loadTexture(path + '\Images\Forest/Mouse/Mouse.png'),
                  'WATER2': loadTexture(path + '\Images\Forest/Water1/Water1o.png'),
                  'WATER3': loadTexture(path + '\Images\Forest/Water2/Water1o.png'),
                  'CLOUD_SPRITE1': loadTexture(path + '\Images\Forest/CloudSprite2/CloudSprite2.png'),
                  'THE_DOOR': loadTexture(path + '\Images\DoorToPistonExtensionsLevels/TheDoor.png'),
                  'SHADED_THE_DOOR': loadTexture(path + '\Images\DoorToPistonExtensionsLevels/ShadedDoor.png'),
                  'OUTLINE_THE_DOOR': loadTexture(path + '\Images\DoorToPistonExtensionsLevels/Outline.png'),
                  'TRAVEL': loadTexture(path + '\Images\DoorToPistonExtensionsLevels/Travel.png'),
                  'SELECT_NEW_KEY': loadTexture(path + '\Images\DoorToPistonExtensionsLevels/SelectNewKey.png'),
                  'TOGGLE_FULL_SCREEN': loadTexture(path + '\Images\DoorToPistonExtensionsLevels/Toggle_Full_Screen.png'),
                  'DIFFICULTY_SLIDER': [loadTexture(path + '\Images\DoorToPistonExtensionsLevels/DifficultySlider\DifficultySlider' + str(x+1) + '.png') for x in range(4)],
                  'BLANK_DIFFICULTY_SLIDER': loadTexture(path + '\Images\DoorToPistonExtensionsLevels/DifficultySlider\BlankSlider.png'),
                  'TO_INTERACT': loadTexture(path + '\Images\DoorToPistonExtensionsLevels/DifficultySlider\ToInteract.png'),
                  'TO_SEARCH_TRASH': loadTexture(path + '\Images\DoorToPistonExtensionsLevels/DifficultySlider\ToSearchTrash.png'),
                  #'WATER4': loadTexture(path + '\Images\TheDoor2-Clouds/Water1/Water1.png'),
                  'CLOUD_SPRITE2': loadTexture(path + '\Images\TheDoor2-Clouds/CloudSprite1/CloudSprite1.png'),
                  'CLOUD_SPRITE3': loadTexture(path + '\Images\TheDoor2-Clouds/CloudSprite2/CloudSprite2.png'),
                  'CLOUD_SPRITE4': loadTexture(path + '\Images\TheDoor2-Clouds/CloudSprite3/CloudSprite3.png'),
                  'CLOUD_SPRITE5': loadTexture(path + '\Images\TheDoor2-Clouds/CloudSprite4/CloudSprite4.png'),
                  'SEWER_WATER1': loadTexture(path + '\Images\AntHill/SewerWater/SewerWaterBigCollision.png'),
                  'SEWER_WATER2': loadTexture(path + '\Images\AntHill/SewerWater/Animation\Animation-Sheet.png'),
                  #'LONG_POOL': loadTexture(path + '\Images\Sewer\WaterPools\LongPool.png'),
                  #'LESS_LONG_POOL': loadTexture(path + '\Images\Sewer\WaterPools\LessLongPool.png'),
                  #'BUCKET_POOL': loadTexture(path + '\Images\Sewer\WaterPools\BucketPool.png'),
                  #'WATER_POOL1': loadTexture(path + '\Images\Sewer\WaterPools\WaterPool1.png'),
                  'WATER_POOL1': loadTexture(path + '\Images\Sewer\\New_water_pools\Water_pool1.png'),
                  'WATER_POOL2': loadTexture(path + '\Images\Sewer\\New_water_pools\Water_pool2.png'),
                  'WATER_POOL3': loadTexture(path + '\Images\Sewer\\New_water_pools\Water_pool3.png'),
                  #'WATER_POOL2': loadTexture(path + '\Images\Sewer\WaterPools\WaterPool2.png'),
                  'BLUE_PIXEL': loadTexture(path + '\Images\Sewer\WaterPools\BluePixel.png'),
                  'SEWER_WATER_FALL': loadTexture(path + '\Images\Sewer\WaterPools\WaterIntoSewerAnimation\SewerWaterFallAnimationSheet.png'),
                  'SEWER_WATER_FALL_FADED': loadTexture(path + '\Images\Sewer\WaterPools\WaterIntoSewerAnimation\Faded.png'),
                  'ELEVATOR_DOOR_HIDER': loadTexture_high_quality(path + '\Images\TheDoor7-TeeterTotterKey\DoorHider.png'),
                  'FOREST_DOOR_HIDER': loadTexture_high_quality(path + '\Images\Forest\DoorHider.png'),
                  'WELL': loadTexture(path + '\Images\Town\Well.png'),
                  'WATER_SURFACE_HIDER_SURFING': loadTexture(path + '\Images\TheDoor12-Surfing\WaterSurfaceHider.png'),
                  'WATER_SURFACE_HIDER_TUTORIAL': loadTexture(path + '\Images\TheDoor13-Tutorial\WaterSurfaceHider\WaterSurfaceHider.png'),
                  'TRASH_HIDER1': loadTexture(path + '\Images\TheDoor13-Tutorial\WaterSurfaceHider\TrashHider1.png'),
                  'TRASH_HIDER2': loadTexture(path + '\Images\TheDoor13-Tutorial\WaterSurfaceHider\TrashHider2.png'),
                  'TRASH': loadTexture(path + '\Images\TheDoor13-Tutorial\Trash\Trash.png'),
                  'SHEATH_TRASH': loadTexture(path + '\Images\TheDoor13-Tutorial\Trash\Sheath_trash.png'),
                  'GRAPPLE_TRASH': loadTexture(path + '\Images\TheDoor13-Tutorial\Trash\Grapple_trash.png'),
                  'RACING_POOL1': loadTexture(path + '\Images\TheDoor11-WaterRace\\New_water_pools\Water_pool1.png'),
                  'RACING_POOL2': loadTexture(path + '\Images\TheDoor11-WaterRace\\New_water_pools\Water_pool2.png'),
                  'RACING_POOL3': loadTexture(path + '\Images\TheDoor11-WaterRace\\New_water_pools\Water_pool3.png'),
                  'RACING_POOL4': loadTexture(path + '\Images\TheDoor11-WaterRace\\New_water_pools\Water_pool4.png'),
                  'RACING_POOL5': loadTexture(path + '\Images\TheDoor11-WaterRace\\New_water_pools\Water_pool5.png'),
                  'RACING_POOL6': loadTexture(path + '\Images\TheDoor11-WaterRace\\New_water_pools\Water_pool6.png'),
                  'RACING_WATER_FALL': loadTexture(path + '\Images\TheDoor11-WaterRace\IrregularlyShapedWaterCollision\Animation-Sheet.png'),
                  #
                  # WaterCover
                  'TUTORIAL_WATER_COVER': loadTexture(path + '\Images\TheDoor13-Tutorial\WaterSurfaceHider\WaterCover.png'),
                  'FOREST_WATER_COVER1': loadTexture(path + '\Images\Forest\Water_covers\Water_cover1.png'),
                  'CLOUD_COVER': loadTexture(path + '\Images\TheDoor2-Clouds\WaterCover.png'),
                  #
                  # MovingSprite
                  'FLOWER1': loadTexture(path + '\Images\Forest/Flower1/Flower1-Sheet.png'),
                  'FLOWER2': loadTexture(path + '\Images\Forest/Flower2/Flower2-Sheet.png'),
                  'FLOWER3': loadTexture(path + '\Images\Forest/Flower3/Flower3-Sheet.png'),
                  'FOREST_GRASS_R0': [loadTexture(path + '\Images\Forest/Grass/Flat\Grass' + str(x+1) + '.png') for x in range(4)],
                  'FOREST_GRASS_R10': [loadTexture(path + '\Images\Forest/Grass/R10\Grass' + str(x+1) + '.png') for x in range(4)],
                  'FOREST_GRASS_R20': [loadTexture(path + '\Images\Forest/Grass/R20\Grass' + str(x+1) + '.png') for x in range(4)],
                  'FOREST_GRASS_R30': [loadTexture(path + '\Images\Forest/Grass/R30\Grass' + str(x+1) + '.png') for x in range(4)],
                  'ANTHILL_GRASS_R0': [loadTexture(path + '\Images\AntHill/Grass/Flat\Grass' + str(x+1) + '.png') for x in range(4)],
                  'ANTHILL_GRASS_R10': [loadTexture(path + '\Images\AntHill/Grass/R10\Grass' + str(x+1) + '.png') for x in range(4)],
                  'ANTHILL_GRASS_R20': [loadTexture(path + '\Images\AntHill/Grass/R20\Grass' + str(x+1) + '.png') for x in range(4)],
                  'ANTHILL_GRASS_R30': [loadTexture(path + '\Images\AntHill/Grass/R30\Grass' + str(x+1) + '.png') for x in range(4)],
                  'WATER_SPRITE1': loadTexture(path + '\Images\TheDoor6-InsideQueenAnt/Water1/Water1-Sheet.png'),
                  'WATER_SPRITE2': loadTexture(path + '\Images\TheDoor6-InsideQueenAnt/Water2/Water2-Sheet.png'),
                  'WATER_SPRITE3': loadTexture(path + '\Images\TheDoor6-InsideQueenAnt/Water3/Water3-Sheet.png'),
                  #
                  # Ants
                  'ANT1': [loadTexture(path + '\Images\Ants\Ant\AllAnt2.png'), loadTexture(path + '\Images\Ants\Ant\AllAnt3.png')],
                  'ANT2': [loadTexture(path + '\Images\AntHill\PlayerMoverAnt\AllAnt2.png'), loadTexture(path + '\Images\AntHill\PlayerMoverAnt\AllAnt3.png')],
                  #
                  # Keys
                  'BLUE_KEY': [loadTexture(path + '\Images\Ants\Key\BlueKey\BlueKey1.png'), loadTexture(path + '\Images\Ants\Key\BlueKey\BlueKey2.png')],
                  'BROWN_KEY': [loadTexture(path + '\Images\Ants\Key\BrownKey\BrownKey1.png'), loadTexture(path + '\Images\Ants\Key\BrownKey\BrownKey2.png')],
                  'GREEN_KEY': [loadTexture(path + '\Images\Ants\Key\GreenKey\GreenKey1.png'), loadTexture(path + '\Images\Ants\Key\GreenKey\GreenKey2.png')],
                  'GREY_KEY': [loadTexture(path + '\Images\Ants\Key\GreyKey\GreyKey1.png'), loadTexture(path + '\Images\Ants\Key\GreyKey\GreyKey2.png')],
                  'ORANGE_KEY': [loadTexture(path + '\Images\Ants\Key\OrangeKey\OrangeKey1.png'), loadTexture(path + '\Images\Ants\Key\OrangeKey\OrangeKey2.png')],
                  'PINK_KEY': [loadTexture(path + '\Images\Ants\Key\PinkKey\PinkKey1.png'), loadTexture(path + '\Images\Ants\Key\PinkKey\PinkKey2.png')],
                  'PURPLE_KEY': [loadTexture(path + '\Images\Ants\Key\PurpleKey\PurpleKey1.png'), loadTexture(path + '\Images\Ants\Key\PurpleKey\PurpleKey2.png')],
                  'RED_KEY': [loadTexture(path + '\Images\Ants\Key\RedKey\RedKey1.png'), loadTexture(path + '\Images\Ants\Key\RedKey\RedKey2.png')],
                  'TEAL_KEY': [loadTexture(path + '\Images\Ants\Key\TealKey\TealKey1.png'), loadTexture(path + '\Images\Ants\Key\TealKey\TealKey2.png')],
                  'YELLOW_KEY': [loadTexture(path + '\Images\Ants\Key\YellowKey\YellowKey1.png'), loadTexture(path + '\Images\Ants\Key\YellowKey\YellowKey2.png')],
                  #
                  # Doors
                  'BLUE_DOOR': loadTexture(path + '\Images\Ants\Door\BlueDoor\BlueDoor.png'),
                  'BROWN_DOOR': loadTexture(path + '\Images\Ants\Door\Door1.png'),
                  'GREEN_DOOR': loadTexture(path + '\Images\Ants\Door\GreenDoor\GreenDoor.png'),
                  'GREY_DOOR': loadTexture(path + '\Images\Ants\Door\GreyDoor\GreyDoor.png'),
                  'ORANGE_DOOR': loadTexture(path + '\Images\Ants\Door\OrangeDoor\OrangeDoor.png'),
                  'PINK_DOOR': loadTexture(path + '\Images\Ants\Door\PinkDoor\PinkDoor.png'),
                  'PURPLE_DOOR': loadTexture(path + '\Images\Ants\Door\PurpleDoor\PurpleDoor.png'),
                  'RED_DOOR': loadTexture(path + '\Images\Ants\Door\RedDoor\RedDoor.png'),
                  'TEAL_DOOR': loadTexture(path + '\Images\Ants\Door\TealDoor\TealDoor.png'),
                  'YELLOW_DOOR': loadTexture(path + '\Images\Ants\Door\YellowDoor\YellowDoor.png'),
                  'WHOLE_FENCE_DOOR': loadTexture(path + '\Images\Ants\Door\Door2\WholeFenceDoor.png'),
                  'FENCE_DOOR_RIGHT': loadTexture(path + '\Images\Ants\Door\Door2\FenceDoorRight.png'),
                  'FENCE_DOOR_LEFT': loadTexture(path + '\Images\Ants\Door\Door2\FenceDoorLeft.png'),
                  #
                  # Door with knob
                  'DOOR_WITH_KNOB': [loadTexture(path + '\Images\Town\DoorWithKnob\DoorWithKnob' + str(x+1) + '.png') for x in range(9)],
                  #
                  # Squirrel
                  'SQUIRREL': [loadTexture(path + '\Images\TheDoor5-TopOfBossTree\Squirrel\Squirrel1.png'), loadTexture(path + '\Images\TheDoor5-TopOfBossTree\Squirrel\Squirrel2.png'), loadTexture(path + '\Images\TheDoor5-TopOfBossTree\Squirrel\Squirrel3.png')],
                  #
                  # Bouncy
                  'BOUNCY_MUSHROOM1': loadTexture(path + '\Images\TheDoor3-TreeTrunk\BouncyMushroom1\BouncyMushroom1.png'),
                  'BOUNCY_MUSHROOM2': loadTexture(path + '\Images\TheDoor3-TreeTrunk\BouncyMushroom2\BouncyMushroom2-shrunk.png'),
                  'BOUNCY_MUSHROOM_LEFT': loadTexture(path + '\Images\TheDoor3-TreeTrunk\BouncyMushroomLeft\BouncyMushroomLeft.png'),
                  'BOUNCY_MUSHROOM_RIGHT': loadTexture(path + '\Images\TheDoor3-TreeTrunk\BouncyMushroomRight\BouncyMushroomRight.png'),
                  'MEDIUM_MUSHY': loadTexture(path + '\Images\TheDoor3-TreeTrunk\MediumMushy\MediumMushy.png'),
                  'SMALL_MUSHY': loadTexture(path + '\Images\TheDoor3-TreeTrunk\SmallMushy\SmallMushy.png'),
                  'SQUARE_BOUNCY_MUSHROOM': loadTexture(path + '\Images\TheDoor6-InsideQueenAnt\SquareBouncyMushroom\SquareBouncyMushroom.png'),
                  #
                  # Hawk
                  #'HAWK': [loadTexture(path + '\Images\Forest\BossHawk\BossHawk' + str(x+1) + '.png') for x in range(8)],
                   'HAWK': [loadTexture(path + '\Images\Forest\BossHawk\\NEW_BossHawk' + str(x+1) + '.png') for x in range(4)],
                  #
                  # Queen Ant
                  'QUEEN_ANT': [loadTexture(path + '\Images\AntHill\QueenAnt\\NewQueenAnt\QueenAntEating' + str(x+1) + '.png') for x in range(12)],
                  #
                  # Leaves
                  'BIG_LEAF': [loadTexture(path + '\Images\LeafCutterAnt\Leaf\BigLeaf\FadingLeaf' + str(x+1) + '.png') for x in range(26)],
                  'SMALL_LEAF': [loadTexture(path + '\Images\LeafCutterAnt\Leaf\SmallLeaf\Leaf' + str(x+1) + '.png') for x in range(26)],
                  #
                  # Upgrade
                  'BUBBLE': loadTexture(path + '\Images\\Upgrade\Bubble\Bubble.png'),
                  'SHADY_BUBBLE': loadTexture(path + '\Images\\Upgrade\Bubble\ShadyBubble.png'),
                  'LESS_SHADY_BUBBLE': loadTexture(path + '\Images\\Upgrade\Bubble\LessShadyBubble.png'),
                  'HIGHLIGHT_BUBBLE': loadTexture(path + '\Images\\Upgrade\Bubble\BubbleHighlight.png'),
                  'PLUS_PISTON_POWER': loadTexture(path + '\Images\\Upgrade\PlusPistonPower\PlusPistonPower.png'),
                  #
                  # Elevator
                  #'ELEVATOR': [loadTexture(path + '\Images\Elevator\Elevator1\Elevator' + str(x+1) + '.png') for x in range(81)],
                  'DOWN_PEG': loadTexture(path + '\Images\Elevator\Elevator2InParts\DownPeg\DownPeg.png'),
                  'ELEVATOR_BACKGROUND': loadTexture(path + '\Images\Elevator\Elevator2InParts\ElevatorBackground\ElevatorBackground.png'),
                  'ELEVATOR_DOOR': [loadTexture(path + '\Images\Elevator\Elevator2InParts\ElevatorDoor\ElevatorDoor' + str(x+1) + '.png') for x in range(41)],
                  'LEFT_MIDDLE_PLATFORM': loadTexture(path + '\Images\Elevator\Elevator2InParts\LeftMiddlePlatform\LeftMiddlePlatform.png'),
                  'PLATFORM_LEFT': loadTexture(path + '\Images\Elevator\Elevator2InParts\PlatformLeft\PlatformLeft.png'),
                  'PLATFORM_LEFT_BOTTOM': loadTexture(path + '\Images\Elevator\Elevator2InParts\PlatformLeftBottom\PlatformLeftBottom.png'),
                  'PLATFORM_MIDDLE': loadTexture(path + '\Images\Elevator\Elevator2InParts\PlatformMiddle\PlatformMiddle.png'),
                  'PLATFORM_MIDDLE_BOTTOM': loadTexture(path + '\Images\Elevator\Elevator2InParts\PlatformMiddleBottom\PlatformMiddleBottom.png'),
                  'PLATFORM_RIGHT': loadTexture(path + '\Images\Elevator\Elevator2InParts\PlatformRight\PlatformRight.png'),
                  'PLATFORM_RIGHT_BOTTOM': loadTexture(path + '\Images\Elevator\Elevator2InParts\PlatformRightBottom\PlatformRightBottom.png'),
                  'RIGHT_MIDDLE_PLATFORM': loadTexture(path + '\Images\Elevator\Elevator2InParts\RightMiddlePlatform\RightMiddlePlatform.png'),
                  'UP_PEG': loadTexture(path + '\Images\Elevator\Elevator2InParts\\UpPeg\\UpPeg.png'),
                  #
                  # Root
                  'ROOT_BASE': [loadTexture(path + '\Images\AntHill\Root\Root1\RootBase\RootBase' + str(x+1) + '.png') for x in range(5)],
                  'FADING_ROOT_ANIMATION': [loadTexture(path + '\Images\AntHill\Root\Root1\FadingRootAnimation\Root' + str(x+1) + '.png') for x in range(14)],
                  'REGROWTH_ANIMATION': [loadTexture(path + '\Images\AntHill\Root\Root1\RegrowthAnimation\Root' + str(x+1) + '.png') for x in range(18)],
                  'REGROWTH_COLLISION': [loadTexture(path + '\Images\AntHill\Root\Root1\RegrowthCollision\Root' + str(x+1) + '.png') for x in range(18)],
                  'SHAKY': [loadTexture(path + '\Images\AntHill\Root\Root1\ShakyRoot\Root' + str(x+1) + '.png') for x in range(4)],
                  'BIG_ROOT': loadTexture(path + '\Images\AntHill\BigRoots.png'),
                  #
                  # DripDrop
                  'DRIP': [loadTexture(path + '\Images\DripDrop\Drip\Drip' + str(x+1) + '.png') for x in range(13)],
                  'DRIPDROP_ANIMATION': [loadTexture(path + '\Images\DripDrop\DripDropAnimation\DripDropAnimation' + str(x+1) + '.png') for x in range(4)],
                  'DRIPDROP_COLLISION': [loadTexture(path + '\Images\DripDrop\DripDropCollision\DripDropCollision' + str(x+1) + '.png') for x in range(4)],
                  'DROP': [loadTexture(path + '\Images\DripDrop\Drop\Drop' + str(x+1) + '.png') for x in range(23)],
                  #
                  # Irregularly shaped water
                  #'TOP_OF_WATER_FALL': loadTexture(path + '\Images\AntHill/SewerWater/TopOfWaterFall.png'),
                  #'WATER_BEGINNING_TO_FALL': loadTexture(path + '\Images\AntHill/SewerWater/WaterBeginningToFall.png'),
                  #'TOP_OF_FALLING_WATER': loadTexture(path + '\Images\AntHill/SewerWater/TopOfFallingWater.png'),
                  #'MIDDLE_OF_FALLING_WATER': loadTexture(path + '\Images\AntHill/SewerWater/MiddleOfFallingWater.png'),
                  #'BOTTOM_OF_FALLING_WATER': loadTexture(path + '\Images\AntHill/SewerWater/BottomOfFallingWater.png'),
                  #'BOTTOM_LAKE': loadTexture(path + '\Images\AntHill/SewerWater/BottomLake.png'),
                  #'FIRST_JOURNEY_DOWN_TUNNEL': loadTexture(path + '\Images\AntHill/SewerWater/FirstJourneyDownTunnel.png'),
                  #'SECOND_JOURNEY_DOWN_TUNNEL': loadTexture(path + '\Images\AntHill/SewerWater/SecondJourneyDownTunnel.png'),
                  #'THIRD_JOURNEY_DOWN_TUNNEL': loadTexture(path + '\Images\AntHill/SewerWater/ThirdJourneyDownTunnel.png'),
                  #'FOURTH_JOURNEY_DOWN_TUNNEL': loadTexture(path + '\Images\AntHill/SewerWater/FourthJourneyDownTunnel.png'),
                  #'FIFTH_JOURNEY_DOWN_TUNNEL': loadTexture(path + '\Images\AntHill/SewerWater/FifthJourneyDownTunnel.png'),
                  #'SIXTH_JOURNEY_DOWN_TUNNEL': loadTexture(path + '\Images\AntHill/SewerWater/SixthJourneyDownTunnel.png'),
                  #'SEVENTH_JOURNEY_DOWN_TUNNEL': loadTexture(path + '\Images\AntHill/SewerWater/SeventhJourneyDownTunnel.png'),
                  #'BOTTOM_OF_WATER_FALL': loadTexture(path + '\Images\AntHill/SewerWater/BottomOfWaterFall.png'),
                  #
                  # SewerJet
                  'SEWER_JET': [loadTexture(path + '\Images\Sewer\SewerJet\SewerJet' + str(x+1) + '.png') for x in range(1)],
                  #
                  # Spinny
                  #'SPINNY1': loadTexture(path + '\Images\Sewer\SpinnyObject\SpinnyObject.png'),
                  #'SPINNY2': loadTexture(path + '\Images\Sewer\SpinnyObject\SpinnyObject2.png'),
                  #'SPINNY3': loadTexture(path + '\Images\Sewer\SpinnyObject\SpinnyObject3.png'),
                  #'SPINNY4': loadTexture(path + '\Images\Sewer\SpinnyObject\SpinnyObject4.png'),
                  #
                  # Leak
                  #'LEAK': [loadTexture(path + '\Images\Sewer\WaterLeak\Leak' + str(x+1) + '.png') for x in range(21)],
                  #
                  # Grate
                  'GA': [loadTexture(path + '\Images\Sewer\WaterFall\Angle\Angle' + str(x+1) + '.png') for x in range(8)],
                  'GG': [loadTexture(path + '\Images\Sewer\WaterFall\Grate\Grate' + str(x+1) + '.png') for x in range(8)],
                  'GH': [loadTexture(path + '\Images\Sewer\WaterFall\Horizontal\WaterFallHorizontal' + str(x+1) + '.png') for x in range(8)],
                  'GT': [loadTexture(path + '\Images\Sewer\WaterFall\T\T' + str(x+1) + '.png') for x in range(8)],
                  'GV': [loadTexture(path + '\Images\Sewer\WaterFall\Vertical\Vertical' + str(x+1) + '.png') for x in range(8)],
                  'GRATE_IMAGE': loadTexture(path + '\Images\Sewer\WaterFall\Grate\GRATE_IMAGE.png'),
                  #
                  # TV
                  'TV': loadTexture(path + '\Images\Sewer\TV\TV.png'),
                  'TV_MARKER': loadTexture(path + '\Images\Sewer\TV\TV_Marker.png'),
                  #
                  # Propeller
                  'PROPELLER': [loadTexture(path + '\Images\Sewer\Propeller\Propeller' + str(x+1) + '.png') for x in range(6)],
                  'PROPELLER_DOWN': [loadTexture(path + '\Images\Sewer\Propeller\VerticalPropeller\Down' + str(x+1) + '.png') for x in range(6)],
                  'PROPELLER_UP': [loadTexture(path + '\Images\Sewer\Propeller\VerticalPropeller\\Up' + str(x+1) + '.png') for x in range(6)],
                  'BUBBLES1': loadTexture(path + '\Images\Sewer\Propeller\Bubbles\Bubbles1\Bubbles.png'),
                  'BUBBLES2': loadTexture(path + '\Images\Sewer\Propeller\Bubbles\Bubbles2\Bubbles.png'),
                  'BUBBLES3': loadTexture(path + '\Images\Sewer\Propeller\Bubbles\Bubbles3\Bubbles.png'),
                  'BUBBLES4': loadTexture(path + '\Images\Sewer\Propeller\Bubbles\Bubbles4\Bubbles.png'),
                  'BUBBLES5': loadTexture(path + '\Images\Sewer\Propeller\Bubbles\Bubbles5\Bubbles.png'),
                  'BUBBLES6': loadTexture(path + '\Images\Sewer\Propeller\Bubbles\Bubbles6\Bubbles.png'),
                  'BUBBLES7': loadTexture(path + '\Images\Sewer\Propeller\Bubbles\Bubbles7\Bubbles.png'),
                  'BUBBLES8': loadTexture(path + '\Images\Sewer\Propeller\Bubbles\Bubbles8\Bubbles.png'),
                  #
                  # Lever
                  'BLOCK': loadTexture(path + '\Images\Sewer\Lever\Block\Block.png'),
                  'BOLT': [loadTexture(path + '\Images\Sewer\Lever\Bolt\Bolt' + str(x+1) + '.png') for x in range(7)],
                  'LEVER': [loadTexture(path + '\Images\Sewer\Lever\Lever\Lever' + str(x+1) + '.png') for x in range(7)],
                  #
                  # Water surface
                  'WATER_SURFACE1': [loadTexture(path + '\Images\WaterSurface\WaterSurface1\WaterSurface' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE1_COVER': [loadTexture(path + '\Images\WaterSurface\WaterSurface1\WaterSurfaceCover' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE2': [loadTexture(path + '\Images\WaterSurface\WaterSurface2\WaterSurface' + str(x+1) + '.png') for x in range(1)],
                  'WATER_SURFACE2_COVER': [loadTexture(path + '\Images\WaterSurface\WaterSurface2\WaterSurfaceCover' + str(x+1) + '.png') for x in range(1)],
                  'WATER_SURFACE_TUTORIAL': [loadTexture(path + '\Images\WaterSurface\WaterSurfaceTutorial\WaterSurfaceTutorial' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_TUTORIAL_COVER': [loadTexture(path + '\Images\WaterSurface\WaterSurfaceTutorial\WaterSurfaceTutorialCover' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_FOREST1': [loadTexture(path + '\Images\WaterSurface\Forest_water1_surface\Forest_water1_surface' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_FOREST1_COVER': [loadTexture(path + '\Images\WaterSurface\Forest_water1_surface\Forest_water1_surface_cover' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_FOREST2': [loadTexture(path + '\Images\WaterSurface\Forest_water2_surface\Forest_water2_surface' + str(x+1) + '.png') for x in range(1)],
                  'WATER_SURFACE_FOREST2_COVER': [loadTexture(path + '\Images\WaterSurface\Forest_water2_surface\Forest_water2_surface_cover' + str(x+1) + '.png') for x in range(1)],
                  'WATER_SURFACE_CLOUD_LEFT': [loadTexture(path + '\Images\WaterSurface\CloudLevel\Left\Left' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_CLOUD_LEFT_COVER': [loadTexture(path + '\Images\WaterSurface\CloudLevel\Left\Left_cover' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_CLOUD_RIGHT': [loadTexture(path + '\Images\WaterSurface\CloudLevel\Right\Right' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_CLOUD_RIGHT_COVER': [loadTexture(path + '\Images\WaterSurface\CloudLevel\Right\Right_cover' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_SURFING': [loadTexture(path + '\Images\WaterSurface\Surfing\Surfing' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_SURFING_COVER': [loadTexture(path + '\Images\WaterSurface\Surfing\Surfing_faded' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE1': [loadTexture(path + '\Images\WaterSurface\Race\Race1\Race' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE1_COVER': [loadTexture(path + '\Images\WaterSurface\Race\Race1\Race_fade' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE2': [loadTexture(path + '\Images\WaterSurface\Race\Race2\Race' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE2_COVER': [loadTexture(path + '\Images\WaterSurface\Race\Race2\Race_fade' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE3': [loadTexture(path + '\Images\WaterSurface\Race\Race3\Race' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE3_COVER': [loadTexture(path + '\Images\WaterSurface\Race\Race3\Race_fade' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE4': [loadTexture(path + '\Images\WaterSurface\Race\Race4\Race' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE4_COVER': [loadTexture(path + '\Images\WaterSurface\Race\Race4\Race_fade' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE5': [loadTexture(path + '\Images\WaterSurface\Race\Race5\Race' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE5_COVER': [loadTexture(path + '\Images\WaterSurface\Race\Race5\Race_fade' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE6': [loadTexture(path + '\Images\WaterSurface\Race\Race6\Race' + str(x+1) + '.png') for x in range(20)],
                  'WATER_SURFACE_RACE6_COVER': [loadTexture(path + '\Images\WaterSurface\Race\Race6\Race_fade' + str(x+1) + '.png') for x in range(20)],
                  #
                  # Goldfish
                  'GOLDFISH': [loadTexture(path + '\Images\Sewer\Goldfish\Goldfish' + str(x+1) + '.png') for x in range(4)],
                  #
                  # Transport pipe
                  'PIPE_WIND': [loadTexture(path + '\Images\Sewer\PipeTransport\Wind\Wind' + str(x+1) + '.png') for x in range(13)],
                  #
                  # Surf board
                  'SURF_BOARD': loadTexture(path + '\Images\Sewer\SurfBoard\Surfboard.png'),
                  #
                  # Wave
                  'SMALL_WAVE': [loadTexture(path + '\Images\Sewer\Wave\SmallWave\Wave' + str(x+1) + '.png') for x in range(1)],
                  'MEDIUM_WAVE': [loadTexture(path + '\Images\Sewer\Wave\MediumWave\Wave' + str(x+1) + '.png') for x in range(1)],
                  'BIG_WAVE': [loadTexture(path + '\Images\Sewer\Wave\BigWave\Wave' + str(x+1) + '.png') for x in range(1)],
                  #
                  # Bucket
                  'BUCKET': loadTexture(path + '\Images\Sewer\Bucket\Bucket.png'),
                  #
                  # Food
                  'ALMOND': loadTexture(path + '\Images\Sewer\Food\Almond.png'),
                  'BANANA': loadTexture(path + '\Images\Sewer\Food\Banana.png'),
                  'BLACKBERRY': loadTexture(path + '\Images\Sewer\Food\Blackberry.png'),
                  'COCONUT': loadTexture(path + '\Images\Sewer\Food\Coconut.png'),
                  'ALMOND_SHADY': loadTexture(path + '\Images\Sewer\Food\Almond_shady.png'),
                  'BANANA_SHADY': loadTexture(path + '\Images\Sewer\Food\Banana_shady.png'),
                  'BLACKBERRY_SHADY': loadTexture(path + '\Images\Sewer\Food\Blackberry_shady.png'),
                  'COCONUT_SHADY': loadTexture(path + '\Images\Sewer\Food\Coconut_shady.png'),
                  #
                  # HamsterOs
                  'HAMSTER_OS': loadTexture(path + '\Images\Town\HamsterOs\HamsterOs.png'),
                  'HAMSTER_OS_OUTLINE': loadTexture(path + '\Images\Town\HamsterOs\HamsterOs_outline.png'),
                  #'PELLET': loadTexture(path + '\Images\Town\HamsterOs\Pellet.png'),
                  #
                  # Human
                  'HUMAN_STANDING': [loadTexture(path + '\Images\Town\Human\HumanStanding\HumanStanding' + str(x+1) + '.png') for x in range(1)],
                  'HUMAN_EATING': [loadTexture(path + '\Images\Town\Human\Eating\Eating' + str(x+1) + '.png') for x in range(3)],
                  'HUMAN_WALKING': [loadTexture(path + '\Images\Town\Human\Walk\HumanWalk' + str(x+1) + '.png') for x in range(6)],
                  'HUMAN_TALKING': [loadTexture(path + '\Images\Town\Human\Talking\Talking' + str(x+1) + '.png') for x in range(2)],
                  'HUMAN_SHAKING': [loadTexture(path + '\Images\Town\Human\Shaking\Shaking' + str(x+1) + '.png') for x in range(3)],
                  'HUMAN_GROSSED': [loadTexture(path + '\Images\Town\Human\GrossedOut\GrossedOut' + str(x+1) + '.png') for x in range(3)],
                  'HUMAN_EXCITED': [loadTexture(path + '\Images\Town\Human\Excited\Excited' + str(x+1) + '.png') for x in range(2)],
                  'HUMAN_HOLDING_TALKING': [loadTexture(path + '\Images\Town\Human\Holding_Talking\Holding_Talking' + str(x+1) + '.png') for x in range(2)],
                  'HEARTS': [loadTexture(path + '\Images\Town\Human\Hearts\Hearts' + str(x+1) + '.png') for x in range(9)],
                  'SHADY_PIXELS': [loadTexture(path + '\Images\Town\IntroSequenceSpecific\Shade' + str(x+1) + '.png') for x in range(5)],
                  #
                  'IThinkIveCompletedTheMachine': loadTexture(path + '\Images\Town\Human\Dialogue\IThinkIveCompletedTheMachine.png'),
                  'IShouldBeAbleToCommunicateWithYou': loadTexture(path + '\Images\Town\Human\Dialogue\IShouldBeAbleToCommunicateWithYou.png'),
                  'OnceWereBothInside': loadTexture(path + '\Images\Town\Human\Dialogue\OnceWereBothInside.png'),
                  'IThinkItsWorking': loadTexture(path + '\Images\Town\Human\Dialogue\IThinkItsWorking.png'),
                  'WowYouReallyLikeHamsterOs': loadTexture(path + '\Images\Town\Human\Dialogue\WowYouReallyLikeHamsterOs.png'),
                  'WaitIDontRememberBeingThisShort': loadTexture(path + '\Images\Town\Human\Dialogue\WaitIDontRememberBeingThisShort.png'),
                  'OhNo': loadTexture(path + '\Images\Town\Human\Dialogue\OhNo.png'),
                  'IveTransformedIntoAHamster': loadTexture(path + '\Images\Town\Human\Dialogue\IveTransformedIntoAHamster.png'),
                  'Oww': loadTexture(path + '\Images\Town\Human\Dialogue\Oww.png'),
                  'ThisIsAwful': loadTexture(path + '\Images\Town\Human\Dialogue\ThisIsAwful.png'),
                  'Ahhh': loadTexture(path + '\Images\Town\Human\Dialogue\Ahhh.png'),
                  'AhhhReverse': loadTexture(path + '\Images\Town\Human\Dialogue\AhhhReverse.png'),
                  'NoNoNo': loadTexture(path + '\Images\Town\Human\Dialogue\\NoNoNo.png'),
                  'Waahh': loadTexture(path + '\Images\Town\Human\Dialogue\Waahh.png'),
                  'WaahhReverse': loadTexture(path + '\Images\Town\Human\Dialogue\WaahhReverse.png'),
                  'EwwIHateHamsterOs': loadTexture(path + '\Images\Town\Human\Dialogue\EwwIHateHamsterOs.png'),
                  'ImBack': loadTexture(path + '\Images\Town\Human\Dialogue\ImBack.png'),
                  'ILoveYou': loadTexture(path + '\Images\Town\Human\Dialogue\ILoveYou.png'),
                  #
                  # Garbage can
                  'WHOLE_GARBAGE_CAN': loadTexture(path + '\Images\Town\GarbageCan\GarbageCan.png'),
                  'TRANSPARENT_GARBAGE_CAN': loadTexture(path + '\Images\Town\GarbageCan\TransparentGarbageCanFront.png'),
                  #
                  # Beetle
                  'BEETLE_WALK_RIGHT': [loadTexture(path + '\Images/AntHill/Beetle/Beetle_WalkingRight/Beetle_WalkingRight' + str(x+1) + '.png') for x in range(24)],
                  'BEETLE_STAND_RIGHT': [loadTexture(path + '\Images/AntHill/Beetle/Beetle_StandingRight/Beetle_StandingRight' + str(x+1) + '.png') for x in range(12)],
                  'RIGHT_LOOK_UP': [loadTexture(path + '\Images/AntHill/Beetle/Beetle_RightLookUp/Beetle_RightLookUp' + str(x+1) + '.png') for x in range(6)],
                  'RIGHT_JUMP': [loadTexture(path + '\Images/AntHill/Beetle/Beetle_RightJump/Beetle_RightJump' + str(x+1) + '.png') for x in range(9)],
                  'RIGHT_IN_THE_AIR': [loadTexture(path + '\Images/AntHill/Beetle/Beetle_InTheAir/Beetle_InTheAir' + str(x+1) + '.png') for x in range(10)],
                  'BUTTON': [loadTexture(path + '\Images/AntHill/Beetle/YellowButton/YellowButton' + str(x+1) + '.png') for x in range(10)],
                  #
                  'IWannaLeave': loadTexture(path + '\Images/AntHill/Beetle/IWannaLeave/IWannaLeave.png'),
                  'OhThankYouThankYou': loadTexture(path + '\Images/AntHill/Beetle/OhThankYouThankYou/OhThankYouThankYou.png'),
                  'OohBigRoom': loadTexture(path + '\Images/AntHill/Beetle/OohBigRoom/OohBigRoom.png'),
                  'NeatNeat': loadTexture(path + '\Images/AntHill/Beetle/NeatNeat/NeatNeat.png'),
                  'AnotherDoor': loadTexture(path + '\Images/AntHill/Beetle/AnotherDoor/AnotherDoor.png'),
                  'WhoKnewAntsMadeDoors': loadTexture(path + '\Images/AntHill/Beetle/WhoKnewAntsMadeDoors/WhoKnewAntsMadeDoors.png'),
                  'IDidnt': loadTexture(path + '\Images/AntHill/Beetle/IDidnt/IDidnt.png'),
                  'Although': loadTexture(path + '\Images/AntHill/Beetle/Although/Although.png'),
                  'MostDontKnow': loadTexture(path + '\Images/AntHill/Beetle/MostDontKnow/MostDontKnow.png'),
                  'BeetlesCanTalk': loadTexture(path + '\Images/AntHill/Beetle/BeetlesCanTalk/BeetlesCanTalk.png'),
                  'KekKekKek': loadTexture(path + '\Images/AntHill/Beetle/KekKekKek/KekKekKek.png'),
                  'HamsterFriend': loadTexture(path + '\Images/AntHill/Beetle/HamsterFriend/HamsterFriend.png'),
                  'CanYouOpenTheDoor': loadTexture(path + '\Images/AntHill/Beetle/CanYouOpenTheDoor/CanYouOpenTheDoor.png'),
                  'YayThankYouThankYou': loadTexture(path + '\Images/AntHill/Beetle/YayThankYouThankYou/YayThankYouThankYou.png'),
                  'HamsterFriendHamsterFriend': loadTexture(path + '\Images/AntHill/Beetle/HamsterFriendHamsterFriend/HamsterFriendHamsterFriend.png'),
                  'ImGonnaPressThis': loadTexture(path + '\Images/AntHill/Beetle/ImGonnaPressThis/ImGonnaPressThis.png'),
                  'OpenDoorOpenDoor': loadTexture(path + '\Images/AntHill/Beetle/OpenDoorOpenDoor/OpenDoorOpenDoor.png'),
                  'ThanksHamsterFriend': loadTexture(path + '\Images/AntHill/Beetle/ThanksHamsterFriend/ThanksHamsterFriend.png'),
                  'WereAGoodTeam': loadTexture(path + '\Images/AntHill/Beetle/WereAGoodTeam/WereAGoodTeam.png'),
                  'IOpenDoors': loadTexture(path + '\Images/AntHill/Beetle/IOpenDoors/IOpenDoors.png'),
                  'AndYouAlsoOpenDoors': loadTexture(path + '\Images/AntHill/Beetle/AndYouAlsoOpenDoors/AndYouAlsoOpenDoors.png'),
                  'YouKnow': loadTexture(path + '\Images/AntHill/Beetle/YouKnow/YouKnow.png'),
                  'ThisKindaFeelsLikeAn': loadTexture(path + '\Images/AntHill/Beetle/ThisKindaFeelsLikeAn/ThisKindaFeelsLikeAn.png'),
                  'EscortMission': loadTexture(path + '\Images/AntHill/Beetle/EscortMission/EscortMission.png'),
                  'LikeFromAVideoGame': loadTexture(path + '\Images/AntHill/Beetle/LikeFromAVideoGame/LikeFromAVideoGame.png'),
                  'Although2': loadTexture(path + '\Images/AntHill/Beetle/Although2/Although2.png'),
                  'IDontNeedProtection': loadTexture(path + '\Images/AntHill/Beetle/IDontNeedProtection/IDontNeedProtection.png'),
                  'OhLook': loadTexture(path + '\Images/AntHill/Beetle/OhLook/OhLook.png'),
                  'WeFoundTheQueen': loadTexture(path + '\Images/AntHill/Beetle/WeFoundTheQueen/WeFoundTheQueen.png'),
                  'Wahhhh': loadTexture(path + '\Images/AntHill/Beetle/Wahhhh/Wahhhh.png'),
                  'HeavyButton': loadTexture(path + '\Images/AntHill/Beetle/HeavyButton/HeavyButton.png'),
                  #
                  'WOW1': loadTexture(path + '\Images/AntHill/Beetle/Wows\Wow1.png'),
                  'WOW2': loadTexture(path + '\Images/AntHill/Beetle/Wows\Wow2.png'),
                  'WOW3': loadTexture(path + '\Images/AntHill/Beetle/Wows\Wow3.png'),
                  'WOW4': loadTexture(path + '\Images/AntHill/Beetle/Wows\Wow4.png'),
                  'ThatWasWild': loadTexture(path + '\Images/AntHill/Beetle/ThatWasWild\ThatWasWild.png'),
                  'ThanksForComingInAfterMe': loadTexture(path + '\Images/AntHill/Beetle/ThanksForComingInAfterMe\ThanksForComingInAfterMe.png'),
                  'IDontThinkICanFlyYouOut': loadTexture(path + '\Images/AntHill/Beetle/IDontThinkICanFlyYouOut\IDontThinkICanFlyYouOut.png'),
                  'IllMeetYouPastThisAcid': loadTexture(path + '\Images/AntHill/Beetle/IllMeetYouPastThisAcid\IllMeetYouPastThisAcid.png'),
                  'ImSoGladYouMadeItOut': loadTexture(path + '\Images/AntHill/Beetle/ImSoGladYouMadeItOut\ImSoGladYouMadeItOut.png'),
                  'IThinkImJustGonnaHangoutForABit': loadTexture(path + '\Images/AntHill/Beetle/IThinkImJustGonnaHangoutForABit\IThinkImJustGonnaHangoutForABit.png'),
                  'HereIFoundThisEarlier': loadTexture(path + '\Images/AntHill/Beetle/HereIFoundThisEarlier\HereIFoundThisEarlier.png'),
                  'IllComeMeetYouOutsideSometime': loadTexture(path + '\Images/AntHill/Beetle/IllComeMeetYouOutsideSometime\IllComeMeetYouOutsideSometime.png'),
                  #
                  'HeyaHamsterFriend': loadTexture(path + '\Images/AntHill/Beetle/HeyaHamsterFriend\HeyaHamsterFriend.png'),
                  'ImSoHappyToSeeYouAgain': loadTexture(path + '\Images/AntHill/Beetle/ImSoHappyToSeeYouAgain\ImSoHappyToSeeYouAgain.png'),
                  'IHopeYoureDoinWell': loadTexture(path + '\Images/AntHill/Beetle/IHopeYoureDoinWell\IHopeYoureDoinWell.png'),
                  #
                  'PleaseComeInAndSaveMe': loadTexture(path + '\Images/AntHill/Beetle/PleaseComeInAndSaveMe\PleaseComeInAndSaveMe.png'),
                  'HelpMeHamsterFriend': loadTexture(path + '\Images/AntHill/Beetle/HelpMeHamsterFriend\HelpMeHamsterFriend.png'),
                  #
                  # Surfing Rat
                  'SURFING_RAT_TALKING': [loadTexture(path + '\Images/TheDoor12-Surfing\Rat\RatTalking' + str(x+1) + '.png') for x in range(12)],
                  'SURFING_RAT_STANDING': [loadTexture(path + '\Images/TheDoor12-Surfing\Rat\RatStanding' + str(x+1) + '.png') for x in range(12)],
                  #
                  'ButIThinkYouCouldBeBetter': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\ButIThinkYouCouldBeBetter.png'),
                  'ComeBackAgainSometimeDudette': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\ComeBackAgainSometimeDudette.png'),
                  'DoYouSurfBro': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\DoYouSurfBro.png'),
                  'EpicDudette': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\EpicDudette.png'),
                  'Gnarly': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\Gnarly.png'),
                  'IfSoIdLoveToWatch': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\IfSoIdLoveToWatch.png'),
                  'IHopeThatDidntHurt': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\IHopeThatDidntHurt.png'),
                  'ItsAPleasureSeeinYouSurf': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\ItsAPleasureSeeinYouSurf.png'),
                  'ItsOkIfWipeoutsHappen': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\ItsOkIfWipeoutsHappen.png'),
                  'IWantYouToHaveThis': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\IWantYouToHaveThis.png'),
                  'KeepGoinHamsterGirl': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\KeepGoinHamsterGirl.png'),
                  'Nice': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\\Nice.png'),
                  'OofYouOkBrah': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\OofYouOkBrah.png'),
                  'RideThatBarrelBrah': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\RideThatBarrelBrah.png'),
                  'Sick': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\Sick.png'),
                  'ThatWasRadicalBro': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\ThatWasRadicalBro.png'),
                  'ThatWasRighteousBro': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\ThatWasRighteousBro.png'),
                  'TubularBrah': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\TubularBrah.png'),
                  'WassupHamsterDudette': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\WassupHamsterDudette.png'),
                  'Wicked': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\Wicked.png'),
                  'Wild': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\Wild.png'),
                  'Woah': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\Woah.png'),
                  'YeahGetOutThereGirl': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\YeahGetOutThereGirl.png'),
                  'YouShouldComeSurfAgain': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\YouShouldComeSurfAgain.png'),
                  'YouWerePrettyCoolOutThere': loadTexture(path + '\Images/TheDoor12-Surfing\RatDialogue\YouWerePrettyCoolOutThere.png'),
                  #
                  # Surfing clock, numbers, and progress bar
                  'SURFING_CLOCK': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\Clock\Clock.png'),
                  'SURFING_CLOCK_HAND': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\Clock\ClockHand.png'),
                  'SURFING_PROGRESS_BAR_OUTSIDE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\ProgressBar\ProgressBarOutside.png'),
                  'SURFING_PROGRESS_BAR_INSIDE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\ProgressBar\ProgressBarInside.png'),
                  'ZERO': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\Numbers\Zero.png'),
                  'ONE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\Numbers\One.png'),
                  'TWO': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\Numbers\Two.png'),
                  'THREE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\Numbers\Three.png'),
                  'FOUR': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\Numbers\Four.png'),
                  'FIVE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\Numbers\Five.png'),
                  'SIX': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\Numbers\Six.png'),
                  'SEVEN': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\Numbers\Seven.png'),
                  'EIGHT': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\Numbers\Eight.png'),
                  'NINE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\Numbers\\Nine.png'),
                  'SLASH': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\Numbers\Slash.png'),
                  'PLUS': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\Numbers\Plus.png'),
                  'MINUS': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\Numbers\Minus.png'),
                  'PERIOD': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\Numbers\Period.png'),
                  #
                  'ZERO_ORANGE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\NumbersOrange\ZeroOrange.png'),
                  'ONE_ORANGE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\NumbersOrange\OneOrange.png'),
                  'TWO_ORANGE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\NumbersOrange\TwoOrange.png'),
                  'THREE_ORANGE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\NumbersOrange\ThreeOrange.png'),
                  'FOUR_ORANGE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\NumbersOrange\FourOrange.png'),
                  'FIVE_ORANGE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\NumbersOrange\FiveOrange.png'),
                  'SIX_ORANGE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\NumbersOrange\SixOrange.png'),
                  'SEVEN_ORANGE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\NumbersOrange\SevenOrange.png'),
                  'EIGHT_ORANGE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\NumbersOrange\EightOrange.png'),
                  'NINE_ORANGE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\NumbersOrange\\NineOrange.png'),
                  'SLASH_ORANGE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\NumbersOrange\SlashOrange.png'),
                  'PLUS_ORANGE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\NumbersOrange\PlusOrange.png'),
                  'MINUS_ORANGE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\NumbersOrange\MinusOrange.png'),
                  'PERIOD_ORANGE': loadTexture(path + '\Images/TheDoor12-Surfing\SurfingGameUI\\NumbersOrange\PeriodOrange.png'),
                  #
                  # Eating Rat
                  'EATING_RAT_TALKING': [loadTexture(path + '\Images/TheDoor12-Surfing\EatingRat\RatTalking' + str(x+1) + '.png') for x in range(12)],
                  'EATING_RAT_STANDING': [loadTexture(path + '\Images/TheDoor12-Surfing\EatingRat\RatStanding' + str(x+1) + '.png') for x in range(12)],
                  'DoYouHappenToHaveAnyFood': loadTexture(path + '\Images/TheDoor12-Surfing\EatingRatDialogue\DoYouHappenToHaveAnyFood.png'),
                  'IFeelSoSatisfiedNow': loadTexture(path + '\Images/TheDoor12-Surfing\EatingRatDialogue\IFeelSoSatisfiedNow.png'),
                  'ItsBeenToughToFindFoodRecently': loadTexture(path + '\Images/TheDoor12-Surfing\EatingRatDialogue\ItsBeenToughToFindFoodRecently.png'),
                  'IWantYouToHaveThis2': loadTexture(path + '\Images/TheDoor12-Surfing\EatingRatDialogue\IWantYouToHaveThis.png'),
                  'OhHelloLittleHamster': loadTexture(path + '\Images/TheDoor12-Surfing\EatingRatDialogue\OhHelloLittleHamster.png'),
                  'OhThankYouSoMuch': loadTexture(path + '\Images/TheDoor12-Surfing\EatingRatDialogue\OhThankYouSoMuch.png'),
                  'SoYummy': loadTexture(path + '\Images/TheDoor12-Surfing\EatingRatDialogue\SoYummy.png'),
                  'ThankYouForFeedingMe': loadTexture(path + '\Images/TheDoor12-Surfing\EatingRatDialogue\ThankYouForFeedingMe.png'),
                  'ThisTastesWonderful': loadTexture(path + '\Images/TheDoor12-Surfing\EatingRatDialogue\ThisTastesWonderful.png'),
                  'HiyaHamsterFriend': loadTexture(path + '\Images/TheDoor12-Surfing\EatingRatDialogue\HiyaHamsterFriend.png'),
                  #
                  # Loading screen backgrounds
                  'LOADING_FOREST_BG': loadTexture(path + '\Images/LoadingScreens\Forest\LoadingForestBG.png'),
                  'LOADING_FOREST_BG_TOP': loadTexture(path + '\Images/LoadingScreens\Forest\LoadingForestBGTop.png'),
                  'LOADING_FOREST_BG_BOTTOM': loadTexture(path + '\Images/LoadingScreens\Forest\LoadingForestBGBottom.png'),
                  'LOADING_ANTHILL_BG': loadTexture(path + '\Images/LoadingScreens\AntHill\LoadingBGMiddle.png'),
                  'LOADING_ANTHILL_BG_TOP': loadTexture(path + '\Images/LoadingScreens\AntHill\LoadingBGTop.png'),
                  'LOADING_ANTHILL_BG_BOTTOM': loadTexture(path + '\Images/LoadingScreens\AntHill\LoadingBGBottom.png'),
                  'LOADING_SEWER_BG_MIDDLE': loadTexture(path + '\Images/LoadingScreens\Sewer\LoadSewerBGMiddle.png'),
                  'LOADING_SEWER_BG_TOPBOTTOM': loadTexture(path + '\Images/LoadingScreens\Sewer\LoadSewerBGTopBottom.png'),
                  'LOADING_SEWER_BG_WATER_MIDDLE': loadTexture(path + '\Images/LoadingScreens\Sewer\LoadSewerBGWaterMiddle.png'),
                  'LOADING_TEXT': [loadTexture(path + '\Images/LoadingScreens\LoadingText\LoadingText' + str(x+1) + '.png') for x in range(4)],
                  'LOADING_TEXT_PINK': [loadTexture(path + '\Images/LoadingScreens\LoadingText\LoadingTextPink' + str(x+1) + '.png') for x in range(4)],
                  'TRANSPARENT_BLACK_GRADIENT': loadTexture(path + '\Images/LoadingScreens\TransparentBlackGradient\TransparentBlackGradient.png'),
                  'SHADY_BLACK_PIXEL': loadTexture(path + '\Images/LoadingScreens\ShadyBlackPixel.png'),
                  'PAUSE_MENU_RECTANGLE': loadTexture(path + '\Images/LoadingScreens\PauseMenuRectangle.png'),
                  'CONTINUE': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Continue.png'),
                  'PLAY': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Play.png'),
                  'EXIT': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Exit.png'),
                  'SAVE_FILE': loadTexture(path + '\Images/LoadingScreens\PauseMenu\SaveFile.png'),
                  'SAVE_FILE_SHADE': loadTexture(path + '\Images/LoadingScreens\PauseMenu\SaveFileShade.png'),
                  'SAVE_FILE_HIGHLIGHT': loadTexture(path + '\Images/LoadingScreens\PauseMenu\SaveFileHighlight.png'),
                  'CHECK_MARK1': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Checkmark1.png'),
                  'CHECK_MARK2': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Checkmark2.png'),
                  'CHECK_MARK_HIGHLIGHT': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Checkmark_highlight.png'),
                  'DISPLAY_PLAYTIME': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Display_Playtime.png'),
                  'DELETE': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Delete.png'),
                  'DELETE_HIGHLIGHT': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Delete_highlight.png'),
                  'CONFIRM_DELETION': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Confirm.png'),
                  'CONFIRM_PLAY': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Confirm_play.png'),
                  'YES': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Yes.png'),
                  'YES_HIGHLIGHT': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Yes_highlight.png'),
                  'NO': loadTexture(path + '\Images/LoadingScreens\PauseMenu\\No.png'),
                  'NO_HIGHLIGHT': loadTexture(path + '\Images/LoadingScreens\PauseMenu\\No_highlight.png'),
                  'GRAPPLE_PORTION': loadTexture(path + '\Images/LoadingScreens\PauseMenu\GrapplePortion.png'),
                  'OPTIONS': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Options.png'),
                  'MAIN_MENU': loadTexture(path + '\Images/LoadingScreens\PauseMenu\MainMenu.png'),
                  'CHAIN': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Chain.png'),
                  'BACK': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Back.png'),
                  'CREDITS': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Credits.png'),
                  'SCREEN_OPTIONS': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Screen.png'),
                  'SOUND': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Sound.png'),
                  'HOTKEYS': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Hotkeys.png'),
                  'RESOLUTION': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolution.png'),
                  'RESOLUTION_IMAGES': [loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\R800x600.png'), loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\R1024x768.png'), loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\R1152x864.png'), loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\R1280x720.png'), loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\R1280x768.png'), loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\R1280x800.png'), loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\R1280x960.png'), loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\R1280x1024.png'), loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\R1360x768.png'), loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\R1366x768.png'), loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\R1400x1050.png'), loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\R1440x900.png'), loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\R1680x1050.png'), loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\R1920x1080.png')],
                  'SAVE': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Save.png'),
                  'SAVED': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Saved.png'),
                  'DEFAULTS': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Defaults.png'),
                  'SOUND_BAR_BEING_MOVED': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Sound\BarBeingMoved.png'),
                  'SOUND_ADJUSTMENT_BAR': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Sound\SoundAdjustmentBar.png'),
                  #
                  'FOREST_MINI': loadTexture(path + '\Images/Pause_menu_map\\Used_images\Forest.png'),
                  'TOWN_MINI': loadTexture(path + '\Images/Pause_menu_map\\Used_images\Town.png'),
                  'ANTHILL_MINI': loadTexture(path + '\Images/Pause_menu_map\\Used_images\AntHill.png'),
                  'SEWER_MINI': loadTexture(path + '\Images/Pause_menu_map\\Used_images\Sewer.png'),
                  'BLACK_PIXEL': loadTexture(path + '\Images/LoadingScreens\PauseMenu\BLACK_PIXEL.png'),
                  'WHITE_PIXEL': loadTexture(path + '\Images/LoadingScreens\PauseMenu\WHITE_PIXEL.png'),
                  'HOTKEY_OUTLINE': loadTexture(path + '\Images/LoadingScreens\PauseMenu\HotKeyOutline.png'),
                  'N0': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\Individual_Numbers\\N0.png'),
                  'N1': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\Individual_Numbers\\N1.png'),
                  'N2': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\Individual_Numbers\\N2.png'),
                  'N3': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\Individual_Numbers\\N3.png'),
                  'N4': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\Individual_Numbers\\N4.png'),
                  'N5': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\Individual_Numbers\\N5.png'),
                  'N6': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\Individual_Numbers\\N6.png'),
                  'N7': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\Individual_Numbers\\N7.png'),
                  'N8': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\Individual_Numbers\\N8.png'),
                  'N9': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\Individual_Numbers\\N9.png'),
                  'Nx': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\Individual_Numbers\MultiplicationSymbol.png'),
                  'CHANGE_RESOLUTION_NOTE': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Resolutions\Individual_Numbers\ChangeResolutionNote.png'),
                  'FULL_SCREEN': loadTexture(path + '\Images/LoadingScreens\PauseMenu\FullScreen.png'),
                  'WINDOWED': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Windowed.png'),
                  'SHINY_OUTSIDE': loadTexture(path + '\Images/LoadingScreens\PauseMenu\ShinyOutside.png'),
                  'STAR': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Star.png'),
                  'SHADY_STAR': loadTexture(path + '\Images/LoadingScreens\PauseMenu\Shady_star.png'),
                  #
                  # Mouses
                  'ACTUAL_MOUSE': loadTexture(path + '\Images\MouseReplacement\ActualMouse.png'),
                  'TIP_OF_PISTON_MOUSE': loadTexture(path + '\Images\MouseReplacement\TipOfPiston.png'),
                  #
                  # The Machine
                  'THE_MACHINE_DISREPAIR': [loadTexture(path + '\Images\Town\TheMachine\TheMachineDisrepair\TheMachineDisrepair' + str(x+1) + '.png') for x in range(8)],
                  'THE_MACHINE_DOOR': [loadTexture(path + '\Images\Town\TheMachine\TheMachineDoor\TheMachineDoor' + str(x+1) + '.png') for x in range(6)],
                  'THE_MACHINE_CLOSING': [loadTexture(path + '\Images\Town\TheMachine\TheMachine\TheMachine' + str(x+1) + '.png') for x in range(6)],
                  'JUST_THE_DAMAGE': loadTexture(path + '\Images\Town\TheMachine\JustTheDamage.png'),
                  'GREEN_BUTTON': [loadTexture(path + '\Images/Town\TheMachine\GreenButton\GreenButton' + str(x+1) + '.png') for x in range(2)],
                  'SHINY_GREEN_BUTTON': loadTexture(path + '\Images/Town\TheMachine\GreenButton\ShinyGreenButton.png'),
                  'RED_BUTTON': [loadTexture(path + '\Images/Town\TheMachine\RedButton\RedButton' + str(x+1) + '.png') for x in range(2)],
                  'WHOLE_CLOSED_MACHINE': loadTexture(path + '\Images/Town\TheMachine\Whole_closed_machine.png'),
                  #
                  # The Machine Parts
                  'SCREW_DRIVER': loadTexture(path + '\Images\Town\TheMachine\MachineParts\MachineScrewDriver.png'),
                  'WIRE_CUTTER': loadTexture(path + '\Images\Town\TheMachine\MachineParts\MachineWireCutter.png'),
                  'WRENCH': loadTexture(path + '\Images\Town\TheMachine\MachineParts\MachineWrench.png'),
                  'SMOKE': [loadTexture(path + '\Images\Town\TheMachine\Smoke\Smoke' + str(x+1) + '.png') for x in range(6)],
                  #
                  # Hamster Dialogue
                  'ThatFallWasWild': loadTexture(path + '\Images\Hamster\Dialogue\ThatFallWasWild.png'),
                  'INeedToGetOutOfThisTrashCan': loadTexture(path + '\Images\Hamster\Dialogue\INeedToGetOutOfThisTrashCan.png'),
                  'MaybeICanBuildSomethingToEscape': loadTexture(path + '\Images\Hamster\Dialogue\MaybeICanBuildSomethingToEscape.png'),
                  'ICanPressToSinkDown': loadTexture(path + '\Images\Hamster\Dialogue\ICanPressToSinkDown.png'),
                  'ICanPressToFloatUp': loadTexture(path + '\Images\Hamster\Dialogue\ICanPressToFloatUp.png'),
                  'ICanPressToPropelMyselfWithThisHoseNozzle': loadTexture(path + '\Images\Hamster\Dialogue\ICanPressToPropelMyselfWithThisHoseNozzle.png'),
                  'ICanPressToAttachMyselfToThosePlatforms': loadTexture(path + '\Images\Hamster\Dialogue\ICanPressToAttachMyselfToThosePlatforms.png'),
                  'ICanPressToDetach': loadTexture(path + '\Images\Hamster\Dialogue\ICanPressToDetach.png'),
                  'ICanPropelMyselfWithThisWater': loadTexture(path + '\Images\Hamster\Dialogue\ICanPropelMyselfWithThisWater.png'),
                  'ICanGetOutOfHereThroughTheExitToMyLeftNow': loadTexture(path + '\Images\Hamster\Dialogue\ICanGetOutOfHereThroughTheExitToMyLeftNow.png'),
                  'OhNoMyMachineIsBroken': loadTexture(path + '\Images\Hamster\Dialogue\OhNoMyMachineIsBroken.png'),
                  'IllNeedToFindSomeToolsToMakeRepairs': loadTexture(path + '\Images\Hamster\Dialogue\IllNeedToFindSomeToolsToMakeRepairs.png'),
                  'IShouldSearchTheForestToMyLeft': loadTexture(path + '\Images\Hamster\Dialogue\IShouldSearchTheForestToMyLeft.png'),
                  'ICanPressToRepairMyMachine': loadTexture(path + '\Images\Hamster\Dialogue\ICanPressToRepairMyMachine.png'),
                  'ICanNowFastTravelHereUsingThePauseMenu': loadTexture(path + '\Images\Hamster\Dialogue\ICanNowFastTravelHereUsingThePauseMenu.png'),
                  'ICanPressToAccessThePauseMenu': loadTexture(path + '\Images\Hamster\Dialogue\ICanPressToAccessThePauseMenu.png'),
                  #
                  # Alphabet
                  'A': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\A.png'),
                  'B': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\B.png'),
                  'C': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\C.png'),
                  'D': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\D.png'),
                  'E': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\E.png'),
                  'F': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\F.png'),
                  'G': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\G.png'),
                  'H': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\H.png'),
                  'I': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\I.png'),
                  'J': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\J.png'),
                  'K': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\K.png'),
                  'L': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\L.png'),
                  'M': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\M.png'),
                  'N': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\\N.png'),
                  'O': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\O.png'),
                  'P': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\P.png'),
                  'Q': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Q.png'),
                  'R': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\R.png'),
                  'S': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\S.png'),
                  'T': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\T.png'),
                  'U': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\\U.png'),
                  'V': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\V.png'),
                  'W': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\W.png'),
                  'X': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\X.png'),
                  'Y': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Y.png'),
                  'Z': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Z.png'),
                  '0': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Q0.png'),
                  '1': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Q1.png'),
                  '2': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Q2.png'),
                  '3': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Q3.png'),
                  '4': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Q4.png'),
                  '5': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Q5.png'),
                  '6': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Q6.png'),
                  '7': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Q7.png'),
                  '8': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Q8.png'),
                  '9': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Q9.png'),
                  ',': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Z_Comma.png'),
                  '-': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Z_Minus.png'),
                  '.': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Z_Period.png'),
                  '/': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Z_Slash.png'),
                  ';': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Z_Semicolon.png'),
                  '=': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Z_Equal.png'),
                  '[': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Z_LEFTBRACKET.png'),
                  ']': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Z_RIGHTBRACKET.png'),
                  ':': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Z_Colon.png'),
                  '*': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharacters\Z_Asterisk.png'),
                  #
                  'RA': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\A.png'),
                  'RB': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\B.png'),
                  'RC': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\C.png'),
                  'RD': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\D.png'),
                  'RE': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\E.png'),
                  'RF': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\F.png'),
                  'RG': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\G.png'),
                  'RH': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\H.png'),
                  'RI': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\I.png'),
                  'RJ': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\J.png'),
                  'RK': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\K.png'),
                  'RL': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\L.png'),
                  'RM': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\M.png'),
                  'RN': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\\N.png'),
                  'RO': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\O.png'),
                  'RP': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\P.png'),
                  'RQ': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Q.png'),
                  'RR': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\R.png'),
                  'RS': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\S.png'),
                  'RT': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\T.png'),
                  'RU': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\\U.png'),
                  'RV': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\V.png'),
                  'RW': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\W.png'),
                  'RX': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\X.png'),
                  'RY': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Y.png'),
                  'RZ': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Z.png'),
                  'R0': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Q0.png'),
                  'R1': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Q1.png'),
                  'R2': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Q2.png'),
                  'R3': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Q3.png'),
                  'R4': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Q4.png'),
                  'R5': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Q5.png'),
                  'R6': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Q6.png'),
                  'R7': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Q7.png'),
                  'R8': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Q8.png'),
                  'R9': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Q9.png'),
                  'R,': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Z_Comma.png'),
                  'R-': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Z_Minus.png'),
                  'R.': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Z_Period.png'),
                  'R/': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Z_Slash.png'),
                  'R;': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Z_Semicolon.png'),
                  'R=': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Z_Equal.png'),
                  'R[': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Z_LEFTBRACKET.png'),
                  'R]': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Z_RIGHTBRACKET.png'),
                  'R:': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Z_Colon.png'),
                  'R*': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersRed\Z_Asterisk.png'),
                  #
                  'BA': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\A.png'),
                  'BB': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\B.png'),
                  'BC': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\C.png'),
                  'BD': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\D.png'),
                  'BE': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\E.png'),
                  'BF': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\F.png'),
                  'BG': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\G.png'),
                  'BH': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\H.png'),
                  'BI': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\I.png'),
                  'BJ': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\J.png'),
                  'BK': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\K.png'),
                  'BL': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\L.png'),
                  'BM': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\M.png'),
                  'BN': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\\N.png'),
                  'BO': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\O.png'),
                  'BP': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\P.png'),
                  'BQ': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Q.png'),
                  'BR': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\R.png'),
                  'BS': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\S.png'),
                  'BT': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\T.png'),
                  'BU': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\\U.png'),
                  'BV': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\V.png'),
                  'BW': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\W.png'),
                  'BX': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\X.png'),
                  'BY': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Y.png'),
                  'BZ': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Z.png'),
                  'B0': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Q0.png'),
                  'B1': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Q1.png'),
                  'B2': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Q2.png'),
                  'B3': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Q3.png'),
                  'B4': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Q4.png'),
                  'B5': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Q5.png'),
                  'B6': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Q6.png'),
                  'B7': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Q7.png'),
                  'B8': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Q8.png'),
                  'B9': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Q9.png'),
                  'B,': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Z_Comma.png'),
                  'B-': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Z_Minus.png'),
                  'B.': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Z_Period.png'),
                  'B/': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Z_Slash.png'),
                  'B;': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Z_Semicolon.png'),
                  'B=': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Z_Equal.png'),
                  'B[': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Z_LEFTBRACKET.png'),
                  'B]': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Z_RIGHTBRACKET.png'),
                  'B:': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Z_Colon.png'),
                  'B*': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Z_Asterisk.png'),
                  'B?': loadTexture(path + '\Images\LoadingScreens\PauseMenu\AllCharactersBlack\Z_Question.png'),
                  'TIMER': loadTexture(path + '\Images\LoadingScreens\PauseMenu\Timer.png')
                  }



for event in pygame.event.get():
  break

make_opengl_rect((screen_width, screen_height), LOADING_HAMSTER_FACE_IMAGE[1], (0, 0), 0, False, (0, 0, screen_width, screen_height))
pygame.display.flip()


load_OpenGLTextures()


MAP_images = {# MAPS, collision, not pretty
              'MAP12': path + '\Images/' + 'MAP12.png',
              'FOREST': path + '\Images/Forest/Forest3.png',
              'ANTHILL': path + '\Images/AntHill/AntHill4.png',
              'SEWER': path + '\Images/Sewer/Sewer_NEW3.png',
              'TOWN': path + '\Images/Town\Town3.png',
              'THE_DOOR1': path + '\Images/TheDoor1-MetalBars/TheDoor1-MetalBars2.png',
              'THE_DOOR2': path + '\Images/TheDoor2-Clouds/TheDoor2-Clouds2.png',
              'THE_DOOR3': path + '\Images/TheDoor3-TreeTrunk/TreeTrunk4.png',
              'THE_DOOR4': path + '\Images/TheDoor4-AntHillFootBall/FootBallField3.png',
              'THE_DOOR5': path + '\Images/TheDoor5-TopOfBossTree/TopOfBossTree3.png',
              'THE_DOOR6': path + '\Images/TheDoor6-InsideQueenAnt/InsideQueenAnt3.png',
              'THE_DOOR7': path + '\Images/TheDoor7-TeeterTotterKey/ElevatorDoorV2.png',
              'THE_DOOR8': path + '\Images/TheDoor8-RacingCircles/TheDoor8-RacingCirclesV2.png',
              'THE_DOOR9': path + '\Images/TheDoor9-ClimbingRoots/TheDoor9-ClimbingRoots1.png',
              'THE_DOOR10': path + '\Images/TheDoor10-SewerWaterFall/TheDoor10-SewerWaterFallNew1.png',
              'THE_DOOR11': path + '\Images/TheDoor11-WaterRace\TheDoor11-WaterRace_NEW2.png',
              'THE_DOOR12': path + '\Images/TheDoor12-Surfing\TheDoor12-Surfing1.png',
              'THE_DOOR13': path + '\Images/TheDoor13-Tutorial\TheDoor13-Tutorial1.png',
              'THE_DOOR26': path + '\Images/TheDoor26-ClimbingLeaves/TheDoor26-ClimbingLeavesV2.png',
              #
              # Pretty maps
              'PRETTY_MAP12': path + '\Images\MAP12.png',
              'PRETTY_MAP_FOREST': path + '\Images\Forest\Forest2.png',
              'PRETTY_MAP_ANTHILL': path + '\Images\AntHill/AntHill5.png',
              'PRETTY_MAP_SEWER': path + '\Images\Sewer\Sewer_NEW5.png',
              'PRETTY_MAP_TOWN': path + '\Images/Town\Town2.png',
              'PRETTY_MAP_THE_DOOR1': path + '\Images\TheDoor1-MetalBars/TheDoor1-MetalBars1.png',
              'PRETTY_MAP_THE_DOOR2': path + '\Images\TheDoor2-Clouds/TheDoor2-Clouds1.png',
              'PRETTY_MAP_THE_DOOR3': path + '\Images\TheDoor3-TreeTrunk/TreeTrunk3.png',
              'PRETTY_MAP_THE_DOOR4': path + '\Images\TheDoor4-AntHillFootBall/FootBallField2.png',
              'PRETTY_MAP_THE_DOOR5': path + '\Images\TheDoor5-TopOfBossTree/TopOfBossTree2.png',
              'PRETTY_MAP_THE_DOOR6': path + '\Images\TheDoor6-InsideQueenAnt/InsideQueenAnt2.png',
              'PRETTY_MAP_THE_DOOR7': path + '\Images\TheDoor7-TeeterTotterKey/ElevatorDoorV3.png',
              'PRETTY_MAP_THE_DOOR8': path + '\Images\TheDoor8-RacingCircles/TheDoor8-RacingCirclesV3.png',
              'PRETTY_MAP_THE_DOOR9': path + '\Images\TheDoor9-ClimbingRoots/TheDoor9-ClimbingRoots13.png',
              'PRETTY_MAP_THE_DOOR10': path + '\Images/TheDoor10-SewerWaterFall/TheDoor10-SewerWaterFallNew2.png',
              'PRETTY_MAP_THE_DOOR11': path + '\Images/TheDoor11-WaterRace\TheDoor11-WaterRace_NEW1.png',
              'PRETTY_MAP_THE_DOOR12': path + '\Images/TheDoor12-Surfing\TheDoor12-Surfing2.png',
              'PRETTY_MAP_THE_DOOR13': path + '\Images/TheDoor13-Tutorial\TheDoor13-Tutorial2.png',
              'PRETTY_MAP_THE_DOOR26': path + '\Images\TheDoor26-ClimbingLeaves/TheDoor26-ClimbingLeavesV3.png'
              }


maximum_piston_length_dict = {'0': 100,
                              '1': 112,
                              '2': 123,
                              '3': 135,
                              '4': 147,
                              '5': 158,
                              '6': 170,
                              '7': 182,
                              '8': 193,
                              '9': 205,
                              '10': 217,
                              '11': 228,
                              '12': 240}


key_to_pygame_index_dict = {
                            str(pygame.K_BACKSPACE): 'BACKSPACE',
                            str(pygame.K_TAB): 'TAB',
                            str(pygame.K_RETURN): 'RETURN',
                            str(pygame.K_ESCAPE): 'ESCAPE',
                            str(pygame.K_SPACE): 'SPACE',
                            str(pygame.K_COMMA): ',',
                            str(pygame.K_MINUS): '-',
                            str(pygame.K_PERIOD): '.',
                            str(pygame.K_SLASH): '/',
                            str(pygame.K_0): '0',
                            str(pygame.K_1): '1',
                            str(pygame.K_2): '2',
                            str(pygame.K_3): '3',
                            str(pygame.K_4): '4',
                            str(pygame.K_5): '5',
                            str(pygame.K_6): '6',
                            str(pygame.K_7): '7',
                            str(pygame.K_8): '8',
                            str(pygame.K_9): '9',
                            str(pygame.K_SEMICOLON): ';',
                            str(pygame.K_EQUALS): '=',
                            str(pygame.K_LEFTBRACKET): '[',
                            str(pygame.K_RIGHTBRACKET): ']',
                            str(pygame.K_a): 'A',
                            str(pygame.K_b): 'B',
                            str(pygame.K_c): 'C',
                            str(pygame.K_d): 'D',
                            str(pygame.K_e): 'E',
                            str(pygame.K_f): 'F',
                            str(pygame.K_g): 'G',
                            str(pygame.K_h): 'H',
                            str(pygame.K_i): 'I',
                            str(pygame.K_j): 'J',
                            str(pygame.K_k): 'K',
                            str(pygame.K_l): 'L',
                            str(pygame.K_m): 'M',
                            str(pygame.K_n): 'N',
                            str(pygame.K_o): 'O',
                            str(pygame.K_p): 'P',
                            str(pygame.K_q): 'Q',
                            str(pygame.K_r): 'R',
                            str(pygame.K_s): 'S',
                            str(pygame.K_t): 'T',
                            str(pygame.K_u): 'U',
                            str(pygame.K_v): 'V',
                            str(pygame.K_w): 'W',
                            str(pygame.K_x): 'X',
                            str(pygame.K_y): 'Y',
                            str(pygame.K_z): 'Z',
                            str(pygame.K_DELETE): 'DELETE',
                            str(pygame.K_UP): 'UP',
                            str(pygame.K_DOWN): 'DOWN',
                            str(pygame.K_LEFT): 'LEFT',
                            str(pygame.K_RIGHT): 'RIGHT',
                            str(pygame.K_INSERT): 'INSERT',
                            str(pygame.K_HOME): 'HOME',
                            str(pygame.K_END): 'END',
                            str(pygame.K_PAGEUP): 'PAGE UP',
                            str(pygame.K_PAGEDOWN): 'PAGE DOWN',
                            str(pygame.K_F1): 'F1',
                            str(pygame.K_F2): 'F2',
                            str(pygame.K_F3): 'F3',
                            str(pygame.K_F4): 'F4',
                            str(pygame.K_F5): 'F5',
                            str(pygame.K_F6): 'F6',
                            str(pygame.K_F7): 'F7',
                            str(pygame.K_F8): 'F8',
                            str(pygame.K_F9): 'F9',
                            str(pygame.K_F10): 'F10',
                            str(pygame.K_F11): 'F11',
                            str(pygame.K_F12): 'F12',
                            str(pygame.K_CAPSLOCK): 'CAPSLOCK',
                            str(pygame.K_RSHIFT): 'RIGHT SHIFT',
                            str(pygame.K_LSHIFT): 'LEFT SHIFT',
                            str(pygame.K_RCTRL): 'RIGHT CONTROL',
                            str(pygame.K_LCTRL): 'LEFT CONTROL',
                            str(pygame.K_RALT): 'RIGHT ALT',
                            str(pygame.K_LALT): 'LEFT ALT'}


default_control_path = path + '\Controls\Default_Controls.txt'
current_control_path = path + '\Controls\Current_Controls.txt'


def return_current_controls_to_default():
  with open(default_control_path, 'r') as file:
    current_save_data = file.readlines()
  #
  with open(current_control_path, 'w') as file:
    file.writelines(current_save_data)

with open(current_control_path, 'r') as file:
  temp_save_data = file.readlines()
  if len(temp_save_data) != 9:
    return_current_controls_to_default()


all_available_hotkeys_dict = {}

#for k, v in key_to_pygame_index_dict.items():
#  all_available_hotkeys_dict[pygame.key.name(i)] = int(k)

all_available_hotkeys_dict['left_click'] = 512
all_available_hotkeys_dict['weird_click'] = 513
all_available_hotkeys_dict['right_click'] = 514


current_hotkeys = {}

def get_current_controls():
  with open(current_control_path, 'r') as file:
    current_save_data = file.readlines()
  current_hotkeys['MOVE_LEFT'] = int(current_save_data[0])
  current_hotkeys['MOVE_RIGHT'] = int(current_save_data[1])
  current_hotkeys['FLOAT_UP'] = int(current_save_data[2])
  current_hotkeys['SINK_DOWN'] = int(current_save_data[3])
  current_hotkeys['INTERACT'] = int(current_save_data[4])
  current_hotkeys['EXTEND_WATER_JET'] = int(current_save_data[5])
  current_hotkeys['EXTEND_GRAPPLING_HOOK'] = int(current_save_data[6])
  current_hotkeys['DETACH_GRAPPLING_HOOK'] = int(current_save_data[7])
  current_hotkeys['PAUSE'] = int(current_save_data[8])

get_current_controls()


class PressedControls():
  def __init__(self):
    self.pressed_controls = {'MOVE_LEFT': False,
                    'MOVE_RIGHT': False,
                    'FLOAT_UP': False,
                    'SINK_DOWN': False,
                    'INTERACT': False,
                    'EXTEND_WATER_JET': False,
                    'EXTEND_GRAPPLING_HOOK': False,
                    'DETACH_GRAPPLING_HOOK': False,
                    'PAUSE': False}

Currently_pressed_controls = PressedControls()

def update_pressed_controls():
  for k,v in current_hotkeys.items():
    v = int(v)
    if v == 512:
      Currently_pressed_controls.pressed_controls[k] = left_click
      continue
    if v == 513:
      Currently_pressed_controls.pressed_controls[k] = weird_click
      continue
    if v == 514:
      Currently_pressed_controls.pressed_controls[k] = right_click
      continue
    else:
      Currently_pressed_controls.pressed_controls[k] = keys[v]
      continue


def get_hotkey_button_string(desired_hotkey_key):
  hotkey_index = current_hotkeys[desired_hotkey_key]
  if hotkey_index == 512:
    return 'LEFT CLICK'
  if hotkey_index == 513:
    return 'WEIRD CLICK'
  if hotkey_index == 514:
    return 'RIGHT CLICK'
  desired_string = key_to_pygame_index_dict[str(hotkey_index)]
  return desired_string


 #################
###  FUNCTIONS  ###
 #################


maximum_velocity_x = 400
maximum_velocity_y = 925
maximum_velocity_overall = math.sqrt(maximum_velocity_x**2 + maximum_velocity_y**2)
my_gravity = 400

def gravity():
  PLAYER.Fgx, PLAYER.Fgy = 0, my_gravity


def find_all_possible_ball_collisions(object1, object2):
  impact_points = []
  collision_happened = False
  offset_x, offset_y = (object1.x_pos - object2.x_pos), (object1.y_pos - object2.y_pos)
  if object2.mask.overlap(object1.mask, (round(offset_x), round(offset_y))):
    overlapped_mask = object2.mask.overlap_mask(object1.mask, (round(offset_x), round(offset_y)))
    mask_surface = overlapped_mask.to_surface()
    for i in range(69):
      for j in range(69):
        cur_color = mask_surface.get_at((i,j))
        if (cur_color[0] != 0) or (cur_color[1] != 0) or (cur_color[2] != 0):
          PLAYER.solid_ball_points.append((i,j))
    collision_happened = True
  else:
    impact_points.append(False)
  return impact_points, collision_happened


def find_ball_collisions_exhaustive(object1, object2):
  impact_points = []
  collision_happened = False
  offset_x, offset_y = (object1.x_pos - object2.x_pos), (object1.y_pos - object2.y_pos)
  overlapped_mask = object2.mask.overlap_mask(object1.mask, (round(offset_x), round(offset_y)))
  mask_surface = overlapped_mask.to_surface()
  for i in range(len(PLAYER.solid_ball_points)):
    cur_color = mask_surface.get_at((PLAYER.solid_ball_points[i][0], PLAYER.solid_ball_points[i][1]))
    if (cur_color[0] != 0) or (cur_color[1] != 0) or (cur_color[2] != 0):
      impact_points.append((PLAYER.solid_ball_points[i][0], PLAYER.solid_ball_points[i][1]))
  if impact_points != []:
    collision_happened = True
  else:
    impact_points.append(False)
  return impact_points, collision_happened


def find_collisions(object1, object2):
  impact_points = []
  offset_x, offset_y = (object1.x_pos - object2.x_pos), (object1.y_pos - object2.y_pos)
  impact_points.append(object2.mask.overlap_mask(object1.mask, (round(offset_x), round(offset_y))).outline(object2.outline_every))
  if impact_points == [[]]:
    return False, False
  else:
    return impact_points[0], True


def find_surf_board_collisions(object1, object2, object2_image):
  object2_mask = pygame.mask.from_surface(object2_image)
  impact_points = []
  offset_x, offset_y = (object1.x_pos - object2.x_pos), (object1.y_pos - object2.y_pos)
  impact_points.append(object2_mask.overlap_mask(object1.mask, (round(offset_x), round(offset_y))).outline(object2.outline_every))
  if impact_points == [[]]:
    return False, False
  else:
    return impact_points[0], True


def find_collisions_with_offsets(object1, object2, additional_offset_x, additional_offset_y):
  object1.mask = pygame.mask.from_surface(object1.current_image)
  impact_points = []
  offset_x, offset_y = (object1.x_pos - object2.x_pos - additional_offset_x), (object1.y_pos - object2.y_pos - additional_offset_y)
  impact_points.append(object2.mask.overlap_mask(object1.mask, (round(offset_x), round(offset_y))).outline())
  if impact_points == [[]]:
    return False, False
  else:
    return impact_points[0], True


def find_collisions_with_offsets_pause_menu(img1_mask, img2_mask, additional_offset_x, additional_offset_y):
  impact_points = []
  offset_x, offset_y = (additional_offset_x), (additional_offset_y)
  impact_points.append(img2_mask.overlap_mask(img1_mask, (round(offset_x), round(offset_y))).outline())
  if impact_points == [[]]:
    return False, False
  else:
    return impact_points[0], True


def find_food_collisions_with_offsets(object1, object2, additional_offset_x, additional_offset_y):
  #object1.mask = pygame.mask.from_surface(object1.current_image)
  impact_points = []
  offset_x, offset_y = (object1.x_pos - object2.x_pos - additional_offset_x), (object1.y_pos - object2.y_pos - additional_offset_y)
  impact_points.append(object2.mask.overlap_mask(object1.mask, (round(offset_x), round(offset_y))).outline())
  if impact_points == [[]]:
    return False, False
  else:
    return impact_points[0], True


def find_point_collision_with_offsets(object1, object2, additional_offset_x, additional_offset_y):
  object1.mask = pygame.mask.from_surface(object1.current_image)
  impact_points = []
  collision_happened = False
  offset_x, offset_y = (object1.x_pos - object2.x_pos - additional_offset_x), (object1.y_pos - object2.y_pos - additional_offset_y)
  if object2.mask.overlap_mask(object1.mask, (round(offset_x), round(offset_y))).outline(97):
    collision_happened = True
  else:
    impact_points.append(False)
  return collision_happened


def find_collisions_with_offsets_mask(object1, object1_mask, object2, additional_offset_x, additional_offset_y):
  impact_points = []
  collision_happened = False
  offset_x, offset_y = (object1.x_pos - object2.x_pos - additional_offset_x), (object1.y_pos - object2.y_pos - additional_offset_y)
  if object2.mask.overlap(object1_mask, (round(offset_x), round(offset_y))):
    impact_points.append(object2.mask.overlap_mask(object1.mask, (round(offset_x), round(offset_y))).outline(object2.outline_every))
    collision_happened = True
  else:
    impact_points.append(False)
  return impact_points[0], collision_happened


def find_special_water_collisions_with_offsets_mask(object1_mask, object1_x_pos, object1_y_pos, object2, additional_offset_x, additional_offset_y):
  impact_points = []
  collision_happened = False
  offset_x, offset_y = (object1_x_pos - object2.x_pos - additional_offset_x), (object1_y_pos - object2.y_pos - additional_offset_y)
  if object2.mask.overlap(object1_mask, (round(offset_x), round(offset_y))):
    impact_points.append(object2.mask.overlap_mask(object1_mask, (round(offset_x), round(offset_y))).outline())
    collision_happened = True
  else:
    impact_points.append(False)
  return impact_points[0], collision_happened


def find_collisions_with_offsets_grate_water(object1_x, object1_y, object1_mask, object2, additional_offset_x, additional_offset_y):
  impact_points = []
  collision_happened = False
  offset_x, offset_y = (object1_x - object2.x_pos - additional_offset_x), (object1_y - object2.y_pos - additional_offset_y)
  if object2.mask.overlap(object1_mask, (round(offset_x), round(offset_y))):
    impact_points.append(object2.mask.overlap_mask(object1_mask, (round(offset_x), round(offset_y))).outline(object2.outline_every))
    collision_happened = True
  else:
    impact_points.append(False)
  return impact_points[0], collision_happened


def find_collisions_with_offsets_BigElevator(object1, object1_mask, object2, additional_offset_x, additional_offset_y):
  impact_points = []
  offset_x, offset_y = (object1.x_pos - object2.x_pos - additional_offset_x), (object1.y_pos - object2.y_pos - additional_offset_y)
  impact_points.append(object2.mask.overlap_mask(object1_mask, (round(offset_x), round(offset_y))).outline(object2.outline_every))
  if impact_points == [[]]:
    return False, False
  else:
    return impact_points[0], True


def find_collisions_with_offsets_with_map(object1, object2, additional_offset_x, additional_offset_y):
  impact_points = []
  offset_x, offset_y = (object1.x_pos - object2.x_pos - additional_offset_x), (object1.y_pos - object2.y_pos - additional_offset_y)
  impact_points.append(object2.mask.overlap_mask(object1.mask, (round(offset_x), round(offset_y))).outline(object2.outline_every))
  if impact_points == [[]]:
    return False, False
  else:
    return impact_points[0], True


def find_avg_impact_point(map, player, list_of_collisions):
  total_points = 0
  total_x = 0
  total_y = 0
  for i in range(len(list_of_collisions)):
    total_points += 1
    total_x += list_of_collisions[i][0]
    total_y += list_of_collisions[i][1]
  avg_x, avg_y = int(round(total_x / total_points, 0)), int(round(total_y / total_points, 0))
  return avg_x, avg_y


def rotate_square_image(image, angle):
    orig_rect = image.get_rect()
    rot_image = pygame.transform.rotate(image, angle)
    rot_rect = orig_rect.copy()
    rot_rect.center = rot_image.get_rect().center
    rot_image = rot_image.subsurface(rot_rect).copy()
    return rot_image


def rotate_rectangular_image(image, rect, angle):
        rot_image = pygame.transform.rotate(image, angle)
        rot_rect = rot_image.get_rect(center=rect.center)
        return rot_image, rot_rect


def find_normal_force_angle(map, player, avg_impact_angle):
  return (avg_impact_angle + 180) % 360


def get_absolute_player_points(cur_points):
  return [[int(i+PLAYER.x_pos), int(j+PLAYER.y_pos)] for [i, j] in cur_points]


def elasticity_function(map, player, minimum_elasticity, maximum_elasticity, given_angle_difference):
  if given_angle_difference == 0:
    return minimum_elasticity
  if 0 < given_angle_difference < 90:
    return (((maximum_elasticity - minimum_elasticity) / (90 - 0)) * given_angle_difference) + minimum_elasticity
  if given_angle_difference == 90:
    return maximum_elasticity
  if 90 < given_angle_difference < 180:
    return (((minimum_elasticity - maximum_elasticity) / (180 - 90)) * (given_angle_difference - 90)) + maximum_elasticity
  if given_angle_difference == 180:
    return minimum_elasticity
  if 180 < given_angle_difference < 360:
    return maximum_elasticity


def find_avg_impact_angle(map, player, avg_impact_x, avg_impact_y):
  center_x, center_y = (69 - 1) / 2, (69 - 1) / 2
  avg_impact_x_from_center, avg_impact_y_from_center = avg_impact_x - center_x, avg_impact_y - center_y
  if avg_impact_x_from_center == 0 or avg_impact_y_from_center == 0:
    if avg_impact_x_from_center == avg_impact_y_from_center == 0:
      return 0
    if avg_impact_x_from_center > 0 and avg_impact_y_from_center == 0: #0 +x
      return 0
    if avg_impact_x_from_center == 0 and avg_impact_y_from_center > 0: #270 -y
      return 270
    if avg_impact_x_from_center < 0 and avg_impact_y_from_center == 0: #180 -x
      return 180
    if avg_impact_x_from_center == 0 and avg_impact_y_from_center < 0: #90 +y
      return 90
  if avg_impact_x_from_center > 0 and avg_impact_y_from_center < 0: #0-90
    return abs(math.degrees(math.atan(avg_impact_y_from_center / avg_impact_x_from_center)))
  if avg_impact_x_from_center < 0 and avg_impact_y_from_center < 0: #90-180
    return math.degrees(math.atan(avg_impact_x_from_center / avg_impact_y_from_center)) + 90
  if avg_impact_x_from_center < 0 and avg_impact_y_from_center > 0: #180-270
    return abs(math.degrees(math.atan(avg_impact_y_from_center / avg_impact_x_from_center))) + 180
  if avg_impact_x_from_center > 0 and avg_impact_y_from_center > 0: #270-360
    return math.degrees(math.atan(avg_impact_x_from_center / avg_impact_y_from_center)) + 270


def find_avg_impact_angle_for_surf_board(avg_impact_x, avg_impact_y):
  center_x, center_y = (141 - 1) / 2, (141 - 1) / 2
  avg_impact_x_from_center, avg_impact_y_from_center = avg_impact_x - center_x, avg_impact_y - center_y
  if avg_impact_x_from_center == 0 or avg_impact_y_from_center == 0:
    if avg_impact_x_from_center == avg_impact_y_from_center == 0:
      return 0
    if avg_impact_x_from_center > 0 and avg_impact_y_from_center == 0: #0 +x
      return 0
    if avg_impact_x_from_center == 0 and avg_impact_y_from_center > 0: #270 -y
      return 270
    if avg_impact_x_from_center < 0 and avg_impact_y_from_center == 0: #180 -x
      return 180
    if avg_impact_x_from_center == 0 and avg_impact_y_from_center < 0: #90 +y
      return 90
  if avg_impact_x_from_center > 0 and avg_impact_y_from_center < 0: #0-90
    return abs(math.degrees(math.atan(avg_impact_y_from_center / avg_impact_x_from_center)))
  if avg_impact_x_from_center < 0 and avg_impact_y_from_center < 0: #90-180
    return math.degrees(math.atan(avg_impact_x_from_center / avg_impact_y_from_center)) + 90
  if avg_impact_x_from_center < 0 and avg_impact_y_from_center > 0: #180-270
    return abs(math.degrees(math.atan(avg_impact_y_from_center / avg_impact_x_from_center))) + 180
  if avg_impact_x_from_center > 0 and avg_impact_y_from_center > 0: #270-360
    return math.degrees(math.atan(avg_impact_x_from_center / avg_impact_y_from_center)) + 270


def find_angle_difference(angle1, angle2):
  difference = angle1 - angle2
  return ((difference + 180) % 360) - 180


def find_reflection_angle(angle_being_reflected, angle_of_reflection):
  difference_between_angles = abs(angle_being_reflected - angle_of_reflection)
  if angle_being_reflected == angle_of_reflection:
    return angle_of_reflection
  if angle_being_reflected > angle_of_reflection:
    return (angle_being_reflected - (2 * difference_between_angles)) % 360
  if angle_of_reflection > angle_being_reflected:
    return (angle_being_reflected + (2 * difference_between_angles)) % 360


def grapple_normal_force(resulting_angle, current_motion):
  PLAYER.Fgx, PLAYER.Fgy = 0, 0
  normal_force_angle = resulting_angle
  opposite_motion_angle = find_normal_force_angle(MAP, PLAYER, current_motion)
  final_velocity_angle = find_reflection_angle(opposite_motion_angle, normal_force_angle) % 360
  VIx, VIy = PLAYER.x_vel, PLAYER.y_vel
  current_total_Fx = PLAYER.Fgx + PLAYER.movement_Fx + PLAYER.piston_Fx
  current_total_Fy = PLAYER.Fgy + PLAYER.movement_Fy + PLAYER.piston_Fy
  initial_velocity = find_hypotnuse(VIx, VIy)
  if Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
    elasticity = elasticity_function(MAP, PLAYER, 0.0, 0.5, abs(find_angle_difference(current_motion, normal_force_angle)))
  if not Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
    elasticity = elasticity_function(MAP, PLAYER, 0.25, 1.0, abs(find_angle_difference(current_motion, normal_force_angle)))
  final_velocity = elasticity * initial_velocity
  if elasticity > 0.75:
    elasticity = 1
  if final_velocity_angle % 90 == 0:
    if final_velocity_angle == 0:
      final_velocity_angle = 359.9999
    if final_velocity_angle == 90:
      final_velocity_angle = 89.9999
    if final_velocity_angle == 180:
      final_velocity_angle = 179.9999
    if final_velocity_angle == 270:
      final_velocity_angle = 269.9999
  if abs(find_angle_difference(my_sheath.rotation, current_motion)) > 90:
    if 0 <= normal_force_angle <= 90:
      #
      if 270 < final_velocity_angle < 360:
        VFx, VFy = abs(final_velocity * math.cos(math.radians(360 - final_velocity_angle))), abs(final_velocity * math.sin(math.radians(360 - final_velocity_angle)))
        PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
        PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
        return VFx, VFy, False
      #
      if final_velocity_angle == 0 or final_velocity_angle == 360:
        VFx, VFy = final_velocity, 0
        PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
        PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
        return VFx, VFy, False
      #
      if 0 < final_velocity_angle < 90:
        VFx, VFy = abs(final_velocity * math.cos(math.radians(final_velocity_angle))), - abs(final_velocity * math.sin(math.radians(final_velocity_angle)))
        PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
        PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
        return VFx, VFy, False
      #
      if final_velocity_angle == 90:
        VFx, VFy = 0, abs(final_velocity)
        PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
        PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
        return VFx, VFy, False
      #
      if 90 < final_velocity_angle < 180:
        VFx, VFy = - abs(final_velocity * math.cos(math.radians(180 - final_velocity_angle))), - abs(final_velocity * math.sin(math.radians(180 - final_velocity_angle)))
        PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
        PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
        return VFx, VFy, False
      if 180 <= final_velocity_angle <= 270:
        return PLAYER.x_vel, PLAYER.y_vel, True
      #
      #
    if 90 < normal_force_angle <= 180:
      if 0 < final_velocity_angle < 90:
        VFx, VFy = abs(final_velocity * math.cos(math.radians(final_velocity_angle))), - abs(final_velocity * math.sin(math.radians(final_velocity_angle)))
        PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
        PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
        return VFx, VFy, False
      #
      if final_velocity_angle == 90:
        VFx, VFy = 0, - abs(final_velocity)
        PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
        PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
        return VFx, VFy, False
      #
      if 90 < final_velocity_angle < 180:
        VFx, VFy = - abs(final_velocity * math.cos(math.radians(180 - final_velocity_angle))), - abs(final_velocity * math.sin(math.radians(180 - final_velocity_angle)))
        PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
        PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
        return VFx, VFy, False
      #
      if final_velocity_angle == 180:
        VFx, VFy = - abs(final_velocity), 0
        PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
        PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
        return VFx, VFy, False
      #
      if 180 < final_velocity_angle < 270:
        VFx, VFy = - abs(final_velocity * math.cos(math.radians(final_velocity_angle - 180))), abs(final_velocity * math.sin(math.radians(final_velocity_angle - 180)))
        PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
        PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
        return VFx, VFy, False
      if 270 <= final_velocity_angle <= 360:
        return PLAYER.x_vel, PLAYER.y_vel, True
      #
      #
    if 180 < normal_force_angle <= 270:
      if 90 < final_velocity_angle < 180:
        VFx, VFy = - abs(final_velocity * math.cos(math.radians(180 - final_velocity_angle))), - abs(final_velocity * math.sin(math.radians(180 - final_velocity_angle)))
        PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs(PLAYER.Fgx) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
        PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
        return VFx, VFy, False
      #
      if final_velocity_angle == 180:
        VFx, VFy = - abs(final_velocity), 0
        PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs(PLAYER.Fgx) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
        PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
        return VFx, VFy, False
      #
      if 180 < final_velocity_angle < 270:
        VFx, VFy = - abs(final_velocity * math.cos(math.radians(final_velocity_angle - 180))), abs(final_velocity * math.sin(math.radians(final_velocity_angle - 180)))
        PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs(PLAYER.Fgx) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
        PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
        return VFx, VFy, False
      #
      if final_velocity_angle == 270:
        VFx, VFy = 0, abs(final_velocity)
        PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs(PLAYER.Fgx) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
        PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
        return VFx, VFy, False
      #
      if 270 < final_velocity_angle < 360:
        VFx, VFy = abs(final_velocity * math.cos(math.radians(360 - final_velocity_angle))), abs(final_velocity * math.sin(math.radians(360 - final_velocity_angle)))
        PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs(PLAYER.Fgx) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
        PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
        return VFx, VFy, False
      if 0 <= final_velocity_angle <= 90:
        return PLAYER.x_vel, PLAYER.y_vel, True
      #
      #
    if 270 < normal_force_angle <= 360:
      if 180 < final_velocity_angle < 270:
        VFx, VFy = - abs(final_velocity * math.cos(math.radians(final_velocity_angle - 180))), abs(final_velocity * math.sin(math.radians(final_velocity_angle - 180)))
        PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs(PLAYER.Fgx) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
        PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
        return VFx, VFy, False
      #
      if final_velocity_angle == 270:
        VFx, VFy = 0, abs(final_velocity)
        PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs(PLAYER.Fgx) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
        PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
        return VFx, VFy, False
      #
      if 270 < final_velocity_angle < 360:
        VFx, VFy = abs(final_velocity * math.cos(math.radians(360 - final_velocity_angle))), abs(final_velocity * math.sin(math.radians(360 - final_velocity_angle)))
        PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs(PLAYER.Fgx) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
        PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
        return VFx, VFy, False
      #
      if final_velocity_angle == 0 or final_velocity_angle == 360:
        VFx, VFy = abs(final_velocity), 0
        PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs(PLAYER.Fgx) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
        PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
        return VFx, VFy, False
      #
      if 0 < final_velocity_angle < 90:
        VFx, VFy = abs(final_velocity * math.cos(math.radians(360 - final_velocity_angle))), - abs(final_velocity * math.sin(math.radians(360 - final_velocity_angle)))
        PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs(PLAYER.Fgx) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
        PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
        return VFx, VFy, False
      if 90 <= final_velocity_angle <= 180:
        return PLAYER.x_vel, PLAYER.y_vel, True
  return PLAYER.x_vel, PLAYER.y_vel, True


def normal_force(resulting_angle, current_motion, elasticity_x, elasticity_y, max_x_vel, max_y_vel):
  normal_force_angle = resulting_angle
  elasticity = elasticity_function(MAP, PLAYER, 0.25, 1.0, abs(find_angle_difference(current_motion, normal_force_angle)))
  if not SUPER_BOUNCY:
    elasticity_x, elasticity_y = elasticity, elasticity
  opposite_motion_angle = find_normal_force_angle(MAP, PLAYER, current_motion)
  final_velocity_angle = find_reflection_angle(opposite_motion_angle, normal_force_angle)
  VIx, VIy = PLAYER.x_vel, PLAYER.y_vel
  current_total_Fx = PLAYER.Fgx + PLAYER.movement_Fx + PLAYER.piston_Fx + PLAYER.water_Fx + PLAYER.forces_for_next_frame_x
  current_total_Fy = PLAYER.Fgy + PLAYER.movement_Fy + PLAYER.piston_Fy + PLAYER.water_Fy + PLAYER.forces_for_next_frame_y
###
###
  if collison_with_bottom_ball_happened and collison_with_left_ball_happened and resulting_angle == 0:
    VFx, VFy = abs(elasticity * VIx), -abs(elasticity * VIy)
    PLAYER.FNx = abs((PLAYER.mass * abs(VIx - VFx)) / (1 / fps)) + abs(current_total_Fx)
    PLAYER.FNy = -abs((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs(current_total_Fy)
    player_collision_sound(VIx, VIy, VFx, VFy)
    return VFx, VFy, False
###
  if collison_with_bottom_ball_happened and collison_with_right_ball_happened and resulting_angle == 180:
    VFx, VFy = -abs(elasticity * VIx), -abs(elasticity * VIy)
    PLAYER.FNx = -abs((PLAYER.mass * abs(VIx - VFx)) / (1 / fps)) - abs(current_total_Fx)
    PLAYER.FNy = -abs((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs(current_total_Fy)
    player_collision_sound(VIx, VIy, VFx, VFy)
    return VFx, VFy, False
###
  if collison_with_left_ball_happened and not collison_with_bottom_ball_happened and resulting_angle == 0:
    VFx, VFy = abs(elasticity * VIx), VIy
    PLAYER.FNx = abs((PLAYER.mass * abs(VIx - VFx)) / (1 / fps)) + abs(current_total_Fx)
    PLAYER.FNy = 0
    player_collision_sound(VIx, VIy, VFx, VFy)
    return VFx, VFy, False
###
  if collison_with_right_ball_happened and not collison_with_bottom_ball_happened and resulting_angle == 180:
    VFx, VFy = -abs(elasticity * VIx), VIy
    PLAYER.FNx = -abs((PLAYER.mass * abs(VIx - VFx)) / (1 / fps)) - abs(current_total_Fx)
    PLAYER.FNy = 0
    player_collision_sound(VIx, VIy, VFx, VFy)
    return VFx, VFy, False
###
  if collison_with_top_ball_happened and not collison_with_left_ball_happened and not collison_with_right_ball_happened and resulting_angle == 270:
    VFx, VFy = VIx, abs(elasticity * VIy)
    PLAYER.FNx = 0
    PLAYER.FNy = abs((PLAYER.mass * abs(VIy - VFy)) / (1 / fps)) + abs(current_total_Fy)
    player_collision_sound(VIx, VIy, VFx, VFy)
    return VFx, VFy, False
###
  if collison_with_top_ball_happened and collison_with_left_ball_happened and resulting_angle == 270:
    VFx, VFy = abs(elasticity * VIx), abs(elasticity * VIy)
    PLAYER.FNx = abs((PLAYER.mass * abs(VIx - VFx)) / (1 / fps)) + abs(current_total_Fx)
    PLAYER.FNy = abs((PLAYER.mass * abs(VIy - VFy)) / (1 / fps)) + abs(current_total_Fy)
    player_collision_sound(VIx, VIy, VFx, VFy)
    return VFx, VFy, False
###
  if collison_with_top_ball_happened and collison_with_right_ball_happened and resulting_angle == 270:
    VFx, VFy = -abs(elasticity * VIx), abs(elasticity * VIy)
    PLAYER.FNx = -abs((PLAYER.mass * abs(VIx - VFx)) / (1 / fps)) - abs(current_total_Fx)
    PLAYER.FNy = abs((PLAYER.mass * abs(VIy - VFy)) / (1 / fps)) + abs(current_total_Fy)
    player_collision_sound(VIx, VIy, VFx, VFy)
    return VFx, VFy, False
###
  if collison_with_bottom_ball_happened and not collison_with_left_ball_happened and not collison_with_right_ball_happened and resulting_angle == 90: # ball hits flat floor
    if PLAYER.x_vel > 0:
      PLAYER.movement_Fx -= 50
    if PLAYER.x_vel < 0:
      PLAYER.movement_Fx += 50
    if abs(KEy) < 3:
      PLAYER.FNy = - my_gravity
      PLAYER.y_vel = 0
      VIx, VIy, VFx, VFy = 0, 0, 0, 0
      player_collision_sound(VIx, VIy, VFx, VFy)
      return PLAYER.x_vel, PLAYER.y_vel, False
    VFx, VFy = PLAYER.x_vel, -abs(0.25 * VIy)
    PLAYER.FNx = 0
    PLAYER.FNy = -abs((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - current_total_Fy
    player_collision_sound(VIx, VIy, VFx, VFy)
    return VFx, VFy, False
###
### next, not right angles
###
  initial_velocity = find_hypotnuse(VIx, VIy)
  final_velocity = elasticity * initial_velocity
  final_velocity_x, final_velocity_y = final_velocity, final_velocity
  if SUPER_BOUNCY:
    final_velocity_x, final_velocity_y = elasticity_x * initial_velocity, elasticity_y * initial_velocity
###
  if normal_force_angle == 0:
    normal_force_angle = 359.999
  if normal_force_angle == 90:
    normal_force_angle = 89.999
  if normal_force_angle == 180:
    normal_force_angle = 179.999
  if normal_force_angle == 270:
    normal_force_angle = 269.999
  if 0 < normal_force_angle < 90:
    if 180 <= final_velocity_angle < 225:
      final_velocity_angle = 179.999
    if 270 < final_velocity_angle < 360:
      VFx, VFy = abs(final_velocity_x * math.cos(math.radians(360 - final_velocity_angle))), abs(final_velocity_y * math.sin(math.radians(360 - final_velocity_angle)))
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
      PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    #
    if final_velocity_angle == 0 or final_velocity_angle == 360:
      VFx, VFy = final_velocity_x, 0
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
      PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    #
    if 0 < final_velocity_angle < 90:
      VFx, VFy = abs(final_velocity_x * math.cos(math.radians(final_velocity_angle))), - abs(final_velocity_y * math.sin(math.radians(final_velocity_angle)))
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
      PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    #
    if final_velocity_angle == 90:
      VFx, VFy = 0, abs(final_velocity_y)
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
      PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    #
    if 90 < final_velocity_angle < 180:
      VFx, VFy = - abs(final_velocity_x * math.cos(math.radians(180 - final_velocity_angle))), - abs(final_velocity_y * math.sin(math.radians(180 - final_velocity_angle)))
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
      PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    if 180 < final_velocity_angle < 270:
      PLAYER.erroring = 1
      return PLAYER.x_vel, PLAYER.y_vel, True
    #
    #
  if 90 < normal_force_angle < 180:
    if 315 <= final_velocity_angle < 360:
      final_velocity_angle = 0.001
    if 0 < final_velocity_angle < 90:
      VFx, VFy = abs(final_velocity_x * math.cos(math.radians(final_velocity_angle))), - abs(final_velocity_y * math.sin(math.radians(final_velocity_angle)))
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
      PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    #
    if final_velocity_angle == 90:
      VFx, VFy = 0, - abs(final_velocity_y)
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
      PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    #
    if 90 < final_velocity_angle < 180:
      VFx, VFy = - abs(final_velocity_x * math.cos(math.radians(180 - final_velocity_angle))), - abs(final_velocity_y * math.sin(math.radians(180 - final_velocity_angle)))
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
      PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    #
    if final_velocity_angle == 180:
      VFx, VFy = - abs(final_velocity_x), 0
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
      PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    #
    if 180 < final_velocity_angle < 270:
      VFx, VFy = - abs(final_velocity_x * math.cos(math.radians(final_velocity_angle - 180))), abs(final_velocity_y * math.sin(math.radians(final_velocity_angle - 180)))
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.cos(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
      PLAYER.FNy = -((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) - abs((PLAYER.mass * my_gravity) * math.sin(math.radians(normal_force_angle))) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) - abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    if 270 < final_velocity_angle < 360:
      PLAYER.erroring = 2
      return PLAYER.x_vel, PLAYER.y_vel, True
    #
    #
  if 180 < normal_force_angle < 270:
    if 90 < final_velocity_angle < 180:
      VFx, VFy = - abs(final_velocity_x * math.cos(math.radians(180 - final_velocity_angle))), - abs(final_velocity_y * math.sin(math.radians(180 - final_velocity_angle)))
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs(PLAYER.Fgx) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
      PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    #
    if final_velocity_angle == 180:
      VFx, VFy = - abs(final_velocity_x), 0
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs(PLAYER.Fgx) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
      PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    #
    if 180 < final_velocity_angle < 270:
      VFx, VFy = - abs(final_velocity_x * math.cos(math.radians(final_velocity_angle - 180))), abs(final_velocity_y * math.sin(math.radians(final_velocity_angle - 180)))
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs(PLAYER.Fgx) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
      PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    #
    if final_velocity_angle == 270:
      VFx, VFy = 0, abs(final_velocity_y)
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs(PLAYER.Fgx) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
      PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    #
    if 270 < final_velocity_angle < 360:
      VFx, VFy = abs(final_velocity_x * math.cos(math.radians(360 - final_velocity_angle))), abs(final_velocity_y * math.sin(math.radians(360 - final_velocity_angle)))
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = -((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) - abs(PLAYER.Fgx) - abs(PLAYER.movement_Fx) - abs(PLAYER.piston_Fx) - abs(PLAYER.Fx)
      PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    if 0 < final_velocity_angle < 90:
      PLAYER.erroring = 3
      return PLAYER.x_vel, PLAYER.y_vel, True
    #
    #
  if 270 < normal_force_angle < 360:
    if 180 < final_velocity_angle < 270:
      VFx, VFy = - abs(final_velocity_x * math.cos(math.radians(final_velocity_angle - 180))), abs(final_velocity_y * math.sin(math.radians(final_velocity_angle - 180)))
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs(PLAYER.Fgx) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
      PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    #
    if final_velocity_angle == 270:
      VFx, VFy = 0, abs(final_velocity_y)
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs(PLAYER.Fgx) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
      PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    #
    if 270 < final_velocity_angle < 360:
      VFx, VFy = abs(final_velocity_x * math.cos(math.radians(360 - final_velocity_angle))), abs(final_velocity_y * math.sin(math.radians(360 - final_velocity_angle)))
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs(PLAYER.Fgx) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
      PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    #
    if final_velocity_angle == 0 or final_velocity_angle == 360:
      VFx, VFy = abs(final_velocity_x), 0
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs(PLAYER.Fgx) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
      PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) + abs(PLAYER.movement_Fy) + abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    #
    if 0 < final_velocity_angle < 90:
      VFx, VFy = abs(final_velocity_x * math.cos(math.radians(360 - final_velocity_angle))), - abs(final_velocity_y * math.sin(math.radians(360 - final_velocity_angle)))
      if SUPER_BOUNCY:
        if abs(VFx) > max_x_vel:
          if VFx > 0:
            VFx = max_x_vel
          if VFx < 0:
            VFx = -max_x_vel
        if abs(VFy) > max_y_vel:
          if VFy > 0:
            VFy = max_y_vel
          if VFy < 0:
            VFy = -max_y_vel
      PLAYER.FNx = ((PLAYER.mass * abs(VFx - VIx)) / (1 / fps)) + abs(PLAYER.Fgx) + abs(PLAYER.movement_Fx) + abs(PLAYER.piston_Fx) + abs(PLAYER.Fx)
      PLAYER.FNy = ((PLAYER.mass * abs(VFy - VIy)) / (1 / fps)) + abs(PLAYER.Fgy) - abs(PLAYER.movement_Fy) - abs(PLAYER.piston_Fy) + abs(PLAYER.Fy)
      player_collision_sound(VIx, VIy, VFx, VFy)
      return VFx, VFy, False
    if 90 < final_velocity_angle < 180:
      PLAYER.erroring = 4
      return PLAYER.x_vel, PLAYER.y_vel, True
  return PLAYER.x_vel, PLAYER.y_vel, True


def Kinetic_energy():
  return (1 / 2)*(PLAYER.mass)*(PLAYER.y_vel)**2


def find_motion_angle(map, object):
  unreverse_y = - object.y_vel
  if object.x_vel == 0 or unreverse_y == 0:
    if object.x_vel == unreverse_y == 0:
      return 0
    if object.x_vel > 0 and unreverse_y == 0: #0 +x
      return 0
    if object.x_vel == 0 and unreverse_y < 0: #90 -y
      return 270
    if object.x_vel < 0 and unreverse_y == 0: #180 -x
      return 180
    if object.x_vel == 0 and unreverse_y > 0: #270 +y
      return 90
  if object.x_vel > 0 and object.y_vel > 0: #
    return 360 - ((abs(math.degrees(math.atan(abs(object.y_vel) / abs(object.x_vel))) % 90)) + 270) + 270
  if object.x_vel < 0 and object.y_vel > 0: #
    return abs(math.degrees(math.atan(abs(object.y_vel) / abs(object.x_vel))) % 90) + 180
  if object.x_vel < 0 and object.y_vel < 0: #
    return (180 - (abs(math.degrees(math.atan(abs(object.y_vel) / abs(object.x_vel))) % 90) + 90)) + 90
  if object.x_vel > 0 and object.y_vel < 0: #
    return abs(math.degrees(math.atan(abs(object.y_vel) / abs(object.x_vel))) % 90) + 0


def Next_piston_rotation_angle(map, player, my_piston_sheath, Current_mouse_angle):
  Current_angle_difference = find_angle_difference(Current_mouse_angle, my_piston_sheath.rotation)
  return my_piston_sheath.rotation + ((0.1 * Current_angle_difference) * My_cached_info.target_fps_over_fps)


def adjust_PushPistonCoverImage(my_piston):
  my_current_rotation = my_sheath.rotation%360
  cur_cos = math.cos(math.radians(my_current_rotation))
  cur_sin = math.sin(math.radians(my_current_rotation))
  showing_segment = my_piston.segment_of_piston_showing[0] 
  if 0 <= my_current_rotation < 90:
    my_piston.Cover_x_pos += abs(34*cur_cos) - abs(4.5*cur_sin)
    my_piston.Cover_y_pos -= abs(34*cur_sin) + abs(4.5*cur_cos) + (my_piston.extension*cur_sin)
    return
  if 90 <= my_current_rotation < 180:
    my_piston.Cover_x_pos -= abs(34*cur_cos) + abs(4.5*cur_sin) - (my_piston.extension*cur_cos)
    my_piston.Cover_y_pos -= abs(34*cur_sin) + abs(4.5*cur_cos) + (my_piston.extension*cur_sin)
    return
  if 180 <= my_current_rotation < 270:
    my_piston.Cover_x_pos -= abs(34*cur_cos) + abs(4.5*cur_sin) - (my_piston.extension*cur_cos)
    my_piston.Cover_y_pos += abs(34*cur_sin) - abs(4.5*cur_cos)
    return
  if 270 <= my_current_rotation < 360:
    my_piston.Cover_x_pos += abs(34*cur_cos) - abs(4.5*cur_sin)
    my_piston.Cover_y_pos += abs(34*cur_sin) - abs(4.5*cur_cos)
    return


def adjust_GrapplePistonCoverImage(my_piston):
  my_current_rotation = my_sheath.rotation%360
  cur_cos = math.cos(math.radians(my_current_rotation))
  cur_sin = math.sin(math.radians(my_current_rotation))
  showing_segment = my_piston.segment_of_piston_showing[0] 
  if 0 <= my_current_rotation < 90:
    my_piston.Cover_x_pos += abs(32*cur_cos) - abs(13*cur_sin)
    my_piston.Cover_y_pos -= abs(32*cur_sin) + abs(13*cur_cos) + (my_piston.extension*cur_sin)
    return
  if 90 <= my_current_rotation < 180:
    my_piston.Cover_x_pos -= abs(32*cur_cos) + abs(13*cur_sin) - (my_piston.extension*cur_cos)
    my_piston.Cover_y_pos -= abs(32*cur_sin) + abs(13*cur_cos) + (my_piston.extension*cur_sin)
    return
  if 180 <= my_current_rotation < 270:
    my_piston.Cover_x_pos -= abs(32*cur_cos) + abs(13*cur_sin) - (my_piston.extension*cur_cos)
    my_piston.Cover_y_pos += abs(32*cur_sin) - abs(13*cur_cos)
    return
  if 270 <= my_current_rotation < 360:
    my_piston.Cover_x_pos += abs(32*cur_cos) - abs(13*cur_sin)
    my_piston.Cover_y_pos += abs(32*cur_sin) - abs(13*cur_cos)
    return


def regular_update_PushPiston(my_piston):
  #my_piston.image = my_piston.all_images[my_piston.extension]
  #my_piston.current_image = rotate_square_image(my_piston.image, my_sheath.rotation)
  #
  if my_piston.extension < 0 or my_piston.extension_float < 0:
    my_piston.extension, my_piston.extension_float = 0, 0
  if my_piston.extension > 240 or my_piston.extension_float > 240:
    my_piston.extension, my_piston.extension_float = 240, 240
  my_piston.Cover_x_pos = 0
  my_piston.Cover_y_pos = 0
  my_piston.extension = round(my_piston.extension_float)
  my_piston.number_of_pixels_to_move += delta_milliseconds / 4
  my_piston.cropped_region[0] = (486 - ((round(my_piston.number_of_pixels_to_move))%243))%243
  my_piston.cropped_region[2] = my_piston.extension
  my_piston.cropped_current_CoverImage = my_piston.CoverImage.subsurface((my_piston.cropped_region[0], my_piston.cropped_region[1], my_piston.cropped_region[2], my_piston.cropped_region[3]))
  adjust_PushPistonCoverImage(my_piston)
  my_piston.current_image, my_piston.CoverRect = rotate_rectangular_image(my_piston.cropped_current_CoverImage, my_piston.CoverRect, my_sheath.rotation)
  #
  if True in my_piston.is_touching_wall:
    my_piston.Splash_x_pos, my_piston.Splash_y_pos = 0, 0
    find_splash_pos()
    my_piston.current_number_of_splash_milliseconds += delta_milliseconds
    if my_piston.current_number_of_splash_milliseconds >= my_piston.number_of_milliseconds_before_new_splash:
      my_piston.current_number_of_splash_milliseconds = 0
      my_piston.current_splash_image_index += 1
      if my_piston.current_splash_image_index == 4:
        my_piston.current_splash_image_index = 0
      my_piston.current_Splash = my_piston.SplashImages[my_piston.current_splash_image_index]
      my_piston.GPU_current_Splash = my_piston.GPU_SplashImages[my_piston.current_splash_image_index]
      my_piston.current_Splash = rotate_square_image(my_piston.current_Splash, (my_sheath.rotation+90))
  #
  return


def find_splash_pos():
  cur_rot = my_sheath.rotation%360
  cur_cos = math.cos(math.radians(cur_rot))
  cur_sin = math.sin(math.radians(cur_rot))
  if cur_rot == 0:
    my_piston1.Splash_x_pos += 24 + my_piston1.extension
    my_piston1.Splash_y_pos += 0
    return
  if 0 < cur_rot < 90:
    my_piston1.Splash_x_pos += abs((24 + my_piston1.extension)*cur_cos)
    my_piston1.Splash_y_pos -= abs((24 + my_piston1.extension)*cur_sin)
    return
  if cur_rot == 90:
    my_piston1.Splash_x_pos += 0
    my_piston1.Splash_y_pos -= 24 + my_piston1.extension
    return
  if 90 < cur_rot < 180:
    my_piston1.Splash_x_pos -= abs((24 + my_piston1.extension)*cur_cos)
    my_piston1.Splash_y_pos -= abs((24 + my_piston1.extension)*cur_sin)
    return
  if cur_rot == 180:
    my_piston1.Splash_x_pos -= 24 + my_piston1.extension
    my_piston1.Splash_y_pos += 0
    return
  if 180 < cur_rot < 270:
    my_piston1.Splash_x_pos -= abs((24 + my_piston1.extension)*cur_cos)
    my_piston1.Splash_y_pos += abs((24 + my_piston1.extension)*cur_sin)
    return
  if cur_rot == 270:
    my_piston1.Splash_x_pos += 0
    my_piston1.Splash_y_pos += 24 + my_piston1.extension
    return
  if 270 < cur_rot < 360:
    my_piston1.Splash_x_pos += abs((24 + my_piston1.extension)*cur_cos)
    my_piston1.Splash_y_pos += abs((24 + my_piston1.extension)*cur_sin)
    return


def regular_update_GrapplePiston(my_piston):
  my_piston.extension = round(my_piston.extension_float)
  if (my_piston.extension > my_piston.maximum_extension):
    my_piston.extension = my_piston.maximum_extension
    my_piston.extension_float = my_piston.maximum_extension
  if my_piston.extension < 0:
    my_piston.extension = 0
    my_piston.extension_float = 0
  #
  my_piston.Cover_x_pos = 0
  my_piston.Cover_y_pos = 0
  my_piston.cropped_region[0] = 242 - my_piston.extension
  my_piston.cropped_region[2] = my_piston.extension
  if my_piston.grapple_claw_x_pos == 0:
    my_piston.cropped_current_CoverImage = my_piston.CoverImage.subsurface((my_piston.cropped_region[0], my_piston.cropped_region[1], my_piston.cropped_region[2], my_piston.cropped_region[3]))
    adjust_GrapplePistonCoverImage(my_piston)
    my_piston.current_image, my_piston.CoverRect = rotate_rectangular_image(my_piston.cropped_current_CoverImage, my_piston.CoverRect, my_sheath.rotation)
    my_piston.GPU_current_image = my_piston.GPU_CoverImage
  if my_piston.grapple_claw_x_pos != 0:
    my_piston.cropped_current_CoverImage = my_piston.ClosedCoverImage.subsurface((my_piston.cropped_region[0], my_piston.cropped_region[1], my_piston.cropped_region[2], my_piston.cropped_region[3]))
    adjust_GrapplePistonCoverImage(my_piston)
    my_piston.current_image, my_piston.CoverRect = rotate_rectangular_image(my_piston.cropped_current_CoverImage, my_piston.CoverRect, my_sheath.rotation)
    my_piston.GPU_current_image = my_piston.GPU_ClosedCoverImage
  #
  #my_piston.image = my_piston.all_images[my_piston.extension]
  #my_piston.current_image = rotate_square_image(my_piston.image, my_sheath.rotation)
  return


def find_mouse_angle(map, player, Mouse_x, Mouse_y):
  center_x, center_y = player.x_pos + 34 + PLAYER.blit_change_x - PLAYER.x_dif, player.y_pos + 34 + PLAYER.blit_change_y - PLAYER.y_dif
  Mouse_x, Mouse_y = Mouse_x + PLAYER.x_pos - stop_scrolling_left, Mouse_y + PLAYER.y_pos - stop_scrolling_top
  if center_x == Mouse_x and center_y == Mouse_y: #mouse on circle
    return 0
  #
  if Mouse_x > center_x and Mouse_y == center_y: #0
    return 0
  #
  if Mouse_x > center_x and Mouse_y < center_y: #0-90
    dif_x, dif_y = abs(Mouse_x - center_x), abs(Mouse_y - center_y)
    mouse_angle = abs(math.degrees(math.atan(dif_y / dif_x)))
    return mouse_angle
  #
  if Mouse_x == center_x and Mouse_y < center_y: #90
    return 90
  #
  if Mouse_x < center_x and Mouse_y < center_y: #90-180
    dif_x, dif_y = abs(Mouse_x - center_x), abs(Mouse_y - center_y)
    mouse_angle = 180 - abs(math.degrees(math.atan(dif_y / dif_x)))
    return mouse_angle
  #
  if Mouse_x < center_x and Mouse_y == center_y: #180
    return 180
  #
  if Mouse_x < center_x and Mouse_y > center_y: #180-270
    dif_x, dif_y = abs(Mouse_x - center_x), abs(Mouse_y - center_y)
    mouse_angle = 180 + abs(math.degrees(math.atan(dif_y / dif_x)))
    return mouse_angle
  #
  if Mouse_x == center_x and Mouse_y > center_y: #270
    return 270
  #
  if Mouse_x > center_x and Mouse_y > center_y: #270-360
    dif_x, dif_y = abs(Mouse_x - center_x), abs(Mouse_y - center_y)
    mouse_angle = 360 - abs(math.degrees(math.atan(dif_y / dif_x)))
    return mouse_angle


def find_mouse_angle2(map, player, Mouse_x, Mouse_y):
  center_x, center_y = player.x_pos + 34, player.y_pos + 34
  Mouse_x, Mouse_y = Mouse_x + PLAYER.x_pos - stop_scrolling_left, Mouse_y + PLAYER.y_pos - stop_scrolling_top
  if center_x == Mouse_x and center_y == Mouse_y: #mouse on circle
    return 0
  #
  if Mouse_x > center_x and Mouse_y == center_y: #0
    return 0
  #
  if Mouse_x > center_x and Mouse_y < center_y: #0-90
    dif_x, dif_y = abs(Mouse_x - center_x), abs(Mouse_y - center_y)
    mouse_angle = abs(math.degrees(math.atan(dif_y / dif_x)))
    return mouse_angle
  #
  if Mouse_x == center_x and Mouse_y < center_y: #90
    return 90
  #
  if Mouse_x < center_x and Mouse_y < center_y: #90-180
    dif_x, dif_y = abs(Mouse_x - center_x), abs(Mouse_y - center_y)
    mouse_angle = 180 - abs(math.degrees(math.atan(dif_y / dif_x)))
    return mouse_angle
  #
  if Mouse_x < center_x and Mouse_y == center_y: #180
    return 180
  #
  if Mouse_x < center_x and Mouse_y > center_y: #180-270
    dif_x, dif_y = abs(Mouse_x - center_x), abs(Mouse_y - center_y)
    mouse_angle = 180 + abs(math.degrees(math.atan(dif_y / dif_x)))
    return mouse_angle
  #
  if Mouse_x == center_x and Mouse_y > center_y: #270
    return 270
  #
  if Mouse_x > center_x and Mouse_y > center_y: #270-360
    dif_x, dif_y = abs(Mouse_x - center_x), abs(Mouse_y - center_y)
    mouse_angle = 360 - abs(math.degrees(math.atan(dif_y / dif_x)))
    return mouse_angle


def regular_piston_sheath_update():
  Current_mouse_angle = find_mouse_angle(MAP, PLAYER, Mouse_x, Mouse_y)
  my_sheath.rotation = Next_piston_rotation_angle(MAP, PLAYER, my_sheath, Current_mouse_angle)
  my_sheath.current_image = rotate_square_image(my_sheath.image, my_sheath.rotation)
  if PLAYER.surfing_check_points:
    cur_rot = my_sheath.rotation % 360
    if 0 <= cur_rot < 90:
      PLAYER.surfing_spin_checkpoints[0] = True
    if 90 <= cur_rot < 180:
      PLAYER.surfing_spin_checkpoints[1] = True
    if 180 <= cur_rot < 270:
      PLAYER.surfing_spin_checkpoints[2] = True
    if 270 <= cur_rot <= 360:
      PLAYER.surfing_spin_checkpoints[3] = True
  return


def lever_piston_sheath_update():
  Current_mouse_angle = find_mouse_angle(MAP, PLAYER, Mouse_x, Mouse_y)
  new_rotation = Next_piston_rotation_angle(MAP, PLAYER, my_sheath, Current_mouse_angle)
  return new_rotation


def abbreviated_piston_sheath_update():
  my_sheath.current_image = rotate_square_image(my_sheath.image, my_sheath.rotation)
  return


def find_min_max_impact_point(map, player, list_of_collisions):
  minx, maxx, miny, maxy = list_of_collisions[0][0][0], 0, list_of_collisions[0][0][1], 0
  for i in range(len(list_of_collisions)):
    if list_of_collisions[i] != False:
      for j in range(len(list_of_collisions[i])):
        if list_of_collisions[i][j][0] < minx:
          minx = list_of_collisions[i][j][0]
        if list_of_collisions[i][j][0] > maxx:
          maxx = list_of_collisions[i][j][0]
          maxx_y = list_of_collisions[i][j][1]
        if list_of_collisions[i][j][1] < miny:
          miny = list_of_collisions[i][j][1]
        if list_of_collisions[i][j][1] > maxy:
          maxy = list_of_collisions[i][j][1]
          maxy_x = list_of_collisions[i][j][0]
  return minx, maxx, miny, maxy, maxx_y, maxy_x


def find_midpoint(x1, x2, y1, y2):
  return int((x1 + x2) / 2), int((y1 + y2) / 2)


def find_tip_push_piston_impact_angle(map, player, my_current_piston, tip_x, tip_y):
  if tip_x == 275 and tip_y == 275: #null
    return 0
  if tip_x > 275 and tip_y == 275: #0
    return 0
  if tip_x > 275 and tip_y < 275: #0-90
    return abs(math.degrees(math.atan((tip_y-275) / (tip_x-275))))
  if tip_x == 275 and tip_y < 275: #90
    return 90
  if tip_x < 275 and tip_y < 275: #90-180
    return 180 - abs(math.degrees(math.atan((tip_y-275) / (tip_x-275))))
  if tip_x < 275 and tip_y == 275: #180
    return 180
  if tip_x < 275 and tip_y > 275: #180-270
    return 180 + abs(math.degrees(math.atan((tip_y-275) / (tip_x-275))))
  if tip_x == 275 and tip_y > 275: #270
    return 270
  if tip_x > 275 and tip_y > 275: #270-360
    return 360 - abs(math.degrees(math.atan((tip_y-275) / (tip_x-275))))


def pushing_with_head_of_push_piston(map, player, my_current_piston, tip_impact_x, tip_impact_y):
  avg_tip_impact_hypotnuse = math.sqrt((tip_impact_x - 275)**2 + (tip_impact_y - 275)**2) - 33
  current_piston_extension = my_current_piston.extension
  if current_piston_extension - 30 <= avg_tip_impact_hypotnuse <= current_piston_extension + 30:
    return True
  return False


def find_center_of_ball(map, player):
  return player.x_pos + 34, player.y_pos + 34


def change_direction_from_push_piston(map, player, my_piston1_normal_force_angle, given_extension_speed):
  my_extension_speed = given_extension_speed
  if my_piston1_normal_force_angle == 0:
    PLAYER.piston_Fx = my_extension_speed
    PLAYER.piston_Fy = 0
    return
  #
  if 0 < my_piston1_normal_force_angle < 90:
    PLAYER.piston_Fx = abs(my_extension_speed * math.cos(math.radians(my_piston1_normal_force_angle)))
    PLAYER.piston_Fy = -(my_extension_speed * math.sin(math.radians(my_piston1_normal_force_angle)))
    return
  #
  if my_piston1_normal_force_angle == 90:
    PLAYER.piston_Fx = 0
    PLAYER.piston_Fy = -my_extension_speed
    return
  #
  if 90 < my_piston1_normal_force_angle < 180:
    PLAYER.piston_Fx = -abs(my_extension_speed * math.cos(math.radians(180 - my_piston1_normal_force_angle)))
    PLAYER.piston_Fy = -abs(my_extension_speed * math.sin(math.radians(180 - my_piston1_normal_force_angle)))
    return
  #
  if my_piston1_normal_force_angle == 180:
    PLAYER.piston_Fx = -my_extension_speed
    PLAYER.piston_Fy = 0
    return
  #
  if 180 < my_piston1_normal_force_angle < 270:
    PLAYER.piston_Fx = -abs(my_extension_speed * math.cos(math.radians(my_piston1_normal_force_angle - 180)))
    PLAYER.piston_Fy = abs(my_extension_speed * math.sin(math.radians(my_piston1_normal_force_angle - 180)))
    return
  #
  if my_piston1_normal_force_angle == 270:
    PLAYER.piston_Fx = 0
    PLAYER.piston_Fy = -my_extension_speed
    return
  #
  if 270 < my_piston1_normal_force_angle < 360:
    PLAYER.piston_Fx = abs(my_extension_speed * math.cos(math.radians(360 - my_piston1_normal_force_angle)))
    PLAYER.piston_Fy = abs(my_extension_speed * math.sin(math.radians(360 - my_piston1_normal_force_angle)))
    return
  return


def is_push_piston_underwater():
  piston_submersion = 34*math.sin(math.radians(my_sheath.rotation%360)) + 34
  if piston_submersion >= PLAYER.how_submerged:
    return False
  else:
    return True


def do_everything_push_piston(my_push_piston, PREVIOUS_PUSH_PISTON):
  if not My_cached_info.playing_quiet_water_jet:
    My_cached_info.playing_quiet_water_jet = True
    MixerSounds['QUIET_WATER_JET'].play(loops = -1, fade_ms = 500)
  get_extra_push = False
  #if my_push_piston.extension <= 0:
  #  my_push_piston.extension = 1
  #  regular_update_PushPiston(my_push_piston)
  my_push_piston.mask = pygame.mask.from_surface(my_push_piston.current_image)
  my_push_piston.cur_offset_x = my_push_piston.Cover_x_pos + 275
  my_push_piston.cur_offset_y = my_push_piston.Cover_y_pos + 275
  retract_after = 30 // my_push_piston.outline_every
  object_extension_speed = 2900
  if PLAYER.how_submerged != 0:
    push_piston_is_underwater = is_push_piston_underwater()
    if push_piston_is_underwater:
      if my_push_piston.extension_float > my_push_piston.extension_float_added:
        my_push_piston.extension_float -= my_push_piston.extension_float_added
      for _ in range(My_cached_info.whole_number_of_frames_this_frame):
        my_push_piston.is_touching_wall.append(True)
        my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
      my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
      change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, 1350)
      regular_piston_sheath_update()
      regular_update_PushPiston(my_push_piston)
      if not My_cached_info.playing_loud_water_jet:
        My_cached_info.playing_loud_water_jet = True
        MixerSounds['LOUD_WATER_JET'].play(-1)
      return PREVIOUS_PUSH_PISTON
  if ELEVATORS != []:
    if MAP.region == 'TheDoor7':
      elevator_extension_speed = 1800
      for SingleElevator in ELEVATORS:
        absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
        distance_between_player_and_PlatformLeftTop = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformLeftTop_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformLeftTop_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformLeftTop_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformLeftTop_rect[3]/2)))
        distance_between_player_and_PlatformMiddleTop = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformMiddleTop_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformMiddleTop_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformMiddleTop_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformMiddleTop_rect[3]/2)))
        distance_between_player_and_PlatformRightTop = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformRightTop_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformRightTop_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformRightTop_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformRightTop_rect[3]/2)))
        distance_between_player_and_PlatformLeftBottom = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformLeftBottom_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformLeftBottom_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformLeftBottom_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformLeftBottom_rect[3]/2)))
        distance_between_player_and_PlatformMiddleBottom = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformMiddleBottom_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformMiddleBottom_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformMiddleBottom_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformMiddleBottom_rect[3]/2)))
        distance_between_player_and_PlatformRightBottom = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformRightBottom_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformRightBottom_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformRightBottom_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformRightBottom_rect[3]/2)))
        distance_between_player_and_LeftMiddlePlatform = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.LeftMiddlePlatform_x_pos + ((1/2)*screen_width) - (SingleElevator.LeftMiddlePlatform_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.LeftMiddlePlatform_y_pos + ((1/2)*screen_height) - (SingleElevator.LeftMiddlePlatform_rect[3]/2)))
        distance_between_player_and_RightMiddlePlatform = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.RightMiddlePlatform_x_pos + ((1/2)*screen_width) - (SingleElevator.RightMiddlePlatform_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.RightMiddlePlatform_y_pos + ((1/2)*screen_height) - (SingleElevator.RightMiddlePlatform_rect[3]/2)))
        distance_between_player_and_DownPeg1 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.DownPeg1_x_pos + ((1/2)*screen_width) - (SingleElevator.DownPeg1_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.DownPeg1_y_pos + ((1/2)*screen_height) - (SingleElevator.DownPeg1_rect[3]/2)))
        distance_between_player_and_DownPeg2 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.DownPeg2_x_pos + ((1/2)*screen_width) - (SingleElevator.DownPeg2_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.DownPeg2_y_pos + ((1/2)*screen_height) - (SingleElevator.DownPeg2_rect[3]/2)))
        distance_between_player_and_DownPeg3 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.DownPeg3_x_pos + ((1/2)*screen_width) - (SingleElevator.DownPeg3_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.DownPeg3_y_pos + ((1/2)*screen_height) - (SingleElevator.DownPeg3_rect[3]/2)))
        distance_between_player_and_UpPeg1 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.UpPeg1_x_pos + ((1/2)*screen_width) - (SingleElevator.UpPeg1_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.UpPeg1_y_pos + ((1/2)*screen_height) - (SingleElevator.UpPeg1_rect[3]/2)))
        distance_between_player_and_UpPeg2 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.UpPeg2_x_pos + ((1/2)*screen_width) - (SingleElevator.UpPeg2_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.UpPeg2_y_pos + ((1/2)*screen_height) - (SingleElevator.UpPeg2_rect[3]/2)))
        distance_between_player_and_UpPeg3 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.UpPeg3_x_pos + ((1/2)*screen_width) - (SingleElevator.UpPeg3_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.UpPeg3_y_pos + ((1/2)*screen_height) - (SingleElevator.UpPeg3_rect[3]/2)))
        distance_between_player_and_UpPeg4 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.UpPeg4_x_pos + ((1/2)*screen_width) - (SingleElevator.UpPeg4_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.UpPeg4_y_pos + ((1/2)*screen_height) - (SingleElevator.UpPeg4_rect[3]/2)))
        distance_between_player_and_UpPeg5 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.UpPeg5_x_pos + ((1/2)*screen_width) - (SingleElevator.UpPeg5_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.UpPeg5_y_pos + ((1/2)*screen_height) - (SingleElevator.UpPeg5_rect[3]/2)))
        distance_between_player_and_LeftDoor = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.LeftDoor_x_pos + ((1/2)*screen_width) - (SingleElevator.LeftDoor_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.LeftDoor_y_pos + ((1/2)*screen_height) - (SingleElevator.LeftDoor_rect[3]/2)))
        distance_between_player_and_RightDoor = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.RightDoor_x_pos + ((1/2)*screen_width) - (SingleElevator.RightDoor_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.RightDoor_y_pos + ((1/2)*screen_height) - (SingleElevator.RightDoor_rect[3]/2)))
        if distance_between_player_and_PlatformLeftTop < (275 + 302):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.PlatformLeftTop_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 1, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
        if distance_between_player_and_PlatformMiddleTop < (275 + 302):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.PlatformMiddleTop_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 601, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
        if distance_between_player_and_PlatformRightTop < (275 + 302):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.PlatformRightTop_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 1201, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
        if distance_between_player_and_PlatformLeftBottom < (275 + 302):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.PlatformLeftBottom_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 1, ((1/2) * screen_height) + my_push_piston.cur_offset_y - 495)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
        if distance_between_player_and_PlatformMiddleBottom < (275 + 302):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.PlatformMiddleBottom_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 601, ((1/2) * screen_height) + my_push_piston.cur_offset_y - 495)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
        if distance_between_player_and_PlatformRightBottom < (275 + 302):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.PlatformRightBottom_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 1201, ((1/2) * screen_height) + my_push_piston.cur_offset_y - 495)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
        if distance_between_player_and_LeftMiddlePlatform < (275 + 245):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.LeftMiddlePlatform_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 357, ((1/2) * screen_height) + my_push_piston.cur_offset_y - 248)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
        if distance_between_player_and_RightMiddlePlatform < (275 + 245):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.RightMiddlePlatform_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 967, ((1/2) * screen_height) + my_push_piston.cur_offset_y - 248)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
        if distance_between_player_and_DownPeg1 < (275 + 28):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.DownPeg1_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 894, ((1/2) * screen_height) + my_push_piston.cur_offset_y - 48)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
        if distance_between_player_and_DownPeg2 < (275 + 28):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.DownPeg2_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 680, ((1/2) * screen_height) + my_push_piston.cur_offset_y - 295)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
        if distance_between_player_and_DownPeg3 < (275 + 28):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.DownPeg3_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 1108, ((1/2) * screen_height) + my_push_piston.cur_offset_y - 295)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
        if distance_between_player_and_UpPeg1 < (275 + 28):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg1_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 497, ((1/2) * screen_height) + my_push_piston.cur_offset_y - 220 + 20)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
        if distance_between_player_and_UpPeg2 < (275 + 28):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg2_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 1291, ((1/2) * screen_height) + my_push_piston.cur_offset_y - 220 + 20)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
        if distance_between_player_and_UpPeg3 < (275 + 28):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg3_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 466, ((1/2) * screen_height) + my_push_piston.cur_offset_y - 467 + 20)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
        if distance_between_player_and_UpPeg4 < (275 + 28):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg4_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 894, ((1/2) * screen_height) + my_push_piston.cur_offset_y - 467 + 20)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
        if distance_between_player_and_UpPeg5 < (275 + 28):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg5_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 1322, ((1/2) * screen_height) + my_push_piston.cur_offset_y - 467 + 20)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
        if distance_between_player_and_LeftDoor < (275 + 225):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.LeftDoor_current_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 17, ((1/2) * screen_height) + my_push_piston.cur_offset_y - 48)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
        if distance_between_player_and_RightDoor < (275 + 225):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.RightDoor_current_image), my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x - 1750, ((1/2) * screen_height) + my_push_piston.cur_offset_y - 48)
          if SingleElevator_col_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(SingleElevator_col_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, elevator_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
  if ELEVATORS != [] and MAP.region != 'TheDoor7':
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleElevator in ELEVATORS:
      distance_between_player_and_SingleElevator = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.x_pos + ((1/2)*screen_width) - (SingleElevator.rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.y_pos + ((1/2)*screen_height) - (SingleElevator.rect[3]/2)))
      if distance_between_player_and_SingleElevator < (275 + find_hypotnuse(SingleElevator.rect[2], SingleElevator.rect[3])):
        Elevator_col_points, Elevator_col_happened = find_collisions_with_offsets(SingleElevator, my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
        if Elevator_col_happened:
          for _ in range(My_cached_info.whole_number_of_frames_this_frame):
            my_push_piston.is_touching_wall.append(True)
            my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
          if len(Elevator_col_points) > retract_after:
            my_push_piston.extension_float -= my_push_piston.extension_float_added
          my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
          change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, object_extension_speed)
          regular_piston_sheath_update()
          regular_update_PushPiston(my_push_piston)
          if not My_cached_info.playing_loud_water_jet:
            My_cached_info.playing_loud_water_jet = True
            MixerSounds['LOUD_WATER_JET'].play(-1)
          return PREVIOUS_PUSH_PISTON
  #
  if CLOUDS != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    cur_cloud_index = -1
    for SingleCloud in CLOUDS:
      cur_cloud_index += 1
      distance_between_player_and_SingleCloud = find_hypotnuse(abs(absolute_center_of_player_x - (SingleCloud.x_pos - ((1/2)*screen_width) + (SingleCloud.rect[2]/2))), abs(absolute_center_of_player_y - (SingleCloud.y_pos - ((1/2)*screen_height) + (SingleCloud.rect[3]/2))))
      if distance_between_player_and_SingleCloud <= (SingleCloud.radius + 275 + 5):
        piston_collision_with_cloud_points, piston_collision_with_cloud_happened = find_collisions_with_offsets(SingleCloud, my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
        if piston_collision_with_cloud_happened:
          PLAYER.on_a_cloud_prev_frames = [False, False, False, False, False, False, False, False]
          global STANDING_ON_CLOUD, STANDING_ON_WHICH_CLOUD
          SingleCloud_collision_points, SingleCloud_collision_happened = find_collisions_with_offsets(SingleCloud, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          if not SingleCloud_collision_happened:
            if STANDING_ON_CLOUD and (STANDING_ON_WHICH_CLOUD == cur_cloud_index):
              if My_cached_info.got_boost_milliseconds <= 0:
                PLAYER.x_vel += (SingleCloud.x_pos - SingleCloud.prev_x_pos) / (1 / fps)
                PLAYER.y_vel += (SingleCloud.y_pos - SingleCloud.prev_y_pos) / (1 / fps)
            STANDING_ON_CLOUD = False
            STANDING_ON_WHICH_CLOUD = 666
            My_cached_info.got_boost_milliseconds = 100
          for _ in range(My_cached_info.whole_number_of_frames_this_frame):
            my_push_piston.is_touching_wall.append(True)
            my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
          if len(piston_collision_with_cloud_points) > retract_after:
            my_push_piston.extension_float -= my_push_piston.extension_float_added
          my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
          change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, object_extension_speed)
          regular_piston_sheath_update()
          regular_update_PushPiston(my_push_piston)
          if not My_cached_info.playing_loud_water_jet:
            My_cached_info.playing_loud_water_jet = True
            MixerSounds['LOUD_WATER_JET'].play(-1)
          return PREVIOUS_PUSH_PISTON
  #
  if SPINNY_OBJECTS != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleSpinny in SPINNY_OBJECTS:
      distance_between_player_and_SingleSpinny = find_hypotnuse(abs(absolute_center_of_player_x - (SingleSpinny.x_pos - ((1/2)*screen_width) + (SingleSpinny.rect[2]/2))), abs(absolute_center_of_player_y - (SingleSpinny.y_pos - ((1/2)*screen_height) + (SingleSpinny.rect[3]/2))))
      if distance_between_player_and_SingleSpinny <= (SingleSpinny.radius + 275 + 5):
        piston_collision_with_SingleSpinny_points, piston_collision_with_SingleSpinny_happened = find_collisions_with_offsets(SingleSpinny, my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
        if piston_collision_with_SingleSpinny_happened:
          for _ in range(My_cached_info.whole_number_of_frames_this_frame):
            my_push_piston.is_touching_wall.append(True)
            my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
          if len(piston_collision_with_SingleSpinny_points) > retract_after:
            my_push_piston.extension_float -= my_push_piston.extension_float_added
          my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
          change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, object_extension_speed)
          regular_piston_sheath_update()
          regular_update_PushPiston(my_push_piston)
          if not My_cached_info.playing_loud_water_jet:
            My_cached_info.playing_loud_water_jet = True
            MixerSounds['LOUD_WATER_JET'].play(-1)
          return PREVIOUS_PUSH_PISTON
  #
  if GARBAGE_CAN != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleGarbageCan in GARBAGE_CAN:
      if SingleGarbageCan.player_is_inside or SingleGarbageCan.player_is_tentatively_inside:
        distance_between_player_and_SingleGarbageCan = find_hypotnuse(abs(absolute_center_of_player_x - (SingleGarbageCan.x_pos - ((1/2)*screen_width) + (SingleGarbageCan.rect[2]/2))), abs(absolute_center_of_player_y - (SingleGarbageCan.y_pos - ((1/2)*screen_height) + (SingleGarbageCan.rect[3]/2))))
        if distance_between_player_and_SingleGarbageCan <= (SingleGarbageCan.radius + 275 + 5):
          piston_collision_with_SingleGarbageCan_points, piston_collision_with_SingleGarbageCan_happened = find_collisions_with_offsets(SingleGarbageCan, my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
          if piston_collision_with_SingleGarbageCan_happened:
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(piston_collision_with_SingleGarbageCan_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, object_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
  #
  if WATER_SURFACES != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleWaterSurface in WATER_SURFACES:
      distance_between_player_and_SingleRoot = find_hypotnuse(abs(absolute_center_of_player_x - (SingleWaterSurface.x_pos - ((1/2)*screen_width) + (SingleWaterSurface.rect[2]/2))), abs(absolute_center_of_player_y - (SingleWaterSurface.y_pos - ((1/2)*screen_height) + (SingleWaterSurface.rect[3]/2))))
      if distance_between_player_and_SingleRoot < (275 + SingleWaterSurface.radius + 5):
        piston_collision_with_water_points, piston_collision_with_water_happened = find_collisions_with_offsets(SingleWaterSurface, my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
        if piston_collision_with_water_happened:
          for _ in range(My_cached_info.whole_number_of_frames_this_frame):
            my_push_piston.is_touching_wall.append(True)
            my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
          if len(piston_collision_with_water_points) > retract_after:
            my_push_piston.extension_float -= my_push_piston.extension_float_added
          my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
          change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, object_extension_speed)
          regular_piston_sheath_update()
          regular_update_PushPiston(my_push_piston)
          if not My_cached_info.playing_loud_water_jet:
            My_cached_info.playing_loud_water_jet = True
            MixerSounds['LOUD_WATER_JET'].play(-1)
          return PREVIOUS_PUSH_PISTON
  #
  if IRREGULARLY_SHAPED_WATER != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleIrregularlyShapedWater in IRREGULARLY_SHAPED_WATER:
      distance_between_player_and_SingleIrregularlyShapedWater = find_hypotnuse(abs(absolute_center_of_player_x - (SingleIrregularlyShapedWater.x_pos - ((1/2)*screen_width) + (SingleIrregularlyShapedWater.rect[2]/2))), abs(absolute_center_of_player_y - (SingleIrregularlyShapedWater.y_pos - ((1/2)*screen_height) + (SingleIrregularlyShapedWater.rect[3]/2))))
      if distance_between_player_and_SingleIrregularlyShapedWater < (275 + SingleIrregularlyShapedWater.radius + 5):
        piston_collision_with_water_points, piston_collision_with_water_happened = find_collisions_with_offsets(SingleIrregularlyShapedWater, my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
        if piston_collision_with_water_happened:
          for _ in range(My_cached_info.whole_number_of_frames_this_frame):
            my_push_piston.is_touching_wall.append(True)
            my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
          if len(piston_collision_with_water_points) > retract_after:
            my_push_piston.extension_float -= my_push_piston.extension_float_added
          my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
          change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, object_extension_speed)
          regular_piston_sheath_update()
          regular_update_PushPiston(my_push_piston)
          if not My_cached_info.playing_loud_water_jet:
            My_cached_info.playing_loud_water_jet = True
            MixerSounds['LOUD_WATER_JET'].play(-1)
          return PREVIOUS_PUSH_PISTON
  #
  if SQUIRRELS != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleSquirrel in SQUIRRELS:
      distance_between_player_and_SingleSquirrel = find_hypotnuse(abs(absolute_center_of_player_x - (SingleSquirrel.x_pos - ((1/2)*screen_width) + (SingleSquirrel.rect[2]/2))), abs(absolute_center_of_player_y - (SingleSquirrel.y_pos - ((1/2)*screen_height) + (SingleSquirrel.rect[3]/2))))
      if distance_between_player_and_SingleSquirrel < (275 + SingleSquirrel.radius + 5):
        piston_collision_with_water_points, piston_collision_with_water_happened = find_collisions_with_offsets(SingleSquirrel, my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
        if piston_collision_with_water_happened:
          for _ in range(My_cached_info.whole_number_of_frames_this_frame):
            my_push_piston.is_touching_wall.append(True)
            my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
          if len(piston_collision_with_water_points) > retract_after:
            my_push_piston.extension_float -= my_push_piston.extension_float_added
          my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
          change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, object_extension_speed)
          regular_piston_sheath_update()
          regular_update_PushPiston(my_push_piston)
          if not My_cached_info.playing_loud_water_jet:
            My_cached_info.playing_loud_water_jet = True
            MixerSounds['LOUD_WATER_JET'].play(-1)
          return PREVIOUS_PUSH_PISTON
  #
  if ROOTS != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleRoot in ROOTS:
      if SingleRoot.is_solid:
        distance_between_player_and_SingleRoot = find_hypotnuse(abs(absolute_center_of_player_x - (SingleRoot.x_pos - ((1/2)*screen_width) + (SingleRoot.rect[2]/2))), abs(absolute_center_of_player_y - (SingleRoot.y_pos - ((1/2)*screen_height) + (SingleRoot.rect[3]/2))))
        if distance_between_player_and_SingleRoot < (275 + SingleRoot.radius + 5):
          piston_collision_with_root_points, piston_collision_with_root_happened = find_collisions_with_offsets(SingleRoot, my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
          if piston_collision_with_root_happened:
            if not SingleRoot.damaged_this_frame:
              SingleRoot.accumulated_damage += 5 * My_cached_info.target_fps_over_fps
            SingleRoot.damaged_this_frame = True
            SingleRoot.currently_falling = True
            if (SingleRoot.time_of_contact + SingleRoot.time_to_finish_regrowth) < My_cached_info.fake_frame_counter:
              SingleRoot.time_of_contact = My_cached_info.fake_frame_counter
            for _ in range(My_cached_info.whole_number_of_frames_this_frame):
              my_push_piston.is_touching_wall.append(True)
              my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
            if len(piston_collision_with_root_points) > retract_after:
              my_push_piston.extension_float -= my_push_piston.extension_float_added
            my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
            change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, object_extension_speed)
            regular_piston_sheath_update()
            regular_update_PushPiston(my_push_piston)
            if not My_cached_info.playing_loud_water_jet:
              My_cached_info.playing_loud_water_jet = True
              MixerSounds['LOUD_WATER_JET'].play(-1)
            return PREVIOUS_PUSH_PISTON
  #
  if DOORS != []:
    for SingleDoor in DOORS:
      if SingleDoor.door_type == 1:
        piston_collision_with_door_points, piston_collision_with_door_happened = find_collisions_with_offsets(SingleDoor, my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
        if piston_collision_with_door_happened:
          for _ in range(My_cached_info.whole_number_of_frames_this_frame):
            my_push_piston.is_touching_wall.append(True)
            my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
          if len(piston_collision_with_door_points) > retract_after:
            my_push_piston.extension_float -= my_push_piston.extension_float_added
          my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
          change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, object_extension_speed)
          regular_piston_sheath_update()
          regular_update_PushPiston(my_push_piston)
          if not My_cached_info.playing_loud_water_jet:
            My_cached_info.playing_loud_water_jet = True
            MixerSounds['LOUD_WATER_JET'].play(-1)
          return PREVIOUS_PUSH_PISTON
      if SingleDoor.door_type == 2:
        if SingleDoor.rotation == 0:
          if not SingleDoor.is_open:
            piston_collision_with_door_points, piston_collision_with_door_happened = find_collisions_with_offsets(SingleDoor, my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
            if piston_collision_with_door_happened:
              for _ in range(My_cached_info.whole_number_of_frames_this_frame):
                my_push_piston.is_touching_wall.append(True)
                my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
              if len(piston_collision_with_door_points) > retract_after:
                my_push_piston.extension_float -= my_push_piston.extension_float_added
              my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
              change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, object_extension_speed)
              regular_piston_sheath_update()
              regular_update_PushPiston(my_push_piston)
              if not My_cached_info.playing_loud_water_jet:
                My_cached_info.playing_loud_water_jet = True
                MixerSounds['LOUD_WATER_JET'].play(-1)
              return PREVIOUS_PUSH_PISTON
  #
  if TEETERTOTTERS != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleTeeterTotter in TEETERTOTTERS:
      distance_between_player_and_curTotter = find_hypotnuse(abs(absolute_center_of_player_x - SingleTeeterTotter.collision_circle_x), abs(absolute_center_of_player_y - SingleTeeterTotter.collision_circle_y))
      if distance_between_player_and_curTotter < (34 + my_push_piston.extension + SingleTeeterTotter.collision_circle_radius):
        piston_collision_with_teetertotter_points, piston_collision_with_teetertotter_happened = find_collisions_with_offsets(SingleTeeterTotter, my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
        if not piston_collision_with_teetertotter_happened:
          SingleTeeterTotter.is_the_push_piston_pushing = False
        if piston_collision_with_teetertotter_happened:
          for _ in range(My_cached_info.whole_number_of_frames_this_frame):
            my_push_piston.is_touching_wall.append(True)
            my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
          SingleTeeterTotter.is_the_push_piston_pushing = True
          if len(piston_collision_with_teetertotter_points) > retract_after:
            my_push_piston.extension_float -= my_push_piston.extension_float_added
          my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
          change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, object_extension_speed)
          regular_piston_sheath_update()
          regular_update_PushPiston(my_push_piston)
          if not My_cached_info.playing_loud_water_jet:
            My_cached_info.playing_loud_water_jet = True
            MixerSounds['LOUD_WATER_JET'].play(-1)
          return PREVIOUS_PUSH_PISTON
  #
  if BOUNCIES != []:
    center_of_player_x, center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleBouncy in BOUNCIES:
      distance_between_piston_and_SingleBouncy = find_hypotnuse(abs(center_of_player_x - SingleBouncy.collision_circle_x), abs(center_of_player_y - SingleBouncy.collision_circle_y))
      if distance_between_piston_and_SingleBouncy < (34 + my_push_piston.extension + SingleBouncy.collision_circle_radius):
        bouncy_col_points, bouncy_col_happened = find_collisions_with_offsets(SingleBouncy, my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
        if bouncy_col_happened:
          for _ in range(My_cached_info.whole_number_of_frames_this_frame):
            my_push_piston.is_touching_wall.append(True)
            my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
          if len(bouncy_col_points) > retract_after:
            my_push_piston.extension_float -= my_push_piston.extension_float_added
          if Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            my_push_piston.extension_float -= my_push_piston.extension_float_added
          regular_piston_sheath_update()
          regular_update_PushPiston(my_push_piston)
          if not My_cached_info.playing_loud_water_jet:
            My_cached_info.playing_loud_water_jet = True
            MixerSounds['LOUD_WATER_JET'].play(-1)
          return PREVIOUS_PUSH_PISTON
  #
  if WAVES != []:
    center_of_player_x, center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleWave in WAVES:
      distance_between_player_and_wave = find_hypotnuse(abs(absolute_center_of_player_x - (SingleWave.x_pos - ((1/2)*screen_width) + (SingleWave.rect[2]/2))), abs(absolute_center_of_player_y - (SingleWave.y_pos - ((1/2)*screen_height) + (SingleWave.rect[3]/2))))
      if distance_between_player_and_wave <= (SingleWave.radius + 34 + my_push_piston.extension):
        SingleWave_col_points, SingleWave_col_happened = find_collisions_with_offsets(SingleWave, my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
        if SingleWave_col_happened:
          for _ in range(My_cached_info.whole_number_of_frames_this_frame):
            my_push_piston.is_touching_wall.append(True)
            my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
          if len(SingleWave_col_points) > retract_after:
            my_push_piston.extension_float -= my_push_piston.extension_float_added
          my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
          change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, object_extension_speed)
          regular_piston_sheath_update()
          regular_update_PushPiston(my_push_piston)
          if not My_cached_info.playing_loud_water_jet:
            My_cached_info.playing_loud_water_jet = True
            MixerSounds['LOUD_WATER_JET'].play(-1)
          return PREVIOUS_PUSH_PISTON
  #
  if BUCKETS != []:
    center_of_player_x, center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleBucket in BUCKETS:
      distance_between_player_and_bucket = find_hypotnuse(abs(absolute_center_of_player_x - (SingleBucket.x_pos - ((1/2)*screen_width) + (SingleBucket.rect[2]/2))), abs(absolute_center_of_player_y - (SingleBucket.y_pos - ((1/2)*screen_height) + (SingleBucket.rect[3]/2))))
      if distance_between_player_and_bucket <= (SingleBucket.radius + 34 + my_push_piston.extension_float):
        SingleBucket_col_points, SingleBucket_col_happened = find_collisions_with_offsets(SingleBucket, my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
        if SingleBucket_col_happened:
          for _ in range(My_cached_info.whole_number_of_frames_this_frame):
            my_push_piston.is_touching_wall.append(True)
            my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
          if len(SingleBucket_col_points) > retract_after:
            my_push_piston.extension_float -= my_push_piston.extension_float_added
          my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
          change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, object_extension_speed)
          regular_piston_sheath_update()
          regular_update_PushPiston(my_push_piston)
          if not My_cached_info.playing_loud_water_jet:
            My_cached_info.playing_loud_water_jet = True
            MixerSounds['LOUD_WATER_JET'].play(-1)
          return PREVIOUS_PUSH_PISTON
  #
  if QueenAnt != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    distance_between_player_and_QueenAnt = find_hypotnuse(abs(absolute_center_of_player_x - QueenAnt.x_pos + ((1/2)*screen_width) - (QueenAnt.rect[2]/2)), abs(absolute_center_of_player_y - QueenAnt.y_pos + ((1/2)*screen_height) - (QueenAnt.rect[3]/2)))
    if distance_between_player_and_QueenAnt < (275 + 400):
      QueenAnt_collision_points, QueenAnt_collision_happened = find_collisions_with_offsets(QueenAnt, my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
      if QueenAnt_collision_happened:
        for _ in range(My_cached_info.whole_number_of_frames_this_frame):
          my_push_piston.is_touching_wall.append(True)
          my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
        if len(QueenAnt_collision_points) > retract_after:
          my_push_piston.extension_float -= my_push_piston.extension_float_added
        my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
        change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, object_extension_speed)
        regular_piston_sheath_update()
        regular_update_PushPiston(my_push_piston)
        if not My_cached_info.playing_loud_water_jet:
          My_cached_info.playing_loud_water_jet = True
          MixerSounds['LOUD_WATER_JET'].play(-1)
        return PREVIOUS_PUSH_PISTON
  #
  if DOORS_WITH_KNOB != []:
    center_of_player_x, center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleDoorWithKnob in DOORS_WITH_KNOB:
      if SingleDoorWithKnob.door_png_name == 'DOOR_WITH_KNOB':
        if SingleDoorWithKnob.current_door_opening == 4:
          distance_between_player_and_SingleDoorWithKnob = find_hypotnuse(abs(absolute_center_of_player_x - (SingleDoorWithKnob.x_pos - ((1/2)*screen_width) + (SingleDoorWithKnob.rect[2]/2))), abs(absolute_center_of_player_y - (SingleDoorWithKnob.y_pos - ((1/2)*screen_height) + (SingleDoorWithKnob.rect[3]/2))))
          if distance_between_player_and_SingleDoorWithKnob <= (SingleDoorWithKnob.radius + 34 + my_push_piston.extension_float):
            SingleDoorWithKnob.current_image = SingleDoorWithKnob.whole_door_images[4]
            SingleDoorWithKnob_col_points, SingleDoorWithKnob_col_happened = find_collisions_with_offsets(SingleDoorWithKnob, my_push_piston, ((1/2) * screen_width) + my_push_piston.cur_offset_x, ((1/2) * screen_height) + my_push_piston.cur_offset_y)
            if SingleDoorWithKnob_col_happened:
              for _ in range(My_cached_info.whole_number_of_frames_this_frame):
                my_push_piston.is_touching_wall.append(True)
                my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
              if len(SingleDoorWithKnob_col_points) > retract_after:
                my_push_piston.extension_float -= my_push_piston.extension_float_added
              my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
              change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, object_extension_speed)
              regular_piston_sheath_update()
              regular_update_PushPiston(my_push_piston)
              if not My_cached_info.playing_loud_water_jet:
                My_cached_info.playing_loud_water_jet = True
                MixerSounds['LOUD_WATER_JET'].play(-1)
              return PREVIOUS_PUSH_PISTON
  #
  if not ON_AN_ELEVATOR:
    #cur_collision_points, collision_happened = find_collisions(MAP, my_push_piston)
    cur_collision_points, collision_happened = find_collisions_with_offsets_with_map(MAP, my_push_piston, my_push_piston.cur_offset_x, my_push_piston.cur_offset_y)
  if ON_AN_ELEVATOR:
    collision_happened = False
  regular_piston_sheath_update()
  if not collision_happened:
    if my_push_piston.extension < my_push_piston.maximum_extension:
      my_push_piston.extension_float += my_push_piston.extension_float_added
    regular_update_PushPiston(my_push_piston)
    my_push_piston.mask = pygame.mask.from_surface(my_push_piston.current_image)
    #cur_collision_points, collision_happened = find_collisions(MAP, my_push_piston)
    cur_collision_points, collision_happened = find_collisions_with_offsets_with_map(MAP, my_push_piston, my_push_piston.cur_offset_x, my_push_piston.cur_offset_y)
    for _ in range(My_cached_info.whole_number_of_frames_this_frame):
      PREVIOUS_PUSH_PISTON.append('Nothing')
      PREVIOUS_PUSH_PISTON = PREVIOUS_PUSH_PISTON[1:]
    return PREVIOUS_PUSH_PISTON
  #
  if collision_happened:
    for _ in range(My_cached_info.whole_number_of_frames_this_frame):
      my_push_piston.is_touching_wall.append(True)
      my_push_piston.is_touching_wall = my_push_piston.is_touching_wall[1:]
    if len(cur_collision_points) > retract_after:
      my_push_piston.extension_float -= my_push_piston.extension_float_added
    my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
    change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, 1800)
    regular_update_PushPiston(my_push_piston)
    if 270 < (my_sheath.rotation%360) <= 360 or 0 <= (my_sheath.rotation%360) < 90:
      for _ in range(My_cached_info.whole_number_of_frames_this_frame):
        PREVIOUS_PUSH_PISTON.append('RIGHT')
        PREVIOUS_PUSH_PISTON = PREVIOUS_PUSH_PISTON[1:]
    if 90 < (my_sheath.rotation%360) < 270:
      for _ in range(My_cached_info.whole_number_of_frames_this_frame):
        PREVIOUS_PUSH_PISTON.append('LEFT')
        PREVIOUS_PUSH_PISTON = PREVIOUS_PUSH_PISTON[1:]
    if (my_sheath.rotation%360) == 90 or (my_sheath.rotation%360) == 270:
      for _ in range(My_cached_info.whole_number_of_frames_this_frame):
        PREVIOUS_PUSH_PISTON.append('Nothing')
        PREVIOUS_PUSH_PISTON = PREVIOUS_PUSH_PISTON[1:]
    if not My_cached_info.playing_loud_water_jet:
      My_cached_info.playing_loud_water_jet = True
      MixerSounds['LOUD_WATER_JET'].play(-1)
    return PREVIOUS_PUSH_PISTON


def find_grappling_piston_force(map, player, my_piston2):
  xG, yG = my_piston2.grapple_claw_x_pos, my_piston2.grapple_claw_y_pos
  xB, yB = find_center_of_ball(map, player)
  current_hypotnuse = find_hypotnuse(abs(xB - xG), abs(yB - yG))
  #
  if yB > yG: # ball is below grapple
  #
    if xG == xB: # ball is centered
      return 0, -abs(player.mass * my_gravity * 1.5)
  #
    if xG > xB: # ball is left of grapple
      my_theta = math.degrees(math.acos(abs(xB - xG) / current_hypotnuse))
      return abs(player.mass * my_gravity * 1.5 * math.cos(math.radians(my_theta))), -abs(player.mass * my_gravity * 1.5 * math.sin(math.radians(my_theta)))
  #
    if xG < xB: # ball is right of grapple
      my_theta = math.degrees(math.acos(abs(xB - xG) / current_hypotnuse))
      return -abs(player.mass * my_gravity * 1.5 * math.cos(math.radians(my_theta))), -abs(player.mass * my_gravity * 1.5 * math.sin(math.radians(my_theta)))
  #
  if yB == yG: # ball is level with grapple
  #
    if xB < xG: # ball is left of grapple
      return abs(player.mass * my_gravity * 1.5), 0
  #
    if xB > xG: # ball is right of grapple
      return -abs(player.mass * my_gravity * 1.5), 0
  #
  if yB < yG: # ball is above grapple
  #
    if xG >= xB: # ball is left of grapple
      my_theta = math.degrees(math.acos(abs(xB - xG) / current_hypotnuse))
      return abs(player.mass * my_gravity * math.cos(math.radians(my_theta))), abs(player.mass * my_gravity * 2.5 * math.sin(math.radians(my_theta)))
  #
    if xG < xB: # ball is right_of_grapple
      my_theta = math.degrees(math.acos(abs(xB - xG) / current_hypotnuse))
      return -abs(player.mass * my_gravity * math.cos(math.radians(my_theta))), abs(player.mass * my_gravity * 2.5 * math.sin(math.radians(my_theta)))


def connect_grapple_piston_to_wall(my_grapple_piston):
  xc, yc = find_center_of_ball(MAP, PLAYER)
  xg, yg = my_grapple_piston.grapple_claw_x_pos, my_grapple_piston.grapple_claw_y_pos # grapple position
  my_grapple_piston.extension = int(find_hypotnuse(abs(xc - xg), abs(yc - yg)) - 29)
  my_grapple_piston.extension_float = my_grapple_piston.extension
  my_sheath.rotation = find_mouse_angle2(MAP, PLAYER, xg - 2 - PLAYER.x_pos + stop_scrolling_left, yg - 2 - PLAYER.y_pos + stop_scrolling_top)
  my_grapple_piston.rotation = my_sheath.rotation
  for _ in range(1):
    difference_between_current_and_last_grapple_length = abs(my_grapple_piston.extension - my_grapple_piston.last_extension)
    if difference_between_current_and_last_grapple_length >= (0.5 * my_piston2.extension_float_added):
      if my_grapple_piston.extension > my_grapple_piston.last_extension:
        if not My_cached_info.playing_extend_grapple:
          MixerSounds['EXTEND'].play(-1)
          My_cached_info.playing_extend_grapple = True
          MixerSounds['RETRACT'].stop()
          My_cached_info.play_retract_grapple = False
          continue
        else:
          continue
      if my_grapple_piston.extension < my_grapple_piston.last_extension:
        if not My_cached_info.play_retract_grapple:
          MixerSounds['RETRACT'].play(-1)
          My_cached_info.play_retract_grapple = True
          MixerSounds['EXTEND'].stop()
          My_cached_info.playing_extend_grapple = False
          continue
        else:
          continue
    if difference_between_current_and_last_grapple_length <= 2:
      MixerSounds['EXTEND'].stop()
      My_cached_info.playing_extend_grapple = False
      MixerSounds['RETRACT'].stop()
      My_cached_info.play_retract_grapple = False
      continue
    else:
      if My_cached_info.playing_extend_grapple:
        if my_grapple_piston.extension >= my_grapple_piston.last_extension - (0.5 * my_piston2.extension_float_added):
          continue
        else:
          MixerSounds['EXTEND'].stop()
          My_cached_info.playing_extend_grapple = False
          continue
      if My_cached_info.play_retract_grapple:
        if my_grapple_piston.extension <= my_grapple_piston.last_extension + (0.5 * my_piston2.extension_float_added):
          continue
        else:
          MixerSounds['RETRACT'].stop()
          My_cached_info.play_retract_grapple = False
          continue


def try_moving_player_closer_to_grapple(my_grapple_piston):
  orig_player_x_pos, orig_player_y_pos = PLAYER.x_pos, PLAYER.y_pos
  distance_to_try_moving = my_grapple_piston.extension - my_grapple_piston.maximum_extension
  moved_x = distance_to_try_moving * math.cos(math.radians(my_grapple_piston.rotation))
  moved_y = -distance_to_try_moving * math.sin(math.radians(my_grapple_piston.rotation))
  PLAYER.x_pos += moved_x
  PLAYER.y_pos += moved_y
  cur_col_points, cur_col_happened = find_collisions(MAP, PLAYER)
  if cur_col_happened:
    if (collison_with_left_ball_happened or collison_with_right_ball_happened) and (len(cur_col_points) < 30):
      return
    PLAYER.x_pos, PLAYER.y_pos = orig_player_x_pos, orig_player_y_pos
    return
  else:
    return



def find_tip_of_grapple_piston(my_grapple_piston):
  center_x, center_y = my_grapple_piston.x_pos + 275 + ((1/2) * screen_width), my_grapple_piston.y_pos + 275 + ((1/2) * screen_height)
  my_rot = my_sheath.rotation % 360
  if my_rot == 0:
    return center_x + 33 + my_grapple_piston.extension, center_y
  if 0 < my_rot < 90:
    cur_hyp = 33 + my_grapple_piston.extension
    return center_x + abs(cur_hyp * math.cos(math.radians(my_rot))), center_y - abs(cur_hyp * math.sin(math.radians(my_rot)))
  if my_rot == 90:
    return center_x, center_y - 33 - my_grapple_piston.extension
  if 90 < my_rot < 180:
    cur_hyp = 33 + my_grapple_piston.extension
    return center_x - abs(cur_hyp * math.cos(math.radians(my_rot))), center_y - abs(cur_hyp * math.sin(math.radians(my_rot)))
  if my_rot == 180:
    return center_x - 33 - my_grapple_piston.extension, center_y
  if 180 < my_rot < 270:
    cur_hyp = 33 + my_grapple_piston.extension
    return center_x - abs(cur_hyp * math.cos(math.radians(my_rot))), center_y + abs(cur_hyp * math.sin(math.radians(my_rot)))
  if my_rot == 270:
    return center_x, center_y + 33 + my_grapple_piston.extension
  if 270 < my_rot < 360:
    cur_hyp = 33 + my_grapple_piston.extension
    return center_x + abs(cur_hyp * math.cos(math.radians(my_rot))), center_y + abs(cur_hyp * math.sin(math.radians(my_rot)))


def unhook_grapple_piston(my_grapple_piston):
  xc, yc = find_center_of_ball(MAP, PLAYER)
  xg, yg = my_grapple_piston.grapple_claw_x_pos, my_grapple_piston.grapple_claw_y_pos # grapple position
  if my_grapple_piston.maximum_extension + 50 < int(find_hypotnuse(abs(xc - xg), abs(yc - yg)) - 34):
    return True
  return False


def find_surf_board_rotated_attach_xy(SingleSurfBoard):
  ball_center_x, ball_center_y = 70, 70
  distance_between_ball_center_and_attach = find_hypotnuse(ball_center_x - SingleSurfBoard.attach_x, ball_center_y - SingleSurfBoard.attach_y)
  angle_to_attach = SingleSurfBoard.image_rotation
  attach_x = ball_center_x + (distance_between_ball_center_and_attach * math.cos(math.radians(angle_to_attach)))
  attach_y = ball_center_y + (distance_between_ball_center_and_attach * math.sin(math.radians(angle_to_attach)))
  return attach_x, attach_y


def do_everything_grapple_piston(my_grapple_piston):
  global KEY_GRABBED_BY_PLAYER, GRAPPLED_TO_PLATFORM, BOX_GRABBED_BY_PLAYER
  cur_col_grapple_points, cur_col_grapple_happened = [(0,0)], False
  my_grapple_piston.mask = pygame.mask.from_surface(my_grapple_piston.current_image)
  my_grapple_piston.cur_offset_x = my_grapple_piston.Cover_x_pos + 275
  my_grapple_piston.cur_offset_y = my_grapple_piston.Cover_y_pos + 275
  if Currently_pressed_controls.pressed_controls['DETACH_GRAPPLING_HOOK'] and not PLAYER.in_a_pipe:
    if Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
      my_grapple_piston.extension_float += my_grapple_piston.extension_float_added
    regular_piston_sheath_update()
    regular_update_GrapplePiston(my_piston2)
    return cur_col_grapple_points, cur_col_grapple_happened
  #
  if PLAYER.carrying_food:
    regular_piston_sheath_update()
    current_food = FOOD[PLAYER.carrying_which_food]
    FOOD[PLAYER.carrying_which_food].image_rotation = (my_sheath.rotation) % 360
    cur_collision_points, collision_happened = find_collisions_with_offsets_with_map(MAP, my_grapple_piston, my_grapple_piston.cur_offset_x, my_grapple_piston.cur_offset_y)
    if collision_happened: # new collision with grapple piston
      if len(cur_collision_points) > 30:
        if my_grapple_piston.extension_float > my_grapple_piston.extension_float_added:
          my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
    if Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK'] and not collision_happened:
      my_grapple_piston.extension_float += my_grapple_piston.extension_float_added
    if not Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
      if my_grapple_piston.extension_float > my_grapple_piston.extension_float_added:
        my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
    regular_update_GrapplePiston(my_grapple_piston)
    FOOD[PLAYER.carrying_which_food].x_pos, FOOD[PLAYER.carrying_which_food].y_pos = np.subtract(find_tip_of_grapple_piston(my_grapple_piston), (FOOD[PLAYER.carrying_which_food].rect[2]/2, FOOD[PLAYER.carrying_which_food].rect[3]/2))
    my_grapple_piston.grapple_claw_x_pos = FOOD[PLAYER.carrying_which_food].x_pos + (FOOD[PLAYER.carrying_which_food].rect[2]/2) - ((1/2) * screen_width)
    my_grapple_piston.grapple_claw_y_pos = FOOD[PLAYER.carrying_which_food].y_pos + (FOOD[PLAYER.carrying_which_food].rect[3]/2) - ((1/2) * screen_height)
    Marker.x_pos, Marker.y_pos = my_grapple_piston.grapple_claw_x_pos, my_grapple_piston.grapple_claw_y_pos
    Marker.prev_x_pos, Marker.prev_y_pos = Marker.x_pos, Marker.y_pos
    return cur_col_grapple_points, cur_col_grapple_happened
  #
  if BOX_GRABBED_BY_PLAYER:
    regular_piston_sheath_update()
    HAMSTER_BOX[0].rotation = (my_sheath.rotation) % 360
    cur_collision_points, collision_happened = find_collisions_with_offsets_with_map(MAP, my_grapple_piston, my_grapple_piston.cur_offset_x, my_grapple_piston.cur_offset_y)
    if collision_happened: # new collision with grapple piston
      if len(cur_collision_points) > 30:
        if my_grapple_piston.extension_float > my_grapple_piston.extension_float_added:
          my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
    if Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK'] and not collision_happened:
      my_grapple_piston.extension_float += my_grapple_piston.extension_float_added
    if not Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
      if my_grapple_piston.extension_float > my_grapple_piston.extension_float_added:
        my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
    regular_update_GrapplePiston(my_grapple_piston)
    HAMSTER_BOX[0].x_pos, HAMSTER_BOX[0].y_pos = np.subtract(find_tip_of_grapple_piston(my_grapple_piston), (HAMSTER_BOX[0].rect[2]/2, HAMSTER_BOX[0].rect[3]/2))
    my_grapple_piston.grapple_claw_x_pos = HAMSTER_BOX[0].x_pos + (HAMSTER_BOX[0].rect[2]/2) - ((1/2) * screen_width)
    my_grapple_piston.grapple_claw_y_pos = HAMSTER_BOX[0].y_pos + (HAMSTER_BOX[0].rect[3]/2) - ((1/2) * screen_height)
    Marker.x_pos, Marker.y_pos = my_grapple_piston.grapple_claw_x_pos, my_grapple_piston.grapple_claw_y_pos
    Marker.prev_x_pos, Marker.prev_y_pos = Marker.x_pos, Marker.y_pos
    return cur_col_grapple_points, cur_col_grapple_happened
  #
  if PLAYER.not_yet_on_the_board:
    SURF_BOARDS[PLAYER.on_which_surf_board].image_rotation = (my_sheath.rotation+90) % 360
    current_attach_x, current_attach_y = find_surf_board_rotated_attach_xy(SURF_BOARDS[PLAYER.on_which_surf_board])
    my_grapple_piston.grapple_claw_x_pos = SURF_BOARDS[PLAYER.on_which_surf_board].x_pos + current_attach_y - ((1/2)*screen_width)
    my_grapple_piston.grapple_claw_y_pos = SURF_BOARDS[PLAYER.on_which_surf_board].y_pos + current_attach_x - ((1/2)*screen_height)
    current_x = PLAYER.x_pos
    current_y = PLAYER.y_pos
    target_x = SURF_BOARDS[PLAYER.on_which_surf_board].x_pos + 36 - ((1/2)*screen_width)
    target_y = SURF_BOARDS[PLAYER.on_which_surf_board].y_pos + 36 - ((1/2)*screen_height)
    distance_to_move_x = (target_x - current_x)
    distance_to_move_y = (target_y - current_y)
    angle_to_move = math.degrees(math.atan2(distance_to_move_y, distance_to_move_x))
    distance_allowed_to_move = my_grapple_piston.extension_float_added
    PLAYER.x_pos += distance_allowed_to_move * math.cos(math.radians(angle_to_move))
    PLAYER.y_pos += distance_allowed_to_move * math.sin(math.radians(angle_to_move))
    PLAYER.x_pos += SURF_BOARDS[PLAYER.on_which_surf_board].current_x - SURF_BOARDS[PLAYER.on_which_surf_board].previous_x
    PLAYER.y_pos += SURF_BOARDS[PLAYER.on_which_surf_board].current_y - SURF_BOARDS[PLAYER.on_which_surf_board].previous_y
    distance_left_to_move = find_hypotnuse(PLAYER.x_pos - target_x, PLAYER.y_pos - target_y)
    if distance_left_to_move <= my_grapple_piston.extension_float_added:
      PLAYER.x_pos = target_x
      PLAYER.y_pos = target_y
      PLAYER.on_a_surf_board = True
      PLAYER.not_yet_on_the_board = False
    connect_grapple_piston_to_wall(my_grapple_piston)
    regular_update_GrapplePiston(my_grapple_piston)
    return cur_col_grapple_points, cur_col_grapple_happened
  if PLAYER.on_a_surf_board:
    regular_piston_sheath_update()
    SURF_BOARDS[PLAYER.on_which_surf_board].image_rotation = (my_sheath.rotation+90) % 360
    current_attach_x, current_attach_y = find_surf_board_rotated_attach_xy(SURF_BOARDS[PLAYER.on_which_surf_board])
    my_grapple_piston.grapple_claw_x_pos = SURF_BOARDS[PLAYER.on_which_surf_board].x_pos + current_attach_x - ((1/2)*screen_width)
    my_grapple_piston.grapple_claw_y_pos = SURF_BOARDS[PLAYER.on_which_surf_board].y_pos + current_attach_y - ((1/2)*screen_height)
    Marker.x_pos, Marker.y_pos = my_grapple_piston.grapple_claw_x_pos, my_grapple_piston.grapple_claw_y_pos
    Marker.prev_x_pos, Marker.prev_y_pos = Marker.x_pos, Marker.y_pos
    my_grapple_piston.extension_float = 8
    my_grapple_piston.extension = 8
    regular_update_GrapplePiston(my_grapple_piston)
    SURF_BOARDS[PLAYER.on_which_surf_board].current_image = rotate_square_image(SURF_BOARDS[PLAYER.on_which_surf_board].not_rotated_current_image, SURF_BOARDS[PLAYER.on_which_surf_board].image_rotation)
    SURF_BOARDS[PLAYER.on_which_surf_board].left_collision_image = rotate_square_image(SURF_BOARDS[PLAYER.on_which_surf_board].not_rotated_left_collision_image, SURF_BOARDS[PLAYER.on_which_surf_board].image_rotation)
    SURF_BOARDS[PLAYER.on_which_surf_board].right_collision_image = rotate_square_image(SURF_BOARDS[PLAYER.on_which_surf_board].not_rotated_right_collision_image, SURF_BOARDS[PLAYER.on_which_surf_board].image_rotation)
    return cur_col_grapple_points, cur_col_grapple_happened
  #
  if my_grapple_piston.connected_to_lever:
    LEVERS[my_grapple_piston.connected_to_which_lever].current_milliseconds_before_updating_lever_in_do_everything_grapple_piston += delta_milliseconds
    if LEVERS[my_grapple_piston.connected_to_which_lever].current_milliseconds_before_updating_lever_in_do_everything_grapple_piston >= LEVERS[my_grapple_piston.connected_to_which_lever].milliseconds_before_updating_lever_in_do_everything_grapple_piston:
      LEVERS[my_grapple_piston.connected_to_which_lever].current_milliseconds_before_updating_lever_in_do_everything_grapple_piston %= LEVERS[my_grapple_piston.connected_to_which_lever].milliseconds_before_updating_lever_in_do_everything_grapple_piston
      old_rot = my_sheath.rotation
      new_rot = lever_piston_sheath_update()
      old_rot_sin = math.sin(math.radians(old_rot))
      new_rot_sin = math.sin(math.radians(new_rot))
      skip_this_time = False
      if new_rot_sin - 0.025 > old_rot_sin:
        LEVERS[my_grapple_piston.connected_to_which_lever].going_down = False
      if new_rot_sin < old_rot_sin + 0.025:
        LEVERS[my_grapple_piston.connected_to_which_lever].going_down = True
      if old_rot_sin - 0.025 < new_rot_sin < old_rot_sin + 0.025:
        skip_this_time = True
      if LEVERS[my_grapple_piston.connected_to_which_lever].going_down and not skip_this_time:
        if LEVERS[my_grapple_piston.connected_to_which_lever].current_lever_index < 6:
          LEVERS[my_grapple_piston.connected_to_which_lever].current_lever_index += 1
          if LEVERS[my_grapple_piston.connected_to_which_lever].current_lever_index == 6:
            if LEVERS[my_grapple_piston.connected_to_which_lever].current_bolt_index < 6:
              if LEVERS[my_grapple_piston.connected_to_which_lever].allow_another_charge:
                for _ in range(1):
                  if MAP.region != 'TheDoor11':
                    LEVERS[my_grapple_piston.connected_to_which_lever].current_bolt_index += 2
                  else:
                    LEVERS[my_grapple_piston.connected_to_which_lever].current_bolt_index += 6
                if LEVERS[my_grapple_piston.connected_to_which_lever].current_bolt_index >= 6:
                  LEVERS[my_grapple_piston.connected_to_which_lever].current_bolt_index = 6
                LEVERS[my_grapple_piston.connected_to_which_lever].allow_another_charge = False
                LEVERS[my_grapple_piston.connected_to_which_lever].last_charge_time = curr_time
                if MAP.region == 'TheDoor11':
                  PROPELLERS[7].extend_the_whole_way = True
      if not LEVERS[my_grapple_piston.connected_to_which_lever].going_down and not skip_this_time:
        if LEVERS[my_grapple_piston.connected_to_which_lever].current_lever_index > 0:
          LEVERS[my_grapple_piston.connected_to_which_lever].current_lever_index -= 1
      LEVERS[my_grapple_piston.connected_to_which_lever].GPU_current_lever_image = LEVERS[my_grapple_piston.connected_to_which_lever].GPU_lever_images[LEVERS[my_grapple_piston.connected_to_which_lever].current_lever_index]
      LEVERS[my_grapple_piston.connected_to_which_lever].current_image = LEVERS[my_grapple_piston.connected_to_which_lever].images[LEVERS[my_grapple_piston.connected_to_which_lever].current_lever_index]
      LEVERS[my_grapple_piston.connected_to_which_lever].GPU_current_bolt_image = LEVERS[my_grapple_piston.connected_to_which_lever].GPU_bolt_images[LEVERS[my_grapple_piston.connected_to_which_lever].current_bolt_index]
      my_grapple_piston.grapple_claw_x_pos = LEVERS[my_grapple_piston.connected_to_which_lever].x_pos + LEVERS[my_grapple_piston.connected_to_which_lever].lever_added_x_pos + LEVERS[my_grapple_piston.connected_to_which_lever].lever_xy[LEVERS[my_grapple_piston.connected_to_which_lever].current_lever_index][0] - ((1/2)*screen_width)
      my_grapple_piston.grapple_claw_y_pos = LEVERS[my_grapple_piston.connected_to_which_lever].y_pos + LEVERS[my_grapple_piston.connected_to_which_lever].lever_added_y_pos + LEVERS[my_grapple_piston.connected_to_which_lever].lever_xy[LEVERS[my_grapple_piston.connected_to_which_lever].current_lever_index][1] - ((1/2)*screen_height)
      Marker.x_pos, Marker.y_pos = my_grapple_piston.grapple_claw_x_pos, my_grapple_piston.grapple_claw_y_pos
      Marker.prev_x_pos, Marker.prev_y_pos = Marker.x_pos, Marker.y_pos
      regular_update_GrapplePiston(my_grapple_piston)
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      distance_between_player_and_grapple = find_hypotnuse(absolute_center_of_player_x - my_grapple_piston.grapple_claw_x_pos, absolute_center_of_player_y - my_grapple_piston.grapple_claw_y_pos)
      if distance_between_player_and_grapple > (34 + my_grapple_piston.extension + 15):
        my_grapple_piston.grapple_claw_x_pos = 0
        my_grapple_piston.grapple_claw_y_pos = 0
        Marker.x_pos, Marker.y_pos = my_grapple_piston.grapple_claw_x_pos, my_grapple_piston.grapple_claw_y_pos
        Marker.prev_x_pos, Marker.prev_y_pos = Marker.x_pos, Marker.y_pos
        my_grapple_piston.connected_to_lever = False
        my_grapple_piston.connected_to_which_lever = 666
      return cur_col_grapple_points, cur_col_grapple_happened
  #
  if PLAYER.connected_to_door_with_knob:
    CurrentConnectedDoorWithKnob = DOORS_WITH_KNOB[PLAYER.connected_to_which_door_with_knob]
    CurrentConnectedDoorWithKnob.current_milliseconds_needed_to_get_next_door_image += delta_milliseconds
    if CurrentConnectedDoorWithKnob.current_milliseconds_needed_to_get_next_door_image >= CurrentConnectedDoorWithKnob.milliseconds_needed_to_get_next_door_image:
      CurrentConnectedDoorWithKnob.current_milliseconds_needed_to_get_next_door_image %= CurrentConnectedDoorWithKnob.milliseconds_needed_to_get_next_door_image
      old_rot = my_sheath.rotation
      new_rot = lever_piston_sheath_update()
      if CurrentConnectedDoorWithKnob.door_png_name == 'DOOR_WITH_KNOB':
        is_opening = False
        is_closing = False
        skip_this_frame = False
        CurrentConnectedDoorWithKnob.last_door_opening = CurrentConnectedDoorWithKnob.current_door_opening
        original_current_door_opening = CurrentConnectedDoorWithKnob.current_door_opening
        original_grapple_x = my_grapple_piston.grapple_claw_x_pos
        original_grapple_y = my_grapple_piston.grapple_claw_y_pos
        original_connected_knob = PLAYER.connected_to_which_knob
        if (Currently_pressed_controls.pressed_controls['MOVE_LEFT'] and (my_grapple_piston.extension >= (my_grapple_piston.maximum_extension - my_grapple_piston.extension_float_added)) and ((270 < (my_sheath.rotation%360) <= 360) or (0 < (my_sheath.rotation%360) < 90))) or ((0 < my_sheath.rotation%360 < 180) and (new_rot > old_rot + (3*My_cached_info.target_fps_over_fps))):
          is_opening = True
        if (Currently_pressed_controls.pressed_controls['MOVE_RIGHT'] and (my_grapple_piston.extension >= (my_grapple_piston.maximum_extension - my_grapple_piston.extension_float_added)) and (90 < (my_sheath.rotation%360) < 270)) or ((0 < my_sheath.rotation%360 < 180) and (new_rot < old_rot - (3*My_cached_info.target_fps_over_fps))):
          is_closing = True
        if not skip_this_frame:
          if is_opening:
            CurrentConnectedDoorWithKnob.current_door_opening += 1
            if CurrentConnectedDoorWithKnob.current_door_opening >= 9:
              CurrentConnectedDoorWithKnob.current_door_opening = 8
          if is_closing:
            CurrentConnectedDoorWithKnob.current_door_opening -= 1
            if CurrentConnectedDoorWithKnob.current_door_opening <= -1:
              CurrentConnectedDoorWithKnob.current_door_opening = 0
      if CurrentConnectedDoorWithKnob.current_door_opening <= 3:
        PLAYER.connected_to_which_knob = 2
      if CurrentConnectedDoorWithKnob.current_door_opening >= 5:
        PLAYER.connected_to_which_knob = 1
      CurrentConnectedDoorWithKnob.GPU_current_image = CurrentConnectedDoorWithKnob.GPU_images[CurrentConnectedDoorWithKnob.current_door_opening]
      if PLAYER.connected_to_which_knob == 1:
        my_grapple_piston.grapple_claw_x_pos = CurrentConnectedDoorWithKnob.x_pos + CurrentConnectedDoorWithKnob.grapple_xy_poses1[CurrentConnectedDoorWithKnob.current_door_opening][0] - ((1/2)*screen_width)
        my_grapple_piston.grapple_claw_y_pos = CurrentConnectedDoorWithKnob.y_pos + CurrentConnectedDoorWithKnob.grapple_xy_poses1[CurrentConnectedDoorWithKnob.current_door_opening][1] - ((1/2)*screen_height)
      if PLAYER.connected_to_which_knob == 2:
        my_grapple_piston.grapple_claw_x_pos = CurrentConnectedDoorWithKnob.x_pos + CurrentConnectedDoorWithKnob.grapple_xy_poses2[CurrentConnectedDoorWithKnob.current_door_opening][0] - ((1/2)*screen_width)
        my_grapple_piston.grapple_claw_y_pos = CurrentConnectedDoorWithKnob.y_pos + CurrentConnectedDoorWithKnob.grapple_xy_poses2[CurrentConnectedDoorWithKnob.current_door_opening][1] - ((1/2)*screen_height)
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      distance_between_player_and_grapple = find_hypotnuse(absolute_center_of_player_x - my_grapple_piston.grapple_claw_x_pos, absolute_center_of_player_y - my_grapple_piston.grapple_claw_y_pos)
      if distance_between_player_and_grapple > (34 + my_grapple_piston.maximum_extension):
        CurrentConnectedDoorWithKnob.current_door_opening = original_current_door_opening
        CurrentConnectedDoorWithKnob.GPU_current_image = CurrentConnectedDoorWithKnob.GPU_images[CurrentConnectedDoorWithKnob.current_door_opening]
        my_grapple_piston.grapple_claw_x_pos = original_grapple_x
        my_grapple_piston.grapple_claw_y_pos = original_grapple_y
        PLAYER.connected_to_which_knob = original_connected_knob
      Marker.x_pos, Marker.y_pos = my_grapple_piston.grapple_claw_x_pos, my_grapple_piston.grapple_claw_y_pos
      Marker.prev_x_pos, Marker.prev_y_pos = Marker.x_pos, Marker.y_pos
      regular_update_GrapplePiston(my_grapple_piston)
      return cur_col_grapple_points, cur_col_grapple_happened
  #
  if ALLKEYS != []:
    if KEY_GRABBED_BY_PLAYER:
      SingleKey_index = -1
      for SingleKey in ALLKEYS:
        SingleKey_index += 1
        if SingleKey.is_grabbed_by_player:
          cur_collision_points, collision_happened = find_collisions_with_offsets_with_map(MAP, my_grapple_piston, my_grapple_piston.cur_offset_x, my_grapple_piston.cur_offset_y)
          if collision_happened: # new collision with grapple piston
            if len(cur_collision_points) > 30:
              if my_grapple_piston.extension_float > my_grapple_piston.extension_float_added:
                my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
          if Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK'] and not collision_happened:
            my_grapple_piston.extension_float += my_grapple_piston.extension_float_added
          if not Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
            if my_grapple_piston.extension_float > my_grapple_piston.extension_float_added:
              my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
          regular_piston_sheath_update()
          regular_update_GrapplePiston(my_grapple_piston)
          SingleKey.x_pos, SingleKey.y_pos = np.subtract(find_tip_of_grapple_piston(my_grapple_piston), (SingleKey.rect[2]/2, SingleKey.rect[3]/2))
          if SingleKey.is_inserted_coordinate_range[0] < SingleKey.x_pos < SingleKey.is_inserted_coordinate_range[1] and SingleKey.is_inserted_coordinate_range[2] < SingleKey.y_pos < SingleKey.is_inserted_coordinate_range[3]:
            SingleKey.x_pos, SingleKey.y_pos = SingleKey.is_inserted_xy[0], SingleKey.is_inserted_xy[1]
            SingleKey.is_inserted = True
            if MAP.region == 'AntHill':
              everything_save_data(True, SingleKey_index + 1, '1')
              all_current_save_data = everything_save_data(False, 0, '')
              first_door_is_open = all_current_save_data[2][0]
              second_door_is_open = all_current_save_data[4][0]
              third_door_is_open = all_current_save_data[7][0]
              if third_door_is_open == '1':
                DOORS[5].is_open = True
                DOORS[5].is_really_open = True
                everything_save_data(True, 6, '2')
              if first_door_is_open == '1':
                everything_save_data(True, 13, '1')
              if first_door_is_open == '1' and second_door_is_open == '1':
                everything_save_data(True, 13, '2')
              if first_door_is_open == '1' and second_door_is_open == '1' and third_door_is_open == '1':
                everything_save_data(True, 13, '3')
            KEY_GRABBED_BY_PLAYER = False
            SingleKey.is_grabbed_by_player = False
            my_grapple_piston.grapple_claw_x_pos, my_grapple_piston.grapple_claw_y_pos = 0, 0
          return cur_col_grapple_points, cur_col_grapple_happened
    if my_grapple_piston.grapple_claw_x_pos == 0 or my_grapple_piston.grapple_claw_y_pos == 0:
      for SingleKey in ALLKEYS:
        if not SingleKey.is_inserted:
          if not SingleKey.cooldown_before_grabbing_again == 0:
            SingleKey.cooldown_before_grabbing_again -= 1
          if SingleKey.cooldown_before_grabbing_again == 0:
            absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
            distance_between_player_and_SingleKey = find_hypotnuse(abs(absolute_center_of_player_x - SingleKey.x_pos + ((1/2)*screen_width)), abs(absolute_center_of_player_y - SingleKey.y_pos + ((1/2)*screen_height)))
            if distance_between_player_and_SingleKey < (275 + 65 + 50):
              key_col_points, key_col_happened = find_collisions_with_offsets(my_grapple_piston, SingleKey, (-(1/2) * screen_width) - my_grapple_piston.cur_offset_x, (-(1/2) * screen_height) - my_grapple_piston.cur_offset_y)
              if key_col_happened:
                if SingleKey.is_grabbed_by_which_ant != -1:
                  if not ANTS[SingleKey.is_grabbed_by_which_ant].found_a_misplaced_object:
                    ANTS[SingleKey.is_grabbed_by_which_ant].is_returning_object = False
                    ANTS[SingleKey.is_grabbed_by_which_ant].is_searching = True
                KEY_GRABBED_BY_PLAYER = True
                SingleKey.is_grabbed_by_player = True
                SingleKey.is_grabbed_by_ant = False
                my_grapple_piston.grapple_claw_x_pos = SingleKey.x_pos + 10 - ((1/2) * screen_width)
                my_grapple_piston.grapple_claw_y_pos = SingleKey.y_pos + 10 - ((1/2) * screen_height)
                return cur_col_grapple_points, cur_col_grapple_happened
              if not key_col_happened:
                KEY_GRABBED_BY_PLAYER = False
                SingleKey.is_grabbed_by_player = False
  #
  if ELEVATORS != []:
    if MAP.region == 'TheDoor7':
      for SingleElevator in ELEVATORS:
        absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
        distance_between_player_and_PlatformLeftTop = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformLeftTop_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformLeftTop_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformLeftTop_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformLeftTop_rect[3]/2)))
        distance_between_player_and_PlatformMiddleTop = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformMiddleTop_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformMiddleTop_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformMiddleTop_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformMiddleTop_rect[3]/2)))
        distance_between_player_and_PlatformRightTop = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformRightTop_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformRightTop_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformRightTop_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformRightTop_rect[3]/2)))
        distance_between_player_and_PlatformLeftBottom = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformLeftBottom_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformLeftBottom_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformLeftBottom_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformLeftBottom_rect[3]/2)))
        distance_between_player_and_PlatformMiddleBottom = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformMiddleBottom_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformMiddleBottom_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformMiddleBottom_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformMiddleBottom_rect[3]/2)))
        distance_between_player_and_PlatformRightBottom = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformRightBottom_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformRightBottom_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformRightBottom_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformRightBottom_rect[3]/2)))
        distance_between_player_and_LeftMiddlePlatform = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.LeftMiddlePlatform_x_pos + ((1/2)*screen_width) - (SingleElevator.LeftMiddlePlatform_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.LeftMiddlePlatform_y_pos + ((1/2)*screen_height) - (SingleElevator.LeftMiddlePlatform_rect[3]/2)))
        distance_between_player_and_RightMiddlePlatform = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.RightMiddlePlatform_x_pos + ((1/2)*screen_width) - (SingleElevator.RightMiddlePlatform_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.RightMiddlePlatform_y_pos + ((1/2)*screen_height) - (SingleElevator.RightMiddlePlatform_rect[3]/2)))
        distance_between_player_and_DownPeg1 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.DownPeg1_x_pos + ((1/2)*screen_width) - (SingleElevator.DownPeg1_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.DownPeg1_y_pos + ((1/2)*screen_height) - (SingleElevator.DownPeg1_rect[3]/2)))
        distance_between_player_and_DownPeg2 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.DownPeg2_x_pos + ((1/2)*screen_width) - (SingleElevator.DownPeg2_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.DownPeg2_y_pos + ((1/2)*screen_height) - (SingleElevator.DownPeg2_rect[3]/2)))
        distance_between_player_and_DownPeg3 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.DownPeg3_x_pos + ((1/2)*screen_width) - (SingleElevator.DownPeg3_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.DownPeg3_y_pos + ((1/2)*screen_height) - (SingleElevator.DownPeg3_rect[3]/2)))
        distance_between_player_and_UpPeg1 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.UpPeg1_x_pos + ((1/2)*screen_width) - (SingleElevator.UpPeg1_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.UpPeg1_y_pos + ((1/2)*screen_height) - (SingleElevator.UpPeg1_rect[3]/2)))
        distance_between_player_and_UpPeg2 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.UpPeg2_x_pos + ((1/2)*screen_width) - (SingleElevator.UpPeg2_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.UpPeg2_y_pos + ((1/2)*screen_height) - (SingleElevator.UpPeg2_rect[3]/2)))
        distance_between_player_and_UpPeg3 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.UpPeg3_x_pos + ((1/2)*screen_width) - (SingleElevator.UpPeg3_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.UpPeg3_y_pos + ((1/2)*screen_height) - (SingleElevator.UpPeg3_rect[3]/2)))
        distance_between_player_and_UpPeg4 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.UpPeg4_x_pos + ((1/2)*screen_width) - (SingleElevator.UpPeg4_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.UpPeg4_y_pos + ((1/2)*screen_height) - (SingleElevator.UpPeg4_rect[3]/2)))
        distance_between_player_and_UpPeg5 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.UpPeg5_x_pos + ((1/2)*screen_width) - (SingleElevator.UpPeg5_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.UpPeg5_y_pos + ((1/2)*screen_height) - (SingleElevator.UpPeg5_rect[3]/2)))
        distance_between_player_and_LeftDoor = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.LeftDoor_x_pos + ((1/2)*screen_width) - (SingleElevator.LeftDoor_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.LeftDoor_y_pos + ((1/2)*screen_height) - (SingleElevator.LeftDoor_rect[3]/2)))
        distance_between_player_and_RightDoor = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.RightDoor_x_pos + ((1/2)*screen_width) - (SingleElevator.RightDoor_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.RightDoor_y_pos + ((1/2)*screen_height) - (SingleElevator.RightDoor_rect[3]/2)))
  #
  if ELEVATORS != [] and MAP.region != 'TheDoor7':
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleElevator in ELEVATORS:
      distance_between_player_and_SingleElevator = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.x_pos + ((1/2)*screen_width) - (SingleElevator.rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.y_pos + ((1/2)*screen_height) - (SingleElevator.rect[3]/2)))
      if distance_between_player_and_SingleElevator < (275 + find_hypotnuse(SingleElevator.rect[2], SingleElevator.rect[3])):
        elevator_collision_points, elevator_collision_happened = find_collisions_with_offsets(SingleElevator, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
        if elevator_collision_happened:
          if len(elevator_collision_points) > 30:
            my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
          regular_piston_sheath_update()
          regular_update_GrapplePiston(my_piston2)
          return cur_col_grapple_points, cur_col_grapple_happened
  #
  if my_grapple_piston.grapple_claw_x_pos != 0 or my_grapple_piston.grapple_claw_y_pos != 0 and my_grapple_piston.connected_to_map: # currently grappling
    if 0 < my_sheath.rotation < 180:
      if Currently_pressed_controls.pressed_controls['MOVE_LEFT']:
        PLAYER.movement_Fx -= 200
      if Currently_pressed_controls.pressed_controls['MOVE_RIGHT']:
        PLAYER.movement_Fx += 200
    if Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
      PLAYER.piston_Fx, PLAYER.piston_Fy = find_grappling_piston_force(MAP, PLAYER, my_piston2)
      if my_piston2.connected_to_lever: 
        PLAYER.piston_Fx, PLAYER.piston_Fy = 0, 0
      if not my_piston2.connected_to_lever:
        PLAYER.Fgx, PLAYER.movement_Fx, PLAYER.Fgy, PLAYER.movement_Fy = 0, 0, 0, 0
      Marker.prev_x_pos, Marker.prev_y_pos = Marker.x_pos, Marker.y_pos
      Marker.x_pos, Marker.y_pos = my_grapple_piston.grapple_claw_x_pos, my_grapple_piston.grapple_claw_y_pos
      if Marker.prev_x_pos != 0:
        if not STANDING_ON_CLOUD:
          initial_x_vel = PLAYER.x_vel
          initial_y_vel = PLAYER.y_vel
          PLAYER.x_vel = PLAYER.x_vel + (2 * (Marker.x_pos - Marker.prev_x_pos) / (1 / fps) / 300) * My_cached_info.target_fps_over_fps
          PLAYER.y_vel = PLAYER.y_vel + (2 * (Marker.y_pos - Marker.prev_y_pos) / (1 / fps) / 300) * My_cached_info.target_fps_over_fps
          x_accel = (PLAYER.x_vel - initial_x_vel) / (1 / fps)
          y_accel = (PLAYER.y_vel - initial_y_vel) / (1 / fps)
          PLAYER.Fx -= x_accel * PLAYER.mass * 3
          PLAYER.Fy -= y_accel * PLAYER.mass * 2
          orig_x_pos = PLAYER.x_pos
          orig_y_pos = PLAYER.y_pos
          PLAYER.x_pos += (Marker.x_pos - Marker.prev_x_pos)
          PLAYER.y_pos += (Marker.y_pos - Marker.prev_y_pos)
          cur_col_grapple_points, cur_col_grapple_happened = find_collisions(MAP, PLAYER)
          if cur_col_grapple_happened:
            if PLAYER.y_vel < 0:
              cur_col_grapple_points = list(set(cur_col_grapple_points))
              absolute_collision_points = [(i+PLAYER.x_pos, j+PLAYER.y_pos) for [i, j] in cur_col_grapple_points]
              pixel_colors = check_pixels_for_color_exhaustive(absolute_collision_points, (255, 255, 0, 255))
              non_yellow_points = list(set(absolute_collision_points) - set(pixel_colors))
              if non_yellow_points == []:
                cur_col_grapple_points = []
                cur_col_grapple_happened = False
              if non_yellow_points != []:
                cur_col_grapple_points = [(i - PLAYER.x_pos, j - PLAYER.y_pos) for (i, j) in non_yellow_points]
            if PLAYER.y_vel >= 0:
              cur_col_grapple_points = list(set(cur_col_grapple_points))
              absolute_collision_points = [(i+PLAYER.x_pos, j+PLAYER.y_pos) for [i, j] in cur_col_grapple_points]
              pixel_colors = check_pixels_for_color_exhaustive(absolute_collision_points, (255, 255, 0, 255))
              if pixel_colors != []:
                reduce_KEy = True
                relative_yellow_points = [(int(i - PLAYER.x_pos), int(j - PLAYER.y_pos)) for (i, j) in pixel_colors]
                ylist = [j for [i,j] in relative_yellow_points]
                max_ylist = max(ylist)
                if max_ylist < 65:
                  non_yellow_points = list(set(absolute_collision_points) - set(pixel_colors))
                  cur_col_grapple_points = [(i - PLAYER.x_pos, j - PLAYER.y_pos) for (i, j) in non_yellow_points]
                  if cur_col_grapple_points == []:
                    cur_col_grapple_happened = False
                if max_ylist >= 65 and max_ylist != 68:
                  PLAYER.y_pos += max_ylist - 68
          if cur_col_grapple_happened and not collison_with_bottom_ball_happened:
            PLAYER.x_pos, PLAYER.y_pos = orig_x_pos, orig_y_pos
            unhook_yn = unhook_grapple_piston(my_grapple_piston)
            if unhook_yn:
              for i in range(len(MY_VINES)):
                if MY_VINES[i].is_the_player_swinging:
                  if Marker.x_pos != 0:
                    PLAYER.x_vel += ((Marker.x_pos - Marker.prev_x_pos) / (1 / fps)) * 3
                    PLAYER.y_vel += ((Marker.y_pos - Marker.prev_y_pos) / (1 / fps)) * 1.8
                MY_VINES[i].is_the_player_swinging = False
              my_piston2.connected_to_map = False
              my_piston2.connected_to_vine = False
              KEY_GRABBED_BY_PLAYER = False
              for ACloud in CLOUDS:
                ACloud.connected_to_cloud = False
                ACloud.is_the_player_swinging = False
              for SingleKey in ALLKEYS:
                SingleKey.is_grabbed_by_player = False
              for SingleSquirrel in SQUIRRELS:
                if SingleSquirrel.player_grappled_to_squirrel:
                  PLAYER.x_vel += ((Marker.x_pos - Marker.prev_x_pos) / (1 / fps)) * 3
                  PLAYER.y_vel += ((Marker.y_pos - Marker.prev_y_pos) / (1 / fps)) * 1.8
                  SingleSquirrel.player_grappled_to_squirrel = False
              GRAPPLED_TO_PLATFORM = False
              Marker.x_pos, Marker.y_pos, Marker.prev_x_pos, Marker.prev_y_pos, my_piston2.grapple_claw_x_pos, my_piston2.grapple_claw_y_pos = 0, 0, 0, 0, 0, 0
              regular_piston_sheath_update()
              regular_update_GrapplePiston(my_piston2)
              my_piston1.x_pos, my_piston1.y_pos = PLAYER.x_pos - 241, PLAYER.y_pos - 241
              my_piston2.x_pos, my_piston2.y_pos = PLAYER.x_pos - 241, PLAYER.y_pos - 241
              return cur_col_grapple_points, cur_col_grapple_happened
      connect_grapple_piston_to_wall(my_grapple_piston)
      abbreviated_piston_sheath_update()
      if my_grapple_piston.extension > my_grapple_piston.maximum_extension - 10:
        my_motion_angle = find_motion_angle(MAP, PLAYER)
        my_VFx, my_VFy, trans_rights = grapple_normal_force(my_sheath.rotation, my_motion_angle)
      regular_update_GrapplePiston(my_grapple_piston)
      return cur_col_grapple_points, cur_col_grapple_happened
    if not Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
      Marker.prev_x_pos, Marker.prev_y_pos = Marker.x_pos, Marker.y_pos
      Marker.x_pos, Marker.y_pos = my_grapple_piston.grapple_claw_x_pos, my_grapple_piston.grapple_claw_y_pos
      if Marker.prev_x_pos != 0:
        if not STANDING_ON_CLOUD:
          initial_x_vel = PLAYER.x_vel
          initial_y_vel = PLAYER.y_vel
          PLAYER.x_vel = PLAYER.x_vel + (2 * (Marker.x_pos - Marker.prev_x_pos) / (1 / fps) / 300) * My_cached_info.target_fps_over_fps
          PLAYER.y_vel = PLAYER.y_vel + (2 * (Marker.y_pos - Marker.prev_y_pos) / (1 / fps) / 300) * My_cached_info.target_fps_over_fps
          x_accel = (PLAYER.x_vel - initial_x_vel) / (1 / fps)
          y_accel = (PLAYER.y_vel - initial_y_vel) / (1 / fps)
          PLAYER.Fx -= x_accel * PLAYER.mass * 3
          PLAYER.Fy -= y_accel * PLAYER.mass * 2
          orig_x_pos = PLAYER.x_pos
          orig_y_pos = PLAYER.y_pos
          PLAYER.x_pos += (Marker.x_pos - Marker.prev_x_pos)
          PLAYER.y_pos += (Marker.y_pos - Marker.prev_y_pos)
          cur_col_grapple_points, cur_col_grapple_happened = find_collisions(MAP, PLAYER)
          if cur_col_grapple_happened:
            if PLAYER.y_vel < 0:
              cur_col_grapple_points = list(set(cur_col_grapple_points))
              absolute_collision_points = [(i+PLAYER.x_pos, j+PLAYER.y_pos) for [i, j] in cur_col_grapple_points]
              pixel_colors = check_pixels_for_color_exhaustive(absolute_collision_points, (255, 255, 0, 255))
              non_yellow_points = list(set(absolute_collision_points) - set(pixel_colors))
              if non_yellow_points == []:
                cur_col_grapple_points = []
                cur_col_grapple_happened = False
              if non_yellow_points != []:
                cur_col_grapple_points = [(i - PLAYER.x_pos, j - PLAYER.y_pos) for (i, j) in non_yellow_points]
            if PLAYER.y_vel >= 0:
              cur_col_grapple_points = list(set(cur_col_grapple_points))
              absolute_collision_points = [(i+PLAYER.x_pos, j+PLAYER.y_pos) for [i, j] in cur_col_grapple_points]
              pixel_colors = check_pixels_for_color_exhaustive(absolute_collision_points, (255, 255, 0, 255))
              if pixel_colors != []:
                if abs(PLAYER.y_vel) < 50:
                  reduce_KEy = True
                relative_yellow_points = [(int(i - PLAYER.x_pos), int(j - PLAYER.y_pos)) for (i, j) in pixel_colors]
                ylist = [j for [i,j] in relative_yellow_points]
                max_ylist = max(ylist)
                if max_ylist < 65:
                  non_yellow_points = list(set(absolute_collision_points) - set(pixel_colors))
                  cur_col_grapple_points = [(i - PLAYER.x_pos, j - PLAYER.y_pos) for (i, j) in non_yellow_points]
                  if cur_col_grapple_points == []:
                    cur_col_grapple_happened = False
                if max_ylist >= 65 and max_ylist != 68:
                  PLAYER.y_pos += max_ylist - 68
          if cur_col_grapple_happened and not collison_with_bottom_ball_happened:
            PLAYER.x_pos, PLAYER.y_pos = orig_x_pos, orig_y_pos
            unhook_yn = unhook_grapple_piston(my_grapple_piston)
            if unhook_yn:
              for i in range(len(MY_VINES)):
                if MY_VINES[i].is_the_player_swinging:
                  if Marker.x_pos != 0:
                    PLAYER.x_vel += ((Marker.x_pos - Marker.prev_x_pos) / (1 / fps)) * 3
                    PLAYER.y_vel += ((Marker.y_pos - Marker.prev_y_pos) / (1 / fps)) * 1.8
                MY_VINES[i].is_the_player_swinging = False
              my_piston2.connected_to_map = False
              my_piston2.connected_to_vine = False
              KEY_GRABBED_BY_PLAYER = False
              for ACloud in CLOUDS:
                ACloud.connected_to_cloud = False
                ACloud.is_the_player_swinging = False
              for SingleKey in ALLKEYS:
                SingleKey.is_grabbed_by_player = False
              for SingleSquirrel in SQUIRRELS:
                if SingleSquirrel.player_grappled_to_squirrel:
                  PLAYER.x_vel += ((Marker.x_pos - Marker.prev_x_pos) / (1 / fps)) * 3
                  PLAYER.y_vel += ((Marker.y_pos - Marker.prev_y_pos) / (1 / fps)) * 1.8
                  SingleSquirrel.player_grappled_to_squirrel = False
              GRAPPLED_TO_PLATFORM = False
              Marker.x_pos, Marker.y_pos, Marker.prev_x_pos, Marker.prev_y_pos, my_piston2.grapple_claw_x_pos, my_piston2.grapple_claw_y_pos = 0, 0, 0, 0, 0, 0
              regular_piston_sheath_update()
              regular_update_GrapplePiston(my_piston2)
              my_piston1.x_pos, my_piston1.y_pos = PLAYER.x_pos - 241, PLAYER.y_pos - 241
              my_piston2.x_pos, my_piston2.y_pos = PLAYER.x_pos - 241, PLAYER.y_pos - 241
              return cur_col_grapple_points, cur_col_grapple_happened
      connect_grapple_piston_to_wall(my_grapple_piston)
      abbreviated_piston_sheath_update()
      if my_grapple_piston.extension > my_grapple_piston.maximum_extension:
        if my_grapple_piston.extension > my_grapple_piston.maximum_extension + 1:
          try_moving_player_closer_to_grapple(my_grapple_piston)
        my_grapple_piston.extension = my_grapple_piston.maximum_extension
        my_motion_angle = find_motion_angle(MAP, PLAYER)
        my_VFx, my_VFy, trans_rights = grapple_normal_force(my_sheath.rotation, my_motion_angle)
      regular_update_GrapplePiston(my_grapple_piston)
      return cur_col_grapple_points, cur_col_grapple_happened
#
  regular_piston_sheath_update()
  if MY_VINES != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for i in range(len(MY_VINES)):
      distance_between_player_and_SingleVine = find_hypotnuse(abs(absolute_center_of_player_x - (MY_VINES[i].x_pos - ((1/2)*screen_width) + (MY_VINES[i].rect[2]/2))), abs(absolute_center_of_player_y - (MY_VINES[i].y_pos - ((1/2)*screen_height) + (MY_VINES[i].rect[3]/2))))
      if distance_between_player_and_SingleVine <= (MY_VINES[i].radius + 275 + 5):
        vine_collision_happened, collided_segment_of_vine, cur_collision_points = find_collision_with_vine(MY_VINES[i])
        if vine_collision_happened:
          added_x_pos = round(statistics.mean([x for (x, y) in cur_collision_points]))
          added_y_pos = round(statistics.mean([y for (x, y) in cur_collision_points]))
          MY_VINES[i].grapple_added_x_pos = added_x_pos
          MY_VINES[i].grapple_added_y_pos = added_y_pos
          my_grapple_piston.connected_to_vine = True
          MY_VINES[i].is_the_player_swinging = True
          MY_VINES[i].connected_segment_of_vine = collided_segment_of_vine
          my_grapple_piston.radius_from_center_of_vine_segment = find_hypotnuse((MY_VINES[i].rect[2]/2) - added_x_pos, (MY_VINES[i].rect[3]) - added_y_pos)
          my_grapple_piston.grapple_claw_x_pos = MY_VINES[i].x_poss[collided_segment_of_vine] + (MY_VINES[i].rect[2]/2) - stop_scrolling_left + my_grapple_piston.cur_offset_x + added_x_pos
          my_grapple_piston.grapple_claw_y_pos = MY_VINES[i].y_poss[collided_segment_of_vine] + (MY_VINES[i].rect[3]/2) - stop_scrolling_top + my_grapple_piston.cur_offset_y + added_y_pos
          return cur_col_grapple_points, cur_col_grapple_happened
#
  if CLOUDS != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for i in range(len(CLOUDS)):
      distance_between_player_and_SingleCloud = find_hypotnuse(abs(absolute_center_of_player_x - (CLOUDS[i].x_pos - ((1/2)*screen_width) + (CLOUDS[i].rect[2]/2))), abs(absolute_center_of_player_y - (CLOUDS[i].y_pos - ((1/2)*screen_height) + (CLOUDS[i].rect[3]/2))))
      if distance_between_player_and_SingleCloud <= (CLOUDS[i].radius + 275 + 5):
        cloud_collision_points, cloud_collision_happened = find_collisions_with_offsets(CLOUDS[i], my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
        if cloud_collision_happened:
          my_grapple_piston.connected_to_cloud = True
          CLOUDS[i].is_the_player_swinging = True
          my_grapple_piston.grapple_claw_x_pos = my_grapple_piston.x_pos + cloud_collision_points[0][0] + my_grapple_piston.cur_offset_x
          my_grapple_piston.grapple_claw_y_pos = my_grapple_piston.y_pos + cloud_collision_points[0][1] + my_grapple_piston.cur_offset_y
          return cur_col_grapple_points, cur_col_grapple_happened
#
  if SPINNY_OBJECTS != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleSpinny in SPINNY_OBJECTS:
      distance_between_player_and_SingleSpinny = find_hypotnuse(abs(absolute_center_of_player_x - (SingleSpinny.x_pos - ((1/2)*screen_width) + (SingleSpinny.rect[2]/2))), abs(absolute_center_of_player_y - (SingleSpinny.y_pos - ((1/2)*screen_height) + (SingleSpinny.rect[3]/2))))
      if distance_between_player_and_SingleSpinny <= (SingleSpinny.radius + 275 + 5):
        SingleSpinny_collision_points, SingleSpinny_collision_happened = find_collisions_with_offsets(SingleSpinny, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
        if SingleSpinny_collision_happened:
          if len(SingleSpinny_collision_points) > 30:
            my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
          if Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
            my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
#
  if GARBAGE_CAN != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleGarbageCan in GARBAGE_CAN:
      if SingleGarbageCan.player_is_inside or SingleGarbageCan.player_is_tentatively_inside:
        distance_between_player_and_SingleGarbageCan = find_hypotnuse(abs(absolute_center_of_player_x - (SingleGarbageCan.x_pos - ((1/2)*screen_width) + (SingleGarbageCan.rect[2]/2))), abs(absolute_center_of_player_y - (SingleGarbageCan.y_pos - ((1/2)*screen_height) + (SingleGarbageCan.rect[3]/2))))
        if distance_between_player_and_SingleGarbageCan <= (SingleGarbageCan.radius + 275 + 5):
          SingleGarbageCan_collision_points, SingleGarbageCan_collision_happened = find_collisions_with_offsets(SingleGarbageCan, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
          if SingleGarbageCan_collision_happened:
            if len(SingleGarbageCan_collision_points) > 30:
              my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
            if Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
              my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
#
  if BUCKETS != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleBucket in BUCKETS:
      distance_between_player_and_SingleBucket = find_hypotnuse(abs(absolute_center_of_player_x - (SingleBucket.x_pos - ((1/2)*screen_width) + (SingleBucket.rect[2]/2))), abs(absolute_center_of_player_y - (SingleBucket.y_pos - ((1/2)*screen_height) + (SingleBucket.rect[3]/2))))
      if distance_between_player_and_SingleBucket <= (SingleBucket.radius + 275 + 5):
        SingleBucket_collision_points, SingleBucket_collision_happened = find_collisions_with_offsets(SingleBucket, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
        if SingleBucket_collision_happened:
          if len(SingleBucket_collision_points) > 30:
            my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
          if Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
            my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
#
  if ROOTS != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleRoot in ROOTS:
      if SingleRoot.is_solid:
        distance_between_player_and_SingleRoot = find_hypotnuse(abs(absolute_center_of_player_x - (SingleRoot.x_pos - ((1/2)*screen_width) + (SingleRoot.rect[2]/2))), abs(absolute_center_of_player_y - (SingleRoot.y_pos - ((1/2)*screen_height) + (SingleRoot.rect[3]/2))))
        if distance_between_player_and_SingleRoot < (275 + SingleRoot.radius + 5):
          root_collision_points, root_collision_happened = find_collisions_with_offsets(SingleRoot, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
          if root_collision_happened:
            if not SingleRoot.damaged_this_frame:
              SingleRoot.accumulated_damage += 2 * My_cached_info.target_fps_over_fps
            SingleRoot.damaged_this_frame = True
            SingleRoot.grapple_connected = True
            SingleRoot.currently_falling = True
            if (SingleRoot.time_of_contact + SingleRoot.time_to_finish_regrowth) < My_cached_info.fake_frame_counter:
              SingleRoot.time_of_contact = My_cached_info.fake_frame_counter
            my_grapple_piston.grapple_claw_x_pos = my_grapple_piston.x_pos + root_collision_points[0][0] + my_grapple_piston.cur_offset_x
            my_grapple_piston.grapple_claw_y_pos = my_grapple_piston.y_pos + root_collision_points[0][1] + my_grapple_piston.cur_offset_y
            return cur_col_grapple_points, cur_col_grapple_happened
#
  if SURF_BOARDS != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    which_surf_board = 0
    for SingleSurfBoard in SURF_BOARDS:
      distance_between_player_and_SurfBoard = find_hypotnuse(abs(absolute_center_of_player_x - (SingleSurfBoard.x_pos - ((1/2)*screen_width) + (SingleSurfBoard.rect[2]/2))), abs(absolute_center_of_player_y - (SingleSurfBoard.y_pos - ((1/2)*screen_height) + (SingleSurfBoard.rect[3]/2))))
      if distance_between_player_and_SurfBoard < (275 + SingleSurfBoard.radius + 5):
        SingleSurfBoard.current_image = rotate_square_image(SingleSurfBoard.not_rotated_current_image, SingleSurfBoard.image_rotation)
        SurfBoard_collision_points, SurfBoard_collision_happened = find_collisions_with_offsets(SingleSurfBoard, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
        if SurfBoard_collision_happened:
          PLAYER.ball_image_rotation_getting_on_surf_board = PLAYER.ball_image_rotation
          if PLAYER.surfing_check_points:
            if PLAYER.time_since_leaving_board != 0:
              PLAYER.surfing_catch_the_board = True
          my_grapple_piston.grapple_claw_x_pos = SingleSurfBoard.x_pos + SingleSurfBoard.attach_x - ((1/2)*screen_width)
          my_grapple_piston.grapple_claw_y_pos = SingleSurfBoard.y_pos + SingleSurfBoard.attach_y - ((1/2)*screen_height)
          #PLAYER.on_a_surf_board = True
          PLAYER.not_yet_on_the_board = True
          PLAYER.on_which_surf_board = which_surf_board
          return cur_col_grapple_points, cur_col_grapple_happened
      which_surf_board += 1
#
  if HAMSTER_BOX != []:
    if HAMSTER_BOX[0].boundaries[0] <= PLAYER.x_pos + (0.5 * screen_width) <= HAMSTER_BOX[0].boundaries[1]:
      if HAMSTER_BOX[0].boundaries[2] <= PLAYER.y_pos + (0.5 * screen_height) <= HAMSTER_BOX[0].boundaries[3]:
        if not HUMAN[0].eating_HamsterOs:
          absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
          for SingleBox in HAMSTER_BOX:
            if HAMSTER_BOX[0].current_milliseconds_before_picking_up_again <= 0:
              distance_between_player_and_SingleBox = find_hypotnuse(abs(absolute_center_of_player_x - (SingleBox.x_pos - ((1/2)*screen_width) + (SingleBox.rect[2]/2))), abs(absolute_center_of_player_y - (SingleBox.y_pos - ((1/2)*screen_height) + (SingleBox.rect[3]/2))))
              if distance_between_player_and_SingleBox < (275 + SingleBox.radius + 5):
                SingleBox_collision_points, SingleBox_collision_happened = find_collisions_with_offsets(SingleBox, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
                if SingleBox_collision_happened:
                  BOX_GRABBED_BY_PLAYER = True
                  HUMAN[0].following_hamster = True
                  HUMAN[0].moving_toward_HamsterOs = False
                  HAMSTER_BOX[0].held_by_player = True
                  HAMSTER_BOX[0].held_by_human = False
                  my_grapple_piston.grapple_claw_x_pos = SingleBox.x_pos + (SingleBox.rect[2]/2) - ((1/2)*screen_width)
                  my_grapple_piston.grapple_claw_y_pos = SingleBox.y_pos + (SingleBox.rect[3]/2) - ((1/2)*screen_height)
                  return cur_col_grapple_points, cur_col_grapple_happened
#
  if HUMAN != []:
    if HUMAN[0].eating_HamsterOs or HUMAN[0].in_themachine:
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for SingleHuman in HUMAN:
        if HAMSTER_BOX[0].boundaries[0] <= PLAYER.x_pos + (0.5 * screen_width) <= HAMSTER_BOX[0].boundaries[1]:
          if HAMSTER_BOX[0].boundaries[2] <= PLAYER.y_pos + (0.5 * screen_height) <= HAMSTER_BOX[0].boundaries[3]:
            if HAMSTER_BOX[0].current_milliseconds_before_picking_up_again <= 0:
              distance_between_player_and_SingleHuman = find_hypotnuse(abs(absolute_center_of_player_x - (SingleHuman.x_pos - ((1/2)*screen_width) + (SingleHuman.rect[2]/2))), abs(absolute_center_of_player_y - (SingleHuman.y_pos - ((1/2)*screen_height) + (SingleHuman.rect[3]/2))))
              if distance_between_player_and_SingleHuman < (275 + SingleHuman.radius + 5):
                SingleHuman_collision_points, SingleHuman_collision_happened = find_collisions_with_offsets(SingleHuman, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
                if SingleHuman_collision_happened:
                  BOX_GRABBED_BY_PLAYER = True
                  HUMAN[0].in_themachine = False
                  HUMAN[0].eating_HamsterOs = False
                  HUMAN[0].following_hamster = True
                  HAMSTER_BOX[0].held_by_player = True
                  HAMSTER_BOX[0].held_by_human = False
                  my_grapple_piston.grapple_claw_x_pos = SingleHuman.x_pos + (SingleHuman.rect[2]/2) - ((1/2)*screen_width)
                  my_grapple_piston.grapple_claw_y_pos = SingleHuman.y_pos + (SingleHuman.rect[3]/2) - ((1/2)*screen_height)
                  return cur_col_grapple_points, cur_col_grapple_happened
#
  if THE_MACHINE != []:
    My_cached_info.allow_glowing_green_button = False
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    if (THE_MACHINE[0].screw_stage > 2) and (THE_MACHINE[0].wire_cutter_stage > 2) and (THE_MACHINE[0].wrench_stage > 2):
      My_cached_info.allow_glowing_green_button = True
      if HUMAN[0].in_themachine:
        if THE_MACHINE[0].collision_image_index == 0:
          original_collision_image = THE_MACHINE[0].current_image
          THE_MACHINE[0].current_image = THE_MACHINE[0].green_button_images[0]
          THE_MACHINE[0].x_pos += 220
          THE_MACHINE[0].y_pos += 236
          TheMachine_collision_points, TheMachine_collision_happened = find_collisions_with_offsets(THE_MACHINE[0], my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
          THE_MACHINE[0].x_pos -= 220
          THE_MACHINE[0].y_pos -= 236
          THE_MACHINE[0].current_image = original_collision_image
          if TheMachine_collision_happened:
            My_cached_info.won_the_game = True
            return cur_col_grapple_points, cur_col_grapple_happened
#
  if DOORS != []:
    for SingleDoor in DOORS:
      if SingleDoor.door_type == 1:
        door_col_points, door_col_happened = find_collisions_with_offsets(SingleDoor, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
        if door_col_happened:
          if len(door_col_points) > 30:
            my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
          if Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
            my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
      if SingleDoor.door_type == 2:
        if not SingleDoor.is_open:
          door_col_points, door_col_happened = find_collisions_with_offsets(SingleDoor, my_grapple_piston, (1/2) * screen_width, (1/2) * screen_height)
          if door_col_happened:
            if len(door_col_points) > 30:
              my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
            if Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
              my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
#
  if TEETERTOTTERS != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for curTotter in range(len(TEETERTOTTERS)):
      distance_between_player_and_curTotter = find_hypotnuse(abs(absolute_center_of_player_x - TEETERTOTTERS[curTotter].collision_circle_x), abs(absolute_center_of_player_y - TEETERTOTTERS[curTotter].collision_circle_y))
      if distance_between_player_and_curTotter < (34 + my_grapple_piston.extension + TEETERTOTTERS[curTotter].collision_circle_radius):
        totter_col_points, totter_col_happened = find_collisions_with_offsets(TEETERTOTTERS[curTotter], my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
        if totter_col_happened:
          if len(totter_col_points) > 30:
            my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
          if Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
            my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
#
  if SQUIRRELS != []:
    for SingleSquirrel in SQUIRRELS:
      squirrel_col_points, squirrel_col_happened = find_collisions_with_offsets(SingleSquirrel, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
      if squirrel_col_happened:
        my_grapple_piston.grapple_claw_x_pos = my_grapple_piston.x_pos + squirrel_col_points[0][0] + my_grapple_piston.cur_offset_x
        my_grapple_piston.grapple_claw_y_pos = my_grapple_piston.y_pos + squirrel_col_points[0][1] + my_grapple_piston.cur_offset_y
        SingleSquirrel.player_grappled_to_squirrel = True
        return cur_col_grapple_points, cur_col_grapple_happened
#
  if FOOD != []:
    which_food = 0
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleFood in FOOD:
      if not SingleFood.being_eaten and not SingleFood.completely_eaten:
        if SingleFood.current_milliseconds_before_being_allowed_to_hold_food_again <= 0:
          distance_between_player_and_SingleFood = find_hypotnuse(abs(absolute_center_of_player_x - (SingleFood.x_pos - ((1/2)*screen_width) + (SingleFood.rect[2]/2))), abs(absolute_center_of_player_y - (SingleFood.y_pos - ((1/2)*screen_height) + (SingleFood.rect[3]/2))))
          if distance_between_player_and_SingleFood < (275 + SingleFood.radius + 5):
            SingleFood.current_image = rotate_square_image(SingleFood.image, SingleFood.image_rotation)
            SingleFood_collision_points, SingleFood_collision_happened = find_collisions_with_offsets(SingleFood, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
            if SingleFood_collision_happened:
              SingleFood.being_carried = True
              PLAYER.carrying_food = True
              PLAYER.carrying_which_food = which_food
              PLAYER.carrying_which_food_index = SingleFood.food_index
              SingleFood.x_vel = 0
              SingleFood.y_vel = 0
              my_grapple_piston.grapple_claw_x_pos = SingleFood.x_pos + (SingleFood.rect[2]/2) - ((1/2)*screen_width)
              my_grapple_piston.grapple_claw_y_pos = SingleFood.y_pos + (SingleFood.rect[3]/2) - ((1/2)*screen_height)
              return cur_col_grapple_points, cur_col_grapple_happened
      which_food += 1
#
  if LEAVES != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34 + ((1/2)*screen_width), PLAYER.y_pos + ((1/2)*screen_height) + 34
    for SingleLeaf in LEAVES:
      if SingleLeaf.grapplable:
        if SingleLeaf.currently_grapplable:
          distance_between_player_and_leaf = find_hypotnuse(abs(absolute_center_of_player_x - SingleLeaf.x_pos + SingleLeaf.rect[2]), abs(absolute_center_of_player_y - SingleLeaf.y_pos - SingleLeaf.rect[3]))
          if distance_between_player_and_leaf < (275 + SingleLeaf.radius + 5):
            leaf_col_points, leaf_col_happened = find_collisions_with_offsets(SingleLeaf, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
            if leaf_col_happened:
              SingleLeaf.player_grappled_to_leaf = True
              my_grapple_piston.grapple_claw_x_pos = my_grapple_piston.x_pos + leaf_col_points[0][0] + my_grapple_piston.cur_offset_x
              my_grapple_piston.grapple_claw_y_pos = my_grapple_piston.y_pos + leaf_col_points[0][1] + my_grapple_piston.cur_offset_y
              return cur_col_grapple_points, cur_col_grapple_happened
#
  if BOUNCIES != []:
    center_of_player_x, center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleBouncy in BOUNCIES:
      distance_between_grapple_and_SingleBouncy = find_hypotnuse(abs(center_of_player_x - SingleBouncy.collision_circle_x), abs(center_of_player_y - SingleBouncy.collision_circle_y))
      if distance_between_grapple_and_SingleBouncy < (34 + my_grapple_piston.extension + SingleBouncy.collision_circle_radius):
        bouncy_col_points, bouncy_col_happened = find_collisions_with_offsets(SingleBouncy, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
        if bouncy_col_happened:
          if len(bouncy_col_points) > 30:
            my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
          if Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
            my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
#
  if QueenAnt != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    distance_between_player_and_QueenAnt = find_hypotnuse(abs(absolute_center_of_player_x - QueenAnt.x_pos + ((1/2)*screen_width) - (QueenAnt.rect[2]/2)), abs(absolute_center_of_player_y - QueenAnt.y_pos + ((1/2)*screen_height) - (QueenAnt.rect[3]/2)))
    if distance_between_player_and_QueenAnt < (275 + 400):
      QueenAnt_collision_points, QueenAnt_collision_happened = find_collisions_with_offsets(QueenAnt, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
      if QueenAnt_collision_happened:
        if len(QueenAnt_collision_points) > 30:
          my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
        if Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
          my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
#
  if LEVERS != []:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleLever in LEVERS:
      distance_between_player_and_lever = find_hypotnuse(abs(absolute_center_of_player_x - SingleLever.x_pos + ((1/2)*screen_width) - 30), abs(absolute_center_of_player_y - SingleLever.y_pos + ((1/2)*screen_height) - 42))
      if distance_between_player_and_lever < (275 + SingleLever.radius):
        lever_collision_points, lever_collision_happened = find_collisions_with_offsets(SingleLever, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x - SingleLever.lever_added_x_pos, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y - SingleLever.lever_added_y_pos)
        if lever_collision_happened:
          my_grapple_piston.connected_to_lever = True
          my_grapple_piston.connected_to_which_lever = SingleLever.lever_index
          my_grapple_piston.grapple_claw_x_pos = SingleLever.x_pos + SingleLever.lever_added_x_pos + SingleLever.lever_xy[SingleLever.current_lever_index][0] - ((1/2)*screen_width)
          my_grapple_piston.grapple_claw_y_pos = SingleLever.y_pos + SingleLever.lever_added_y_pos + SingleLever.lever_xy[SingleLever.current_lever_index][1] - ((1/2)*screen_height)
          return cur_col_grapple_points, cur_col_grapple_happened
#
  if DOORS_WITH_KNOB != []:
    current_which_door = 0
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    for SingleDoorWithKnob in DOORS_WITH_KNOB:
      if SingleDoorWithKnob.door_png_name == 'DOOR_WITH_KNOB':
        distance_between_player_and_SingleDoorWithKnob = find_hypotnuse(abs(absolute_center_of_player_x - SingleDoorWithKnob.x_pos + ((1/2)*screen_width)), abs(absolute_center_of_player_y - SingleDoorWithKnob.y_pos + ((1/2)*screen_height)))
        if distance_between_player_and_SingleDoorWithKnob < (275 + SingleDoorWithKnob.radius):
          SingleDoorWithKnob.current_image = PyGameTextures[SingleDoorWithKnob.door_png_name][SingleDoorWithKnob.current_door_opening]
          SingleDoorWithKnob_collision_points, SingleDoorWithKnob_collision_happened = find_collisions_with_offsets(SingleDoorWithKnob, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y)
          if SingleDoorWithKnob_collision_happened:
            SingleDoorWithKnob.current_image = PyGameTextures[SingleDoorWithKnob.knob_png_name]
            Knob_collision_happened1 = False
            Knob_collision_happened2 = False
            if SingleDoorWithKnob.grapple_xy_poses1[SingleDoorWithKnob.current_door_opening] != ():
              Knob_collision_points1, Knob_collision_happened1 = find_collisions_with_offsets(SingleDoorWithKnob, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x - SingleDoorWithKnob.grapple_xy_poses1[SingleDoorWithKnob.current_door_opening][0] + 8, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y - SingleDoorWithKnob.grapple_xy_poses1[SingleDoorWithKnob.current_door_opening][1] + 8)
            if SingleDoorWithKnob.grapple_xy_poses2[SingleDoorWithKnob.current_door_opening] != ():
              Knob_collision_points2, Knob_collision_happened2 = find_collisions_with_offsets(SingleDoorWithKnob, my_grapple_piston, ((1/2) * screen_width) + my_grapple_piston.cur_offset_x - SingleDoorWithKnob.grapple_xy_poses2[SingleDoorWithKnob.current_door_opening][0] + 8, ((1/2) * screen_height) + my_grapple_piston.cur_offset_y - SingleDoorWithKnob.grapple_xy_poses2[SingleDoorWithKnob.current_door_opening][1] + 8)
            SingleDoorWithKnob.current_image = PyGameTextures[SingleDoorWithKnob.door_png_name][SingleDoorWithKnob.current_door_opening]
            if Knob_collision_happened1:
              PLAYER.connected_to_door_with_knob = True
              PLAYER.connected_to_which_knob = 1
              PLAYER.connected_to_which_door_with_knob = current_which_door
              my_grapple_piston.grapple_claw_x_pos = SingleDoorWithKnob.x_pos + SingleDoorWithKnob.grapple_xy_poses1[SingleDoorWithKnob.current_door_opening][0] - ((1/2)*screen_width)
              my_grapple_piston.grapple_claw_y_pos = SingleDoorWithKnob.y_pos + SingleDoorWithKnob.grapple_xy_poses1[SingleDoorWithKnob.current_door_opening][1] - ((1/2)*screen_height)
              return cur_col_grapple_points, cur_col_grapple_happened
            if Knob_collision_happened2:
              PLAYER.connected_to_door_with_knob = True
              PLAYER.connected_to_which_knob = 2
              PLAYER.connected_to_which_door_with_knob = current_which_door
              my_grapple_piston.grapple_claw_x_pos = SingleDoorWithKnob.x_pos + SingleDoorWithKnob.grapple_xy_poses2[SingleDoorWithKnob.current_door_opening][0] - ((1/2)*screen_width)
              my_grapple_piston.grapple_claw_y_pos = SingleDoorWithKnob.y_pos + SingleDoorWithKnob.grapple_xy_poses2[SingleDoorWithKnob.current_door_opening][1] - ((1/2)*screen_height)
              return cur_col_grapple_points, cur_col_grapple_happened
            else:
              if SingleDoorWithKnob.current_door_opening == 4:
                if len(SingleDoorWithKnob_collision_points) > 30:
                  my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
                if Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
                  my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
      current_which_door += 1
#
  if not ON_AN_ELEVATOR:
    #cur_collision_points, collision_happened = find_collisions(MAP, my_grapple_piston)
    cur_collision_points, collision_happened = find_collisions_with_offsets_with_map(MAP, my_grapple_piston, my_grapple_piston.cur_offset_x, my_grapple_piston.cur_offset_y)
  if ON_AN_ELEVATOR:
    collision_happened = False
  if not collision_happened: # no collision with grapple piston
    if my_grapple_piston.extension < my_grapple_piston.maximum_extension:
      my_grapple_piston.extension_float += my_grapple_piston.extension_float_added
    regular_update_GrapplePiston(my_grapple_piston)
    return cur_col_grapple_points, cur_col_grapple_happened
  if collision_happened: # new collision with grapple piston
    my_grapple_piston.connected_to_map = True
    if len(cur_collision_points) > 30:
      my_grapple_piston.extension_float -= my_grapple_piston.extension_float_added
    absolute_collision_points = get_absolute_positions(cur_collision_points, my_grapple_piston)
    red_x, red_y = check_pixels_for_color(absolute_collision_points, (255, 0, 0, 255))
    if red_x == 0 and red_y == 0:
      yellow_x, yellow_y = check_pixels_for_color(absolute_collision_points, (255, 255, 0, 255))
      if yellow_x != 0 or yellow_y != 0:
        red_x, red_y = yellow_x, yellow_y
        GRAPPLED_TO_PLATFORM = True
    if red_x != 0 or red_y != 0:
      my_grapple_piston.grapple_claw_x_pos, my_grapple_piston.grapple_claw_y_pos = red_x, red_y
    regular_update_GrapplePiston(my_grapple_piston)
  return cur_col_grapple_points, cur_col_grapple_happened


def find_next_vine_rotation(cur_vine):
  cur_vine.time_since_resetting += delta_milliseconds
  angular_velocity_before_frame = cur_vine.angular_vel
  rotation_before_frame = cur_vine.rotation
  cur_vine.rotations.insert(0, cur_vine.rotation)
  cur_vine.rotations = cur_vine.rotations[:-1]
  cur_vine.angular_accel = 0
  if (270 < cur_vine.rotation <= 360 or 0 <= cur_vine.rotation < 90) and cur_vine.angular_vel > 0:
    cur_vine.angular_accel = -cur_vine.max_angular_accel
    if cur_vine.time_since_resetting > 200:
      cur_vine.reached_pos = True
  if (270 < cur_vine.rotation <= 360 or 0 <= cur_vine.rotation < 90) and cur_vine.angular_vel < 0:
    cur_vine.angular_accel = -cur_vine.max_angular_accel
    if cur_vine.time_since_resetting > 200:
      cur_vine.reached_pos = True
  if 90 < cur_vine.rotation < 270 and cur_vine.angular_vel < 0:
    cur_vine.angular_accel = cur_vine.max_angular_accel
    if cur_vine.time_since_resetting > 200:
      cur_vine.reached_neg = True
  if 90 < cur_vine.rotation < 270 and cur_vine.angular_vel > 0:
    cur_vine.angular_accel = cur_vine.max_angular_accel
    if cur_vine.time_since_resetting > 200:
      cur_vine.reached_neg = True
  cur_vine.angular_vel = cur_vine.angular_vel + (cur_vine.angular_accel * (1 / fps))
  cur_vine.rotation = (cur_vine.rotation + (cur_vine.angular_vel * (1 / fps) + ((1 / 2) * cur_vine.angular_accel * (1 / fps)**2))) % 360
  for _ in range(1):
    if cur_vine.allow_reset:
      rotation_difference_between_frames = abs(rotation_before_frame - cur_vine.rotation)
      if cur_vine.orig_rotation - rotation_difference_between_frames <= rotation_before_frame <= cur_vine.orig_rotation + rotation_difference_between_frames:
        if (cur_vine.orig_angular_vel > 0) and (cur_vine.angular_vel < 0):
          continue
        if (cur_vine.orig_angular_vel < 0) and (cur_vine.angular_vel > 0):
          continue
        cur_vine.angular_vel = cur_vine.orig_angular_vel
        #cur_vine.rotation = cur_vine.orig_rotation
        cur_vine.reached_neg = False
        cur_vine.reached_pos = False
        cur_vine.allow_reset = False
        cur_vine.time_since_resetting = 0
  if cur_vine.reached_pos and cur_vine.reached_neg:
    cur_vine.allow_reset = True


def find_rotated_vine_positions(cur_vine):
  for i in range(cur_vine.vine_length):
    if cur_vine.rotations[i] == 0:
      cur_vine.x_poss[i] = cur_vine.x_poss[0] + (cur_vine.vine_segment_length * i)
      cur_vine.y_poss[i] = cur_vine.y_poss[0] + (0 * i)
    if 0 < cur_vine.rotations[i] < 90:
      cur_vine.x_poss[i] = cur_vine.x_poss[0] + (cur_vine.vine_segment_length * i * math.cos(math.radians(cur_vine.rotations[i] % 90)))
      cur_vine.y_poss[i] = cur_vine.y_poss[0] - (cur_vine.vine_segment_length * i * math.sin(math.radians(cur_vine.rotations[i] % 90)))
    if cur_vine.rotations[i] == 90:
      cur_vine.x_poss[i] = cur_vine.x_poss[0] - (0 * i)
      cur_vine.y_poss[i] = cur_vine.y_poss[0] - (0 * i)
    if 90 < cur_vine.rotations[i] < 180:
      cur_vine.x_poss[i] = cur_vine.x_poss[0] - (cur_vine.vine_segment_length * i * math.sin(math.radians(cur_vine.rotations[i] % 90)))
      cur_vine.y_poss[i] = cur_vine.y_poss[0] - (cur_vine.vine_segment_length * i * math.cos(math.radians(cur_vine.rotations[i] % 90)))
    if cur_vine.rotations[i] == 180:
      cur_vine.x_poss[i] = cur_vine.x_poss[0] - (cur_vine.vine_segment_length * i)
      cur_vine.y_poss[i] = cur_vine.y_poss[0] + (0 * i)
    if 180 < cur_vine.rotations[i] < 270:
      cur_vine.x_poss[i] = cur_vine.x_poss[0] - (cur_vine.vine_segment_length * i * math.cos(math.radians(cur_vine.rotations[i] % 90)))
      cur_vine.y_poss[i] = cur_vine.y_poss[0] + (cur_vine.vine_segment_length * i * math.sin(math.radians(cur_vine.rotations[i] % 90)))
    if cur_vine.rotations[i] == 270:
      cur_vine.x_poss[i] = cur_vine.x_poss[0] + (0 * i)
      cur_vine.y_poss[i] = cur_vine.y_poss[0] + (cur_vine.vine_segment_length * i)
    if 270 < cur_vine.rotations[i] < 360:
      cur_vine.x_poss[i] = cur_vine.x_poss[0] + (cur_vine.vine_segment_length * i * math.sin(math.radians(cur_vine.rotations[i] % 90)))
      cur_vine.y_poss[i] = cur_vine.y_poss[0] + (cur_vine.vine_segment_length * i * math.cos(math.radians(cur_vine.rotations[i] % 90)))


def find_collision_with_vine(current_vine):
  cur_collision_points = []
  for i in range(current_vine.vine_length):
    cur_collision_points, cur_collision_happened = find_vine_collisions_with_offsets(current_vine, i, my_piston2, stop_scrolling_left + my_piston2.cur_offset_x, stop_scrolling_top + my_piston2.cur_offset_y)
    if cur_collision_happened:
      return True, i, cur_collision_points
  return False, 666, cur_collision_points


def find_vine_collisions_with_offsets(object1, my_current_vine_index, object2, additional_offset_x, additional_offset_y): # vine is object 1
  object1.masks[my_current_vine_index] = pygame.mask.from_surface(object1.current_images[my_current_vine_index])
  impact_points = []
  collision_happened = False
  offset_x, offset_y = (object1.x_poss[my_current_vine_index] - object2.x_pos - additional_offset_x), (object1.y_poss[my_current_vine_index] - object2.y_pos - additional_offset_y)
  if object2.mask.overlap(object1.masks[my_current_vine_index], (round(offset_x), round(offset_y))):
    impact_points.append(object1.masks[my_current_vine_index].overlap_mask(object2.mask, (-round(offset_x), -round(offset_y))).outline(10))
    collision_happened = True
  else:
    impact_points.append(False)
  return impact_points[0], collision_happened


def get_absolute_positions(my_list_of_tuples, my_object):
  return [[int(a + my_object.x_pos), int(b + my_object.y_pos)] for (a,b) in my_list_of_tuples]


def check_pixels_for_color(list_of_pixel_points, desired_color):
  for i, j in list_of_pixel_points:
    if MAP.image.get_at((i + int(my_piston2.cur_offset_x), j + int(my_piston2.cur_offset_y))) == desired_color:
      return i + int(my_piston2.cur_offset_x), j + int(my_piston2.cur_offset_y)
  return 0, 0


def check_pixels_for_color_exhaustive(list_of_pixel_points, desired_color):
  desired_color_points = []
  for i, j in list_of_pixel_points:
    cur_color = MAP.image.get_at((int(round(i)), int(round(j))))
    if cur_color == desired_color:
      desired_color_points.append((i, j))
      continue
    if cur_color != desired_color:
      continue
  return desired_color_points
    

def find_slope(map, object, avg_impact_x, avg_impact_y):
  relative_x, relative_y = -(34 - avg_impact_x), -(34 - avg_impact_y)
  try:
    dydx = relative_x / (math.sqrt(34**2 - relative_x**2))
    return dydx
  except:
    if relative_x > 0:
      return 9999
    if relative_x < 0:
      return -9999


def find_angle_between_points(x1, y1, x2, y2):
  return math.degrees(math.atan2(y2 - y1, x2 - x1))%360


def calculate_bubbles():
  PLAYER.milliseconds_since_last_bubble += delta_milliseconds
  if PLAYER.milliseconds_since_last_bubble >= PLAYER.milliseconds_until_next_bubble:
    PLAYER.milliseconds_since_last_bubble %= PLAYER.milliseconds_until_next_bubble
    if PLAYER.how_submerged >= 69:
      if PLAYER.current_number_of_bubbles > 0:
        PLAYER.current_number_of_bubbles -= 1
        return
    else:
      if PLAYER.current_number_of_bubbles < PLAYER.max_number_of_bubbles:
        PLAYER.current_number_of_bubbles += 1
        return


def update_physics():
###
  calculate_bubbles()
  if PLAYER.in_a_pipe or PLAYER.on_a_surf_board or PLAYER.not_yet_on_the_board:
    PLAYER.prev_x_pos.append(PLAYER.x_pos)
    PLAYER.prev_y_pos.append(PLAYER.y_pos)
    PLAYER.prev_x_pos.remove(PLAYER.prev_x_pos[0])
    PLAYER.prev_y_pos.remove(PLAYER.prev_y_pos[0])
    if PLAYER.on_a_surf_board:
      PLAYER.x_pos = SURF_BOARDS[PLAYER.on_which_surf_board].x_pos + 36 - ((1/2)*screen_width)
      PLAYER.y_pos = SURF_BOARDS[PLAYER.on_which_surf_board].y_pos + 36 - ((1/2)*screen_height)
    return
  if ((collision_happened and not leaving_a_wall and ((my_piston2.grapple_claw_x_pos == 0 and my_piston2.grapple_claw_y_pos == 0) or KEY_GRABBED_BY_PLAYER or PLAYER.carrying_food) and abs(PLAYER.water_Fx) <= 200 and abs(PLAYER.water_Fy) <= 400) or STANDING_ON_TEETERTOTTER) and not TOUCHED_ROOT and ((PLAYER.how_submerged == 0) or (PLAYER.how_submerged != 0 and not Currently_pressed_controls.pressed_controls['FLOAT_UP'])):
    adjust_up = True
    dydx = find_slope(MAP, PLAYER, avg_impact_x, avg_impact_y)
    if -1 <= dydx < 0 and  0 < normal_force_angle <  90: # on slope like this: \
      current_motion_angle = find_motion_angle(MAP, PLAYER)
      desired_theta = 180 + math.degrees(math.atan(dydx))
#
      if desired_theta - 30 < current_motion_angle < desired_theta + 30: # moving left on \
        slow_down = False
        speed_up = False
        lift_off = False
        if PLAYER.piston_Fx != 0 or PLAYER.piston_Fy != 0:
          if ((desired_theta - 180 - 30)%360 < (my_sheath.rotation)%360 <= 360) or (0 <= (my_sheath.rotation)%360 <= (desired_theta - 90)%360):
            speed_up = True
          if (desired_theta - 90)%360 <= (my_sheath.rotation)%360 < (desired_theta + 30)%360:
            slow_down = True
          if (desired_theta + 30)%360 < (my_sheath.rotation)%360 < (desired_theta - 180 - 30)%360:
            lift_off = True
        piston_x_accel = 0
        cur_cos = math.cos(math.radians(desired_theta))
        cur_sin = math.sin(math.radians(desired_theta))
        PLAYER.Fx = (PLAYER.mass * (my_gravity / 6) * cur_cos)
        PLAYER.Fy = (PLAYER.mass * (my_gravity / 6)) - (PLAYER.mass * (my_gravity / 6) * cur_sin)
        total_force = find_hypotnuse(PLAYER.Fx, PLAYER.Fy) * (180 - desired_theta) / 10
        if slow_down:
          total_force += abs(find_hypotnuse(PLAYER.piston_Fx + PLAYER.FNx, PLAYER.piston_Fy + PLAYER.FNy) * math.cos(math.radians(abs(((my_sheath.rotation)%360) - (desired_theta + 180)%360))) / 5)
        if speed_up:
          total_force -= abs(find_hypotnuse(PLAYER.piston_Fx + PLAYER.FNx, PLAYER.piston_Fy + PLAYER.FNy) * math.cos(math.radians(abs(((my_sheath.rotation)%360) - (desired_theta + 180)%360))) / 5)
        if Currently_pressed_controls.pressed_controls['MOVE_LEFT']:
          PLAYER.Hamster_activities_during_frame.append('Walk_Left')
          total_force -= 200
        if Currently_pressed_controls.pressed_controls['MOVE_RIGHT']:
          PLAYER.Hamster_activities_during_frame.append('Walk_Right')
          total_force += 200
        PLAYER.Fx = total_force * cur_cos
        PLAYER.Fy = total_force * cur_sin
        PLAYER.x_accel = PLAYER.Fx / PLAYER.mass
        PLAYER.y_accel = PLAYER.Fy / PLAYER.mass
        total_accel = find_hypotnuse(PLAYER.x_accel, PLAYER.y_accel)
        if total_force > 0:
          PLAYER.x_accel = abs(total_accel * cur_cos)
          PLAYER.y_accel = abs(total_accel * cur_sin)
        if total_force < 0:
          PLAYER.x_accel = -abs(total_accel * cur_cos)
          PLAYER.y_accel = -abs(total_accel * cur_sin)
        PLAYER.x_vel = PLAYER.x_vel + (PLAYER.x_accel * (1 / fps))
        PLAYER.y_vel = PLAYER.y_vel + (PLAYER.y_accel * (1 / fps))
        total_vel = find_hypotnuse(PLAYER.x_vel, PLAYER.y_vel)
        if abs(total_vel) > maximum_velocity_x:
          total_vel = maximum_velocity_x
        PLAYER.x_vel = -abs(total_vel * cur_cos)
        PLAYER.y_vel = -abs(total_vel * cur_sin)
        if -3 < PLAYER.x_vel: # change directions
          PLAYER.x_vel = 3.01
          PLAYER.y_vel = abs(PLAYER.y_vel)
        PLAYER.x_pos = PLAYER.x_pos + (PLAYER.x_vel * (1 /fps)) + ((1 / 2) * PLAYER.x_accel * (1 / fps)**2)
        PLAYER.y_pos = PLAYER.y_pos + (PLAYER.y_vel * (1 /fps)) + ((1 / 2) * PLAYER.y_accel * (1 / fps)**2)
        if lift_off:
          piston_x_accel = (PLAYER.piston_Fx + PLAYER.FNx) / PLAYER.mass
          piston_y_accel = (PLAYER.piston_Fy + PLAYER.FNy) / PLAYER.mass
          piston_x_vel = (piston_x_accel * (1 / fps))
          piston_y_vel = (piston_y_accel * (1 / fps))
          PLAYER.x_pos = PLAYER.x_pos + (piston_x_vel * (1 /fps)) + ((1 / 2) * piston_x_accel * (1 / fps)**2)
          PLAYER.y_pos = PLAYER.y_pos + (piston_y_vel * (1 /fps)) + ((1 / 2) * piston_y_accel * (1 / fps)**2)
        if not lift_off:
          if not STANDING_ON_TEETERTOTTER:
            brief_list_of_collisions, brief_collision_happened = find_collisions(MAP, PLAYER)
          if STANDING_ON_TEETERTOTTER:
            brief_list_of_collisions, brief_collision_happened = find_collisions_with_offsets(TEETERTOTTERS[STANDING_ON_WHICH_TEETERTOTTER], PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          original_y_pos = PLAYER.y_pos
          number_of_iterations_up = 0
          if not brief_collision_happened:
            while not brief_collision_happened: # don't float above slope
              adjust_up = False
              if piston_x_accel != 0:
                break
              PLAYER.y_pos += 1
              if not STANDING_ON_TEETERTOTTER:
                brief_list_of_collisions, brief_collision_happened = find_collisions(MAP, PLAYER)
              if STANDING_ON_TEETERTOTTER:
                brief_list_of_collisions, brief_collision_happened = find_collisions_with_offsets(TEETERTOTTERS[STANDING_ON_WHICH_TEETERTOTTER], PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          if brief_collision_happened and adjust_up:
            while brief_collision_happened: # don't float above slope
              number_of_iterations_up += 1
              if number_of_iterations_up == 20:
                break
              if piston_x_accel != 0:
                break
              PLAYER.y_pos -= 1
              if not STANDING_ON_TEETERTOTTER:
                brief_list_of_collisions, brief_collision_happened = find_collisions(MAP, PLAYER)
              if STANDING_ON_TEETERTOTTER:
                brief_list_of_collisions, brief_collision_happened = find_collisions_with_offsets(TEETERTOTTERS[STANDING_ON_WHICH_TEETERTOTTER], PLAYER, (1/2) * screen_width, (1/2) * screen_height)
            PLAYER.y_pos += 1
            PLAYER.y_pos = math.ceil(PLAYER.y_pos)
          if number_of_iterations_up == 20:
            PLAYER.y_pos = original_y_pos
        PLAYER.prev_slope_angle = desired_theta
        PLAYER.prev_x_pos.append(PLAYER.x_pos)
        PLAYER.prev_y_pos.append(PLAYER.y_pos)
        PLAYER.prev_x_pos.remove(PLAYER.prev_x_pos[0])
        PLAYER.prev_y_pos.remove(PLAYER.prev_y_pos[0])
        return
#
      if desired_theta - 30 < (current_motion_angle - 180) < desired_theta + 30: # moving right on \
        slow_down = False
        speed_up = False
        lift_off = False
        if PLAYER.piston_Fx != 0 or PLAYER.piston_Fy != 0:
          if ((desired_theta - 180 - 30)%360 < (my_sheath.rotation)%360 <= 360) or (0 <= (my_sheath.rotation)%360 <= (desired_theta - 90)%360):
            slow_down = True
          if (desired_theta - 90)%360 <= (my_sheath.rotation)%360 < (desired_theta + 30)%360:
            speed_up = True
          if (desired_theta + 30)%360 < (my_sheath.rotation)%360 < (desired_theta - 180 - 30)%360:
            lift_off = True
        piston_x_accel = 0
        cur_cos = math.cos(math.radians(desired_theta))
        cur_sin = math.sin(math.radians(desired_theta))
        PLAYER.Fx = (PLAYER.mass * (my_gravity / 6) * cur_cos)
        PLAYER.Fy = (PLAYER.mass * (my_gravity / 6)) - (PLAYER.mass * (my_gravity / 6) * cur_sin)
        total_force = find_hypotnuse(PLAYER.Fx, PLAYER.Fy) * (180 - desired_theta) / 10
        if slow_down:
          total_force -= abs(find_hypotnuse(PLAYER.piston_Fx + PLAYER.FNx, PLAYER.piston_Fy + PLAYER.FNy) * math.cos(math.radians(abs(((my_sheath.rotation)%360) - (desired_theta + 180)%360))) / 5)
        if speed_up:
          total_force += abs(find_hypotnuse(PLAYER.piston_Fx + PLAYER.FNx, PLAYER.piston_Fy + PLAYER.FNy) * math.cos(math.radians(abs(((my_sheath.rotation)%360) - (desired_theta + 180)%360))) / 5)
        if Currently_pressed_controls.pressed_controls['MOVE_LEFT']:
          PLAYER.Hamster_activities_during_frame.append('Walk_Left')
          total_force -= 200
        if Currently_pressed_controls.pressed_controls['MOVE_RIGHT']:
          PLAYER.Hamster_activities_during_frame.append('Walk_Right')
          total_force += 200
        PLAYER.Fx = total_force * cur_cos
        PLAYER.Fy = total_force * cur_sin
        PLAYER.x_accel = PLAYER.Fx / PLAYER.mass
        PLAYER.y_accel = PLAYER.Fy / PLAYER.mass
        total_accel = find_hypotnuse(PLAYER.x_accel, PLAYER.y_accel)
        if total_force > 0:
          PLAYER.x_accel = abs(total_accel * cur_cos)
          PLAYER.y_accel = abs(total_accel * cur_sin)
        if total_force < 0:
          PLAYER.x_accel = -abs(total_accel * cur_cos)
          PLAYER.y_accel = -abs(total_accel * cur_sin)
        PLAYER.x_vel = PLAYER.x_vel + (PLAYER.x_accel * (1 / fps))
        PLAYER.y_vel = PLAYER.y_vel + (PLAYER.y_accel * (1 / fps))
        total_vel = find_hypotnuse(PLAYER.x_vel, PLAYER.y_vel)
        if abs(total_vel) > maximum_velocity_x + 200:
          total_vel = maximum_velocity_x + 200
        PLAYER.x_vel = abs(total_vel * cur_cos)
        PLAYER.y_vel = abs(total_vel * cur_sin)
        if PLAYER.x_vel < 3: # change directions
          PLAYER.x_vel = -3.01
          PLAYER.y_vel = -abs(PLAYER.y_vel)
        PLAYER.x_pos = PLAYER.x_pos + (PLAYER.x_vel * (1 /fps)) + ((1 / 2) * PLAYER.x_accel * (1 / fps)**2)
        PLAYER.y_pos = PLAYER.y_pos + (PLAYER.y_vel * (1 /fps)) + ((1 / 2) * PLAYER.y_accel * (1 / fps)**2)
        if lift_off:
          piston_x_accel = (PLAYER.piston_Fx + PLAYER.FNx) / PLAYER.mass
          piston_y_accel = (PLAYER.piston_Fy + PLAYER.FNy) / PLAYER.mass
          piston_x_vel = (piston_x_accel * (1 / fps))
          piston_y_vel = (piston_y_accel * (1 / fps))
          PLAYER.x_pos = PLAYER.x_pos + (piston_x_vel * (1 /fps)) + ((1 / 2) * piston_x_accel * (1 / fps)**2)
          PLAYER.y_pos = PLAYER.y_pos + (piston_y_vel * (1 /fps)) + ((1 / 2) * piston_y_accel * (1 / fps)**2)
        if not lift_off:
          if not STANDING_ON_TEETERTOTTER:
            brief_list_of_collisions, brief_collision_happened = find_collisions(MAP, PLAYER)
          if STANDING_ON_TEETERTOTTER:
            brief_list_of_collisions, brief_collision_happened = find_collisions_with_offsets(TEETERTOTTERS[STANDING_ON_WHICH_TEETERTOTTER], PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          original_y_pos = PLAYER.y_pos
          number_of_iterations_up = 0
          if not brief_collision_happened:
            while not brief_collision_happened: # don't float above slope
              adjust_up = False
              if piston_x_accel != 0:
                break
              PLAYER.y_pos += 1
              if not STANDING_ON_TEETERTOTTER:
                brief_list_of_collisions, brief_collision_happened = find_collisions(MAP, PLAYER)
              if STANDING_ON_TEETERTOTTER:
                brief_list_of_collisions, brief_collision_happened = find_collisions_with_offsets(TEETERTOTTERS[STANDING_ON_WHICH_TEETERTOTTER], PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          if brief_collision_happened and adjust_up:
            while brief_collision_happened: # don't float above slope
              number_of_iterations_up += 1
              if number_of_iterations_up == 20:
                break
              if piston_x_accel != 0:
                break
              PLAYER.y_pos -= 1
              if not STANDING_ON_TEETERTOTTER:
                brief_list_of_collisions, brief_collision_happened = find_collisions(MAP, PLAYER)
              if STANDING_ON_TEETERTOTTER:
                brief_list_of_collisions, brief_collision_happened = find_collisions_with_offsets(TEETERTOTTERS[STANDING_ON_WHICH_TEETERTOTTER], PLAYER, (1/2) * screen_width, (1/2) * screen_height)
            PLAYER.y_pos += 1
            PLAYER.y_pos = math.ceil(PLAYER.y_pos)
          if number_of_iterations_up == 20:
            PLAYER.y_pos = original_y_pos
        PLAYER.prev_slope_angle = desired_theta
        PLAYER.prev_x_pos.append(PLAYER.x_pos)
        PLAYER.prev_y_pos.append(PLAYER.y_pos)
        PLAYER.prev_x_pos.remove(PLAYER.prev_x_pos[0])
        PLAYER.prev_y_pos.remove(PLAYER.prev_y_pos[0])
        return
#
    if 1 >= dydx > 0 and 90 < normal_force_angle < 180: # on slope like this: /
      current_motion_angle = find_motion_angle(MAP, PLAYER)
      desired_theta = math.degrees(math.atan(dydx))
      if (desired_theta - 30 < current_motion_angle < desired_theta + 30 or desired_theta - 30 < current_motion_angle - 360 < desired_theta + 30) and current_motion_angle != 180: # moving right on /
        slow_down = False
        speed_up = False
        lift_off = False
        if PLAYER.piston_Fx != 0 or PLAYER.piston_Fy != 0:
          if desired_theta >= 30:
            if ((desired_theta + 180 + 30)%360 <= my_sheath.rotation%360 <= 360) or (0 <= my_sheath.rotation%360 <= (desired_theta - 30)%360):
              lift_off = True
            if (desired_theta - 30)%360 < my_sheath.rotation%360 < (desired_theta + 90)%360:
              slow_down = True
            if (desired_theta + 90)%360 < my_sheath.rotation%360 < (desired_theta + 180 + 30)%360:
              speed_up = True
          if desired_theta < 30:
            if (desired_theta + 180 + 30)%360 <= my_sheath.rotation%360 <= (desired_theta - 30)%360:
              lift_off = True
            if ((desired_theta - 30)%360 < my_sheath.rotation%360 <= 360) or (0 < my_sheath.rotation%360 < (desired_theta + 90)%360):
              slow_down = True
            if (desired_theta + 90)%360 < my_sheath.rotation%360 < (desired_theta + 180 + 30)%360:
              speed_up = True
        piston_x_accel = 0
        cur_cos = math.cos(math.radians(desired_theta))
        cur_sin = math.sin(math.radians(desired_theta))
        PLAYER.Fx = (PLAYER.mass * (my_gravity / 6) * cur_cos)
        PLAYER.Fy = (PLAYER.mass * (my_gravity / 6)) - (PLAYER.mass * (my_gravity / 6) * cur_sin)
        total_force = find_hypotnuse(PLAYER.Fx, PLAYER.Fy) * (desired_theta % 90) / 10
        if slow_down:
          total_force += abs(find_hypotnuse(PLAYER.piston_Fx + PLAYER.FNx, PLAYER.piston_Fy + PLAYER.FNy) * math.cos(math.radians(abs(((my_sheath.rotation)%360) - (desired_theta + 180)%360))) / 5)
        if speed_up:
          total_force -= abs(find_hypotnuse(PLAYER.piston_Fx + PLAYER.FNx, PLAYER.piston_Fy + PLAYER.FNy) * math.cos(math.radians(abs(((my_sheath.rotation)%360) - (desired_theta + 180)%360))) / 5)
        if Currently_pressed_controls.pressed_controls['MOVE_LEFT']:
          PLAYER.Hamster_activities_during_frame.append('Walk_Left')
          total_force += 200
        if Currently_pressed_controls.pressed_controls['MOVE_RIGHT']:
          PLAYER.Hamster_activities_during_frame.append('Walk_Right')
          total_force -= 200
        PLAYER.Fx = total_force * cur_cos
        PLAYER.Fy = total_force * cur_sin
        PLAYER.x_accel = PLAYER.Fx / PLAYER.mass
        PLAYER.y_accel = PLAYER.Fy / PLAYER.mass
        total_accel = find_hypotnuse(PLAYER.x_accel, PLAYER.y_accel)
        if total_force > 0:
          PLAYER.x_accel = -abs(total_accel * cur_cos)
          PLAYER.y_accel = abs(total_accel * cur_sin)
        if total_force < 0:
          PLAYER.x_accel = abs(total_accel * cur_cos)
          PLAYER.y_accel = -abs(total_accel * cur_sin)
        PLAYER.x_vel = PLAYER.x_vel + (PLAYER.x_accel * (1 / fps))
        PLAYER.y_vel = PLAYER.y_vel + (PLAYER.y_accel * (1 / fps))
        total_vel = find_hypotnuse(PLAYER.x_vel, PLAYER.y_vel)
        if abs(total_vel) > maximum_velocity_x:
          total_vel = maximum_velocity_x
        PLAYER.x_vel = abs(total_vel * cur_cos)
        PLAYER.y_vel = -abs(total_vel * cur_sin)
        if PLAYER.x_vel < 3: # change directions
          PLAYER.x_vel = -3.01
          PLAYER.y_vel = abs(PLAYER.y_vel)
        PLAYER.x_pos = PLAYER.x_pos + (PLAYER.x_vel * (1 /fps)) + ((1 / 2) * PLAYER.x_accel * (1 / fps)**2)
        PLAYER.y_pos = PLAYER.y_pos + (PLAYER.y_vel * (1 /fps)) + ((1 / 2) * PLAYER.y_accel * (1 / fps)**2)
        if lift_off:
          piston_x_accel = (PLAYER.piston_Fx + PLAYER.FNx) / PLAYER.mass
          piston_y_accel = (PLAYER.piston_Fy + PLAYER.FNy) / PLAYER.mass
          piston_x_vel = (piston_x_accel * (1 / fps))
          piston_y_vel = (piston_y_accel * (1 / fps))
          PLAYER.x_pos = PLAYER.x_pos + (piston_x_vel * (1 /fps)) + ((1 / 2) * piston_x_accel * (1 / fps)**2)
          PLAYER.y_pos = PLAYER.y_pos + (piston_y_vel * (1 /fps)) + ((1 / 2) * piston_y_accel * (1 / fps)**2)
        if not lift_off:
          if not STANDING_ON_TEETERTOTTER:
            brief_list_of_collisions, brief_collision_happened = find_collisions(MAP, PLAYER)
          if STANDING_ON_TEETERTOTTER:
            brief_list_of_collisions, brief_collision_happened = find_collisions_with_offsets(TEETERTOTTERS[STANDING_ON_WHICH_TEETERTOTTER], PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          original_y_pos = PLAYER.y_pos
          number_of_iterations_up = 0
          if not brief_collision_happened:
            while not brief_collision_happened: # don't float above slope
              adjust_up = False
              if piston_x_accel != 0:
                break
              PLAYER.y_pos += 1
              if not STANDING_ON_TEETERTOTTER:
                brief_list_of_collisions, brief_collision_happened = find_collisions(MAP, PLAYER)
              if STANDING_ON_TEETERTOTTER:
                brief_list_of_collisions, brief_collision_happened = find_collisions_with_offsets(TEETERTOTTERS[STANDING_ON_WHICH_TEETERTOTTER], PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          if brief_collision_happened and adjust_up:
            while brief_collision_happened: # don't float above slope
              number_of_iterations_up += 1
              if number_of_iterations_up == 20:
                break
              if piston_x_accel != 0:
                break
              PLAYER.y_pos -= 1
              if not STANDING_ON_TEETERTOTTER:
                brief_list_of_collisions, brief_collision_happened = find_collisions(MAP, PLAYER)
              if STANDING_ON_TEETERTOTTER:
                brief_list_of_collisions, brief_collision_happened = find_collisions_with_offsets(TEETERTOTTERS[STANDING_ON_WHICH_TEETERTOTTER], PLAYER, (1/2) * screen_width, (1/2) * screen_height)
            PLAYER.y_pos += 1
            PLAYER.y_pos = math.ceil(PLAYER.y_pos)
          if number_of_iterations_up == 20:
            PLAYER.y_pos = original_y_pos
        PLAYER.prev_slope_angle = desired_theta
        PLAYER.prev_x_pos.append(PLAYER.x_pos)
        PLAYER.prev_y_pos.append(PLAYER.y_pos)
        PLAYER.prev_x_pos.remove(PLAYER.prev_x_pos[0])
        PLAYER.prev_y_pos.remove(PLAYER.prev_y_pos[0])
        return
#
      if (desired_theta - 30 < ((current_motion_angle + 180) % 360) < desired_theta + 30 or desired_theta - 30 < current_motion_angle - 360 < desired_theta + 30) and current_motion_angle != 180: # moving left on /
        slow_down = False
        speed_up = False
        lift_off = False
        if PLAYER.piston_Fx != 0 or PLAYER.piston_Fy != 0:
          if desired_theta >= 30:
            if ((desired_theta + 180 + 30)%360 <= my_sheath.rotation%360 <= 360) or (0 <= my_sheath.rotation%360 <= (desired_theta - 30)%360):
              lift_off = True
            if (desired_theta - 30)%360 < my_sheath.rotation%360 < (desired_theta + 90)%360:
              speed_up = True
            if (desired_theta + 90)%360 < my_sheath.rotation%360 < (desired_theta + 180 + 30)%360:
              slow_down = True
          if desired_theta < 30:
            if (desired_theta + 180 + 30)%360 <= my_sheath.rotation%360 <= (desired_theta - 30)%360:
              lift_off = True
            if ((desired_theta - 30)%360 < my_sheath.rotation%360 <= 360) or (0 < my_sheath.rotation%360 < (desired_theta + 90)%360):
              speed_up = True
            if (desired_theta + 90)%360 < my_sheath.rotation%360 < (desired_theta + 180 + 30)%360:
              slow_down = True
        piston_x_accel = 0
        cur_cos = math.cos(math.radians(desired_theta))
        cur_sin = math.sin(math.radians(desired_theta))
        PLAYER.Fx = (PLAYER.mass * (my_gravity / 6) * cur_cos)
        PLAYER.Fy = (PLAYER.mass * (my_gravity / 6)) - (PLAYER.mass * (my_gravity / 6) * cur_sin)
        total_force = find_hypotnuse(PLAYER.Fx, PLAYER.Fy) * (desired_theta % 90) / 10
        if slow_down:
          total_force -= abs(find_hypotnuse(PLAYER.piston_Fx + PLAYER.FNx, PLAYER.piston_Fy + PLAYER.FNy) * math.cos(math.radians(abs(((my_sheath.rotation)%360) - (desired_theta + 180)%360))) / 5)
        if speed_up:
          total_force += abs(find_hypotnuse(PLAYER.piston_Fx + PLAYER.FNx, PLAYER.piston_Fy + PLAYER.FNy) * math.cos(math.radians(abs(((my_sheath.rotation)%360) - (desired_theta + 180)%360))) / 5)
        if Currently_pressed_controls.pressed_controls['MOVE_LEFT']:
          PLAYER.Hamster_activities_during_frame.append('Walk_Left')
          total_force += 200
        if Currently_pressed_controls.pressed_controls['MOVE_RIGHT']:
          PLAYER.Hamster_activities_during_frame.append('Walk_Right')
          total_force -= 200
        PLAYER.Fx = total_force * cur_cos
        PLAYER.Fy = total_force * cur_sin
        PLAYER.x_accel = PLAYER.Fx / PLAYER.mass
        PLAYER.y_accel = PLAYER.Fy / PLAYER.mass
        total_accel = find_hypotnuse(PLAYER.x_accel, PLAYER.y_accel)
        if total_force > 0:
          PLAYER.x_accel = -abs(total_accel * cur_cos)
          PLAYER.y_accel = abs(total_accel * cur_sin)
        if total_force < 0:
          PLAYER.x_accel = abs(total_accel * cur_cos)
          PLAYER.y_accel = -abs(total_accel * cur_sin)
        PLAYER.x_vel = PLAYER.x_vel + (PLAYER.x_accel * (1 / fps))
        PLAYER.y_vel = PLAYER.y_vel + (PLAYER.y_accel * (1 / fps))
        total_vel = find_hypotnuse(PLAYER.x_vel, PLAYER.y_vel)
        if abs(total_vel) > maximum_velocity_x + 200:
          total_vel = maximum_velocity_x + 200
        PLAYER.x_vel = -abs(total_vel * cur_cos)
        PLAYER.y_vel = abs(total_vel * cur_sin)
        if -3 < PLAYER.x_vel: # change directions
          PLAYER.x_vel = 3.01
          PLAYER.y_vel = -abs(PLAYER.y_vel)
        PLAYER.x_pos = PLAYER.x_pos + (PLAYER.x_vel * (1 /fps)) + ((1 / 2) * PLAYER.x_accel * (1 / fps)**2)
        PLAYER.y_pos = PLAYER.y_pos + (PLAYER.y_vel * (1 /fps)) + ((1 / 2) * PLAYER.y_accel * (1 / fps)**2)
        if lift_off:
          piston_x_accel = (PLAYER.piston_Fx + PLAYER.FNx) / PLAYER.mass
          piston_y_accel = (PLAYER.piston_Fy + PLAYER.FNy) / PLAYER.mass
          piston_x_vel = (piston_x_accel * (1 / fps))
          piston_y_vel = (piston_y_accel * (1 / fps))
          PLAYER.x_pos = PLAYER.x_pos + (piston_x_vel * (1 /fps)) + ((1 / 2) * piston_x_accel * (1 / fps)**2)
          PLAYER.y_pos = PLAYER.y_pos + (piston_y_vel * (1 /fps)) + ((1 / 2) * piston_y_accel * (1 / fps)**2)
        if not lift_off:
          if not STANDING_ON_TEETERTOTTER:
            brief_list_of_collisions, brief_collision_happened = find_collisions(MAP, PLAYER)
          if STANDING_ON_TEETERTOTTER:
            brief_list_of_collisions, brief_collision_happened = find_collisions_with_offsets(TEETERTOTTERS[STANDING_ON_WHICH_TEETERTOTTER], PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          original_y_pos = PLAYER.y_pos
          number_of_iterations_up = 0
          if not brief_collision_happened:
            while not brief_collision_happened: # don't float above slope
              adjust_up = False
              if piston_x_accel != 0:
                break
              PLAYER.y_pos += 1
              if not STANDING_ON_TEETERTOTTER:
                brief_list_of_collisions, brief_collision_happened = find_collisions(MAP, PLAYER)
              if STANDING_ON_TEETERTOTTER:
                brief_list_of_collisions, brief_collision_happened = find_collisions_with_offsets(TEETERTOTTERS[STANDING_ON_WHICH_TEETERTOTTER], PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          if brief_collision_happened and adjust_up:
            while brief_collision_happened: # don't float above slope
              number_of_iterations_up += 1
              if number_of_iterations_up == 20:
                break
              if piston_x_accel != 0:
                break
              PLAYER.y_pos -= 1
              if not STANDING_ON_TEETERTOTTER:
                brief_list_of_collisions, brief_collision_happened = find_collisions(MAP, PLAYER)
              if STANDING_ON_TEETERTOTTER:
                brief_list_of_collisions, brief_collision_happened = find_collisions_with_offsets(TEETERTOTTERS[STANDING_ON_WHICH_TEETERTOTTER], PLAYER, (1/2) * screen_width, (1/2) * screen_height)
            PLAYER.y_pos += 1
            PLAYER.y_pos = math.ceil(PLAYER.y_pos)
          if number_of_iterations_up == 20:
            PLAYER.y_pos = original_y_pos
        PLAYER.prev_slope_angle = desired_theta
        PLAYER.prev_x_pos.append(PLAYER.x_pos)
        PLAYER.prev_y_pos.append(PLAYER.y_pos)
        PLAYER.prev_x_pos.remove(PLAYER.prev_x_pos[0])
        PLAYER.prev_y_pos.remove(PLAYER.prev_y_pos[0])
        return
###
  PLAYER.prev_slope_angle = 90
  if not leaving_a_wall:
    if not STANDING_ON_TEETERTOTTER and not ON_AN_ELEVATOR and not STANDING_ON_CLOUD and not ON_A_GARBAGE_CAN and not ON_THE_MACHINE:
      if not collision_happened:
        PLAYER.Hamster_activities_during_frame.append('Fly')
        if Currently_pressed_controls.pressed_controls['MOVE_LEFT']:
          if not 'LEFT' in PREVIOUS_PUSH_PISTON:
            PLAYER.movement_Fx -= 250
        if Currently_pressed_controls.pressed_controls['MOVE_RIGHT']:
          if not 'RIGHT' in PREVIOUS_PUSH_PISTON:
            PLAYER.movement_Fx += 250
    PLAYER.Fx += PLAYER.Fgx + PLAYER.movement_Fx + PLAYER.piston_Fx + PLAYER.water_Fx + PLAYER.FNx
    PLAYER.Fy += PLAYER.Fgy + PLAYER.movement_Fy + PLAYER.piston_Fy + PLAYER.water_Fy + PLAYER.FNy
    PLAYER.x_accel = PLAYER.Fx / PLAYER.mass
    PLAYER.y_accel = PLAYER.Fy / PLAYER.mass
  if leaving_a_wall and PLAYER.erroring != 0:
    temp_Fx = PLAYER.Fgx + PLAYER.movement_Fx + PLAYER.piston_Fx + PLAYER.water_Fx + PLAYER.FNx
    temp_Fy = PLAYER.Fgy + PLAYER.movement_Fy + PLAYER.piston_Fy + PLAYER.water_Fy + PLAYER.FNy
    if PLAYER.erroring == 1:
      if 0 >= temp_Fx and temp_Fy <= 0:
        PLAYER.Fx = temp_Fx
        PLAYER.Fy = temp_Fy
        PLAYER.x_accel = PLAYER.Fx / PLAYER.mass
        PLAYER.y_accel = PLAYER.Fy / PLAYER.mass
    if PLAYER.erroring == 2:
      if 0 <= temp_Fx and temp_Fy <= 0:
        PLAYER.Fx = temp_Fx
        PLAYER.Fy = temp_Fy
        PLAYER.x_accel = PLAYER.Fx / PLAYER.mass
        PLAYER.y_accel = PLAYER.Fy / PLAYER.mass
  PLAYER.x_vel = PLAYER.x_vel + (PLAYER.x_accel * (1 / fps))
  PLAYER.y_vel = PLAYER.y_vel + (PLAYER.y_accel * (1 / fps))
  activated_max_x = False
  activated_max_y = False
  if not PLAYER.in_pipe_wind:
    if abs(PLAYER.x_vel) >= maximum_velocity_x:
      activated_max_x = True
      if PLAYER.x_vel < 0:
        PLAYER.x_vel = -maximum_velocity_x + 0.1
      if PLAYER.x_vel > 0:
        PLAYER.x_vel = maximum_velocity_x - 0.1
    if abs(PLAYER.y_vel) >= maximum_velocity_y:
      activated_max_y = True
      if PLAYER.y_vel < 0:
        PLAYER.y_vel = -maximum_velocity_y + 0.1
      if PLAYER.y_vel > 0:
        PLAYER.y_vel = maximum_velocity_y - 0.1
  if MAP.region == 'TheDoor7':
    if ON_AN_ELEVATOR:
      if collison_with_bottom_ball_happened and collison_with_left_ball_happened and abs(PLAYER.x_vel) < 5:
        PLAYER.y_vel /= 3
      if collison_with_bottom_ball_happened and collison_with_right_ball_happened and abs(PLAYER.x_vel) < 5:
        PLAYER.y_vel /= 3
  if collison_with_bottom_ball_happened:
    if -1 < PLAYER.x_vel < 1:
      PLAYER.x_vel = 0
  if not activated_max_x:
    PLAYER.x_pos = PLAYER.x_pos + (PLAYER.x_vel * (1 / fps) + ((1 / 2) * PLAYER.x_accel * (1 / fps)**2))
  if activated_max_x:
    PLAYER.x_pos = PLAYER.x_pos + (PLAYER.x_vel * (1 / fps))
  if not activated_max_y:
    PLAYER.y_pos = PLAYER.y_pos + (PLAYER.y_vel * (1 / fps) + ((1 / 2) * PLAYER.y_accel * (1 / fps)**2))
  if activated_max_y:
    PLAYER.y_pos = PLAYER.y_pos + (PLAYER.y_vel * (1 / fps))
  PLAYER.prev_x_pos.append(PLAYER.x_pos)
  PLAYER.prev_y_pos.append(PLAYER.y_pos)
  PLAYER.prev_x_pos.remove(PLAYER.prev_x_pos[0])
  PLAYER.prev_y_pos.remove(PLAYER.prev_y_pos[0])


def make_opengl_rect_center_on_circle(image_sizes, cur_ID, offsets, rotate, flip, ltwh):
  adjusted_ltwh = [ltwh[0]/image_sizes[0], ltwh[1]/image_sizes[1], ltwh[2]/image_sizes[0], ltwh[3]/image_sizes[1]]
  if flip:
    rotate = rotate%360
    texts = [(1-adjusted_ltwh[0], 0+adjusted_ltwh[1]), (1-adjusted_ltwh[0], adjusted_ltwh[3]), (1 - adjusted_ltwh[2], adjusted_ltwh[3]), (1 - adjusted_ltwh[2], 0+adjusted_ltwh[1])]
  if not flip:
    rotate = -rotate%360
    #texts = [(1-adjusted_ltwh[0], 0+adjusted_ltwh[1]), (1-adjusted_ltwh[0], adjusted_ltwh[3]), (1 - adjusted_ltwh[2], adjusted_ltwh[3]), (1 - adjusted_ltwh[2], 0+adjusted_ltwh[1])]
    texts = [(adjusted_ltwh[2], 0+adjusted_ltwh[1]), (adjusted_ltwh[2], adjusted_ltwh[3]), (adjusted_ltwh[0], adjusted_ltwh[3]), (adjusted_ltwh[0], 0+adjusted_ltwh[1])]
    #texts = [(texts[2][0], texts[0][1]), (texts[3][0], texts[1][1]), (texts[0][0], texts[2][1]), (texts[1][0], texts[3][1])]
  #texts = [(1,0), (1,1), (0,1), (0,0)]
  x_ratio = image_sizes[0]/screen_width
  y_ratio = image_sizes[1]/screen_height
  offset_x = 2*((offsets[0]*aspect)/screen_width)
  offset_y = 2*(offsets[1]/screen_height)
  x_changer1, y_changer1 = abs(adjusted_ltwh[2]-adjusted_ltwh[0]), abs(adjusted_ltwh[3]-adjusted_ltwh[1])
  x_changer2, y_changer2 = -aspect + offset_x, -1 + offset_y
  verts = [((2*aspect*x_changer1*x_ratio)+x_changer2, -y_changer2), ((2*aspect*x_changer1*x_ratio)+x_changer2, -((2*y_changer1*y_ratio)+y_changer2)), (x_changer2, -((2*y_changer1*y_ratio)+y_changer2)), (x_changer2, -y_changer2)]
  #verts = [(2*aspect, 0), (2*aspect, 2), (0, 2), (0, 0)] # downright, upright, upleft, downleft
  #verts = [(x*abs(adjusted_ltwh[2]-adjusted_ltwh[0]), y*abs(adjusted_ltwh[3]-adjusted_ltwh[1])) for (x, y) in verts]
  #verts = [((x*x_ratio)-aspect + offset_x, -((y*y_ratio)-1 + offset_y)) for (x, y) in verts]
  if True:
    glPushMatrix()
    x_vals = [x for (x, y) in verts]
    y_vals = [y for (x, y) in verts]
    center_x = statistics.mean(x_vals)
    center_y = statistics.mean(y_vals)
    cur_rot = abs(math.degrees(math.atan((center_y - verts[0][1]) / (center_x - verts[0][0]))))
    cur_rots = [cur_rot, 180-cur_rot, 180+cur_rot, 360-cur_rot]
    cur_radius = math.sqrt((center_x - verts[0][0])**2 + (center_y - verts[0][1])**2)
    new_rots = [x + rotate for x in cur_rots]
    new_verts = [0,0,0,0]
    vert_dif = []
    for i in range(4):
      new_verts[i] = (center_x + cur_radius*math.cos(math.radians(new_rots[i])), center_y + cur_radius*math.sin(math.radians(new_rots[i])))
      vert_dif.append((new_verts[i][0] - verts[i][0], new_verts[i][1] - verts[i][1]))
    verts = [new_verts[1], new_verts[2], new_verts[3], new_verts[0]]
    move_image_to_corner_x = min(x_vals) - min([x for (x,y) in verts])
    move_image_to_corner_y = max(y_vals) - max([y for (x,y) in verts])
    verts = [(x+move_image_to_corner_x, y+move_image_to_corner_y) for (x, y) in verts]
    verts = [(verts[2][0], verts[0][1]), (verts[3][0], verts[1][1]), (verts[0][0], verts[2][1]), (verts[1][0], verts[3][1])]
  if flip:
    verts = [(verts[2][0], verts[0][1]), (verts[3][0], verts[1][1]), (verts[0][0], verts[2][1]), (verts[1][0], verts[3][1])]
  new_center_x = statistics.mean([x for (x, y) in verts])
  new_center_y = statistics.mean([y for (x, y) in verts])
  center_dif_x, center_dif_y = center_x - new_center_x, center_y - new_center_y
  verts = [(x + center_dif_x, y + center_dif_y) for (x, y) in verts]
  #
  inside_of_draw_region = True
  minx, maxx = min([x for (x,y) in verts]), max([x for (x,y) in verts])
  miny, maxy = min([y for (x,y) in verts]), max([y for (x,y) in verts])
  if aspect < minx:
    inside_of_draw_region = False
  if -aspect > maxx:
    inside_of_draw_region = False
  if 1 < miny:
    inside_of_draw_region = False
  if -1 > maxy:
    inside_of_draw_region = False
  if inside_of_draw_region:
    glEnable(GL_TEXTURE_2D)
    glBindTexture(GL_TEXTURE_2D, cur_ID)
    glBegin(GL_QUADS)
    for i in range(4):
      glTexCoord2f(texts[i][0], texts[i][1])
      glVertex2f(verts[i][0], verts[i][1])
    glEnd()
    glPopMatrix()
    glDisable(GL_TEXTURE_2D)
  else:
    glPopMatrix()


def make_opengl_rect_center_on_circle_vines(current_blit_change_x, current_blit_change_y):
  if len(MY_VINES) != 0:
    for k in range(len(MY_VINES)):
      if len(MY_VINES[k].rotations) == 1:
        make_opengl_rect(MY_VINES[k].GPU_current_image[0], MY_VINES[k].GPU_current_image[1], (MY_VINES[k].x_poss[0] + current_blit_change_x - PLAYER.x_dif, MY_VINES[k].y_poss[0] + current_blit_change_y - PLAYER.y_dif), MY_VINES[k].rotations[0], False, (0, 0, MY_VINES[k].GPU_current_image[0][0], MY_VINES[k].GPU_current_image[0][1]))
        continue
      image_sizes = MY_VINES[k].GPU_current_images[0][0]
      x_ratio = image_sizes[0]/screen_width
      y_ratio = image_sizes[1]/screen_height
      ltwh = (0, 0, MY_VINES[k].GPU_current_images[0][0][0], MY_VINES[k].GPU_current_images[0][0][1])
      adjusted_ltwh = [ltwh[0]/image_sizes[0], ltwh[1]/image_sizes[1], ltwh[2]/image_sizes[0], ltwh[3]/image_sizes[1]]
      texts = [(adjusted_ltwh[2], 0+adjusted_ltwh[1]), (adjusted_ltwh[2], adjusted_ltwh[3]), (adjusted_ltwh[0], adjusted_ltwh[3]), (adjusted_ltwh[0], 0+adjusted_ltwh[1])]
      x_changer1, y_changer1 = abs(adjusted_ltwh[2]-adjusted_ltwh[0]), abs(adjusted_ltwh[3]-adjusted_ltwh[1])
      cur_ID = MY_VINES[k].GPU_current_images[0][1]
      for l in range(MY_VINES[k].vine_length):
        offsets = (MY_VINES[k].x_poss[l] + current_blit_change_x - PLAYER.x_dif, MY_VINES[k].y_poss[l] + current_blit_change_y - PLAYER.y_dif)
        rotate = -MY_VINES[k].rotations[l]%360
        offset_x = 2*((offsets[0]*aspect)/screen_width)
        offset_y = 2*(offsets[1]/screen_height)
        x_changer2, y_changer2 = -aspect + offset_x, -1 + offset_y
        verts = [((2*aspect*x_changer1*x_ratio)+x_changer2, -y_changer2), ((2*aspect*x_changer1*x_ratio)+x_changer2, -((2*y_changer1*y_ratio)+y_changer2)), (x_changer2, -((2*y_changer1*y_ratio)+y_changer2)), (x_changer2, -y_changer2)]
        #verts = [(2*aspect, 0), (2*aspect, 2), (0, 2), (0, 0)] # downright, upright, upleft, downleft
        #verts = [(x*abs(adjusted_ltwh[2]-adjusted_ltwh[0]), y*abs(adjusted_ltwh[3]-adjusted_ltwh[1])) for (x, y) in verts]
        #verts = [((x*x_ratio)-aspect + offset_x, -((y*y_ratio)-1 + offset_y)) for (x, y) in verts]
        #
        x_vals = [x for (x, y) in verts]
        y_vals = [y for (x, y) in verts]
        center_x = statistics.mean(x_vals)
        center_y = statistics.mean(y_vals)
        if l == 0:
          cur_radius = math.sqrt((center_x - verts[0][0])**2 + (center_y - verts[0][1])**2)
        cur_cos = cur_radius*math.cos(math.radians(45+rotate))
        cur_sin = cur_radius*math.sin(math.radians(45+rotate))
        new_verts = [(center_x + cur_cos, center_y + cur_sin), (center_x - cur_sin, center_y + cur_cos), (center_x - cur_cos, center_y - cur_sin), (center_x + cur_sin, center_y - cur_cos)]
        vert_dif = [(new_verts[0][0] - verts[0][0], new_verts[0][1] - verts[0][1]), (new_verts[1][0] - verts[1][0], new_verts[1][1] - verts[1][1]), (new_verts[2][0] - verts[2][0], new_verts[2][1] - verts[2][1]), (new_verts[3][0] - verts[3][0], new_verts[3][1] - verts[3][1])]
        move_image_to_corner_x = min(x_vals) - min([x for (x,y) in verts])
        move_image_to_corner_y = max(y_vals) - max([y for (x,y) in verts])
        verts = [(new_verts[3][0]+move_image_to_corner_x, new_verts[1][1]+move_image_to_corner_y), (new_verts[0][0]+move_image_to_corner_x, new_verts[2][1]+move_image_to_corner_y), (new_verts[1][0]+move_image_to_corner_x, new_verts[3][1]+move_image_to_corner_y), (new_verts[2][0]+move_image_to_corner_x, new_verts[0][1]+move_image_to_corner_y)]
        #
        center_dif_x, center_dif_y = center_x - statistics.mean([x for (x, y) in verts]), center_y - statistics.mean([y for (x, y) in verts])
        verts = [(verts[0][0]+center_dif_x, verts[0][1]+center_dif_y), (verts[1][0]+center_dif_x, verts[1][1]+center_dif_y), (verts[2][0]+center_dif_x, verts[2][1]+center_dif_y), (verts[3][0]+center_dif_x, verts[3][1]+center_dif_y)]
        #
        inside_of_draw_region = True
        minx, maxx = min([x for (x,y) in verts]), max([x for (x,y) in verts])
        miny, maxy = min([y for (x,y) in verts]), max([y for (x,y) in verts])
        if aspect < minx:
          inside_of_draw_region = False
        if -aspect > maxx:
          inside_of_draw_region = False
        if 1 < miny:
          inside_of_draw_region = False
        if -1 > maxy:
          inside_of_draw_region = False
        if inside_of_draw_region:
          glEnable(GL_TEXTURE_2D)
          glBindTexture(GL_TEXTURE_2D, cur_ID)
          glBegin(GL_QUADS)
          glTexCoord2f(texts[0][0], texts[0][1])
          glVertex2f(verts[0][0], verts[0][1])
          glTexCoord2f(texts[1][0], texts[1][1])
          glVertex2f(verts[1][0], verts[1][1])
          glTexCoord2f(texts[2][0], texts[2][1])
          glVertex2f(verts[2][0], verts[2][1])
          glTexCoord2f(texts[3][0], texts[3][1])
          glVertex2f(verts[3][0], verts[3][1])
          glEnd()
          glDisable(GL_TEXTURE_2D)


def draw_background():
  if BACKGROUND != []:
    for SingleBackground in BACKGROUND:
      if not My_cached_info.currently_pausing:
        if My_cached_info.leaving_the_door5:
          saved_x_pos, saved_y_pos = PLAYER.x_pos, PLAYER.y_pos
          PLAYER.x_pos = (MAP.GPU_image[0][0] / 2)
          PLAYER.y_pos = (MAP.GPU_image[0][1] / 2)
        update_background(SingleBackground)
        if My_cached_info.leaving_the_door5:
          PLAYER.x_pos = saved_x_pos
          PLAYER.y_pos = saved_y_pos
          My_cached_info.leaving_the_door5 = False
      for i in range(len(SingleBackground.GPU_current_images)):
        make_opengl_rect(SingleBackground.GPU_current_images[i][0], SingleBackground.GPU_current_images[i][1], (SingleBackground.current_x_poses[i] + SingleBackground.permanent_add_x, SingleBackground.current_y_poses[i] + SingleBackground.permanent_add_y), 0, False, (0, 0, SingleBackground.GPU_current_images[i][0][0], SingleBackground.GPU_current_images[i][0][1]))

def draw_water_surfaces():
  [make_opengl_rect(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.width, MySprite.GPU_current_image[0][1])) for MySprite in WATER_SURFACES]

def draw_water_surfaces_cover():
  [make_opengl_rect(MySprite.GPU_current_image_cover[0], MySprite.GPU_current_image_cover[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.width, MySprite.GPU_current_image_cover[0][1])) for MySprite in WATER_SURFACES if MySprite.connected_to_which_bucket == 666]

def draw_water_covers():
  [make_opengl_rect(MySprite.GPU_image[0], MySprite.GPU_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.GPU_image[0][0], MySprite.GPU_image[0][1])) for MySprite in WATER_COVERS]

def draw_map():
  make_opengl_rect(MAP.GPU_image[0], MAP.GPU_image[1], (MAP.x_pos - PLAYER.x_pos + stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif, MAP.y_pos - PLAYER.y_pos + stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MAP.GPU_image[0][0], MAP.GPU_image[0][1]))

def draw_pretty_map():
  make_opengl_rect(PRETTY_MAP.GPU_image[0], PRETTY_MAP.GPU_image[1], (PRETTY_MAP.x_pos - PLAYER.x_pos + stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif, PRETTY_MAP.y_pos - PLAYER.y_pos + stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif), 0, False, (0, 0, PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1]))

def draw_rootbases():
  [make_opengl_rect(MySprite.GPU_RootBase_image[0], MySprite.GPU_RootBase_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, MySprite.flipped, (0, 0, MySprite.GPU_RootBase_image[0][0], MySprite.GPU_RootBase_image[0][1])) for MySprite in ROOTS]

def draw_doors():
  [make_opengl_rect(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in DOORS if (MySprite.door_type == 1 or MySprite.door_type == 3)]
  [make_opengl_rect(MySprite.GPU_WholeImage[0], MySprite.GPU_WholeImage[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.GPU_WholeImage[0][0], MySprite.GPU_WholeImage[0][1])) for MySprite in DOORS if MySprite.door_type == 2 and MySprite.rotation == 0]
  [make_opengl_rect(MySprite.GPU_current_LeftImage[0], MySprite.GPU_current_LeftImage[1], (MySprite.LeftImage_x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.LeftImage_y_pos + current_blit_change_y - PLAYER.y_dif), -MySprite.rotation, False, (0, 0, MySprite.GPU_current_LeftImage[0][0], MySprite.GPU_current_LeftImage[0][1])) for MySprite in DOORS if MySprite.door_type == 2 and MySprite.rotation != 0]
  [make_opengl_rect(MySprite.GPU_current_RightImage[0], MySprite.GPU_current_RightImage[1], (MySprite.RightImage_x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.RightImage_y_pos + current_blit_change_y - PLAYER.y_dif), MySprite.rotation, False, (0, 0, MySprite.GPU_current_RightImage[0][0], MySprite.GPU_current_RightImage[0][1])) for MySprite in DOORS if MySprite.door_type == 2 and MySprite.rotation != 0]

def draw_roots():
  [make_opengl_rect(MySprite.GPU_actual_current_image[0], MySprite.GPU_actual_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, MySprite.flipped, (0, 0, MySprite.GPU_actual_current_image[0][0], MySprite.GPU_actual_current_image[0][1])) for MySprite in ROOTS]

def draw_backsprites():
  [make_opengl_rect(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in MY_SPRITES_BACK]

def draw_moving_backsprites():
  for i in range(len(MOVING_SPRITE_BACK)):
    MOVING_SPRITE_BACK[i].current_time_before_frame_switch += delta_milliseconds
    if MOVING_SPRITE_BACK[i].current_time_before_frame_switch >= MOVING_SPRITE_BACK[i].time_needed_before_frame_switch:
      MOVING_SPRITE_BACK[i].current_time_before_frame_switch = MOVING_SPRITE_BACK[i].current_time_before_frame_switch % MOVING_SPRITE_BACK[i].time_needed_before_frame_switch
      MOVING_SPRITE_BACK[i].current_frame += 1
      if MOVING_SPRITE_BACK[i].current_frame == MOVING_SPRITE_BACK[i].number_of_frames:
        MOVING_SPRITE_BACK[i].current_frame = 0
    make_opengl_rect(MOVING_SPRITE_BACK[i].GPU_current_image[0], MOVING_SPRITE_BACK[i].GPU_current_image[1], (MOVING_SPRITE_BACK[i].x_pos + current_blit_change_x - PLAYER.x_dif, MOVING_SPRITE_BACK[i].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, ((MOVING_SPRITE_BACK[i].GPU_current_image[0][0] / MOVING_SPRITE_BACK[i].number_of_frames) * MOVING_SPRITE_BACK[i].current_frame, 0, (MOVING_SPRITE_BACK[i].GPU_current_image[0][0] / MOVING_SPRITE_BACK[i].number_of_frames)+(MOVING_SPRITE_BACK[i].GPU_current_image[0][0] / MOVING_SPRITE_BACK[i].number_of_frames) * MOVING_SPRITE_BACK[i].current_frame, MOVING_SPRITE_BACK[i].GPU_current_image[0][1]))

def draw_grass():
  for SingleGrass in GRASSES:
    if (SingleGrass.in_the_back and My_cached_info.doing_the_back) or (not SingleGrass.in_the_back and not My_cached_info.doing_the_back):
      SingleGrass.current_milliseconds_to_next_image += delta_milliseconds
      if SingleGrass.current_milliseconds_to_next_image >= SingleGrass.milliseconds_to_next_image:
        SingleGrass.current_milliseconds_to_next_image %= SingleGrass.milliseconds_to_next_image
        SingleGrass.current_image_index += 1
        if SingleGrass.current_image_index >= len(OpenGLTextures[SingleGrass.png_name]):
          SingleGrass.current_image_index = 0
      make_opengl_rect(OpenGLTextures[SingleGrass.png_name][SingleGrass.current_image_index][0], OpenGLTextures[SingleGrass.png_name][SingleGrass.current_image_index][1], (SingleGrass.x_pos + current_blit_change_x - PLAYER.x_dif, SingleGrass.y_pos + current_blit_change_y - PLAYER.y_dif), 0, SingleGrass.flipped, (0, 0, OpenGLTextures[SingleGrass.png_name][SingleGrass.current_image_index][0][0], OpenGLTextures[SingleGrass.png_name][SingleGrass.current_image_index][0][1]))
  My_cached_info.doing_the_back = not My_cached_info.doing_the_back

def draw_grass_anthill():
  for SingleGrass in GRASSES:
    SingleGrass.current_milliseconds_to_next_image += delta_milliseconds
    if SingleGrass.current_milliseconds_to_next_image >= SingleGrass.milliseconds_to_next_image:
      SingleGrass.current_milliseconds_to_next_image %= SingleGrass.milliseconds_to_next_image
      SingleGrass.current_image_index += 1
      if SingleGrass.current_image_index >= len(OpenGLTextures[SingleGrass.png_name]):
        SingleGrass.current_image_index = 0
    make_opengl_rect(OpenGLTextures[SingleGrass.png_name][SingleGrass.current_image_index][0], OpenGLTextures[SingleGrass.png_name][SingleGrass.current_image_index][1], (SingleGrass.x_pos + current_blit_change_x - PLAYER.x_dif, SingleGrass.y_pos + current_blit_change_y - PLAYER.y_dif), 0, SingleGrass.flipped, (0, 0, OpenGLTextures[SingleGrass.png_name][SingleGrass.current_image_index][0][0], OpenGLTextures[SingleGrass.png_name][SingleGrass.current_image_index][0][1]))

def draw_grass_town():
  My_cached_info.grass_updates_this_frame += 1
  if My_cached_info.grass_updates_this_frame == 2:
    if GARBAGE_CAN[0].player_is_inside or GARBAGE_CAN[0].player_is_tentatively_inside:
      return
  if My_cached_info.grass_updates_this_frame == 3:
    if not GARBAGE_CAN[0].player_is_inside and not GARBAGE_CAN[0].player_is_tentatively_inside:
      return
  for SingleGrass in GRASSES:
    if (SingleGrass.in_the_back and My_cached_info.doing_the_back) or (not SingleGrass.in_the_back and not My_cached_info.doing_the_back):
      SingleGrass.current_milliseconds_to_next_image += delta_milliseconds
      if SingleGrass.current_milliseconds_to_next_image >= SingleGrass.milliseconds_to_next_image:
        SingleGrass.current_milliseconds_to_next_image %= SingleGrass.milliseconds_to_next_image
        SingleGrass.current_image_index += 1
        if SingleGrass.current_image_index >= len(OpenGLTextures[SingleGrass.png_name]):
          SingleGrass.current_image_index = 0
      make_opengl_rect(OpenGLTextures[SingleGrass.png_name][SingleGrass.current_image_index][0], OpenGLTextures[SingleGrass.png_name][SingleGrass.current_image_index][1], (SingleGrass.x_pos + current_blit_change_x - PLAYER.x_dif, SingleGrass.y_pos + current_blit_change_y - PLAYER.y_dif), 0, SingleGrass.flipped, (0, 0, OpenGLTextures[SingleGrass.png_name][SingleGrass.current_image_index][0][0], OpenGLTextures[SingleGrass.png_name][SingleGrass.current_image_index][0][1]))
  My_cached_info.doing_the_back = not My_cached_info.doing_the_back

def draw_vines():
  make_opengl_rect_center_on_circle_vines(current_blit_change_x, current_blit_change_y)

def draw_squirrels():
  [make_opengl_rect_center_on_circle(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), MySprite.rotate_squirrel, MySprite.flipped, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in SQUIRRELS]

def draw_teetertotters():
  [make_opengl_rect(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), MySprite.rotation, False, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in TEETERTOTTERS]

def draw_bouncies():
  [make_opengl_rect(MySprite.GPU_image[0], MySprite.GPU_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in BOUNCIES]

def draw_moving_bouncies():
  [make_opengl_rect_center_on_circle(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), MySprite.rotation, False, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in MOVING_BOUNCIES]

def draw_TVs():
  for SingleTV in TV: 
    make_opengl_rect(SingleTV.GPU_image[0], SingleTV.GPU_image[1], (SingleTV.x_pos + current_blit_change_x - PLAYER.x_dif, SingleTV.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, SingleTV.GPU_image[0][0], SingleTV.GPU_image[0][1]))
    for i in range(len(SingleTV.active_dots)):
      if SingleTV.active_dots[i]:
        make_opengl_rect(SingleTV.GPU_marker[0], SingleTV.GPU_marker[1], (SingleTV.x_pos + SingleTV.xy_poses[i][0] + current_blit_change_x - PLAYER.x_dif, SingleTV.y_pos + SingleTV.xy_poses[i][1] + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, SingleTV.GPU_marker[0][0], SingleTV.GPU_marker[0][1]))

def draw_propellers():
  [make_opengl_rect(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, MySprite.flipped, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in PROPELLERS]
  [make_opengl_rect(MySprite.GPU_bubbles_png[0], MySprite.GPU_bubbles_png[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif - MySprite.collision_box_width, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, MySprite.flipped, (MySprite.current_bubbles_x, 0, MySprite.current_bubbles_x + MySprite.collision_box_width, MySprite.GPU_bubbles_png[0][1])) for MySprite in PROPELLERS if MySprite.flipped and MySprite.is_on and MySprite.propeller_type == 1]
  [make_opengl_rect(MySprite.GPU_bubbles_png[0], MySprite.GPU_bubbles_png[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif + 48, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, MySprite.flipped, (MySprite.current_bubbles_x, 0, MySprite.current_bubbles_x + MySprite.collision_box_width, MySprite.GPU_bubbles_png[0][1])) for MySprite in PROPELLERS if not MySprite.flipped and MySprite.is_on and MySprite.propeller_type == 1]
  [make_opengl_rect(MySprite.GPU_bubbles_png[0], MySprite.GPU_bubbles_png[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif + 48), 0, MySprite.flipped, (0, MySprite.current_bubbles_x, MySprite.GPU_bubbles_png[0][0], MySprite.current_bubbles_x + MySprite.collision_box_width)) for MySprite in PROPELLERS if MySprite.is_on and (MySprite.propeller_type == 2 or MySprite.propeller_type == 7)]
  [make_opengl_rect(MySprite.GPU_bubbles_png[0], MySprite.GPU_bubbles_png[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif + 48, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (MySprite.current_bubbles_x, 0, MySprite.current_bubbles_x + MySprite.collision_box_width, MySprite.GPU_bubbles_png[0][1])) for MySprite in PROPELLERS if MySprite.is_on and MySprite.propeller_type == 4]
  [make_opengl_rect(MySprite.GPU_bubbles_png[0], MySprite.GPU_bubbles_png[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif - MySprite.collision_box_width), 0, MySprite.flipped, (0, MySprite.current_bubbles_x, MySprite.GPU_bubbles_png[0][0], MySprite.current_bubbles_x + MySprite.collision_box_width)) for MySprite in PROPELLERS if MySprite.is_on and MySprite.propeller_type == 5 or MySprite.propeller_type == 6]

def draw_levers():
  [make_opengl_rect(MySprite.GPU_block_image[0], MySprite.GPU_block_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, MySprite.flipped, (0, 0, MySprite.GPU_block_image[0][0], MySprite.GPU_block_image[0][1])) for MySprite in LEVERS]
  [make_opengl_rect(MySprite.GPU_current_lever_image[0], MySprite.GPU_current_lever_image[1], (MySprite.x_pos + MySprite.lever_added_x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + MySprite.lever_added_y_pos + current_blit_change_y - PLAYER.y_dif), 0, MySprite.flipped, (0, 0, MySprite.GPU_current_lever_image[0][0], MySprite.GPU_current_lever_image[0][1])) for MySprite in LEVERS]
  [make_opengl_rect(MySprite.GPU_current_bolt_image[0], MySprite.GPU_current_bolt_image[1], (MySprite.x_pos + MySprite.bolt_added_x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + MySprite.bolt_added_y_pos + current_blit_change_y - PLAYER.y_dif), 0, MySprite.flipped, (0, 0, MySprite.GPU_current_bolt_image[0][0], MySprite.GPU_current_bolt_image[0][1])) for MySprite in LEVERS]

def draw_big_elevator():
  make_opengl_rect(ELEVATORS[0].GPU_current_background_image[0], ELEVATORS[0].GPU_current_background_image[1], (ELEVATORS[0].PlatformLeftTop_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].PlatformLeftTop_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_current_background_image[0][0], ELEVATORS[0].GPU_current_background_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_PlatformLeftTop_current_image[0], ELEVATORS[0].GPU_PlatformLeftTop_current_image[1], (ELEVATORS[0].PlatformLeftTop_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].PlatformLeftTop_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_PlatformLeftTop_current_image[0][0], ELEVATORS[0].GPU_PlatformLeftTop_current_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_PlatformMiddleTop_current_image[0], ELEVATORS[0].GPU_PlatformMiddleTop_current_image[1], (ELEVATORS[0].PlatformMiddleTop_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].PlatformMiddleTop_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_PlatformMiddleTop_current_image[0][0], ELEVATORS[0].GPU_PlatformMiddleTop_current_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_PlatformRightTop_current_image[0], ELEVATORS[0].GPU_PlatformRightTop_current_image[1], (ELEVATORS[0].PlatformRightTop_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].PlatformRightTop_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_PlatformRightTop_current_image[0][0], ELEVATORS[0].GPU_PlatformRightTop_current_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_PlatformLeftBottom_current_image[0], ELEVATORS[0].GPU_PlatformLeftBottom_current_image[1], (ELEVATORS[0].PlatformLeftBottom_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].PlatformLeftBottom_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_PlatformLeftBottom_current_image[0][0], ELEVATORS[0].GPU_PlatformLeftBottom_current_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_PlatformMiddleBottom_current_image[0], ELEVATORS[0].GPU_PlatformMiddleBottom_current_image[1], (ELEVATORS[0].PlatformMiddleBottom_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].PlatformMiddleBottom_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_PlatformMiddleBottom_current_image[0][0], ELEVATORS[0].GPU_PlatformMiddleBottom_current_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_PlatformRightBottom_current_image[0], ELEVATORS[0].GPU_PlatformRightBottom_current_image[1], (ELEVATORS[0].PlatformRightBottom_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].PlatformRightBottom_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_PlatformRightBottom_current_image[0][0], ELEVATORS[0].GPU_PlatformRightBottom_current_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_LeftMiddlePlatform_current_image[0], ELEVATORS[0].GPU_LeftMiddlePlatform_current_image[1], (ELEVATORS[0].LeftMiddlePlatform_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].LeftMiddlePlatform_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_LeftMiddlePlatform_current_image[0][0], ELEVATORS[0].GPU_LeftMiddlePlatform_current_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_RightMiddlePlatform_current_image[0], ELEVATORS[0].GPU_RightMiddlePlatform_current_image[1], (ELEVATORS[0].RightMiddlePlatform_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].RightMiddlePlatform_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_RightMiddlePlatform_current_image[0][0], ELEVATORS[0].GPU_RightMiddlePlatform_current_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_DownPeg1_current_image[0], ELEVATORS[0].GPU_DownPeg1_current_image[1], (ELEVATORS[0].DownPeg1_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].DownPeg1_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_DownPeg1_current_image[0][0], ELEVATORS[0].GPU_DownPeg1_current_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_DownPeg2_current_image[0], ELEVATORS[0].GPU_DownPeg2_current_image[1], (ELEVATORS[0].DownPeg2_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].DownPeg2_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_DownPeg2_current_image[0][0], ELEVATORS[0].GPU_DownPeg2_current_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_DownPeg3_current_image[0], ELEVATORS[0].GPU_DownPeg3_current_image[1], (ELEVATORS[0].DownPeg3_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].DownPeg3_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_DownPeg3_current_image[0][0], ELEVATORS[0].GPU_DownPeg3_current_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_UpPeg1_current_image[0], ELEVATORS[0].GPU_UpPeg1_current_image[1], (ELEVATORS[0].UpPeg1_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].UpPeg1_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_UpPeg1_current_image[0][0], ELEVATORS[0].GPU_UpPeg1_current_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_UpPeg2_current_image[0], ELEVATORS[0].GPU_UpPeg2_current_image[1], (ELEVATORS[0].UpPeg2_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].UpPeg2_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_UpPeg2_current_image[0][0], ELEVATORS[0].GPU_UpPeg2_current_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_UpPeg3_current_image[0], ELEVATORS[0].GPU_UpPeg3_current_image[1], (ELEVATORS[0].UpPeg3_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].UpPeg3_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_UpPeg3_current_image[0][0], ELEVATORS[0].GPU_UpPeg3_current_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_UpPeg4_current_image[0], ELEVATORS[0].GPU_UpPeg4_current_image[1], (ELEVATORS[0].UpPeg4_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].UpPeg4_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_UpPeg4_current_image[0][0], ELEVATORS[0].GPU_UpPeg4_current_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_UpPeg5_current_image[0], ELEVATORS[0].GPU_UpPeg5_current_image[1], (ELEVATORS[0].UpPeg5_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].UpPeg5_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_UpPeg5_current_image[0][0], ELEVATORS[0].GPU_UpPeg5_current_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_LeftDoor_current_image[0], ELEVATORS[0].GPU_LeftDoor_current_image[1], (ELEVATORS[0].LeftDoor_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].LeftDoor_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_LeftDoor_current_image[0][0], ELEVATORS[0].GPU_LeftDoor_current_image[0][1]))
  make_opengl_rect(ELEVATORS[0].GPU_RightDoor_current_image[0], ELEVATORS[0].GPU_RightDoor_current_image[1], (ELEVATORS[0].RightDoor_x_pos + current_blit_change_x - PLAYER.x_dif, ELEVATORS[0].RightDoor_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, ELEVATORS[0].GPU_RightDoor_current_image[0][0], ELEVATORS[0].GPU_RightDoor_current_image[0][1]))

def draw_eating_rat():
  [make_opengl_rect(MySprite.GPU_current_rat_image[0], MySprite.GPU_current_rat_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, True, (0, 0, MySprite.GPU_current_rat_image[0][0], MySprite.GPU_current_rat_image[0][1])) for MySprite in EATING_RAT]
  [make_opengl_rect(MySprite.GPU_current_dialogue[0], MySprite.GPU_current_dialogue[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif + 250, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif - 38), 0, False, (0, 0, MySprite.GPU_current_dialogue[0][0], MySprite.GPU_current_dialogue[0][1])) for MySprite in EATING_RAT if MySprite.show_dialogue]

def draw_eating_progress():
  if PLAYER.talked_to_eating_rat_before:
    if not PLAYER.collected_wrench:
      food_size_divider = 1.5
      adjusted_almond = ((OpenGLTextures['ALMOND'][0][0] / food_size_divider, OpenGLTextures['ALMOND'][0][1] / food_size_divider), 'x')
      adjusted_banana = ((OpenGLTextures['BANANA'][0][0] / food_size_divider, OpenGLTextures['BANANA'][0][1] / food_size_divider), 'x')
      adjusted_blackberry = ((OpenGLTextures['BLACKBERRY'][0][0] / food_size_divider, OpenGLTextures['BLACKBERRY'][0][1] / food_size_divider), 'x')
      adjusted_coconut = ((OpenGLTextures['COCONUT'][0][0] / food_size_divider, OpenGLTextures['COCONUT'][0][1] / food_size_divider), 'x')
      space_between_food = 10
      leftest_food_pos = screen_width - adjusted_almond[0][0] - adjusted_banana[0][0] - adjusted_blackberry[0][0] - adjusted_coconut[0][0] - (4 * space_between_food)
      make_opengl_rect(adjusted_almond[0], OpenGLTextures['ALMOND'][1], (leftest_food_pos, 10), 0, False, (0, 0, adjusted_almond[0][0], adjusted_almond[0][1]))
      make_opengl_rect(adjusted_banana[0], OpenGLTextures['BANANA'][1], (leftest_food_pos + adjusted_almond[0][0] + (1 * space_between_food), 10), 0, False, (0, 0, adjusted_banana[0][0], adjusted_banana[0][1]))
      make_opengl_rect(adjusted_blackberry[0], OpenGLTextures['BLACKBERRY'][1], (leftest_food_pos + adjusted_almond[0][0] + adjusted_banana[0][0] + (2 * space_between_food), 10), 0, False, (0, 0, adjusted_blackberry[0][0], adjusted_blackberry[0][1]))
      make_opengl_rect(adjusted_coconut[0], OpenGLTextures['COCONUT'][1], (leftest_food_pos + adjusted_almond[0][0] + adjusted_banana[0][0] + adjusted_blackberry[0][0] + (3 * space_between_food), 10), 0, False, (0, 0, adjusted_coconut[0][0], adjusted_coconut[0][1]))
      if My_cached_info.food_that_exists[0]:
        make_opengl_rect(adjusted_almond[0], OpenGLTextures['ALMOND_SHADY'][1], (leftest_food_pos, 10), 0, False, (0, 0, adjusted_almond[0][0], adjusted_almond[0][1]))
      if My_cached_info.food_that_exists[1]:
        make_opengl_rect(adjusted_banana[0], OpenGLTextures['BANANA_SHADY'][1], (leftest_food_pos + adjusted_almond[0][0] + (1 * space_between_food), 10), 0, False, (0, 0, adjusted_banana[0][0], adjusted_banana[0][1]))
      if My_cached_info.food_that_exists[2]:
        make_opengl_rect(adjusted_blackberry[0], OpenGLTextures['BLACKBERRY_SHADY'][1], (leftest_food_pos + adjusted_almond[0][0] + adjusted_banana[0][0] + (2 * space_between_food), 10), 0, False, (0, 0, adjusted_blackberry[0][0], adjusted_blackberry[0][1]))
      if My_cached_info.food_that_exists[3]:
        make_opengl_rect(adjusted_coconut[0], OpenGLTextures['COCONUT_SHADY'][1], (leftest_food_pos + adjusted_almond[0][0] + adjusted_banana[0][0] + adjusted_blackberry[0][0] + (3 * space_between_food), 10), 0, False, (0, 0, adjusted_coconut[0][0], adjusted_coconut[0][1]))

def draw_bubbles():
  [make_opengl_rect(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in BUBBLES]

def draw_waves():
  [make_opengl_rect(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in WAVES]

def draw_surf_boards():
  [make_opengl_rect_center_on_circle(MySprite.GPU_image[0], MySprite.GPU_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), MySprite.image_rotation, MySprite.currently_flipping_image, (0, 0, MySprite.GPU_image[0][0], MySprite.GPU_image[0][1])) for MySprite in SURF_BOARDS]

def draw_doors_with_knobs():
  [make_opengl_rect_center_on_circle(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in DOORS_WITH_KNOB]

def draw_garbage1():
  [make_opengl_rect(MySprite.whole_can[0], MySprite.whole_can[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.whole_can[0][0], MySprite.whole_can[0][1])) for MySprite in GARBAGE_CAN]
  if GARBAGE_CAN[0].player_is_inside:
    make_opengl_rect(OpenGLTextures['THE_DOOR'][0], OpenGLTextures['THE_DOOR'][1], (743 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 2640 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_DOOR'][0][0], OpenGLTextures['THE_DOOR'][0][1]))

def draw_garbage2():
  [make_opengl_rect(MySprite.transparent_can[0], MySprite.transparent_can[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.transparent_can[0][0], MySprite.transparent_can[0][1])) for MySprite in GARBAGE_CAN if MySprite.player_is_tentatively_inside or MySprite.player_is_inside]

def draw_the_machine_doors():
  if My_cached_info.won_the_game:
    Door_image_index = (My_cached_info.time_since_winning_game // 200)
    if Door_image_index >= 5:
      Door_image_index = 5
    door_index_mapping = [5, 4, 3, 2, 1, 0]
    Door_image_index = door_index_mapping[Door_image_index]
    make_opengl_rect(OpenGLTextures['THE_MACHINE_CLOSING'][Door_image_index][0], OpenGLTextures['THE_MACHINE_CLOSING'][Door_image_index][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_CLOSING'][Door_image_index][0][0], OpenGLTextures['THE_MACHINE_CLOSING'][Door_image_index][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))

def draw_dark_background():
  if My_cached_info.won_the_game:
    shady_image_index = (My_cached_info.time_since_winning_game // 250)
    if shady_image_index >= 4:
      shady_image_index = 4
    shady_image_mapping = [4, 3, 2, 1, 0]
    shady_image_index = shady_image_mapping[shady_image_index]
    shady_image = ((OpenGLTextures['SHADY_PIXELS'][shady_image_index][0][0] * screen_width, OpenGLTextures['SHADY_PIXELS'][shady_image_index][0][1] * screen_height), OpenGLTextures['SHADY_PIXELS'][shady_image_index][1])
    make_opengl_rect(shady_image[0], shady_image[1], (0, 0), 0, False, (0, 0, shady_image[0][0], shady_image[0][1]))

def draw_the_machine():
  if THE_MACHINE != []:
    if (THE_MACHINE[0].screw_stage > 2) and (THE_MACHINE[0].wire_cutter_stage > 2) and (THE_MACHINE[0].wrench_stage > 2):
      My_cached_info.allow_glowing_green_button = True
    make_opengl_rect(THE_MACHINE[0].GPU_current_machine_image[0], THE_MACHINE[0].GPU_current_machine_image[1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, THE_MACHINE[0].GPU_current_machine_image[0][0], THE_MACHINE[0].GPU_current_machine_image[0][1]))
    if THE_MACHINE[0].repair_screw_driver:
      if not THE_MACHINE[0].screw_driver_reached_themachine:
        make_opengl_rect(OpenGLTextures['SCREW_DRIVER'][0], OpenGLTextures['SCREW_DRIVER'][1], (THE_MACHINE[0].screw_driver_xy[0] + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].screw_driver_xy[1] + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['SCREW_DRIVER'][0][0], OpenGLTextures['SCREW_DRIVER'][0][1]))
      if THE_MACHINE[0].screw_driver_reached_themachine and THE_MACHINE[0].screw_stage != 0:
        THE_MACHINE[0].smoke1_cur_milliseconds += delta_milliseconds
        num_smoke_image_updates = round(THE_MACHINE[0].smoke1_cur_milliseconds // THE_MACHINE[0].milliseconds_to_update_smoke_image)
        THE_MACHINE[0].smoke1_cur_milliseconds %= THE_MACHINE[0].milliseconds_to_update_smoke_image
        THE_MACHINE[0].smoke1_cur_rot += num_smoke_image_updates
        THE_MACHINE[0].smoke1_cur_rot %= len(THE_MACHINE[0].smoke1_rots)
        smoke1_rot = THE_MACHINE[0].smoke1_rots[THE_MACHINE[0].smoke1_cur_rot]
        if THE_MACHINE[0].screw_stage == 1:
          smoke_index = THE_MACHINE[0].milliseconds_since_screw_driver_repair // (THE_MACHINE[0].milliseconds_for_smoke_to_appear / (len(OpenGLTextures['SMOKE']) - 1))
          if smoke_index > (len(OpenGLTextures['SMOKE']) - 1):
            smoke_index = (len(OpenGLTextures['SMOKE']) - 1)
          smoke_index = round(smoke_index)
          make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_index][0], OpenGLTextures['SMOKE'][smoke_index][1], (THE_MACHINE[0].screw_destination_xy[0] + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].screw_destination_xy[1] + current_blit_change_y - PLAYER.y_dif), smoke1_rot, False, (0, 0, OpenGLTextures['SMOKE'][smoke_index][0][0], OpenGLTextures['SMOKE'][smoke_index][0][1]))
        if THE_MACHINE[0].screw_stage == 2:
          smoke_index = (len(OpenGLTextures['SMOKE']) - 1)
          smoke_index = round(smoke_index)
          make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_index][0], OpenGLTextures['SMOKE'][smoke_index][1], (THE_MACHINE[0].screw_destination_xy[0] + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].screw_destination_xy[1] + current_blit_change_y - PLAYER.y_dif), smoke1_rot, False, (0, 0, OpenGLTextures['SMOKE'][smoke_index][0][0], OpenGLTextures['SMOKE'][smoke_index][0][1]))
        if THE_MACHINE[0].screw_stage == 3:
          smoke_index = (THE_MACHINE[0].milliseconds_since_screw_driver_repair - THE_MACHINE[0].milliseconds_for_smoke_to_hangout - THE_MACHINE[0].milliseconds_for_smoke_to_appear) // (THE_MACHINE[0].milliseconds_for_smoke_to_appear / (len(OpenGLTextures['SMOKE']) - 1))
          smoke_index = (len(OpenGLTextures['SMOKE']) - 1) - smoke_index
          if smoke_index > (len(OpenGLTextures['SMOKE']) - 1):
            smoke_index = (len(OpenGLTextures['SMOKE']) - 1)
          smoke_index = round(smoke_index)
          make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_index][0], OpenGLTextures['SMOKE'][smoke_index][1], (THE_MACHINE[0].screw_destination_xy[0] + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].screw_destination_xy[1] + current_blit_change_y - PLAYER.y_dif), smoke1_rot, False, (0, 0, OpenGLTextures['SMOKE'][smoke_index][0][0], OpenGLTextures['SMOKE'][smoke_index][0][1]))
        if THE_MACHINE[0].screw_stage < 3:
          THE_MACHINE[0].screw_cur_milliseconds += delta_milliseconds
          num_screw_image_updates = round(THE_MACHINE[0].screw_cur_milliseconds // THE_MACHINE[0].milliseconds_to_update_tool_image)
          THE_MACHINE[0].screw_cur_milliseconds %= THE_MACHINE[0].milliseconds_to_update_tool_image
          THE_MACHINE[0].screw_cur_rot += num_screw_image_updates
          THE_MACHINE[0].screw_cur_rot %= len(THE_MACHINE[0].screw_rots)
          screw_rot = THE_MACHINE[0].screw_rots[THE_MACHINE[0].screw_cur_rot]
          make_opengl_rect_center_on_circle(OpenGLTextures['SCREW_DRIVER'][0], OpenGLTextures['SCREW_DRIVER'][1], (THE_MACHINE[0].screw_destination_xy[0] + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].screw_destination_xy[1] + current_blit_change_y - PLAYER.y_dif), screw_rot, False, (0, 0, OpenGLTextures['SCREW_DRIVER'][0][0], OpenGLTextures['SCREW_DRIVER'][0][1]))
    if THE_MACHINE[0].repair_wire_cutter:
      if not THE_MACHINE[0].wire_cutter_reached_themachine:
        make_opengl_rect(OpenGLTextures['WIRE_CUTTER'][0], OpenGLTextures['WIRE_CUTTER'][1], (THE_MACHINE[0].wire_cutter_xy[0] + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].wire_cutter_xy[1] + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['WIRE_CUTTER'][0][0], OpenGLTextures['WIRE_CUTTER'][0][1]))
      if THE_MACHINE[0].wire_cutter_reached_themachine and THE_MACHINE[0].wire_cutter_stage != 0:
        THE_MACHINE[0].smoke2_cur_milliseconds += delta_milliseconds
        num_smoke_image_updates = round(THE_MACHINE[0].smoke2_cur_milliseconds // THE_MACHINE[0].milliseconds_to_update_smoke_image)
        THE_MACHINE[0].smoke2_cur_milliseconds %= THE_MACHINE[0].milliseconds_to_update_smoke_image
        THE_MACHINE[0].smoke2_cur_rot += num_smoke_image_updates
        THE_MACHINE[0].smoke2_cur_rot %= len(THE_MACHINE[0].smoke2_rots)
        smoke2_rot = THE_MACHINE[0].smoke2_rots[THE_MACHINE[0].smoke2_cur_rot]
        THE_MACHINE[0].smoke3_cur_milliseconds += delta_milliseconds
        num_smoke_image_updates = round(THE_MACHINE[0].smoke3_cur_milliseconds // THE_MACHINE[0].milliseconds_to_update_smoke_image)
        THE_MACHINE[0].smoke3_cur_milliseconds %= THE_MACHINE[0].milliseconds_to_update_smoke_image
        THE_MACHINE[0].smoke3_cur_rot += num_smoke_image_updates
        THE_MACHINE[0].smoke3_cur_rot %= len(THE_MACHINE[0].smoke3_rots)
        smoke3_rot = THE_MACHINE[0].smoke3_rots[THE_MACHINE[0].smoke3_cur_rot]
        if THE_MACHINE[0].wire_cutter_stage == 1:
          smoke_index = THE_MACHINE[0].milliseconds_since_wire_cutter_repair // (THE_MACHINE[0].milliseconds_for_smoke_to_appear / (len(OpenGLTextures['SMOKE']) - 1))
          if smoke_index > (len(OpenGLTextures['SMOKE']) - 1):
            smoke_index = (len(OpenGLTextures['SMOKE']) - 1)
          smoke_index = round(smoke_index)
          make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_index][0], OpenGLTextures['SMOKE'][smoke_index][1], (2584 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 716 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke2_rot, False, (0, 0, OpenGLTextures['SMOKE'][smoke_index][0][0], OpenGLTextures['SMOKE'][smoke_index][0][1]))
          make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_index][0], OpenGLTextures['SMOKE'][smoke_index][1], (2627 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 725 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke3_rot, False, (0, 0, OpenGLTextures['SMOKE'][smoke_index][0][0], OpenGLTextures['SMOKE'][smoke_index][0][1]))
        if THE_MACHINE[0].wire_cutter_stage == 2:
          smoke_index = (len(OpenGLTextures['SMOKE']) - 1)
          smoke_index = round(smoke_index)
          make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_index][0], OpenGLTextures['SMOKE'][smoke_index][1], (2584 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 716 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke2_rot, False, (0, 0, OpenGLTextures['SMOKE'][smoke_index][0][0], OpenGLTextures['SMOKE'][smoke_index][0][1]))
          make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_index][0], OpenGLTextures['SMOKE'][smoke_index][1], (2627 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 725 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke3_rot, False, (0, 0, OpenGLTextures['SMOKE'][smoke_index][0][0], OpenGLTextures['SMOKE'][smoke_index][0][1]))
        if THE_MACHINE[0].wire_cutter_stage == 3:
          smoke_index = (THE_MACHINE[0].milliseconds_since_wire_cutter_repair - THE_MACHINE[0].milliseconds_for_smoke_to_hangout - THE_MACHINE[0].milliseconds_for_smoke_to_appear) // (THE_MACHINE[0].milliseconds_for_smoke_to_appear / (len(OpenGLTextures['SMOKE']) - 1))
          smoke_index = (len(OpenGLTextures['SMOKE']) - 1) - smoke_index
          if smoke_index > (len(OpenGLTextures['SMOKE']) - 1):
            smoke_index = (len(OpenGLTextures['SMOKE']) - 1)
          smoke_index = round(smoke_index)
          make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_index][0], OpenGLTextures['SMOKE'][smoke_index][1], (2584 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 716 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke2_rot, False, (0, 0, OpenGLTextures['SMOKE'][smoke_index][0][0], OpenGLTextures['SMOKE'][smoke_index][0][1]))
          make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_index][0], OpenGLTextures['SMOKE'][smoke_index][1], (2627 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 725 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke3_rot, False, (0, 0, OpenGLTextures['SMOKE'][smoke_index][0][0], OpenGLTextures['SMOKE'][smoke_index][0][1]))
        if THE_MACHINE[0].wire_cutter_stage < 3:
          THE_MACHINE[0].wire_cutter_cur_milliseconds += delta_milliseconds
          num_wire_cutter_image_updates = round(THE_MACHINE[0].wire_cutter_cur_milliseconds // THE_MACHINE[0].milliseconds_to_update_tool_image)
          THE_MACHINE[0].wire_cutter_cur_milliseconds %= THE_MACHINE[0].milliseconds_to_update_tool_image
          THE_MACHINE[0].wire_cutter_cur_rot += num_wire_cutter_image_updates
          THE_MACHINE[0].wire_cutter_cur_rot %= len(THE_MACHINE[0].wire_cutter_rots)
          wire_cutter_rot = THE_MACHINE[0].wire_cutter_rots[THE_MACHINE[0].wire_cutter_cur_rot]
          make_opengl_rect_center_on_circle(OpenGLTextures['WIRE_CUTTER'][0], OpenGLTextures['WIRE_CUTTER'][1], (THE_MACHINE[0].wire_cutter_destination_xy[0] + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].wire_cutter_destination_xy[1] + current_blit_change_y - PLAYER.y_dif), wire_cutter_rot, False, (0, 0, OpenGLTextures['WIRE_CUTTER'][0][0], OpenGLTextures['WIRE_CUTTER'][0][1]))
    if THE_MACHINE[0].repair_wrench:
      if not THE_MACHINE[0].wrench_reached_themachine:
        make_opengl_rect(OpenGLTextures['WRENCH'][0], OpenGLTextures['WRENCH'][1], (THE_MACHINE[0].wrench_xy[0] + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].wrench_xy[1] + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['WRENCH'][0][0], OpenGLTextures['WRENCH'][0][1]))
      if THE_MACHINE[0].wrench_reached_themachine and THE_MACHINE[0].wrench_stage != 0:
        THE_MACHINE[0].smoke4_cur_milliseconds += delta_milliseconds
        num_smoke_image_updates = round(THE_MACHINE[0].smoke4_cur_milliseconds // THE_MACHINE[0].milliseconds_to_update_smoke_image)
        THE_MACHINE[0].smoke4_cur_milliseconds %= THE_MACHINE[0].milliseconds_to_update_smoke_image
        THE_MACHINE[0].smoke4_cur_rot += num_smoke_image_updates
        THE_MACHINE[0].smoke4_cur_rot %= len(THE_MACHINE[0].smoke4_rots)
        smoke4_rot = THE_MACHINE[0].smoke4_rots[THE_MACHINE[0].smoke4_cur_rot]
        smoke_size_multiplier = 1.1
        if THE_MACHINE[0].wrench_stage == 1:
          smoke_index = THE_MACHINE[0].milliseconds_since_wrench_repair // (THE_MACHINE[0].milliseconds_for_smoke_to_appear / (len(OpenGLTextures['SMOKE']) - 1))
          if smoke_index > (len(OpenGLTextures['SMOKE']) - 1):
            smoke_index = (len(OpenGLTextures['SMOKE']) - 1)
          smoke_index = round(smoke_index)
          cur_smoke = ((OpenGLTextures['SMOKE'][smoke_index][0][0] * smoke_size_multiplier, OpenGLTextures['SMOKE'][smoke_index][0][1] * smoke_size_multiplier), OpenGLTextures['SMOKE'][smoke_index][1])
          make_opengl_rect_center_on_circle(cur_smoke[0], cur_smoke[1], (2458 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 930 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke4_rot, False, (0, 0, cur_smoke[0][0], cur_smoke[0][1]))
        if THE_MACHINE[0].wrench_stage == 2:
          smoke_index = (len(OpenGLTextures['SMOKE']) - 1)
          smoke_index = round(smoke_index)
          cur_smoke = ((OpenGLTextures['SMOKE'][smoke_index][0][0] * smoke_size_multiplier, OpenGLTextures['SMOKE'][smoke_index][0][1] * smoke_size_multiplier), OpenGLTextures['SMOKE'][smoke_index][1])
          make_opengl_rect_center_on_circle(cur_smoke[0], cur_smoke[1], (2458 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 930 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke4_rot, False, (0, 0, cur_smoke[0][0], cur_smoke[0][1]))
        if THE_MACHINE[0].wrench_stage == 3:
          smoke_index = (THE_MACHINE[0].milliseconds_since_wrench_repair - THE_MACHINE[0].milliseconds_for_smoke_to_hangout - THE_MACHINE[0].milliseconds_for_smoke_to_appear) // (THE_MACHINE[0].milliseconds_for_smoke_to_appear / (len(OpenGLTextures['SMOKE']) - 1))
          smoke_index = (len(OpenGLTextures['SMOKE']) - 1) - smoke_index
          if smoke_index > (len(OpenGLTextures['SMOKE']) - 1):
            smoke_index = (len(OpenGLTextures['SMOKE']) - 1)
          smoke_index = round(smoke_index)
          cur_smoke = ((OpenGLTextures['SMOKE'][smoke_index][0][0] * smoke_size_multiplier, OpenGLTextures['SMOKE'][smoke_index][0][1] * smoke_size_multiplier), OpenGLTextures['SMOKE'][smoke_index][1])
          make_opengl_rect_center_on_circle(cur_smoke[0], cur_smoke[1], (2458 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 930 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke4_rot, False, (0, 0, cur_smoke[0][0], cur_smoke[0][1]))
        if THE_MACHINE[0].wrench_stage < 3:
          THE_MACHINE[0].wrench_cur_milliseconds += delta_milliseconds
          num_wrench_image_updates = round(THE_MACHINE[0].wrench_cur_milliseconds // THE_MACHINE[0].milliseconds_to_update_tool_image)
          THE_MACHINE[0].wrench_cur_milliseconds %= THE_MACHINE[0].milliseconds_to_update_tool_image
          THE_MACHINE[0].wrench_cur_rot += num_wrench_image_updates
          THE_MACHINE[0].wrench_cur_rot %= len(THE_MACHINE[0].wrench_rots)
          wrench_rot = THE_MACHINE[0].wrench_rots[THE_MACHINE[0].wrench_cur_rot]
          make_opengl_rect_center_on_circle(OpenGLTextures['WRENCH'][0], OpenGLTextures['WRENCH'][1], (THE_MACHINE[0].wrench_destination_xy[0] + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].wrench_destination_xy[1] + current_blit_change_y - PLAYER.y_dif), wrench_rot, False, (0, 0, OpenGLTextures['WRENCH'][0][0], OpenGLTextures['WRENCH'][0][1]))
  make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
  make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
  if My_cached_info.allow_glowing_green_button:
    if (My_cached_info.fake_frame_counter % 30) <= 15:
      make_opengl_rect(OpenGLTextures['SHINY_GREEN_BUTTON'][0], OpenGLTextures['SHINY_GREEN_BUTTON'][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif - 10, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif - 10), 0, False, (0, 0, OpenGLTextures['SHINY_GREEN_BUTTON'][0][0], OpenGLTextures['SHINY_GREEN_BUTTON'][0][1]))

def draw_player():
  if not PLAYER.in_a_pipe:
    make_opengl_rect_center_on_circle(PLAYER.GPU_THE_BALL_BACK[0], PLAYER.GPU_THE_BALL_BACK[1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif), PLAYER.ball_image_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(PLAYER.current_Hamster_image[0], PLAYER.current_Hamster_image[1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos), PLAYER.Hamster_image_rotation, PLAYER.flipped, (0, 0, PLAYER.rect[2], PLAYER.rect[3]))
    make_opengl_rect_center_on_circle(PLAYER.GPU_THE_BALL_FRONT[0], PLAYER.GPU_THE_BALL_FRONT[1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif), PLAYER.ball_image_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))

def draw_sheath():
  if PLAYER.has_piston1:
    if not PLAYER.in_a_pipe:
      make_opengl_rect_center_on_circle(my_sheath.GPU_image[0], my_sheath.GPU_image[1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif), my_sheath.rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))

def draw_piston1():
  if my_piston1.extension != 0:
    if not PLAYER.in_a_pipe:
      make_opengl_rect(my_piston1.GPU_CoverImage[0], my_piston1.GPU_CoverImage[1], (my_piston1.Cover_x_pos + stop_scrolling_left+34 + PLAYER.blit_change_x - PLAYER.x_dif, my_piston1.Cover_y_pos + stop_scrolling_top+34 + PLAYER.blit_change_y - PLAYER.y_dif), my_sheath.rotation, False, (my_piston1.cropped_region[0], my_piston1.cropped_region[1], my_piston1.cropped_region[0]+my_piston1.cropped_region[2], my_piston1.cropped_region[3]))

def draw_piston2():
  if my_piston2.extension != 0:
    if not PLAYER.in_a_pipe:
      make_opengl_rect(my_piston2.GPU_current_image[0], my_piston2.GPU_current_image[1], (my_piston2.Cover_x_pos + stop_scrolling_left+34 + PLAYER.blit_change_x - PLAYER.x_dif, my_piston2.Cover_y_pos + stop_scrolling_top+34 + PLAYER.blit_change_y - PLAYER.y_dif), my_sheath.rotation, False, (my_piston2.cropped_region[0], my_piston2.cropped_region[1], my_piston2.cropped_region[0]+my_piston2.cropped_region[2], my_piston2.cropped_region[3]))

def draw_clouds():
  [make_opengl_rect(MySprite.GPU_shown_image[0], MySprite.GPU_shown_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.GPU_shown_image[0][0], MySprite.GPU_shown_image[0][1])) for MySprite in CLOUDS]

def draw_keys():
  [make_opengl_rect_center_on_circle(MySprite.GPU_image[0], MySprite.GPU_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), MySprite.image_rotation, False, (0, 0, MySprite.GPU_image[0][0], MySprite.GPU_image[0][1])) for MySprite in ALLKEYS if not MySprite.is_inserted]

def draw_leaves():
  [make_opengl_rect(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), MySprite.rotation, False, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in LEAVES]

def draw_upgrades():
  if UPGRADES != []:
    if not UPGRADES[0].collected:
      [make_opengl_rect(MySprite.GPU_BubbleImage[0], MySprite.GPU_BubbleImage[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.GPU_BubbleImage[0][0], MySprite.GPU_BubbleImage[0][1])) for MySprite in UPGRADES]
      [make_opengl_rect(MySprite.GPU_PistonImage_current[0], MySprite.GPU_PistonImage_current[1], (MySprite.piston_x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.piston_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (MySprite.push_piston_ltwh[0], MySprite.push_piston_ltwh[1], MySprite.push_piston_ltwh[0]+MySprite.push_piston_ltwh[2], MySprite.push_piston_ltwh[3])) for MySprite in UPGRADES]
      [make_opengl_rect(MySprite.GPU_GrappleImage_current[0], MySprite.GPU_GrappleImage_current[1], (MySprite.grapple_x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.grapple_y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (MySprite.grapple_piston_ltwh[0], MySprite.grapple_piston_ltwh[1], MySprite.grapple_piston_ltwh[0]+MySprite.grapple_piston_ltwh[2], MySprite.grapple_piston_ltwh[3])) for MySprite in UPGRADES]
    if UPGRADES[0].collected and My_cached_info.playing_upgrade_sequence:
      #
      #
      #
      if not My_cached_info.upgrade_finished_flying_around_player:
        My_cached_info.milliseconds_into_upgrade_flying_around_player += delta_milliseconds
        percent_of_the_way_through_sequence = My_cached_info.milliseconds_into_upgrade_flying_around_player / My_cached_info.milliseconds_to_complete_upgrade_flying_around_player
        if UPGRADES[0].fly_clockwise:
          UPGRADES[0].current_angle_around_player = (UPGRADES[0].initial_upgrade_angle_of_approach - (percent_of_the_way_through_sequence * 1000)) % 360
        if UPGRADES[0].fly_counter_clockwise:
          UPGRADES[0].current_angle_around_player = (UPGRADES[0].initial_upgrade_angle_of_approach + (percent_of_the_way_through_sequence * 1000)) % 360
        absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
        distance_between_player_center_and_bubble_center = ((72 - 38) * (1 - percent_of_the_way_through_sequence)) + 38
        additional_x = distance_between_player_center_and_bubble_center * math.cos(math.radians(UPGRADES[0].current_angle_around_player))
        additional_y = distance_between_player_center_and_bubble_center * -math.sin(math.radians(UPGRADES[0].current_angle_around_player))
        image_scaling_factor = (1 - percent_of_the_way_through_sequence)
        scale_bubble = OpenGLTextures['BUBBLE'][0][0] * image_scaling_factor
        piston1_additional_x = 17 * image_scaling_factor
        piston1_additional_y = 14 * image_scaling_factor
        piston2_additional_x = 22 * image_scaling_factor
        piston2_additional_y = 31 * image_scaling_factor
        if scale_bubble <= 0:
          scale_bubble = 0.1
        scale_additional_xy = (OpenGLTextures['BUBBLE'][0][0] - scale_bubble) / 2
        scaled_piston1 = ((UPGRADES[0].GPU_PistonImage_current[0][0] * image_scaling_factor, UPGRADES[0].GPU_PistonImage_current[0][1] * image_scaling_factor), UPGRADES[0].GPU_PistonImage_current[1])
        scaled_piston2 = ((UPGRADES[0].GPU_GrappleImage_current[0][0] * image_scaling_factor, UPGRADES[0].GPU_GrappleImage_current[0][1] * image_scaling_factor), UPGRADES[0].GPU_GrappleImage_current[1])
        My_cached_info.bubble_flying_number_of_pixels_to_move += delta_milliseconds / 6
        make_opengl_rect_center_on_circle((scale_bubble, scale_bubble), OpenGLTextures['BUBBLE'][1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + additional_x + scale_additional_xy, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + additional_y + scale_additional_xy), 0, False, (0, 0, scale_bubble, scale_bubble))
        try:
          make_opengl_rect((UPGRADES[0].GPU_PistonImage_current[0][0] * image_scaling_factor, UPGRADES[0].GPU_PistonImage_current[0][1] * image_scaling_factor), scaled_piston1[1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + additional_x + scale_additional_xy + piston1_additional_x, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + additional_y + scale_additional_xy + piston1_additional_y), 0, False, (UPGRADES[0].push_piston_ltwh[0] * image_scaling_factor, UPGRADES[0].push_piston_ltwh[1] * image_scaling_factor, (UPGRADES[0].push_piston_ltwh[0]+UPGRADES[0].push_piston_ltwh[2]) * image_scaling_factor, UPGRADES[0].push_piston_ltwh[3] * image_scaling_factor))
          make_opengl_rect((UPGRADES[0].GPU_GrappleImage_current[0][0] * image_scaling_factor, UPGRADES[0].GPU_GrappleImage_current[0][1] * image_scaling_factor), scaled_piston2[1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + additional_x + scale_additional_xy + piston2_additional_x, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + additional_y + scale_additional_xy + piston2_additional_y), 0, False, (UPGRADES[0].grapple_piston_ltwh[0] * image_scaling_factor, UPGRADES[0].grapple_piston_ltwh[1] * image_scaling_factor, (UPGRADES[0].grapple_piston_ltwh[0]+UPGRADES[0].grapple_piston_ltwh[2]) * image_scaling_factor, UPGRADES[0].grapple_piston_ltwh[3] * image_scaling_factor))
        except:
          pass
        if My_cached_info.milliseconds_into_upgrade_flying_around_player >= My_cached_info.milliseconds_to_complete_upgrade_flying_around_player:
          My_cached_info.upgrade_finished_flying_around_player = True
        return
      #
      #
      My_cached_info.milliseconds_into_upgrade_sequence += delta_milliseconds
      percent_of_the_way_through_sequence = My_cached_info.milliseconds_into_upgrade_sequence / My_cached_info.milliseconds_to_complete_upgrade_sequence
      step0 = 0.00
      step1 = 0.10
      step2 = 0.20
      step3 = 0.40
      step4 = 0.60
      step5 = 0.80
      step6 = 0.90
      step7 = 1.00
      #
      if step0 <= percent_of_the_way_through_sequence <= step1: # small fade in
        current_transparency_index = math.floor((percent_of_the_way_through_sequence / step1) * 9)
        if current_transparency_index >= 9:
          current_transparency_index = 8
        make_opengl_rect(OpenGLTextures['ALPHA_PUSH_PISTON'][current_transparency_index][0], OpenGLTextures['ALPHA_PUSH_PISTON'][current_transparency_index][1], (((1 / 2) * screen_width) - (my_piston1.maximum_extension / 2), ((1 / 6) * screen_height)), 0, False, (0, 0, my_piston1.maximum_extension - 12, OpenGLTextures['ALPHA_PUSH_PISTON'][current_transparency_index][0][1]))
      #
      if step1 < percent_of_the_way_through_sequence <= step2: # small fully faded in
        make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (((1 / 2) * screen_width) - (my_piston1.maximum_extension / 2), ((1 / 6) * screen_height)), 0, False, (0, 0, my_piston1.maximum_extension - 12, OpenGLTextures['PUSH_PISTON_COVER'][0][1]))
      #
      if step2 < percent_of_the_way_through_sequence <= step3: # fade in the red
        current_transparency_index = math.floor(((percent_of_the_way_through_sequence - step2) / abs(step3 - step2)) * 9)
        if current_transparency_index >= 9:
          current_transparency_index = 8
        make_opengl_rect(OpenGLTextures['RED_ALPHA_PUSH_PISTON'][current_transparency_index][0], OpenGLTextures['RED_ALPHA_PUSH_PISTON'][current_transparency_index][1], (((1 / 2) * screen_width) - (my_piston1.maximum_extension / 2), ((1 / 6) * screen_height)), 0, False, (0, 0, my_piston1.maximum_extension, OpenGLTextures['RED_ALPHA_PUSH_PISTON'][current_transparency_index][0][1]))
        make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (((1 / 2) * screen_width) - (my_piston1.maximum_extension / 2), ((1 / 6) * screen_height)), 0, False, (0, 0, my_piston1.maximum_extension - 12, OpenGLTextures['PUSH_PISTON_COVER'][0][1]))
      #
      if step3 < percent_of_the_way_through_sequence <= step4: # red completely faded in
        make_opengl_rect(OpenGLTextures['RED_ALPHA_PUSH_PISTON'][9][0], OpenGLTextures['RED_ALPHA_PUSH_PISTON'][9][1], (((1 / 2) * screen_width) - (my_piston1.maximum_extension / 2), ((1 / 6) * screen_height)), 0, False, (0, 0, my_piston1.maximum_extension, OpenGLTextures['RED_ALPHA_PUSH_PISTON'][9][0][1]))
        make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (((1 / 2) * screen_width) - (my_piston1.maximum_extension / 2), ((1 / 6) * screen_height)), 0, False, (0, 0, my_piston1.maximum_extension - 12, OpenGLTextures['PUSH_PISTON_COVER'][0][1]))
      #
      if step4 < percent_of_the_way_through_sequence <= step5: # blue coming in over red
        current_transparency_index = math.floor(((percent_of_the_way_through_sequence - step4) / abs(step5 - step4)) * 9)
        if current_transparency_index >= 9:
          current_transparency_index = 8
        make_opengl_rect(OpenGLTextures['RED_ALPHA_PUSH_PISTON'][9][0], OpenGLTextures['RED_ALPHA_PUSH_PISTON'][9][1], (((1 / 2) * screen_width) - (my_piston1.maximum_extension / 2), ((1 / 6) * screen_height)), 0, False, (0, 0, my_piston1.maximum_extension, OpenGLTextures['RED_ALPHA_PUSH_PISTON'][9][0][1]))
        make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (((1 / 2) * screen_width) - (my_piston1.maximum_extension / 2), ((1 / 6) * screen_height)), 0, False, (0, 0, my_piston1.maximum_extension - 12, OpenGLTextures['PUSH_PISTON_COVER'][0][1]))
        make_opengl_rect(OpenGLTextures['ALPHA_PUSH_PISTON'][current_transparency_index][0], OpenGLTextures['ALPHA_PUSH_PISTON'][current_transparency_index][1], (((1 / 2) * screen_width) - (my_piston1.maximum_extension / 2), ((1 / 6) * screen_height)), 0, False, (0, 0, my_piston1.maximum_extension, OpenGLTextures['ALPHA_PUSH_PISTON'][current_transparency_index][0][1]))
      #
      if step5 < percent_of_the_way_through_sequence <= step6:
        make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (((1 / 2) * screen_width) - (my_piston1.maximum_extension / 2), ((1 / 6) * screen_height)), 0, False, (0, 0, my_piston1.maximum_extension, OpenGLTextures['PUSH_PISTON_COVER'][0][1]))
      #
      if step6 < percent_of_the_way_through_sequence <= step7:
        current_transparency_index = 8 - math.floor(((percent_of_the_way_through_sequence - step6) / abs(step7 - step6)) * 9)
        if current_transparency_index >= 9:
          current_transparency_index = 8
        make_opengl_rect(OpenGLTextures['ALPHA_PUSH_PISTON'][current_transparency_index][0], OpenGLTextures['ALPHA_PUSH_PISTON'][current_transparency_index][1], (((1 / 2) * screen_width) - (my_piston1.maximum_extension / 2), ((1 / 6) * screen_height)), 0, False, (0, 0, my_piston1.maximum_extension, OpenGLTextures['ALPHA_PUSH_PISTON'][current_transparency_index][0][1]))
      #
      #
      step0 = 0.00
      step1 = 0.10
      step2 = 0.20
      step3 = 0.40
      step4 = 0.60
      step5 = 0.80
      step6 = 0.90
      step7 = 1.00
      #
      if step0 < percent_of_the_way_through_sequence <= step1: # grapple fade in
        current_transparency_index = math.floor((percent_of_the_way_through_sequence / step1) * 9)
        if current_transparency_index >= 9:
          current_transparency_index = 8
        make_opengl_rect(OpenGLTextures['ALPHA_GRAPPLE_PISTON'][current_transparency_index][0], OpenGLTextures['ALPHA_GRAPPLE_PISTON'][current_transparency_index][1], (((1 / 2) * screen_width) - (my_piston2.maximum_extension / 2), ((1 / 6) * screen_height) + 15), 0, False, (OpenGLTextures['ALPHA_GRAPPLE_PISTON'][current_transparency_index][0][0] - my_piston2.maximum_extension + 12, 0, OpenGLTextures['ALPHA_GRAPPLE_PISTON'][current_transparency_index][0][0], OpenGLTextures['ALPHA_GRAPPLE_PISTON'][current_transparency_index][0][1]))
      #
      if step1 < percent_of_the_way_through_sequence <= step2: # move right
        pixels_moving_right = ((percent_of_the_way_through_sequence - step1) / (step2 - step1)) * 12
        make_opengl_rect(OpenGLTextures['GRAPPLE_PISTON_COVER'][0], OpenGLTextures['GRAPPLE_PISTON_COVER'][1], (((1 / 2) * screen_width) - (my_piston2.maximum_extension / 2) + pixels_moving_right, ((1 / 6) * screen_height) + 15), 0, False, (OpenGLTextures['GRAPPLE_PISTON_COVER'][0][0] - my_piston2.maximum_extension + 12, 0, OpenGLTextures['GRAPPLE_PISTON_COVER'][0][0], OpenGLTextures['GRAPPLE_PISTON_COVER'][0][1]))
      #
      if step2 < percent_of_the_way_through_sequence <= step3: # discolor fade in
        current_transparency_index = math.floor(((percent_of_the_way_through_sequence - step2) / abs(step3 - step2)) * 9)
        if current_transparency_index >= 9:
          current_transparency_index = 8
        make_opengl_rect(OpenGLTextures['DISCOLORED_GRAPPLE'][current_transparency_index][0], OpenGLTextures['DISCOLORED_GRAPPLE'][current_transparency_index][1], (((1 / 2) * screen_width) - (my_piston2.maximum_extension / 2), ((1 / 6) * screen_height) + 15), 0, False, (OpenGLTextures['DISCOLORED_GRAPPLE'][current_transparency_index][0][0] - my_piston2.maximum_extension, 0, OpenGLTextures['DISCOLORED_GRAPPLE'][current_transparency_index][0][0], OpenGLTextures['DISCOLORED_GRAPPLE'][current_transparency_index][0][1]))
        make_opengl_rect(OpenGLTextures['GRAPPLE_PISTON_COVER'][0], OpenGLTextures['GRAPPLE_PISTON_COVER'][1], (((1 / 2) * screen_width) - (my_piston2.maximum_extension / 2) + 12, ((1 / 6) * screen_height) + 15), 0, False, (OpenGLTextures['GRAPPLE_PISTON_COVER'][0][0] - my_piston2.maximum_extension + 12, 0, OpenGLTextures['GRAPPLE_PISTON_COVER'][0][0], OpenGLTextures['GRAPPLE_PISTON_COVER'][0][1]))
      #
      if step3 < percent_of_the_way_through_sequence <= step4: # discolor completely faded in
        make_opengl_rect(OpenGLTextures['DISCOLORED_GRAPPLE'][9][0], OpenGLTextures['DISCOLORED_GRAPPLE'][9][1], (((1 / 2) * screen_width) - (my_piston2.maximum_extension / 2), ((1 / 6) * screen_height) + 15), 0, False, (OpenGLTextures['DISCOLORED_GRAPPLE'][9][0][0] - my_piston2.maximum_extension, 0, OpenGLTextures['DISCOLORED_GRAPPLE'][9][0][0], OpenGLTextures['DISCOLORED_GRAPPLE'][9][0][1]))
        make_opengl_rect(OpenGLTextures['GRAPPLE_PISTON_COVER'][0], OpenGLTextures['GRAPPLE_PISTON_COVER'][1], (((1 / 2) * screen_width) - (my_piston2.maximum_extension / 2) + 12, ((1 / 6) * screen_height) + 15), 0, False, (OpenGLTextures['GRAPPLE_PISTON_COVER'][0][0] - my_piston2.maximum_extension + 12, 0, OpenGLTextures['GRAPPLE_PISTON_COVER'][0][0], OpenGLTextures['GRAPPLE_PISTON_COVER'][0][1]))
      #
      if step4 < percent_of_the_way_through_sequence <= step5: # combine discolor and normal
        current_transparency_index = math.floor(((percent_of_the_way_through_sequence - step4) / abs(step5 - step4)) * 9)
        if current_transparency_index >= 9:
          current_transparency_index = 8
        make_opengl_rect(OpenGLTextures['DISCOLORED_GRAPPLE'][9][0], OpenGLTextures['DISCOLORED_GRAPPLE'][9][1], (((1 / 2) * screen_width) - (my_piston2.maximum_extension / 2), ((1 / 6) * screen_height) + 15), 0, False, (OpenGLTextures['DISCOLORED_GRAPPLE'][9][0][0] - my_piston2.maximum_extension, 0, OpenGLTextures['DISCOLORED_GRAPPLE'][9][0][0], OpenGLTextures['DISCOLORED_GRAPPLE'][9][0][1]))
        make_opengl_rect(OpenGLTextures['GRAPPLE_PISTON_COVER'][0], OpenGLTextures['GRAPPLE_PISTON_COVER'][1], (((1 / 2) * screen_width) - (my_piston2.maximum_extension / 2) + 12, ((1 / 6) * screen_height) + 15), 0, False, (OpenGLTextures['GRAPPLE_PISTON_COVER'][0][0] - my_piston2.maximum_extension + 12, 0, OpenGLTextures['GRAPPLE_PISTON_COVER'][0][0], OpenGLTextures['GRAPPLE_PISTON_COVER'][0][1]))
        make_opengl_rect(OpenGLTextures['ALPHA_GRAPPLE_PISTON'][current_transparency_index][0], OpenGLTextures['ALPHA_GRAPPLE_PISTON'][current_transparency_index][1], (((1 / 2) * screen_width) - (my_piston2.maximum_extension / 2), ((1 / 6) * screen_height) + 15), 0, False, (OpenGLTextures['ALPHA_GRAPPLE_PISTON'][current_transparency_index][0][0] - my_piston2.maximum_extension, 0, OpenGLTextures['ALPHA_GRAPPLE_PISTON'][current_transparency_index][0][0], OpenGLTextures['ALPHA_GRAPPLE_PISTON'][current_transparency_index][0][1]))
      #
      if step5 < percent_of_the_way_through_sequence <= step6: # just exist for a bit
        make_opengl_rect(OpenGLTextures['GRAPPLE_PISTON_COVER'][0], OpenGLTextures['GRAPPLE_PISTON_COVER'][1], (((1 / 2) * screen_width) - (my_piston2.maximum_extension / 2), ((1 / 6) * screen_height) + 15), 0, False, (OpenGLTextures['GRAPPLE_PISTON_COVER'][0][0] - my_piston2.maximum_extension, 0, OpenGLTextures['GRAPPLE_PISTON_COVER'][0][0], OpenGLTextures['GRAPPLE_PISTON_COVER'][0][1]))
      #
      if step6 < percent_of_the_way_through_sequence <= step7: # fade out
        current_transparency_index = 8 - math.floor(((percent_of_the_way_through_sequence - step6) / abs(step7 - step6)) * 9)
        if current_transparency_index >= 9:
          current_transparency_index = 8
        make_opengl_rect(OpenGLTextures['ALPHA_GRAPPLE_PISTON'][current_transparency_index][0], OpenGLTextures['ALPHA_GRAPPLE_PISTON'][current_transparency_index][1], (((1 / 2) * screen_width) - (my_piston2.maximum_extension / 2), ((1 / 6) * screen_height) + 15), 0, False, (OpenGLTextures['ALPHA_GRAPPLE_PISTON'][current_transparency_index][0][0] - my_piston2.maximum_extension, 0, OpenGLTextures['ALPHA_GRAPPLE_PISTON'][current_transparency_index][0][0], OpenGLTextures['ALPHA_GRAPPLE_PISTON'][current_transparency_index][0][1]))

def draw_tools():
  if TOOLS != []:
    if not TOOLS[0].collected:
      [make_opengl_rect(MySprite.GPU_tool_image[0], MySprite.GPU_tool_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.GPU_tool_image[0][0], MySprite.GPU_tool_image[0][1])) for MySprite in TOOLS]
      [make_opengl_rect(MySprite.GPU_BubbleImage[0], MySprite.GPU_BubbleImage[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.GPU_BubbleImage[0][0], MySprite.GPU_BubbleImage[0][1])) for MySprite in TOOLS]
    if My_cached_info.play_tool_sequence:
      My_cached_info.milliseconds_into_tool_flying_around_player += delta_milliseconds
      percent_of_the_way_through_sequence = My_cached_info.milliseconds_into_tool_flying_around_player / My_cached_info.milliseconds_to_complete_tool_flying_around_player
      if My_cached_info.milliseconds_to_complete_tool_flying_around_player <= My_cached_info.milliseconds_into_tool_flying_around_player:
        My_cached_info.milliseconds_into_tool_flying_around_player = 0
        My_cached_info.play_tool_sequence = False
      if TOOLS[0].fly_clockwise:
        TOOLS[0].current_angle_around_player = (TOOLS[0].initial_upgrade_angle_of_approach - (percent_of_the_way_through_sequence * 1000)) % 360
      if TOOLS[0].fly_counter_clockwise:
        TOOLS[0].current_angle_around_player = (TOOLS[0].initial_upgrade_angle_of_approach + (percent_of_the_way_through_sequence * 1000)) % 360
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      distance_between_player_center_and_bubble_center = ((72 - 38) * (1 - percent_of_the_way_through_sequence)) + 38
      additional_x = distance_between_player_center_and_bubble_center * math.cos(math.radians(TOOLS[0].current_angle_around_player))
      additional_y = distance_between_player_center_and_bubble_center * -math.sin(math.radians(TOOLS[0].current_angle_around_player))
      image_scaling_factor = (1 - percent_of_the_way_through_sequence)
      scale_bubble = OpenGLTextures['BUBBLE'][0][0] * image_scaling_factor
      scale_additional_xy = (OpenGLTextures['BUBBLE'][0][0] - scale_bubble) / 2
      if scale_bubble <= 0:
        scale_bubble = 0.1
      try:
        make_opengl_rect((TOOLS[0].GPU_BubbleImage[0][0] * image_scaling_factor, TOOLS[0].GPU_BubbleImage[0][1] * image_scaling_factor), TOOLS[0].GPU_BubbleImage[1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + additional_x + scale_additional_xy, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + additional_y + scale_additional_xy), 0, False, (0, 0, TOOLS[0].GPU_BubbleImage[0][0] * image_scaling_factor, TOOLS[0].GPU_BubbleImage[0][1] * image_scaling_factor))
        make_opengl_rect((TOOLS[0].GPU_tool_image[0][0] * image_scaling_factor, TOOLS[0].GPU_tool_image[0][1] * image_scaling_factor), TOOLS[0].GPU_tool_image[1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + additional_x + scale_additional_xy, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + additional_y + scale_additional_xy), 0, False, (0, 0, TOOLS[0].GPU_tool_image[0][0] * image_scaling_factor, TOOLS[0].GPU_tool_image[0][1] * image_scaling_factor))
      except:
        pass

def draw_elevators():
  [make_opengl_rect(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in ELEVATORS]

def draw_dripdrops():
  [make_opengl_rect(MySprite.GPU_actual_current_image[0], MySprite.GPU_actual_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.GPU_actual_current_image[0][0], MySprite.GPU_actual_current_image[0][1])) for MySprite in DRIPDROPS]

def draw_ants():
  [make_opengl_rect(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), MySprite.rotation, False, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in ANTS]

def draw_player_mover_ants():
  [make_opengl_rect(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), MySprite.rotation, False, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in PLAYER_MOVER_ANTS]

def draw_spinny_objects():
  [make_opengl_rect_center_on_circle(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), MySprite.current_rotation, False, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in SPINNY_OBJECTS]

def draw_hawk():
  make_opengl_rect(Hawk.GPU_current_image[0], Hawk.GPU_current_image[1], (Hawk.x_pos + current_blit_change_x - PLAYER.x_dif, Hawk.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, Hawk.GPU_current_image[0][0], Hawk.GPU_current_image[0][1]))

def draw_beetle():
  if BEETLE_FRIEND != []:
    if BEETLE_FRIEND.eaten != 3:
      make_opengl_rect(BEETLE_FRIEND.GPU_Button[BEETLE_FRIEND.WhichButton][0], BEETLE_FRIEND.GPU_Button[BEETLE_FRIEND.WhichButton][1], (7214 + ((1/2)*screen_width) + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, 3606+25 + ((1/2)*screen_height) + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.GPU_Button[BEETLE_FRIEND.WhichButton][0][0], BEETLE_FRIEND.GPU_Button[BEETLE_FRIEND.WhichButton][0][1]))
      make_opengl_rect(BEETLE_FRIEND.GPU_current_image[0], BEETLE_FRIEND.GPU_current_image[1], (BEETLE_FRIEND.x_pos + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), BEETLE_FRIEND.rotation, BEETLE_FRIEND.image_flipped, (0, 0, BEETLE_FRIEND.GPU_current_image[0][0], BEETLE_FRIEND.GPU_current_image[0][1]))
      if BEETLE_FRIEND.ShowingWhichDialogue != 0:
        if BEETLE_FRIEND.ShowingWhichDialogue == 1:
          make_opengl_rect(BEETLE_FRIEND.IWannaLeave[0], BEETLE_FRIEND.IWannaLeave[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.IWannaLeave[0][0], BEETLE_FRIEND.IWannaLeave[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 2:
          make_opengl_rect(BEETLE_FRIEND.OhThankYouThankYou[0], BEETLE_FRIEND.OhThankYouThankYou[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.OhThankYouThankYou[0][0], BEETLE_FRIEND.OhThankYouThankYou[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 3:
          make_opengl_rect(BEETLE_FRIEND.OohBigRoom[0], BEETLE_FRIEND.OohBigRoom[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.OohBigRoom[0][0], BEETLE_FRIEND.OohBigRoom[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 4:
          make_opengl_rect(BEETLE_FRIEND.NeatNeat[0], BEETLE_FRIEND.NeatNeat[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.NeatNeat[0][0], BEETLE_FRIEND.NeatNeat[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 5:
          make_opengl_rect(BEETLE_FRIEND.AnotherDoor[0], BEETLE_FRIEND.AnotherDoor[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.AnotherDoor[0][0], BEETLE_FRIEND.AnotherDoor[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 6:
          make_opengl_rect(BEETLE_FRIEND.WhoKnewAntsMadeDoors[0], BEETLE_FRIEND.WhoKnewAntsMadeDoors[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.WhoKnewAntsMadeDoors[0][0], BEETLE_FRIEND.WhoKnewAntsMadeDoors[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 7:
          make_opengl_rect(BEETLE_FRIEND.IDidnt[0], BEETLE_FRIEND.IDidnt[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.IDidnt[0][0], BEETLE_FRIEND.IDidnt[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 8:
          make_opengl_rect(BEETLE_FRIEND.Although[0], BEETLE_FRIEND.Although[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.Although[0][0], BEETLE_FRIEND.Although[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 9:
          make_opengl_rect(BEETLE_FRIEND.MostDontKnow[0], BEETLE_FRIEND.MostDontKnow[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.MostDontKnow[0][0], BEETLE_FRIEND.MostDontKnow[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 10:
          make_opengl_rect(BEETLE_FRIEND.BeetlesCanTalk[0], BEETLE_FRIEND.BeetlesCanTalk[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.BeetlesCanTalk[0][0], BEETLE_FRIEND.BeetlesCanTalk[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 11:
          make_opengl_rect(BEETLE_FRIEND.KekKekKek[0], BEETLE_FRIEND.KekKekKek[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.KekKekKek[0][0], BEETLE_FRIEND.KekKekKek[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 12:
          make_opengl_rect(BEETLE_FRIEND.HamsterFriend[0], BEETLE_FRIEND.HamsterFriend[1], (BEETLE_FRIEND.x_pos - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.HamsterFriend[0][0], BEETLE_FRIEND.HamsterFriend[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 13:
          make_opengl_rect(BEETLE_FRIEND.CanYouOpenTheDoor[0], BEETLE_FRIEND.CanYouOpenTheDoor[1], (BEETLE_FRIEND.x_pos - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.CanYouOpenTheDoor[0][0], BEETLE_FRIEND.CanYouOpenTheDoor[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 14:
          make_opengl_rect(BEETLE_FRIEND.YayThankYouThankYou[0], BEETLE_FRIEND.YayThankYouThankYou[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.YayThankYouThankYou[0][0], BEETLE_FRIEND.YayThankYouThankYou[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 15:
          make_opengl_rect(BEETLE_FRIEND.HamsterFriendHamsterFriend[0], BEETLE_FRIEND.HamsterFriendHamsterFriend[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.HamsterFriendHamsterFriend[0][0], BEETLE_FRIEND.HamsterFriendHamsterFriend[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 16:
          make_opengl_rect(BEETLE_FRIEND.ImGonnaPressThis[0], BEETLE_FRIEND.ImGonnaPressThis[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.ImGonnaPressThis[0][0], BEETLE_FRIEND.ImGonnaPressThis[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 17:
          make_opengl_rect(BEETLE_FRIEND.OpenDoorOpenDoor[0], BEETLE_FRIEND.OpenDoorOpenDoor[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.OpenDoorOpenDoor[0][0], BEETLE_FRIEND.OpenDoorOpenDoor[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 18:
          make_opengl_rect(BEETLE_FRIEND.ThanksHamsterFriend[0], BEETLE_FRIEND.ThanksHamsterFriend[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.ThanksHamsterFriend[0][0], BEETLE_FRIEND.ThanksHamsterFriend[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 19:
          make_opengl_rect(BEETLE_FRIEND.WereAGoodTeam[0], BEETLE_FRIEND.WereAGoodTeam[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.WereAGoodTeam[0][0], BEETLE_FRIEND.WereAGoodTeam[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 20:
          make_opengl_rect(BEETLE_FRIEND.IOpenDoors[0], BEETLE_FRIEND.IOpenDoors[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.IOpenDoors[0][0], BEETLE_FRIEND.IOpenDoors[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 21:
          make_opengl_rect(BEETLE_FRIEND.AndYouAlsoOpenDoors[0], BEETLE_FRIEND.AndYouAlsoOpenDoors[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.AndYouAlsoOpenDoors[0][0], BEETLE_FRIEND.AndYouAlsoOpenDoors[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 23:
          make_opengl_rect(BEETLE_FRIEND.YouKnow[0], BEETLE_FRIEND.YouKnow[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.YouKnow[0][0], BEETLE_FRIEND.YouKnow[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 24:
          make_opengl_rect(BEETLE_FRIEND.ThisKindaFeelsLikeAn[0], BEETLE_FRIEND.ThisKindaFeelsLikeAn[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.ThisKindaFeelsLikeAn[0][0], BEETLE_FRIEND.ThisKindaFeelsLikeAn[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 25:
          make_opengl_rect(BEETLE_FRIEND.EscortMission[0], BEETLE_FRIEND.EscortMission[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.EscortMission[0][0], BEETLE_FRIEND.EscortMission[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 26:
          make_opengl_rect(BEETLE_FRIEND.LikeFromAVideoGame[0], BEETLE_FRIEND.LikeFromAVideoGame[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.LikeFromAVideoGame[0][0], BEETLE_FRIEND.LikeFromAVideoGame[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 27:
          make_opengl_rect(BEETLE_FRIEND.Although2[0], BEETLE_FRIEND.Although2[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.Although2[0][0], BEETLE_FRIEND.Although2[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 28:
          make_opengl_rect(BEETLE_FRIEND.IDontNeedProtection[0], BEETLE_FRIEND.IDontNeedProtection[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.IDontNeedProtection[0][0], BEETLE_FRIEND.IDontNeedProtection[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 29:
          make_opengl_rect(BEETLE_FRIEND.OhLook[0], BEETLE_FRIEND.OhLook[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.OhLook[0][0], BEETLE_FRIEND.OhLook[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 30:
          make_opengl_rect(BEETLE_FRIEND.WeFoundTheQueen[0], BEETLE_FRIEND.WeFoundTheQueen[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.WeFoundTheQueen[0][0], BEETLE_FRIEND.WeFoundTheQueen[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 31:
          make_opengl_rect(BEETLE_FRIEND.Wahhhh[0], BEETLE_FRIEND.Wahhhh[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.Wahhhh[0][0], BEETLE_FRIEND.Wahhhh[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 32:
          make_opengl_rect(BEETLE_FRIEND.HeavyButton[0], BEETLE_FRIEND.HeavyButton[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.HeavyButton[0][0], BEETLE_FRIEND.HeavyButton[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 33:
          make_opengl_rect(BEETLE_FRIEND.wow1[0], BEETLE_FRIEND.wow1[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.wow1[0][0], BEETLE_FRIEND.wow1[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 34:
          make_opengl_rect(BEETLE_FRIEND.wow2[0], BEETLE_FRIEND.wow2[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.wow2[0][0], BEETLE_FRIEND.wow2[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 35:
          make_opengl_rect(BEETLE_FRIEND.wow3[0], BEETLE_FRIEND.wow3[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.wow3[0][0], BEETLE_FRIEND.wow3[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 36:
          make_opengl_rect(BEETLE_FRIEND.wow4[0], BEETLE_FRIEND.wow4[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.wow4[0][0], BEETLE_FRIEND.wow4[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 37:
          make_opengl_rect(BEETLE_FRIEND.ThatWasWild[0], BEETLE_FRIEND.ThatWasWild[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.ThatWasWild[0][0], BEETLE_FRIEND.ThatWasWild[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 38:
          make_opengl_rect(BEETLE_FRIEND.ThanksForComingInAfterMe[0], BEETLE_FRIEND.ThanksForComingInAfterMe[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.ThanksForComingInAfterMe[0][0], BEETLE_FRIEND.ThanksForComingInAfterMe[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 39:
          make_opengl_rect(BEETLE_FRIEND.IDontThinkICanFlyYouOut[0], BEETLE_FRIEND.IDontThinkICanFlyYouOut[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.IDontThinkICanFlyYouOut[0][0], BEETLE_FRIEND.IDontThinkICanFlyYouOut[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 40:
          make_opengl_rect(BEETLE_FRIEND.IllMeetYouPastThisAcid[0], BEETLE_FRIEND.IllMeetYouPastThisAcid[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.IllMeetYouPastThisAcid[0][0], BEETLE_FRIEND.IllMeetYouPastThisAcid[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 41:
          make_opengl_rect(BEETLE_FRIEND.ImSoGladYouMadeItOut[0], BEETLE_FRIEND.ImSoGladYouMadeItOut[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.ImSoGladYouMadeItOut[0][0], BEETLE_FRIEND.ImSoGladYouMadeItOut[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 42:
          make_opengl_rect(BEETLE_FRIEND.IThinkImJustGonnaHangoutForABit[0], BEETLE_FRIEND.IThinkImJustGonnaHangoutForABit[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.IThinkImJustGonnaHangoutForABit[0][0], BEETLE_FRIEND.IThinkImJustGonnaHangoutForABit[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 43:
          make_opengl_rect(BEETLE_FRIEND.HereIFoundThisEarlier[0], BEETLE_FRIEND.HereIFoundThisEarlier[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.HereIFoundThisEarlier[0][0], BEETLE_FRIEND.HereIFoundThisEarlier[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 44:
          make_opengl_rect(BEETLE_FRIEND.IllComeMeetYouOutsideSometime[0], BEETLE_FRIEND.IllComeMeetYouOutsideSometime[1], (BEETLE_FRIEND.x_pos + 87 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.IllComeMeetYouOutsideSometime[0][0], BEETLE_FRIEND.IllComeMeetYouOutsideSometime[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 45:
          make_opengl_rect(BEETLE_FRIEND.HeyaHamsterFriend[0], BEETLE_FRIEND.HeyaHamsterFriend[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.HeyaHamsterFriend[0][0], BEETLE_FRIEND.HeyaHamsterFriend[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 46:
          make_opengl_rect(BEETLE_FRIEND.ImSoHappyToSeeYouAgain[0], BEETLE_FRIEND.ImSoHappyToSeeYouAgain[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.ImSoHappyToSeeYouAgain[0][0], BEETLE_FRIEND.ImSoHappyToSeeYouAgain[0][1]))
        if BEETLE_FRIEND.ShowingWhichDialogue == 47:
          make_opengl_rect(BEETLE_FRIEND.IHopeYoureDoinWell[0], BEETLE_FRIEND.IHopeYoureDoinWell[1], (BEETLE_FRIEND.x_pos + - 171 + 40 + BEETLE_FRIEND.blit_change_x + current_blit_change_x - PLAYER.x_dif, BEETLE_FRIEND.y_pos - 49 + BEETLE_FRIEND.blit_change_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, BEETLE_FRIEND.IHopeYoureDoinWell[0][0], BEETLE_FRIEND.IHopeYoureDoinWell[0][1]))
    if BEETLE_FRIEND.eaten == 3 and not PLAYER.collected_wire_cutter:
      BEETLE_FRIEND.milliseconds_yelling_outside_queen += delta_milliseconds
      if 0 <= BEETLE_FRIEND.milliseconds_yelling_outside_queen <= 1800:
        make_opengl_rect(BEETLE_FRIEND.HelpMeHamsterFriend[0], BEETLE_FRIEND.HelpMeHamsterFriend[1], (QueenAnt.x_pos + current_blit_change_x - PLAYER.x_dif + 525, QueenAnt.y_pos + current_blit_change_y - PLAYER.y_dif + 169), 0, False, (0, 0, BEETLE_FRIEND.HelpMeHamsterFriend[0][0], BEETLE_FRIEND.HelpMeHamsterFriend[0][1]))
      if 1800 < BEETLE_FRIEND.milliseconds_yelling_outside_queen < 2000:
        pass
      if 2000 <= BEETLE_FRIEND.milliseconds_yelling_outside_queen <= 3800:
        make_opengl_rect(BEETLE_FRIEND.PleaseComeInAndSaveMe[0], BEETLE_FRIEND.PleaseComeInAndSaveMe[1], (QueenAnt.x_pos + current_blit_change_x - PLAYER.x_dif + 525, QueenAnt.y_pos + current_blit_change_y - PLAYER.y_dif + 169), 0, False, (0, 0, BEETLE_FRIEND.PleaseComeInAndSaveMe[0][0], BEETLE_FRIEND.PleaseComeInAndSaveMe[0][1]))
      if 3800 < BEETLE_FRIEND.milliseconds_yelling_outside_queen <= 4000:
        pass
      if BEETLE_FRIEND.milliseconds_yelling_outside_queen > 4000:
        BEETLE_FRIEND.milliseconds_yelling_outside_queen = 0

def draw_queen_ant():
  make_opengl_rect(QueenAnt.GPU_current_image[0], QueenAnt.GPU_current_image[1], (QueenAnt.x_pos + current_blit_change_x - PLAYER.x_dif, QueenAnt.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, QueenAnt.GPU_current_image[0][0], QueenAnt.GPU_current_image[0][1]))

def draw_player_upgrade_cutscene():
  if PLAY_UPGRADE_CUTSCENE_start_frame <= frame_counter < PLAY_UPGRADE_CUTSCENE_end_frame:
    make_opengl_rect(UPGRADES[0].GPU_PlusPistonPowerImage[0], UPGRADES[0].GPU_PlusPistonPowerImage[1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif - 127 + 34, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif - 32 - 10), 0, False, (0, 0, UPGRADES[0].GPU_PlusPistonPowerImage[0][0], UPGRADES[0].GPU_PlusPistonPowerImage[0][1]))

def draw_leaks():
  [make_opengl_rect_center_on_circle(MySprite.GPU_image[0], MySprite.GPU_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), MySprite.rotation, False, (0, 0, MySprite.GPU_image[0][0], MySprite.GPU_image[0][1])) for MySprite in LEAKS]

def draw_sprites_front():
  [make_opengl_rect(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in MY_SPRITES_FRONT]

def draw_moving_sprites_front():
  for i in range(len(MOVING_SPRITE_FRONT)):
    MOVING_SPRITE_FRONT[i].current_time_before_frame_switch += delta_milliseconds
    if MOVING_SPRITE_FRONT[i].current_time_before_frame_switch >= MOVING_SPRITE_FRONT[i].time_needed_before_frame_switch:
      MOVING_SPRITE_FRONT[i].current_time_before_frame_switch = MOVING_SPRITE_FRONT[i].current_time_before_frame_switch % MOVING_SPRITE_FRONT[i].time_needed_before_frame_switch
      MOVING_SPRITE_FRONT[i].current_frame += 1
      if MOVING_SPRITE_FRONT[i].current_frame == MOVING_SPRITE_FRONT[i].number_of_frames:
        MOVING_SPRITE_FRONT[i].current_frame = 0
    make_opengl_rect(MOVING_SPRITE_FRONT[i].GPU_current_image[0], MOVING_SPRITE_FRONT[i].GPU_current_image[1], (MOVING_SPRITE_FRONT[i].x_pos + current_blit_change_x - PLAYER.x_dif, MOVING_SPRITE_FRONT[i].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, ((MOVING_SPRITE_FRONT[i].GPU_current_image[0][0] / MOVING_SPRITE_FRONT[i].number_of_frames) * MOVING_SPRITE_FRONT[i].current_frame, 0, (MOVING_SPRITE_FRONT[i].GPU_current_image[0][0] / MOVING_SPRITE_FRONT[i].number_of_frames)+(MOVING_SPRITE_FRONT[i].GPU_current_image[0][0] / MOVING_SPRITE_FRONT[i].number_of_frames) * MOVING_SPRITE_FRONT[i].current_frame, MOVING_SPRITE_FRONT[i].GPU_current_image[0][1]))

def draw_transport_pipes():
  if PLAYER.in_a_pipe:
    my_piston2.my_grapple_claw_x_pos = 0
    my_piston2.my_grapple_claw_y_pos = 0
  [make_opengl_rect(MySprite.GPU_current_wind_image[0], MySprite.GPU_current_wind_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif + MySprite.rect[2], MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, MySprite.flipped, (0, 0, MySprite.blow_width, MySprite.GPU_current_wind_image[0][1])) for MySprite in TRANSPORT_PIPES if MySprite.blow_width != 0 and not MySprite.flipped and not MySprite.up and not MySprite.down]
  [make_opengl_rect(MySprite.GPU_current_wind_image[0], MySprite.GPU_current_wind_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif - MySprite.blow_width, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, MySprite.flipped, (0, 0, MySprite.blow_width, MySprite.GPU_current_wind_image[0][1])) for MySprite in TRANSPORT_PIPES if MySprite.blow_width != 0 and MySprite.flipped and not MySprite.up and not MySprite.down]
  [make_opengl_rect(MySprite.GPU_current_wind_image[0], MySprite.GPU_current_wind_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif - MySprite.blow_width), 90, False, (0, 0, MySprite.blow_width, MySprite.GPU_current_wind_image[0][1])) for MySprite in TRANSPORT_PIPES if MySprite.blow_width != 0 and MySprite.up]
  [make_opengl_rect(MySprite.GPU_current_wind_image[0], MySprite.GPU_current_wind_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif + MySprite.rect[3]), 270, False, (0, 0, MySprite.blow_width, MySprite.GPU_current_wind_image[0][1])) for MySprite in TRANSPORT_PIPES if MySprite.blow_width != 0 and MySprite.down]

def draw_goldfish():
  [make_opengl_rect_center_on_circle(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), MySprite.image_rotation, MySprite.flipped, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in GOLDFISH]

def draw_grates():
  PLAYER.forces_for_next_frame_x = 0
  PLAYER.forces_for_next_frame_y = 0
  if GRATES != []:
    closest_irregularly_shaped_water = 999999
    grate_water_force = 3000
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    x_adjust = ((1/2)*screen_width)
    y_adjust = ((1/2)*screen_height)
    ignore_other_collisions = False
    for i in range(GRATES[0].active_quads[0], GRATES[0].active_quads[1] + 1):
      for j in range(GRATES[0].active_quads[2], GRATES[0].active_quads[3] + 1):
        current_string = GRATES[0].TheDoor10_map[j][i]
        if (GRATES[0].TheDoor10_map[j][i] != '') or j == 22:
          try:
            current_grate, current_timing = GRATES[0].TheDoor10_map_timing[j][i]
            current_step, pixels_showing = get_current_timing_for_grates(current_grate, current_timing)
          except:
            if j == 22:
              pixels_showing = 256
              if 0 <= i <= 11:
                current_step = 2
                current_string = 'GHR'
              if i == 12:
                continue
              if 13 <= i:
                current_step = 2
                current_string = 'GH'
          if (current_step != 0) and not ignore_other_collisions:
            difference_in_x_distance = abs((stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + 34) - (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust + 128))
            difference_in_y_distance = abs((stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + 34) - (GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust + 128))
            distance_between_player_and_water = find_hypotnuse(difference_in_x_distance, difference_in_y_distance)
            if distance_between_player_and_water < closest_irregularly_shaped_water:
              closest_irregularly_shaped_water = distance_between_player_and_water
            if distance_between_player_and_water < (34 + 185):
              try:
                water_collision_points, water_collision_happened = find_collisions_with_offsets_grate_water(GRATES[0].xy_poses[j][i][0], GRATES[0].xy_poses[j][i][1], pygame.mask.from_surface(PyGameTextures[GRATES[0].TheDoor10_map[j][i]][GRATES[0].current_frame]), PLAYER, 0, 0)
              except:
                water_collision_points, water_collision_happened = find_collisions_with_offsets_grate_water(GRATES[0].xy_poses[j][i][0], GRATES[0].xy_poses[j][i][1], pygame.mask.from_surface(PyGameTextures[current_string][GRATES[0].current_frame]), PLAYER, 0, 0)
              if water_collision_happened:
                ignore_other_collisions = True
                Fx, Fy = 0, 0
                if current_string == 'GA':
                  PLAYER.forces_for_next_frame_x = -grate_water_force
                  PLAYER.forces_for_next_frame_y = grate_water_force / 2
                if current_string == 'GG':
                  PLAYER.forces_for_next_frame_x = 0
                  PLAYER.forces_for_next_frame_y = grate_water_force
                if current_string == 'GH':
                  PLAYER.forces_for_next_frame_x = -grate_water_force
                  PLAYER.forces_for_next_frame_y = 0
                if current_string == 'GT':
                  if GRATES[0].xy_poses[j][i][0] <= (PLAYER.x_pos + 34) <= GRATES[0].xy_poses[j][i][0] + 256:
                    avg_x = ((PLAYER.x_pos + 34) - GRATES[0].offset_x) % 256
                  if (PLAYER.x_pos + 34) < GRATES[0].xy_poses[j][i][0]:
                    avg_x = 0
                  if (PLAYER.x_pos + 34) > GRATES[0].xy_poses[j][i][0] + 256:
                    avg_x = 256
                  if avg_x < 128:
                    PLAYER.forces_for_next_frame_x = -grate_water_force
                  if avg_x >= 128:
                    PLAYER.forces_for_next_frame_x = grate_water_force
                  PLAYER.forces_for_next_frame_y = grate_water_force
                if current_string == 'GV':
                  PLAYER.forces_for_next_frame_y = grate_water_force
                if current_string == 'GAR':
                  PLAYER.forces_for_next_frame_x = grate_water_force
                  PLAYER.forces_for_next_frame_y = grate_water_force / 2
                if current_string == 'GGR':
                  PLAYER.forces_for_next_frame_y = grate_water_force
                if current_string == 'GHR':
                  PLAYER.forces_for_next_frame_x = grate_water_force
                if current_string == 'GTR':
                  if GRATES[0].xy_poses[j][i][0] <= (PLAYER.x_pos + 34) <= GRATES[0].xy_poses[j][i][0] + 256:
                    avg_x = ((PLAYER.x_pos + 34) - GRATES[0].offset_x) % 256
                  if (PLAYER.x_pos + 34) < GRATES[0].xy_poses[j][i][0]:
                    avg_x = 0
                  if (PLAYER.x_pos + 34) > GRATES[0].xy_poses[j][i][0] + 256:
                    avg_x = 256
                  if avg_x < 128:
                    PLAYER.forces_for_next_frame_x = -grate_water_force
                  if avg_x >= 128:
                    PLAYER.forces_for_next_frame_x = grate_water_force
                  PLAYER.forces_for_next_frame_y = grate_water_force
                if current_string == 'GVR':
                  PLAYER.forces_for_next_frame_y = grate_water_force
          if len(current_string) == 2:
            #
            if current_string == 'GA':
              if current_step == 0:
                continue
              if current_step == 1:
                make_opengl_rect(OpenGLTextures['GA'][GRATES[0].current_frame][0], OpenGLTextures['GA'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust + (256-pixels_showing), GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, ((256-pixels_showing), 0, OpenGLTextures['GA'][GRATES[0].current_frame][0][0], OpenGLTextures['GA'][GRATES[0].current_frame][0][1]))
                continue
              if current_step == 2:
                make_opengl_rect(OpenGLTextures['GA'][GRATES[0].current_frame][0], OpenGLTextures['GA'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, OpenGLTextures['GA'][GRATES[0].current_frame][0][0], OpenGLTextures['GA'][GRATES[0].current_frame][0][1]))
                continue
              if current_step == 3:
                make_opengl_rect(OpenGLTextures['GA'][GRATES[0].current_frame][0], OpenGLTextures['GA'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, pixels_showing, OpenGLTextures['GA'][GRATES[0].current_frame][0][1]))
                continue
            #
            if current_string == 'GG':
              make_opengl_rect(OpenGLTextures['GRATE_IMAGE'][0], OpenGLTextures['GRATE_IMAGE'][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, OpenGLTextures['GRATE_IMAGE'][0][0], OpenGLTextures['GRATE_IMAGE'][0][1]))
              if current_step == 0:
                continue
              if current_step == 1:
                make_opengl_rect(OpenGLTextures['GG'][GRATES[0].current_frame][0], OpenGLTextures['GG'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, OpenGLTextures['GG'][GRATES[0].current_frame][0][0], pixels_showing))
                continue
              if current_step == 2:
                make_opengl_rect(OpenGLTextures['GG'][GRATES[0].current_frame][0], OpenGLTextures['GG'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, OpenGLTextures['GG'][GRATES[0].current_frame][0][0], OpenGLTextures['GG'][GRATES[0].current_frame][0][1]))
                continue
              if current_step == 3:
                make_opengl_rect(OpenGLTextures['GG'][GRATES[0].current_frame][0], OpenGLTextures['GG'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust + (256 - pixels_showing)), 0, False, (0, (256 - pixels_showing), OpenGLTextures['GG'][GRATES[0].current_frame][0][0], OpenGLTextures['GG'][GRATES[0].current_frame][0][1]))
                continue
            #
            if current_string == 'GH':
              if current_step == 0:
                continue
              if current_step == 1:
                make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust + (256-pixels_showing), GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, ((256-pixels_showing), 0, OpenGLTextures['GH'][GRATES[0].current_frame][0][0], OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                continue
              if current_step == 2:
                make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, OpenGLTextures['GH'][GRATES[0].current_frame][0][0], OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                continue
              if current_step == 3:
                make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, pixels_showing, OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                continue
            #
            if current_string == 'GT':
              if current_step == 0:
                if j == 22:
                  if 0 <= i <= 11:
                    make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, (0, 0, OpenGLTextures['GH'][GRATES[0].current_frame][0][0], OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                  if 13 <= i:
                    make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, OpenGLTextures['GH'][GRATES[0].current_frame][0][0], OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                continue
              if current_step == 1:
                if j == 22 and pixels_showing <= 256:
                  if 0 <= i <= 11:
                    make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, (0, 0, OpenGLTextures['GH'][GRATES[0].current_frame][0][0], OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                  if 13 <= i:
                    make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, OpenGLTextures['GH'][GRATES[0].current_frame][0][0], OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                if j == 22 and pixels_showing >= 182:
                  pixels_showing = 182
                make_opengl_rect(OpenGLTextures['GT'][GRATES[0].current_frame][0], OpenGLTextures['GT'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, OpenGLTextures['GT'][GRATES[0].current_frame][0][0], pixels_showing))
                continue
              if current_step == 2:
                make_opengl_rect(OpenGLTextures['GT'][GRATES[0].current_frame][0], OpenGLTextures['GT'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, OpenGLTextures['GT'][GRATES[0].current_frame][0][0], OpenGLTextures['GT'][GRATES[0].current_frame][0][1]))
                continue
              if current_step == 3:
                if j == 22 and pixels_showing <= (256-175):
                  if 0 <= i <= 11:
                    make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, (0, 0, OpenGLTextures['GH'][GRATES[0].current_frame][0][0], OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                  if 13 <= i:
                    make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, OpenGLTextures['GH'][GRATES[0].current_frame][0][0], OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                else:
                  make_opengl_rect(OpenGLTextures['GT'][GRATES[0].current_frame][0], OpenGLTextures['GT'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust + (256 - pixels_showing)), 0, False, (0, (256 - pixels_showing), OpenGLTextures['GT'][GRATES[0].current_frame][0][0], OpenGLTextures['GT'][GRATES[0].current_frame][0][1]))
                continue
            #
            if current_string == 'GV':
              if current_step == 0:
                continue
              if current_step == 1:
                make_opengl_rect(OpenGLTextures['GV'][GRATES[0].current_frame][0], OpenGLTextures['GV'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, OpenGLTextures['GV'][GRATES[0].current_frame][0][0], pixels_showing))
                continue
              if current_step == 2:
                make_opengl_rect(OpenGLTextures['GV'][GRATES[0].current_frame][0], OpenGLTextures['GV'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, OpenGLTextures['GV'][GRATES[0].current_frame][0][0], OpenGLTextures['GV'][GRATES[0].current_frame][0][1]))
                continue
              if current_step == 3:
                make_opengl_rect(OpenGLTextures['GV'][GRATES[0].current_frame][0], OpenGLTextures['GV'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust + (256 - pixels_showing)), 0, False, (0, (256 - pixels_showing), OpenGLTextures['GV'][GRATES[0].current_frame][0][0], OpenGLTextures['GV'][GRATES[0].current_frame][0][1]))
                continue
            #
            #
          if len(current_string) == 3:
            if current_string == 'GAR':
              if current_step == 0:
                continue
              if current_step == 1:
                make_opengl_rect(OpenGLTextures['GA'][GRATES[0].current_frame][0], OpenGLTextures['GA'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, (0, 0, pixels_showing, OpenGLTextures['GA'][GRATES[0].current_frame][0][1]))
                continue
              if current_step == 2:
                make_opengl_rect(OpenGLTextures['GA'][GRATES[0].current_frame][0], OpenGLTextures['GA'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, (0, 0, OpenGLTextures['GA'][GRATES[0].current_frame][0][0], OpenGLTextures['GA'][GRATES[0].current_frame][0][1]))
                continue
              if current_step == 3:
                make_opengl_rect(OpenGLTextures['GA'][GRATES[0].current_frame][0], OpenGLTextures['GA'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust + abs(pixels_showing - 256), GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, ((256-pixels_showing), 0, OpenGLTextures['GA'][GRATES[0].current_frame][0][0], OpenGLTextures['GA'][GRATES[0].current_frame][0][1]))
                continue
            #
            if current_string == 'GGR':
              make_opengl_rect(OpenGLTextures['GRATE_IMAGE'][0], OpenGLTextures['GRATE_IMAGE'][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, OpenGLTextures['GRATE_IMAGE'][0][0], OpenGLTextures['GRATE_IMAGE'][0][1]))
              if current_step == 0:
                continue
              if current_step == 1:
                make_opengl_rect(OpenGLTextures['GG'][GRATES[0].current_frame][0], OpenGLTextures['GG'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, (0, 0, OpenGLTextures['GG'][GRATES[0].current_frame][0][0], pixels_showing))
                continue
              if current_step == 2:
                make_opengl_rect(OpenGLTextures['GG'][GRATES[0].current_frame][0], OpenGLTextures['GG'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, (0, 0, OpenGLTextures['GG'][GRATES[0].current_frame][0][0], OpenGLTextures['GG'][GRATES[0].current_frame][0][1]))
                continue
              if current_step == 3:
                make_opengl_rect(OpenGLTextures['GG'][GRATES[0].current_frame][0], OpenGLTextures['GG'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust + (256 - pixels_showing)), 0, True, (0, (256 - pixels_showing), OpenGLTextures['GG'][GRATES[0].current_frame][0][0], OpenGLTextures['GG'][GRATES[0].current_frame][0][1]))
                continue
            #
            if current_string == 'GHR':
              if current_step == 0:
                continue
              if current_step == 1:
                make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, (0, 0, pixels_showing, OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                continue
              if current_step == 2:
                make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, (0, 0, OpenGLTextures['GH'][GRATES[0].current_frame][0][0], OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                continue
              if current_step == 3:
                make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust + abs(pixels_showing - 256), GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, ((256-pixels_showing), 0, OpenGLTextures['GH'][GRATES[0].current_frame][0][0], OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                continue
            #
            if current_string == 'GTR':
              if current_step == 0:
                if j == 22:
                  if 0 <= i <= 11:
                    make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, (0, 0, OpenGLTextures['GH'][GRATES[0].current_frame][0][0], OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                  if 13 <= i:
                    make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, OpenGLTextures['GH'][GRATES[0].current_frame][0][0], OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                continue
              if current_step == 1:
                if j == 22 and pixels_showing <= 256:
                  if 0 <= i <= 11:
                    make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, (0, 0, OpenGLTextures['GH'][GRATES[0].current_frame][0][0], OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                  if 13 <= i:
                    make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, OpenGLTextures['GH'][GRATES[0].current_frame][0][0], OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                if j == 22 and pixels_showing >= 182:
                  pixels_showing = 182
                make_opengl_rect(OpenGLTextures['GT'][GRATES[0].current_frame][0], OpenGLTextures['GT'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, (0, 0, OpenGLTextures['GT'][GRATES[0].current_frame][0][0], pixels_showing))
                continue
              if current_step == 2:
                make_opengl_rect(OpenGLTextures['GT'][GRATES[0].current_frame][0], OpenGLTextures['GT'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, (0, 0, OpenGLTextures['GT'][GRATES[0].current_frame][0][0], OpenGLTextures['GT'][GRATES[0].current_frame][0][1]))
                continue
              if current_step == 3:
                if j == 22 and pixels_showing <= (256-175):
                  if 0 <= i <= 11:
                    make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, (0, 0, OpenGLTextures['GH'][GRATES[0].current_frame][0][0], OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                  if 13 <= i:
                    make_opengl_rect(OpenGLTextures['GH'][GRATES[0].current_frame][0], OpenGLTextures['GH'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, False, (0, 0, OpenGLTextures['GH'][GRATES[0].current_frame][0][0], OpenGLTextures['GH'][GRATES[0].current_frame][0][1]))
                else:
                  make_opengl_rect(OpenGLTextures['GT'][GRATES[0].current_frame][0], OpenGLTextures['GT'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust + (256 - pixels_showing)), 0, True, (0, (256 - pixels_showing), OpenGLTextures['GT'][GRATES[0].current_frame][0][0], OpenGLTextures['GT'][GRATES[0].current_frame][0][1]))
                continue
            #
            if current_string == 'GVR':
              if current_step == 0:
                continue
              if current_step == 1:
                make_opengl_rect(OpenGLTextures['GV'][GRATES[0].current_frame][0], OpenGLTextures['GV'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, (0, 0, OpenGLTextures['GV'][GRATES[0].current_frame][0][0], pixels_showing))
                continue
              if current_step == 2:
                make_opengl_rect(OpenGLTextures['GV'][GRATES[0].current_frame][0], OpenGLTextures['GV'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust), 0, True, (0, 0, OpenGLTextures['GV'][GRATES[0].current_frame][0][0], OpenGLTextures['GV'][GRATES[0].current_frame][0][1]))
                continue
              if current_step == 3:
                make_opengl_rect(OpenGLTextures['GV'][GRATES[0].current_frame][0], OpenGLTextures['GV'][GRATES[0].current_frame][1], (GRATES[0].offset_x + (i*256) + current_blit_change_x - PLAYER.x_dif + x_adjust, GRATES[0].offset_y + (j*256) + current_blit_change_y - PLAYER.y_dif + y_adjust + (256 - pixels_showing)), 0, True, (0, (256 - pixels_showing), OpenGLTextures['GV'][GRATES[0].current_frame][0][0], OpenGLTextures['GV'][GRATES[0].current_frame][0][1]))
                continue
    if MAP.region == 'TheDoor10':
      if 5856 <= PLAYER.y_pos <= 6015:
        if 380 <= PLAYER.x_pos <= 2943:
          PLAYER.forces_for_next_frame_x = grate_water_force
        if 3452 <= PLAYER.x_pos <= 6015:
          PLAYER.forces_for_next_frame_x = -grate_water_force
    try:
      if collison_with_bottom_ball_happened:
        PLAYER.forces_for_next_frame_y = 0
    except:
      pass
    if not My_cached_info.currently_pausing:
      if closest_irregularly_shaped_water < 1200:
        irregularly_shaped_water_loudness = My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER'] * ((1200 - closest_irregularly_shaped_water) / 1200)
        if irregularly_shaped_water_loudness > (My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER']):
          irregularly_shaped_water_loudness = (My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER'])
        if irregularly_shaped_water_loudness < 0:
          irregularly_shaped_water_loudness = 0
        MixerSounds['IRREGULARLY_SHAPED_WATER'].set_volume(irregularly_shaped_water_loudness)
        if not My_cached_info.playing_irregularly_shaped_water_sound:
          MixerSounds['IRREGULARLY_SHAPED_WATER'].play(-1)
          My_cached_info.playing_irregularly_shaped_water_sound = True
      if closest_irregularly_shaped_water >= 1200:
        MixerSounds['IRREGULARLY_SHAPED_WATER'].stop()
        My_cached_info.playing_irregularly_shaped_water_sound = False
  if PLAYER.in_a_pipe:
    PLAYER.forces_for_next_frame_x = 0
    PLAYER.forces_for_next_frame_y = 0

def draw_surfing_rat():
  [make_opengl_rect(MySprite.GPU_current_rat_image[0], MySprite.GPU_current_rat_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.GPU_current_rat_image[0][0], MySprite.GPU_current_rat_image[0][1])) for MySprite in SURFING_RAT]
  [make_opengl_rect(MySprite.GPU_current_dialogue[0], MySprite.GPU_current_dialogue[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif - 250, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif - 38), 0, False, (0, 0, MySprite.GPU_current_dialogue[0][0], MySprite.GPU_current_dialogue[0][1])) for MySprite in SURFING_RAT if MySprite.show_dialogue and MySprite.is_on_screen]
  if MAP.region == 'TheDoor12':
    #[make_opengl_rect_center_on_circle(MySprite.GPU_SURFING_CLOCK[0], MySprite.GPU_SURFING_CLOCK[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), MySprite.image_rotation, MySprite.currently_flipping_image, (0, 0, MySprite.GPU_SURFING_CLOCK[0][0], MySprite.GPU_SURFING_CLOCK[0][1])) for MySprite in SURFING_CLOCK if MySprite.is_showing]
    if SURFING_CLOCK != []:
      if SURFING_CLOCK.is_showing:
        make_opengl_rect(SURFING_CLOCK.GPU_SURFING_CLOCK[0], SURFING_CLOCK.GPU_SURFING_CLOCK[1], (screen_width - (1.25*SURFING_CLOCK.GPU_SURFING_CLOCK[0][0]), 1.5 * 27), 0, False, (0, 0, SURFING_CLOCK.GPU_SURFING_CLOCK[0][0], SURFING_CLOCK.GPU_SURFING_CLOCK[0][1]))
        make_opengl_rect_center_on_circle(SURFING_CLOCK.GPU_SURFING_CLOCK_HAND[0], SURFING_CLOCK.GPU_SURFING_CLOCK_HAND[1], (screen_width - (1.25*SURFING_CLOCK.GPU_SURFING_CLOCK_HAND[0][0]), 1.5 * 27), SURFING_CLOCK.surfing_clock_hand_rotation, True, (0, 0, SURFING_CLOCK.GPU_SURFING_CLOCK_HAND[0][0], SURFING_CLOCK.GPU_SURFING_CLOCK_HAND[0][1]))
    if SURFING_PROGRESS_BAR != []:
      if SURFING_PROGRESS_BAR.is_showing:
        make_opengl_rect(SURFING_PROGRESS_BAR.GPU_SURFING_PROGRESS_BAR_OUTSIDE[0], SURFING_PROGRESS_BAR.GPU_SURFING_PROGRESS_BAR_OUTSIDE[1], (screen_width - (1.25*SURFING_CLOCK.GPU_SURFING_CLOCK[0][0]) - 16, 0.25 * 27), 0, False, (0, 0, SURFING_PROGRESS_BAR.GPU_SURFING_PROGRESS_BAR_OUTSIDE[0][0], SURFING_PROGRESS_BAR.GPU_SURFING_PROGRESS_BAR_OUTSIDE[0][1]))
        make_opengl_rect(SURFING_PROGRESS_BAR.GPU_SURFING_PROGRESS_BAR_INSIDE[0], SURFING_PROGRESS_BAR.GPU_SURFING_PROGRESS_BAR_INSIDE[1], (screen_width - (1.25*SURFING_CLOCK.GPU_SURFING_CLOCK[0][0]) - 16 + 3, (0.25 * 27) + 3), 0, False, (0, 0, SURFING_PROGRESS_BAR.how_filled, SURFING_PROGRESS_BAR.GPU_SURFING_PROGRESS_BAR_INSIDE[0][1]))
        current_added_for_number_spacing = 0
        for i in range(len(SURFING_PROGRESS_BAR.fraction_string)):
          make_opengl_rect(SURFING_PROGRESS_BAR.current_GPU_numbers[i][0], SURFING_PROGRESS_BAR.current_GPU_numbers[i][1], (screen_width - (1.25*SURFING_CLOCK.GPU_SURFING_CLOCK[0][0]) - 16 + 3 + SURFING_PROGRESS_BAR.progress_bar_spacing_on_each_side + current_added_for_number_spacing, (0.25 * 27) + 3 + 3), 0, False, (0, 0, SURFING_PROGRESS_BAR.current_GPU_numbers[i][0][0], SURFING_PROGRESS_BAR.current_GPU_numbers[i][0][1]))
          current_added_for_number_spacing += SURFING_PROGRESS_BAR.number_spacing_dict[SURFING_PROGRESS_BAR.fraction_string[i]]

def draw_food():
  [make_opengl_rect_center_on_circle(MySprite.GPU_image[0], MySprite.GPU_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), MySprite.image_rotation, MySprite.flipped, (0, 0, MySprite.GPU_image[0][0], MySprite.GPU_image[0][1])) for MySprite in FOOD if not (PLAYER.carrying_food and (PLAYER.carrying_which_food_index == MySprite.food_index) and PLAYER.in_a_pipe)]

def draw_HamsterOs():
  if not (HAMSTER_BOX[0].in_themachine):
    [make_opengl_rect_center_on_circle(MySprite.GPU_image[0], MySprite.GPU_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), MySprite.rotation, False, (0, 0, MySprite.GPU_image[0][0], MySprite.GPU_image[0][1])) for MySprite in HAMSTER_BOX if not MySprite.held_by_human]

def draw_HamsterOs_in_machine():
  if HAMSTER_BOX[0].in_themachine:
    [make_opengl_rect_center_on_circle(MySprite.GPU_image[0], MySprite.GPU_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), MySprite.rotation, False, (0, 0, MySprite.GPU_image[0][0], MySprite.GPU_image[0][1])) for MySprite in HAMSTER_BOX if not MySprite.held_by_human]

def draw_HamsterOs_in_machine_outline():
  if My_cached_info.allow_glowing_green_button:
    if (My_cached_info.fake_frame_counter % 36) <= 18:
      [make_opengl_rect_center_on_circle(OpenGLTextures['HAMSTER_OS_OUTLINE'][0], OpenGLTextures['HAMSTER_OS_OUTLINE'][1], (2598 + (0.5 * screen_width) + current_blit_change_x - PLAYER.x_dif, 915 + (0.5 * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS_OUTLINE'][0][0], OpenGLTextures['HAMSTER_OS_OUTLINE'][0][1])) for MySprite in HAMSTER_BOX if not HUMAN[0].in_themachine]

def draw_human():
  human_scale = 1.0
  human_scaled = ((HUMAN[0].GPU_current_image[0][0] * human_scale, HUMAN[0].GPU_current_image[0][1] * human_scale), HUMAN[0].GPU_current_image[1])
  make_opengl_rect(human_scaled[0], human_scaled[1], (HUMAN[0].x_pos + current_blit_change_x - PLAYER.x_dif, HUMAN[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, HUMAN[0].flipped, (0, 0, human_scaled[0][0], human_scaled[0][1]))

def draw_splash():
  if True in my_piston1.is_touching_wall:
    if not PLAYER.in_a_pipe:
      make_opengl_rect_center_on_circle(my_piston1.GPU_current_Splash[0], my_piston1.GPU_current_Splash[1], (my_piston1.Splash_x_pos + stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif, my_piston1.Splash_y_pos + stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif), my_sheath.rotation+90, False, (0, 0, my_piston1.SplashRect[2], my_piston1.SplashRect[3]))
  else:
    My_cached_info.playing_loud_water_jet = False
    MixerSounds['LOUD_WATER_JET'].fadeout(150)

def draw_bucket():
  [make_opengl_rect(MySprite.GPU_current_image[0], MySprite.GPU_current_image[1], (MySprite.x_pos + current_blit_change_x - PLAYER.x_dif, MySprite.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MySprite.GPU_current_image[0][0], MySprite.GPU_current_image[0][1])) for MySprite in BUCKETS]

def draw_numbers_above_hamster():
  global NUMBERS_ABOVE_HAMSTER
  if NUMBERS_ABOVE_HAMSTER != []:
    for SingleNumberAboveHamster in NUMBERS_ABOVE_HAMSTER:
      SingleNumberAboveHamster.current_milliseconds_before_expiry += delta_milliseconds
      distance_added_up = 150*(SingleNumberAboveHamster.current_milliseconds_before_expiry / SingleNumberAboveHamster.milliseconds_before_expiry)
      symbol_distance_added = 0
      on_which_symbol_currently = 0
      for SingleSymbol in SingleNumberAboveHamster.current_GPU_numbers:
        make_opengl_rect(SingleSymbol[0], SingleSymbol[1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + 34 - (SingleNumberAboveHamster.length_of_all_symbols / 2) + symbol_distance_added, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif - 32 - distance_added_up - 8), 0, False, (0, 0, SingleSymbol[0][0], SingleSymbol[0][1]))
        symbol_distance_added += SingleNumberAboveHamster.number_spacing_dict[SingleNumberAboveHamster.number_string[on_which_symbol_currently]]
        on_which_symbol_currently += 1
      if SingleNumberAboveHamster.current_milliseconds_before_expiry >= SingleNumberAboveHamster.milliseconds_before_expiry:
        SingleNumberAboveHamster.will_expire = True
    NUMBERS_ABOVE_HAMSTER = [x for x in NUMBERS_ABOVE_HAMSTER if not x.will_expire]

def draw_mouse():
  current_mouse_angle = find_mouse_angle(MAP, PLAYER, Mouse_x, Mouse_y)
  cur_player_x, cur_player_y = stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + 34, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + 34
  cur_mouse_x, cur_mouse_y = Mouse_x - (OpenGLTextures['ACTUAL_MOUSE'][0][0]/2), Mouse_y - (OpenGLTextures['ACTUAL_MOUSE'][0][1]/2)
  distance_between_center_of_player_and_mouse = find_hypotnuse(cur_player_x - Mouse_x, cur_player_y - Mouse_y)
  if distance_between_center_of_player_and_mouse < (34 + my_piston1.maximum_extension):
    make_opengl_rect(OpenGLTextures['ACTUAL_MOUSE'][0], OpenGLTextures['ACTUAL_MOUSE'][1], (cur_mouse_x, cur_mouse_y), 0, False, (0, 0, OpenGLTextures['ACTUAL_MOUSE'][0][0], OpenGLTextures['ACTUAL_MOUSE'][0][1]))
  if not (distance_between_center_of_player_and_mouse < (34 + my_piston1.maximum_extension)):
    make_opengl_rect(OpenGLTextures['ACTUAL_MOUSE'][0], OpenGLTextures['ACTUAL_MOUSE'][1], (cur_mouse_x, cur_mouse_y), 0, False, (0, 0, OpenGLTextures['ACTUAL_MOUSE'][0][0], OpenGLTextures['ACTUAL_MOUSE'][0][1]))

def draw_sublevel_difficulty():
  for SingleSublevelDifficulty in SUB_LEVEL_DIFFICULTIES:
    if not PLAYER.allowed_door_privileges:
      if SingleSublevelDifficulty.difficulty != 5:
        continue
    if not SingleSublevelDifficulty.allowed_to_display:
      continue
    if SingleSublevelDifficulty.player_is_close:
      percent_of_the_way_through_appearing_fully = SingleSublevelDifficulty.millisecond_counter / SingleSublevelDifficulty.milliseconds_to_completion
      if percent_of_the_way_through_appearing_fully >= 1:
        percent_of_the_way_through_appearing_fully = 1
      current_GPU_image = ((SingleSublevelDifficulty.GPU_image[0][0] * percent_of_the_way_through_appearing_fully, SingleSublevelDifficulty.GPU_image[0][1] * percent_of_the_way_through_appearing_fully), SingleSublevelDifficulty.GPU_image[1])
      adjust_x = abs(SingleSublevelDifficulty.GPU_image[0][0] - current_GPU_image[0][0]) / 2
      adjust_y = abs(SingleSublevelDifficulty.GPU_image[0][1] - current_GPU_image[0][1])
      make_opengl_rect(current_GPU_image[0], current_GPU_image[1], (math.floor(SingleSublevelDifficulty.x_pos + current_blit_change_x - PLAYER.x_dif + adjust_x), math.floor(SingleSublevelDifficulty.y_pos + current_blit_change_y - PLAYER.y_dif + adjust_y)), 0, False, (0, 0, current_GPU_image[0][0], current_GPU_image[0][1]))
      current_hotkey_string = get_hotkey_button_string('INTERACT')
      character_spacing_x = 0
      character_spacings = []
      for SingleCharacter in current_hotkey_string:
        if SingleCharacter != ' ':
          SingleCharacter = 'R' + SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3 * percent_of_the_way_through_appearing_fully, OpenGLTextures[SingleCharacter][0][1] * 3 * percent_of_the_way_through_appearing_fully), OpenGLTextures[SingleCharacter][1])
          character_spacings.append(character_spacing_x)
          character_spacing_x += (current_character_image[0][0]) + (3 * percent_of_the_way_through_appearing_fully)
        if SingleCharacter == ' ':
          character_spacing_x += 3 * percent_of_the_way_through_appearing_fully
      whole_word_distance = character_spacings[-1] + current_character_image[0][0]
      additional_x = (current_GPU_image[0][0] - whole_word_distance) / 2
      current_character_spacing_index = 0
      for SingleCharacter in current_hotkey_string:
        if SingleCharacter != ' ':
          SingleCharacter = 'R' + SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3 * percent_of_the_way_through_appearing_fully, OpenGLTextures[SingleCharacter][0][1] * 3 * percent_of_the_way_through_appearing_fully), OpenGLTextures[SingleCharacter][1])
          make_opengl_rect(current_character_image[0], current_character_image[1], (math.floor(SingleSublevelDifficulty.x_pos + current_blit_change_x - PLAYER.x_dif + math.floor(additional_x + character_spacings[current_character_spacing_index] + adjust_x)), math.floor(SingleSublevelDifficulty.y_pos + current_blit_change_y - PLAYER.y_dif + adjust_y + math.floor((32 * percent_of_the_way_through_appearing_fully)))), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          current_character_spacing_index += 1
    #
    else:
      percent_of_the_way_through_appearing_fully = (SingleSublevelDifficulty.milliseconds_to_completion - SingleSublevelDifficulty.millisecond_counter) / SingleSublevelDifficulty.milliseconds_to_completion
      if percent_of_the_way_through_appearing_fully <= 0:
        percent_of_the_way_through_appearing_fully = 0
        continue
      current_GPU_image = ((SingleSublevelDifficulty.GPU_image[0][0] * percent_of_the_way_through_appearing_fully, SingleSublevelDifficulty.GPU_image[0][1] * percent_of_the_way_through_appearing_fully), SingleSublevelDifficulty.GPU_image[1])
      adjust_x = abs(SingleSublevelDifficulty.GPU_image[0][0] - current_GPU_image[0][0]) / 2
      adjust_y = abs(SingleSublevelDifficulty.GPU_image[0][1] - current_GPU_image[0][1])
      make_opengl_rect(current_GPU_image[0], current_GPU_image[1], (math.floor(SingleSublevelDifficulty.x_pos + current_blit_change_x - PLAYER.x_dif + adjust_x), math.floor(SingleSublevelDifficulty.y_pos + current_blit_change_y - PLAYER.y_dif + adjust_y)), 0, False, (0, 0, current_GPU_image[0][0], current_GPU_image[0][1]))
      current_hotkey_string = get_hotkey_button_string('INTERACT')
      character_spacing_x = 0
      character_spacings = []
      for SingleCharacter in current_hotkey_string:
        if SingleCharacter != ' ':
          SingleCharacter = 'R' + SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3 * percent_of_the_way_through_appearing_fully, OpenGLTextures[SingleCharacter][0][1] * 3 * percent_of_the_way_through_appearing_fully), OpenGLTextures[SingleCharacter][1])
          character_spacings.append(character_spacing_x)
          character_spacing_x += (current_character_image[0][0]) + (3 * percent_of_the_way_through_appearing_fully)
        if SingleCharacter == ' ':
          character_spacing_x += 3 * percent_of_the_way_through_appearing_fully
      whole_word_distance = character_spacings[-1] + current_character_image[0][0]
      additional_x = (current_GPU_image[0][0] - whole_word_distance) / 2
      current_character_spacing_index = 0
      for SingleCharacter in current_hotkey_string:
        if SingleCharacter != ' ':
          SingleCharacter = 'R' + SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3 * percent_of_the_way_through_appearing_fully, OpenGLTextures[SingleCharacter][0][1] * 3 * percent_of_the_way_through_appearing_fully), OpenGLTextures[SingleCharacter][1])
          make_opengl_rect(current_character_image[0], current_character_image[1], (math.floor(SingleSublevelDifficulty.x_pos + current_blit_change_x - PLAYER.x_dif + math.floor(additional_x + character_spacings[current_character_spacing_index] + adjust_x)), math.floor(SingleSublevelDifficulty.y_pos + current_blit_change_y - PLAYER.y_dif + adjust_y + math.floor((32 * percent_of_the_way_through_appearing_fully)))), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          current_character_spacing_index += 1

def draw_use_fast_travel_thoughts():
  if not PLAYER.talked_fast_travel:
    if PLAYER.hamster_thinks_her_goal:
      My_cached_info.fast_travel_dialogue_milliseconds = 10000
      return
    if GARBAGE_CAN[0].player_is_inside or GARBAGE_CAN[0].player_is_tentatively_inside:
      if My_cached_info.fast_travel_dialogue_milliseconds == 0:
        return
    if My_cached_info.fast_travel_dialogue_milliseconds == 0:
      everything_save_data(True, 90, '1')
    My_cached_info.fast_travel_dialogue_milliseconds += delta_milliseconds
    if 500 <= My_cached_info.fast_travel_dialogue_milliseconds <= 4000:
      make_opengl_rect(OpenGLTextures['ICanNowFastTravelHereUsingThePauseMenu'][0], OpenGLTextures['ICanNowFastTravelHereUsingThePauseMenu'][1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113), 0, False, (0, 0, OpenGLTextures['ICanNowFastTravelHereUsingThePauseMenu'][0][0], OpenGLTextures['ICanNowFastTravelHereUsingThePauseMenu'][0][1]))
    if 4200 <= My_cached_info.fast_travel_dialogue_milliseconds <= 7700:
      make_opengl_rect(OpenGLTextures['ICanPressToAccessThePauseMenu'][0], OpenGLTextures['ICanPressToAccessThePauseMenu'][1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113), 0, False, (0, 0, OpenGLTextures['ICanPressToAccessThePauseMenu'][0][0], OpenGLTextures['ICanPressToAccessThePauseMenu'][0][1]))
      current_hotkey_string = get_hotkey_button_string('PAUSE')
      character_spacing_x = 0
      for SingleCharacter in current_hotkey_string:
        if SingleCharacter != ' ':
          SingleCharacter = 'R' + SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3, OpenGLTextures[SingleCharacter][0][1] * 3), OpenGLTextures[SingleCharacter][1])
          make_opengl_rect(current_character_image[0], current_character_image[1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136 + 160 + character_spacing_x, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113 + 12), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          character_spacing_x += current_character_image[0][0] + 3
        if SingleCharacter == ' ':
          character_spacing_x += 9

def draw_hamster_thoughts():
  global delta_milliseconds
  try:
    hamster_thoughts_delta_milliseconds = delta_milliseconds
  except:
    hamster_thoughts_delta_milliseconds = 13
  #
  if PLAYER.intro_data[0] == 0:
    PLAYER.which_dialogue = 1
  #
  if PLAYER.which_dialogue != 2:
    if PLAYER.intro_data[1] == 0:
      if 3040 <= PLAYER.x_pos <= 3280:
        if 3686 <= PLAYER.y_pos <= 3804:
          PLAYER.dialogue_millisecond_counter = 0
          PLAYER.which_dialogue = 2
          PLAYER.intro_data[0] = 1
          everything_save_data(True, 47, '1')
  if 3400 <= PLAYER.x_pos:
    PLAYER.intro_data[1] = 1
    everything_save_data(True, 48, '1')
    if PLAYER.which_dialogue == 2:
      PLAYER.which_dialogue = 0
  #
  if PLAYER.which_dialogue != 3:
    if PLAYER.intro_data[2] == 0:
      if 3409 <= PLAYER.x_pos:
        PLAYER.dialogue_millisecond_counter = 0
        PLAYER.which_dialogue = 3
        PLAYER.intro_data[0] = 1
        everything_save_data(True, 47, '1')
        PLAYER.intro_data[1] = 1
        everything_save_data(True, 48, '1')
  if 3760 <= PLAYER.x_pos:
    PLAYER.intro_data[2] = 1
    everything_save_data(True, 49, '1')
    if PLAYER.which_dialogue == 3:
      PLAYER.which_dialogue = 0
  #
  if PLAYER.which_dialogue != 6:
    if my_piston2.grapple_claw_x_pos != 0 and not PLAYER.have_detached_before:
      PLAYER.which_dialogue = 6
      PLAYER.dialogue_millisecond_counter = 0
  #
  if PLAYER.which_dialogue != 7:
    if PLAYER.has_piston1 and PLAYER.has_piston2:
      if PLAYER.x_pos < 3398:
        if PLAYER.intro_data != [1, 1, 1, 1, 1, 1]:
          PLAYER.allowed_door_privileges = True
          PLAYER.which_dialogue = 7
          PLAYER.dialogue_millisecond_counter = 0
          PLAYER.intro_data = [1, 1, 1, 1, 1, 1]
          everything_save_data(True, 47, '1')
          everything_save_data(True, 48, '1')
          everything_save_data(True, 49, '1')
          everything_save_data(True, 50, '1')
          everything_save_data(True, 51, '1')
          everything_save_data(True, 52, '1')
  #
  #
  if PLAYER.which_dialogue != 0:
    #
    if PLAYER.which_dialogue == 1:
      if hamster_thoughts_delta_milliseconds >= 50:
        hamster_thoughts_delta_milliseconds = 50
      PLAYER.dialogue_millisecond_counter += hamster_thoughts_delta_milliseconds
      if 1000 <= PLAYER.dialogue_millisecond_counter <= 3500:
        make_opengl_rect(OpenGLTextures['ThatFallWasWild'][0], OpenGLTextures['ThatFallWasWild'][1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 117, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113), 0, False, (0, 0, OpenGLTextures['ThatFallWasWild'][0][0], OpenGLTextures['ThatFallWasWild'][0][1]))
      if 3700 <= PLAYER.dialogue_millisecond_counter <= 6500:
        make_opengl_rect(OpenGLTextures['INeedToGetOutOfThisTrashCan'][0], OpenGLTextures['INeedToGetOutOfThisTrashCan'][1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 117, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113), 0, False, (0, 0, OpenGLTextures['INeedToGetOutOfThisTrashCan'][0][0], OpenGLTextures['INeedToGetOutOfThisTrashCan'][0][1]))
      if 6700 <= PLAYER.dialogue_millisecond_counter <= 9500:
        make_opengl_rect(OpenGLTextures['MaybeICanBuildSomethingToEscape'][0], OpenGLTextures['MaybeICanBuildSomethingToEscape'][1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 117, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113), 0, False, (0, 0, OpenGLTextures['MaybeICanBuildSomethingToEscape'][0][0], OpenGLTextures['MaybeICanBuildSomethingToEscape'][0][1]))
      if 9500 < PLAYER.dialogue_millisecond_counter:
        PLAYER.which_dialogue = 0
        PLAYER.dialogue_millisecond_counter = 0
        PLAYER.intro_data[0] = 1
        everything_save_data(True, 47, '1')
    #
    if PLAYER.which_dialogue == 2:
      if Currently_pressed_controls.pressed_controls['SINK_DOWN']:
        PLAYER.dialogue_millisecond_counter += hamster_thoughts_delta_milliseconds
      make_opengl_rect(OpenGLTextures['ICanPressToSinkDown'][0], OpenGLTextures['ICanPressToSinkDown'][1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113), 0, False, (0, 0, OpenGLTextures['ICanPressToSinkDown'][0][0], OpenGLTextures['ICanPressToSinkDown'][0][1]))
      current_hotkey_string = get_hotkey_button_string('SINK_DOWN')
      character_spacing_x = 0
      for SingleCharacter in current_hotkey_string:
        if SingleCharacter != ' ':
          SingleCharacter = 'R' + SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3, OpenGLTextures[SingleCharacter][0][1] * 3), OpenGLTextures[SingleCharacter][1])
          make_opengl_rect(current_character_image[0], current_character_image[1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136 + 160 + character_spacing_x, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113 + 12), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          character_spacing_x += current_character_image[0][0] + 3
        if SingleCharacter == ' ':
          character_spacing_x += 9
      if PLAYER.dialogue_millisecond_counter >= 500:
        PLAYER.which_dialogue = 0
        PLAYER.dialogue_millisecond_counter = 0
        PLAYER.intro_data[0] = 1
        everything_save_data(True, 47, '1')
        PLAYER.intro_data[1] = 1
        everything_save_data(True, 48, '1')
    #
    if PLAYER.which_dialogue == 3:
      if Currently_pressed_controls.pressed_controls['FLOAT_UP']:
        PLAYER.dialogue_millisecond_counter += hamster_thoughts_delta_milliseconds
      make_opengl_rect(OpenGLTextures['ICanPressToFloatUp'][0], OpenGLTextures['ICanPressToFloatUp'][1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113), 0, False, (0, 0, OpenGLTextures['ICanPressToFloatUp'][0][0], OpenGLTextures['ICanPressToFloatUp'][0][1]))
      current_hotkey_string = get_hotkey_button_string('FLOAT_UP')
      character_spacing_x = 0
      for SingleCharacter in current_hotkey_string:
        if SingleCharacter != ' ':
          SingleCharacter = 'R' + SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3, OpenGLTextures[SingleCharacter][0][1] * 3), OpenGLTextures[SingleCharacter][1])
          make_opengl_rect(current_character_image[0], current_character_image[1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136 + 160 + character_spacing_x, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113 + 12), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          character_spacing_x += current_character_image[0][0] + 3
        if SingleCharacter == ' ':
          character_spacing_x += 9
      if PLAYER.dialogue_millisecond_counter >= 500:
        PLAYER.which_dialogue = 0
        PLAYER.dialogue_millisecond_counter = 0
        PLAYER.intro_data[0] = 1
        everything_save_data(True, 47, '1')
        PLAYER.intro_data[1] = 1
        everything_save_data(True, 48, '1')
        PLAYER.intro_data[2] = 1
        everything_save_data(True, 49, '1')
    #
    if PLAYER.which_dialogue == 4:
      if Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
        PLAYER.dialogue_millisecond_counter += hamster_thoughts_delta_milliseconds
      make_opengl_rect(OpenGLTextures['ICanPressToPropelMyselfWithThisHoseNozzle'][0], OpenGLTextures['ICanPressToPropelMyselfWithThisHoseNozzle'][1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113 - 18), 0, False, (0, 0, OpenGLTextures['ICanPressToPropelMyselfWithThisHoseNozzle'][0][0], OpenGLTextures['ICanPressToPropelMyselfWithThisHoseNozzle'][0][1]))
      current_hotkey_string = get_hotkey_button_string('EXTEND_WATER_JET')
      character_spacing_x = 0
      for SingleCharacter in current_hotkey_string:
        if SingleCharacter != ' ':
          SingleCharacter = 'R' + SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3, OpenGLTextures[SingleCharacter][0][1] * 3), OpenGLTextures[SingleCharacter][1])
          make_opengl_rect(current_character_image[0], current_character_image[1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136 + 160 + character_spacing_x, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113 + 12 - 19), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          character_spacing_x += current_character_image[0][0] + 3
        if SingleCharacter == ' ':
          character_spacing_x += 9
      if PLAYER.dialogue_millisecond_counter >= 500:
        PLAYER.which_dialogue = 0
        PLAYER.dialogue_millisecond_counter = 0
    #
    if PLAYER.which_dialogue == 5:
      if Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK']:
        PLAYER.dialogue_millisecond_counter += hamster_thoughts_delta_milliseconds
      make_opengl_rect(OpenGLTextures['ICanPressToAttachMyselfToThosePlatforms'][0], OpenGLTextures['ICanPressToAttachMyselfToThosePlatforms'][1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113 - 18), 0, False, (0, 0, OpenGLTextures['ICanPressToAttachMyselfToThosePlatforms'][0][0], OpenGLTextures['ICanPressToAttachMyselfToThosePlatforms'][0][1]))
      current_hotkey_string = get_hotkey_button_string('EXTEND_GRAPPLING_HOOK')
      character_spacing_x = 0
      for SingleCharacter in current_hotkey_string:
        if SingleCharacter != ' ':
          SingleCharacter = 'R' + SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3, OpenGLTextures[SingleCharacter][0][1] * 3), OpenGLTextures[SingleCharacter][1])
          make_opengl_rect(current_character_image[0], current_character_image[1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136 + 160 + character_spacing_x, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113 + 12 - 19), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          character_spacing_x += current_character_image[0][0] + 3
        if SingleCharacter == ' ':
          character_spacing_x += 9
      if PLAYER.dialogue_millisecond_counter >= 800 or my_piston2.grapple_claw_x_pos != 0:
        PLAYER.which_dialogue = 0
        PLAYER.dialogue_millisecond_counter = 0
    #
    if PLAYER.which_dialogue == 6:
      if Currently_pressed_controls.pressed_controls['DETACH_GRAPPLING_HOOK']:
        PLAYER.dialogue_millisecond_counter += hamster_thoughts_delta_milliseconds
      make_opengl_rect(OpenGLTextures['ICanPressToDetach'][0], OpenGLTextures['ICanPressToDetach'][1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113), 0, False, (0, 0, OpenGLTextures['ICanPressToDetach'][0][0], OpenGLTextures['ICanPressToDetach'][0][1]))
      current_hotkey_string = get_hotkey_button_string('DETACH_GRAPPLING_HOOK')
      character_spacing_x = 0
      for SingleCharacter in current_hotkey_string:
        if SingleCharacter != ' ':
          SingleCharacter = 'R' + SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3, OpenGLTextures[SingleCharacter][0][1] * 3), OpenGLTextures[SingleCharacter][1])
          make_opengl_rect(current_character_image[0], current_character_image[1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136 + 160 + character_spacing_x, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113 + 12), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          character_spacing_x += current_character_image[0][0] + 3
        if SingleCharacter == ' ':
          character_spacing_x += 9
      if Currently_pressed_controls.pressed_controls['DETACH_GRAPPLING_HOOK']:
        PLAYER.which_dialogue = 0
        PLAYER.dialogue_millisecond_counter = 0
        PLAYER.have_detached_before = True
    #
    if PLAYER.which_dialogue == 7:
      PLAYER.dialogue_millisecond_counter += hamster_thoughts_delta_milliseconds
      make_opengl_rect(OpenGLTextures['ICanPropelMyselfWithThisWater'][0], OpenGLTextures['ICanPropelMyselfWithThisWater'][1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113), 0, False, (0, 0, OpenGLTextures['ICanPropelMyselfWithThisWater'][0][0], OpenGLTextures['ICanPropelMyselfWithThisWater'][0][1]))
      if (PLAYER.dialogue_millisecond_counter >= 2800) or (PLAYER.x_pos <= 2989):
        PLAYER.which_dialogue = 0
        PLAYER.dialogue_millisecond_counter = 0
    #
  if PLAYER.CollectedUpgrades[11]:
    if PLAYER.x_pos > 5690:
      if PLAYER.post_tutorial_data[0] == 0:
        if MAP.region == 'TheDoor13':
          PLAYER.intro_data[3] = 1
          PLAYER.intro_data[4] = 1
          everything_save_data(True, 47, '1')
          everything_save_data(True, 48, '1')
          everything_save_data(True, 49, '1')
          everything_save_data(True, 50, '1')
          everything_save_data(True, 51, '1')
          make_opengl_rect(OpenGLTextures['ICanGetOutOfHereThroughTheExitToMyLeftNow'][0], OpenGLTextures['ICanGetOutOfHereThroughTheExitToMyLeftNow'][1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113 - 18), 0, False, (0, 0, OpenGLTextures['ICanGetOutOfHereThroughTheExitToMyLeftNow'][0][0], OpenGLTextures['ICanGetOutOfHereThroughTheExitToMyLeftNow'][0][1]))
    #
  if MAP.region == 'Town':
    if (1828 <= PLAYER.x_pos <= 2770) and (667 <= PLAYER.y_pos <= 1018):
      if (THE_MACHINE[0].screw_stage < 4) and (THE_MACHINE[0].wire_cutter_stage < 4) and (THE_MACHINE[0].wrench_stage < 4) and not PLAYER.collected_screw_driver and not PLAYER.collected_wire_cutter and not PLAYER.collected_wrench:
        if not PLAYER.hamster_thinks_her_goal:
          if PLAYER.post_tutorial_data[1] == 1:
            PLAYER.dialogue_millisecond_counter = 3400
          PLAYER.post_tutorial_data[1] = 1
          everything_save_data(True, 56, '1')
        PLAYER.hamster_thinks_her_goal = True
    if PLAYER.hamster_thinks_her_goal:
      PLAYER.dialogue_millisecond_counter += delta_milliseconds
      if 300 <= PLAYER.dialogue_millisecond_counter <= 3300:
        make_opengl_rect(OpenGLTextures['OhNoMyMachineIsBroken'][0], OpenGLTextures['OhNoMyMachineIsBroken'][1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136 + 21, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113), 0, False, (0, 0, OpenGLTextures['OhNoMyMachineIsBroken'][0][0], OpenGLTextures['OhNoMyMachineIsBroken'][0][1]))
      if 3500 <= PLAYER.dialogue_millisecond_counter <= 6500:
        make_opengl_rect(OpenGLTextures['IllNeedToFindSomeToolsToMakeRepairs'][0], OpenGLTextures['IllNeedToFindSomeToolsToMakeRepairs'][1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136 + 21, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113), 0, False, (0, 0, OpenGLTextures['IllNeedToFindSomeToolsToMakeRepairs'][0][0], OpenGLTextures['IllNeedToFindSomeToolsToMakeRepairs'][0][1]))
      if 6700 <= PLAYER.dialogue_millisecond_counter <= 9700:
        make_opengl_rect(OpenGLTextures['IShouldSearchTheForestToMyLeft'][0], OpenGLTextures['IShouldSearchTheForestToMyLeft'][1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136 + 21, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113), 0, False, (0, 0, OpenGLTextures['IShouldSearchTheForestToMyLeft'][0][0], OpenGLTextures['IShouldSearchTheForestToMyLeft'][0][1]))
    #
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    if (2224 <= absolute_center_of_player_x <= 2770) and (667 <= absolute_center_of_player_y <= 1018):
      if (PLAYER.collected_screw_driver and not THE_MACHINE[0].repair_screw_driver) or (PLAYER.collected_wire_cutter and not THE_MACHINE[0].repair_wire_cutter) or (PLAYER.collected_wrench and not THE_MACHINE[0].repair_wrench):
        make_opengl_rect(OpenGLTextures['ICanPressToRepairMyMachine'][0], OpenGLTextures['ICanPressToRepairMyMachine'][1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113), 0, False, (0, 0, OpenGLTextures['ICanPressToRepairMyMachine'][0][0], OpenGLTextures['ICanPressToRepairMyMachine'][0][1]))
        current_hotkey_string = get_hotkey_button_string('INTERACT')
        character_spacing_x = 0
        for SingleCharacter in current_hotkey_string:
          if SingleCharacter != ' ':
            SingleCharacter = 'R' + SingleCharacter
            current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3, OpenGLTextures[SingleCharacter][0][1] * 3), OpenGLTextures[SingleCharacter][1])
            make_opengl_rect(current_character_image[0], current_character_image[1], (stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif + PLAYER.adjust_x_pos - 136 + 160 + character_spacing_x, stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif + PLAYER.adjust_y_pos - 113 + 11), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
            character_spacing_x += current_character_image[0][0] + 3
          if SingleCharacter == ' ':
            character_spacing_x += 9

def draw_trash():
  for SingleTrash in TRASH:
    make_opengl_rect(SingleTrash.GPU_trash_image[0], SingleTrash.GPU_trash_image[1], (SingleTrash.x_pos + current_blit_change_x - PLAYER.x_dif, SingleTrash.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, SingleTrash.GPU_trash_image[0][0], SingleTrash.GPU_trash_image[0][1]))
    if not SingleTrash.trash_has_been_collected:
      make_opengl_rect(SingleTrash.GPU_collectable[0], SingleTrash.GPU_collectable[1], (SingleTrash.x_pos + current_blit_change_x - PLAYER.x_dif, SingleTrash.y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, SingleTrash.GPU_collectable[0][0], SingleTrash.GPU_collectable[0][1]))

def draw_play_timer():
  timer_x, timer_y = 5, 5
  make_opengl_rect(OpenGLTextures['TIMER'][0], OpenGLTextures['TIMER'][1], (timer_x, timer_y), 0, False, (0, 0, OpenGLTextures['TIMER'][0][0], OpenGLTextures['TIMER'][0][1]))
  #
  current_milliseconds = My_cached_info.play_time
  cur_hours = int(current_milliseconds // 3600000)
  if cur_hours >= 100:
    cur_hours == 99
  current_milliseconds -= (cur_hours * 3600000)
  cur_minutes = int(current_milliseconds // 60000)
  if cur_minutes >= 60:
    cur_minutes = 59
  current_milliseconds -= (cur_minutes * 60000)
  cur_seconds = int(current_milliseconds // 1000)
  if cur_seconds >= 60:
    cur_seconds = 59
  current_milliseconds -= (cur_seconds * 1000)
  cur_milliseconds = current_milliseconds
  if cur_milliseconds >= 1000:
    cur_milliseconds = 999
  #
  cur_hours = str(cur_hours)
  cur_minutes = str(cur_minutes)
  cur_seconds = str(cur_seconds)
  cur_milliseconds = str(cur_milliseconds)
  if len(cur_hours) == 1:
    cur_hours = '0' + cur_hours
  if len(cur_minutes) == 1:
    cur_minutes = '0' + cur_minutes
  if len(cur_seconds) == 1:
    cur_seconds = '0' + cur_seconds
  if len(cur_milliseconds) == 1:
    cur_milliseconds = '00' + cur_milliseconds
  if len(cur_milliseconds) == 2:
    cur_milliseconds = '0' + cur_milliseconds
  #
  whole_time_string = cur_hours + ':' + cur_minutes + ':' + cur_seconds + '.' + cur_milliseconds
  character_spacing_x = 0
  for SingleCharacter in whole_time_string:
    if SingleCharacter != ' ':
      SingleCharacter = 'B' + SingleCharacter
      current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3, OpenGLTextures[SingleCharacter][0][1] * 3), OpenGLTextures[SingleCharacter][1])
      make_opengl_rect(current_character_image[0], current_character_image[1], (timer_x + 16 + character_spacing_x, timer_y + 16), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
      character_spacing_x += current_character_image[0][0] + 3
    if SingleCharacter == ' ':
      character_spacing_x += 9


def milliseconds_to_time_string(current_milliseconds):
  cur_hours = int(current_milliseconds // 3600000)
  if cur_hours >= 100:
    cur_hours == 99
  current_milliseconds -= (cur_hours * 3600000)
  cur_minutes = int(current_milliseconds // 60000)
  if cur_minutes >= 60:
    cur_minutes = 59
  current_milliseconds -= (cur_minutes * 60000)
  cur_seconds = int(current_milliseconds // 1000)
  if cur_seconds >= 60:
    cur_seconds = 59
  current_milliseconds -= (cur_seconds * 1000)
  cur_milliseconds = current_milliseconds
  if cur_milliseconds >= 1000:
    cur_milliseconds = 999
  #
  cur_hours = str(cur_hours)
  cur_minutes = str(cur_minutes)
  cur_seconds = str(cur_seconds)
  cur_milliseconds = str(cur_milliseconds)
  if len(cur_hours) == 1:
    cur_hours = '0' + cur_hours
  if len(cur_minutes) == 1:
    cur_minutes = '0' + cur_minutes
  if len(cur_seconds) == 1:
    cur_seconds = '0' + cur_seconds
  if len(cur_milliseconds) == 1:
    cur_milliseconds = '00' + cur_milliseconds
  if len(cur_milliseconds) == 2:
    cur_milliseconds = '0' + cur_milliseconds
  #
  whole_time_string = cur_hours + ':' + cur_minutes + ':' + cur_seconds + '.' + cur_milliseconds
  return whole_time_string





def get_drawing_functions():
  global DRAWING_FUNCTIONS
  DRAWING_FUNCTIONS = []
  #
  if MAP.region == 'MAP12':
    DRAWING_FUNCTIONS.append(draw_background)
    DRAWING_FUNCTIONS.append(draw_map)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    DRAWING_FUNCTIONS.append(draw_ants)
    DRAWING_FUNCTIONS.append(draw_keys)
    DRAWING_FUNCTIONS.append(draw_rootbases)
    DRAWING_FUNCTIONS.append(draw_vines)
    DRAWING_FUNCTIONS.append(draw_water_surfaces)
    DRAWING_FUNCTIONS.append(draw_bubbles)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_doors)
    DRAWING_FUNCTIONS.append(draw_clouds)
    DRAWING_FUNCTIONS.append(draw_teetertotters)
    DRAWING_FUNCTIONS.append(draw_leaves)
    DRAWING_FUNCTIONS.append(draw_roots)
    DRAWING_FUNCTIONS.append(draw_dripdrops)
    DRAWING_FUNCTIONS.append(draw_upgrades)
    DRAWING_FUNCTIONS.append(draw_splash)
    DRAWING_FUNCTIONS.append(draw_sprites_front)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_mouse)
  #
  if MAP.region == 'Forest':
    DRAWING_FUNCTIONS.append(draw_background)
    DRAWING_FUNCTIONS.append(draw_moving_backsprites)
    DRAWING_FUNCTIONS.append(draw_map)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    DRAWING_FUNCTIONS.append(draw_sublevel_difficulty)
    DRAWING_FUNCTIONS.append(draw_doors)
    DRAWING_FUNCTIONS.append(draw_backsprites)
    DRAWING_FUNCTIONS.append(draw_grass)
    DRAWING_FUNCTIONS.append(draw_vines)
    DRAWING_FUNCTIONS.append(draw_squirrels)
    DRAWING_FUNCTIONS.append(draw_water_surfaces)
    DRAWING_FUNCTIONS.append(draw_bubbles)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_keys)
    DRAWING_FUNCTIONS.append(draw_clouds)
    DRAWING_FUNCTIONS.append(draw_grass)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_tools)
    DRAWING_FUNCTIONS.append(draw_hawk)
    DRAWING_FUNCTIONS.append(draw_leaves)
    DRAWING_FUNCTIONS.append(draw_splash)
    DRAWING_FUNCTIONS.append(draw_water_surfaces_cover)
    DRAWING_FUNCTIONS.append(draw_water_covers)
    DRAWING_FUNCTIONS.append(draw_sprites_front)
    DRAWING_FUNCTIONS.append(draw_moving_sprites_front)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_mouse)
  #
  if MAP.region == 'TheDoor1':
    DRAWING_FUNCTIONS.append(draw_map)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    DRAWING_FUNCTIONS.append(draw_backsprites)
    DRAWING_FUNCTIONS.append(draw_sublevel_difficulty)
    DRAWING_FUNCTIONS.append(draw_vines)
    DRAWING_FUNCTIONS.append(draw_grass)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_grass)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_teetertotters)
    DRAWING_FUNCTIONS.append(draw_upgrades)
    DRAWING_FUNCTIONS.append(draw_splash)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_mouse)
  #
  if MAP.region == 'TheDoor2':
    DRAWING_FUNCTIONS.append(draw_map)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    DRAWING_FUNCTIONS.append(draw_backsprites)
    DRAWING_FUNCTIONS.append(draw_sublevel_difficulty)
    DRAWING_FUNCTIONS.append(draw_water_surfaces)
    DRAWING_FUNCTIONS.append(draw_bubbles)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_clouds)
    DRAWING_FUNCTIONS.append(draw_sprites_front)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_upgrades)
    DRAWING_FUNCTIONS.append(draw_splash)
    DRAWING_FUNCTIONS.append(draw_water_surfaces_cover)
    DRAWING_FUNCTIONS.append(draw_water_covers)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_mouse)
  #
  if MAP.region == 'TheDoor3':
    DRAWING_FUNCTIONS.append(draw_map)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    DRAWING_FUNCTIONS.append(draw_backsprites)
    DRAWING_FUNCTIONS.append(draw_sublevel_difficulty)
    DRAWING_FUNCTIONS.append(draw_bouncies)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_upgrades)
    DRAWING_FUNCTIONS.append(draw_splash)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_mouse)
  #
  if MAP.region == 'TheDoor4':
    DRAWING_FUNCTIONS.append(draw_map)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    DRAWING_FUNCTIONS.append(draw_backsprites)
    DRAWING_FUNCTIONS.append(draw_sublevel_difficulty)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_ants)
    DRAWING_FUNCTIONS.append(draw_upgrades)
    DRAWING_FUNCTIONS.append(draw_splash)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_mouse)
  #
  if MAP.region == 'TheDoor5':
    DRAWING_FUNCTIONS.append(draw_map)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    DRAWING_FUNCTIONS.append(draw_backsprites)
    DRAWING_FUNCTIONS.append(draw_sublevel_difficulty)
    DRAWING_FUNCTIONS.append(draw_vines)
    DRAWING_FUNCTIONS.append(draw_squirrels)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_upgrades)
    DRAWING_FUNCTIONS.append(draw_splash)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_mouse)
  #
  if MAP.region == 'AntHill':
    DRAWING_FUNCTIONS.append(draw_background)
    DRAWING_FUNCTIONS.append(draw_backsprites)
    DRAWING_FUNCTIONS.append(draw_doors)
    DRAWING_FUNCTIONS.append(draw_rootbases)
    DRAWING_FUNCTIONS.append(draw_roots)
    DRAWING_FUNCTIONS.append(draw_map)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    #DRAWING_FUNCTIONS.append(draw_backsprites)
    DRAWING_FUNCTIONS.append(draw_moving_backsprites)
    DRAWING_FUNCTIONS.append(draw_sublevel_difficulty)
    DRAWING_FUNCTIONS.append(draw_ants)
    DRAWING_FUNCTIONS.append(draw_water_surfaces)
    DRAWING_FUNCTIONS.append(draw_bubbles)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_keys)
    DRAWING_FUNCTIONS.append(draw_grass_anthill)
    DRAWING_FUNCTIONS.append(draw_beetle)
    DRAWING_FUNCTIONS.append(draw_queen_ant)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_sprites_front)
    DRAWING_FUNCTIONS.append(draw_splash)
    DRAWING_FUNCTIONS.append(draw_moving_sprites_front)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_mouse)
  #
  if MAP.region == 'TheDoor6':
    DRAWING_FUNCTIONS.append(draw_background)
    DRAWING_FUNCTIONS.append(draw_map)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    DRAWING_FUNCTIONS.append(draw_vines)
    DRAWING_FUNCTIONS.append(draw_beetle)
    DRAWING_FUNCTIONS.append(draw_tools)
    DRAWING_FUNCTIONS.append(draw_moving_bouncies)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_moving_sprites_front)
    DRAWING_FUNCTIONS.append(draw_splash)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_mouse)
  #
  if MAP.region == 'TheDoor7':
    DRAWING_FUNCTIONS.append(draw_map)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    DRAWING_FUNCTIONS.append(draw_backsprites)
    DRAWING_FUNCTIONS.append(draw_sublevel_difficulty)
    DRAWING_FUNCTIONS.append(draw_doors)
    DRAWING_FUNCTIONS.append(draw_big_elevator)
    DRAWING_FUNCTIONS.append(draw_ants)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_player_mover_ants)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_keys)
    DRAWING_FUNCTIONS.append(draw_sprites_front)
    DRAWING_FUNCTIONS.append(draw_upgrades)
    DRAWING_FUNCTIONS.append(draw_splash)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_mouse)
  #
  if MAP.region == 'TheDoor8':
    DRAWING_FUNCTIONS.append(draw_map)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    DRAWING_FUNCTIONS.append(draw_backsprites)
    DRAWING_FUNCTIONS.append(draw_sublevel_difficulty)
    DRAWING_FUNCTIONS.append(draw_doors)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_player_mover_ants)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_keys)
    DRAWING_FUNCTIONS.append(draw_upgrades)
    DRAWING_FUNCTIONS.append(draw_splash)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_mouse)
  #
  if MAP.region == 'TheDoor9':
    DRAWING_FUNCTIONS.append(draw_background)
    DRAWING_FUNCTIONS.append(draw_doors)
    DRAWING_FUNCTIONS.append(draw_map)
    DRAWING_FUNCTIONS.append(draw_rootbases)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    DRAWING_FUNCTIONS.append(draw_roots)
    DRAWING_FUNCTIONS.append(draw_backsprites)
    DRAWING_FUNCTIONS.append(draw_sublevel_difficulty)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_upgrades)
    DRAWING_FUNCTIONS.append(draw_splash)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_mouse)
  #
  if MAP.region == 'Sewer':
    DRAWING_FUNCTIONS.append(draw_background)
    DRAWING_FUNCTIONS.append(draw_map)
    DRAWING_FUNCTIONS.append(draw_grates)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    DRAWING_FUNCTIONS.append(draw_backsprites)
    DRAWING_FUNCTIONS.append(draw_moving_backsprites)
    DRAWING_FUNCTIONS.append(draw_TVs)
    DRAWING_FUNCTIONS.append(draw_sublevel_difficulty)
    DRAWING_FUNCTIONS.append(draw_propellers)
    DRAWING_FUNCTIONS.append(draw_levers)
    DRAWING_FUNCTIONS.append(draw_water_surfaces)
    DRAWING_FUNCTIONS.append(draw_surfing_rat)
    DRAWING_FUNCTIONS.append(draw_surf_boards)
    DRAWING_FUNCTIONS.append(draw_bubbles)
    DRAWING_FUNCTIONS.append(draw_vines)
    DRAWING_FUNCTIONS.append(draw_food)
    DRAWING_FUNCTIONS.append(draw_eating_rat)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_tools)
    DRAWING_FUNCTIONS.append(draw_goldfish)
    DRAWING_FUNCTIONS.append(draw_transport_pipes)
    DRAWING_FUNCTIONS.append(draw_splash)
    DRAWING_FUNCTIONS.append(draw_bucket)
    DRAWING_FUNCTIONS.append(draw_sprites_front)
    DRAWING_FUNCTIONS.append(draw_moving_sprites_front)
    DRAWING_FUNCTIONS.append(draw_water_surfaces_cover)
    DRAWING_FUNCTIONS.append(draw_water_covers)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_eating_progress)
    DRAWING_FUNCTIONS.append(draw_mouse)
  #
  if MAP.region == 'TheDoor10':
    DRAWING_FUNCTIONS.append(draw_background)
    DRAWING_FUNCTIONS.append(draw_map)
    DRAWING_FUNCTIONS.append(draw_grates)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    DRAWING_FUNCTIONS.append(draw_backsprites)
    DRAWING_FUNCTIONS.append(draw_moving_backsprites)
    DRAWING_FUNCTIONS.append(draw_sublevel_difficulty)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_upgrades)
    DRAWING_FUNCTIONS.append(draw_splash)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_mouse)
  #
  if MAP.region == 'TheDoor11':
    DRAWING_FUNCTIONS.append(draw_background)
    DRAWING_FUNCTIONS.append(draw_map)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    DRAWING_FUNCTIONS.append(draw_backsprites)
    DRAWING_FUNCTIONS.append(draw_moving_backsprites)
    DRAWING_FUNCTIONS.append(draw_sublevel_difficulty)
    DRAWING_FUNCTIONS.append(draw_water_surfaces)
    DRAWING_FUNCTIONS.append(draw_levers)
    DRAWING_FUNCTIONS.append(draw_bubbles)
    DRAWING_FUNCTIONS.append(draw_propellers)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_goldfish)
    DRAWING_FUNCTIONS.append(draw_upgrades)
    DRAWING_FUNCTIONS.append(draw_splash)
    DRAWING_FUNCTIONS.append(draw_water_surfaces_cover)
    DRAWING_FUNCTIONS.append(draw_water_covers)
    DRAWING_FUNCTIONS.append(draw_moving_sprites_front)
    DRAWING_FUNCTIONS.append(draw_dripdrops)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_mouse)
  #
  if MAP.region == 'TheDoor12':
    DRAWING_FUNCTIONS.append(draw_background)
    DRAWING_FUNCTIONS.append(draw_map)
    #DRAWING_FUNCTIONS.append(draw_grates)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    DRAWING_FUNCTIONS.append(draw_backsprites)
    DRAWING_FUNCTIONS.append(draw_moving_backsprites)
    DRAWING_FUNCTIONS.append(draw_sublevel_difficulty)
    DRAWING_FUNCTIONS.append(draw_surfing_rat)
    DRAWING_FUNCTIONS.append(draw_waves)
    DRAWING_FUNCTIONS.append(draw_water_surfaces)
    DRAWING_FUNCTIONS.append(draw_surf_boards)
    DRAWING_FUNCTIONS.append(draw_bubbles)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_numbers_above_hamster)
    DRAWING_FUNCTIONS.append(draw_upgrades)
    DRAWING_FUNCTIONS.append(draw_propellers)
    DRAWING_FUNCTIONS.append(draw_TVs)
    DRAWING_FUNCTIONS.append(draw_levers)
    DRAWING_FUNCTIONS.append(draw_sprites_front)
    DRAWING_FUNCTIONS.append(draw_splash)
    DRAWING_FUNCTIONS.append(draw_water_surfaces_cover)
    DRAWING_FUNCTIONS.append(draw_water_covers)
    DRAWING_FUNCTIONS.append(draw_moving_sprites_front)
    DRAWING_FUNCTIONS.append(draw_bucket)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_mouse)
  #
  if MAP.region == 'Town':
    DRAWING_FUNCTIONS.append(draw_background)
    DRAWING_FUNCTIONS.append(draw_grass_town)
    DRAWING_FUNCTIONS.append(draw_map)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    DRAWING_FUNCTIONS.append(draw_backsprites)
    DRAWING_FUNCTIONS.append(draw_moving_backsprites)
    DRAWING_FUNCTIONS.append(draw_doors_with_knobs)
    DRAWING_FUNCTIONS.append(draw_garbage1)
    DRAWING_FUNCTIONS.append(draw_the_machine)
    DRAWING_FUNCTIONS.append(draw_vines)
    DRAWING_FUNCTIONS.append(draw_HamsterOs_in_machine_outline)
    DRAWING_FUNCTIONS.append(draw_HamsterOs_in_machine)
    DRAWING_FUNCTIONS.append(draw_human)
    DRAWING_FUNCTIONS.append(draw_HamsterOs)
    DRAWING_FUNCTIONS.append(draw_sublevel_difficulty)
    DRAWING_FUNCTIONS.append(draw_beetle)
    DRAWING_FUNCTIONS.append(draw_dark_background)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_sprites_front)
    DRAWING_FUNCTIONS.append(draw_moving_sprites_front)
    DRAWING_FUNCTIONS.append(draw_grass_town)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_splash)
    DRAWING_FUNCTIONS.append(draw_garbage2)
    DRAWING_FUNCTIONS.append(draw_grass_town)
    DRAWING_FUNCTIONS.append(draw_the_machine_doors)
    DRAWING_FUNCTIONS.append(draw_use_fast_travel_thoughts)
    DRAWING_FUNCTIONS.append(draw_hamster_thoughts)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_mouse)
  #
  if MAP.region == 'TheDoor13':
    DRAWING_FUNCTIONS.append(draw_background)
    DRAWING_FUNCTIONS.append(draw_map)
    DRAWING_FUNCTIONS.append(draw_pretty_map)
    DRAWING_FUNCTIONS.append(draw_water_surfaces)
    DRAWING_FUNCTIONS.append(draw_backsprites)
    DRAWING_FUNCTIONS.append(draw_trash)
    DRAWING_FUNCTIONS.append(draw_sublevel_difficulty)
    DRAWING_FUNCTIONS.append(draw_bubbles)
    DRAWING_FUNCTIONS.append(draw_grass)
    DRAWING_FUNCTIONS.append(draw_player)
    DRAWING_FUNCTIONS.append(draw_sheath)
    DRAWING_FUNCTIONS.append(draw_sprites_front)
    DRAWING_FUNCTIONS.append(draw_piston2)
    DRAWING_FUNCTIONS.append(draw_grass)
    DRAWING_FUNCTIONS.append(draw_piston1)
    DRAWING_FUNCTIONS.append(draw_upgrades)
    DRAWING_FUNCTIONS.append(draw_splash)
    DRAWING_FUNCTIONS.append(draw_water_surfaces_cover)
    DRAWING_FUNCTIONS.append(draw_water_covers)
    DRAWING_FUNCTIONS.append(draw_hamster_thoughts)
    if My_cached_info.show_play_time:
      DRAWING_FUNCTIONS.append(draw_play_timer)
    DRAWING_FUNCTIONS.append(draw_mouse)


def draw_all():
  global NUMBERS_ABOVE_HAMSTER, current_blit_change_x, current_blit_change_y
  if not My_cached_info.play_intro_sequence:
    current_blit_change_x = -PLAYER.x_pos + PLAYER.blit_change_x
    current_blit_change_y = -PLAYER.y_pos + PLAYER.blit_change_y
    if stop_scrolling_left < abs(current_blit_change_x) < stop_scrolling_right: # ball not seeing left or right edge
      PLAYER.x_dif = 0
    if stop_scrolling_top < abs(current_blit_change_y) < stop_scrolling_bottom: # ball not seeing top and bottom edge
      PLAYER.y_dif = 0
    if abs(current_blit_change_x) >= stop_scrolling_right: # stop scrolling right side
      PLAYER.x_dif = stop_scrolling_right + (current_blit_change_x)
    if abs(current_blit_change_x) <= stop_scrolling_left: # stop scrolling left side
      PLAYER.x_dif = current_blit_change_x + stop_scrolling_left
    if abs(current_blit_change_y) <= stop_scrolling_top: # stop scrolling top side
      PLAYER.y_dif = current_blit_change_y + stop_scrolling_top
    if abs(current_blit_change_y) >= stop_scrolling_bottom: # stop scrolling bottom side
      PLAYER.y_dif = stop_scrolling_bottom + (current_blit_change_y)
    #
    for SingleDrawFunction in DRAWING_FUNCTIONS:
      SingleDrawFunction()
  #
  if My_cached_info.play_intro_sequence:
    PLAYER.x_pos, PLAYER.y_pos = 1168, 352
    PLAYER.x_vel, PLAYER.y_vel = 0, 0
    current_blit_change_x = -My_cached_info.intro_x
    current_blit_change_y = -My_cached_info.intro_y
    if stop_scrolling_left < abs(current_blit_change_x) < stop_scrolling_right: # ball not seeing left or right edge
      PLAYER.x_dif = 0
    if stop_scrolling_top < abs(current_blit_change_y) < stop_scrolling_bottom: # ball not seeing top and bottom edge
      PLAYER.y_dif = 0
    if abs(current_blit_change_x) >= stop_scrolling_right: # stop scrolling right side
      PLAYER.x_dif = stop_scrolling_right + (current_blit_change_x)
    if abs(current_blit_change_x) <= stop_scrolling_left: # stop scrolling left side
      PLAYER.x_dif = current_blit_change_x + stop_scrolling_left
    if abs(current_blit_change_y) <= stop_scrolling_top: # stop scrolling top side
      PLAYER.y_dif = current_blit_change_y + stop_scrolling_top
    if abs(current_blit_change_y) >= stop_scrolling_bottom: # stop scrolling bottom side
      PLAYER.y_dif = stop_scrolling_bottom + (current_blit_change_y)
    PLAYER.blit_change_x, PLAYER.blit_change_y = 0, 0
    draw_intro_sequence()
    #
    current_hotkey_string = get_hotkey_button_string('PAUSE')
    character_spacing_x = 0
    whole_skip_string = 'PRESS '
    for SingleCharacter in whole_skip_string:
      if SingleCharacter != ' ':
        SingleCharacter = 'B' + SingleCharacter
        current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3, OpenGLTextures[SingleCharacter][0][1] * 3), OpenGLTextures[SingleCharacter][1])
        make_opengl_rect(current_character_image[0], current_character_image[1], (16 + character_spacing_x, 16), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
        character_spacing_x += current_character_image[0][0] + 3
      if SingleCharacter == ' ':
        character_spacing_x += 9
    whole_skip_string = current_hotkey_string
    for SingleCharacter in whole_skip_string:
      if SingleCharacter != ' ':
        SingleCharacter = 'R' + SingleCharacter
        current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3, OpenGLTextures[SingleCharacter][0][1] * 3), OpenGLTextures[SingleCharacter][1])
        make_opengl_rect(current_character_image[0], current_character_image[1], (16 + character_spacing_x, 16), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
        character_spacing_x += current_character_image[0][0] + 3
      if SingleCharacter == ' ':
        character_spacing_x += 9
    whole_skip_string = ' TO SKIP CUTSCENE'
    for SingleCharacter in whole_skip_string:
      if SingleCharacter != ' ':
        SingleCharacter = 'B' + SingleCharacter
        current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3, OpenGLTextures[SingleCharacter][0][1] * 3), OpenGLTextures[SingleCharacter][1])
        make_opengl_rect(current_character_image[0], current_character_image[1], (16 + character_spacing_x, 16), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
        character_spacing_x += current_character_image[0][0] + 3
      if SingleCharacter == ' ':
        character_spacing_x += 9


def draw_map_prettymap_background():
  #for SingleBackground in BACKGROUND:
  #  for i in range(len(SingleBackground.GPU_current_images)):
  #    make_opengl_rect(SingleBackground.GPU_current_images[i][0], SingleBackground.GPU_current_images[i][1], (SingleBackground.current_x_poses[i] + SingleBackground.permanent_add_x, SingleBackground.current_y_poses[i] + SingleBackground.permanent_add_y), 0, False, (0, 0, SingleBackground.GPU_current_images[i][0][0], SingleBackground.GPU_current_images[i][0][1]))
  make_opengl_rect(MAP.GPU_image[0], MAP.GPU_image[1], (MAP.x_pos - My_cached_info.intro_x + stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif, MAP.y_pos - My_cached_info.intro_y + stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MAP.GPU_image[0][0], MAP.GPU_image[0][1]))
  make_opengl_rect(PRETTY_MAP.GPU_image[0], PRETTY_MAP.GPU_image[1], (PRETTY_MAP.x_pos - My_cached_info.intro_x + stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif, PRETTY_MAP.y_pos - My_cached_info.intro_y + stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif), 0, False, (0, 0, PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1]))


def draw_map_prettymap_background_ending_sequence():
  #for SingleBackground in BACKGROUND:
  #  for i in range(len(SingleBackground.GPU_current_images)):
  #    make_opengl_rect(SingleBackground.GPU_current_images[i][0], SingleBackground.GPU_current_images[i][1], (SingleBackground.current_x_poses[i] + SingleBackground.permanent_add_x, SingleBackground.current_y_poses[i] + SingleBackground.permanent_add_y), 0, False, (0, 0, SingleBackground.GPU_current_images[i][0][0], SingleBackground.GPU_current_images[i][0][1]))
  make_opengl_rect(MAP.GPU_image[0], MAP.GPU_image[1], (MAP.x_pos - My_cached_info.intro_x + stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif, MAP.y_pos - My_cached_info.intro_y + stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MAP.GPU_image[0][0], MAP.GPU_image[0][1]))
  make_opengl_rect(PRETTY_MAP.GPU_image[0], PRETTY_MAP.GPU_image[1], (PRETTY_MAP.x_pos - My_cached_info.intro_x + stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif, PRETTY_MAP.y_pos - My_cached_info.intro_y + stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif), 0, False, (0, 0, PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1]))


def play_won_the_game_sequence():
  global clock
  global Mouse_x, Mouse_y
  global keys, Mouse_x, Mouse_y, left_click, weird_click, right_click
  won_curr_time = pygame.time.get_ticks()
  won_prev_time = pygame.time.get_ticks() - 13
  won_delta_milliseconds = 13
  won_fps = (1 / (won_curr_time - won_prev_time))*1000
  won_millisecond_counter = 0
  frames_this_frame_remainder = 0
  elapsed_fps_float = 0
  bound_left = -(MAP.x_pos - PLAYER.x_pos + stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif)
  bound_top = -(MAP.y_pos - PLAYER.y_pos + stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif)
  bound_right = bound_left + screen_width
  bound_bottom = bound_top + screen_height
  original_blit_change_x = PLAYER.blit_change_x - PLAYER.x_dif
  original_blit_change_y = PLAYER.blit_change_y - PLAYER.y_dif
  my_piston1.number_of_pixels_to_move = 0
  my_sheath.rotation = 225
  Mouse_x, Mouse_y = -9999999, 9999999
  regular_piston_sheath_update()
  start_of_sequence_time = pygame.time.get_ticks()
  time_in_step_of_sequence = 0
  step_in_sequence = 0
  played_water_jet_sound_yet = False
  while True:
    for event in pygame.event.get():
      if event.type == pygame.QUIT:
        everything_save_data(True, 83, str(My_cached_info.play_time))
        raise SystemExit
    #
    keys = pygame.key.get_pressed()
    Mouse_x, Mouse_y = pygame.mouse.get_pos()
    left_click, weird_click, right_click = pygame.mouse.get_pressed()
    update_pressed_controls()
    if Currently_pressed_controls.pressed_controls['PAUSE'] and step_in_sequence <= 4:
      step_in_sequence = 5
      time_in_step_of_sequence = 0
    #
    #
    time_in_step_of_sequence += won_delta_milliseconds
    #
    if step_in_sequence == 0:
      if PLAYER.blit_change_x != 0:
        if PLAYER.blit_change_x > 1:
          PLAYER.blit_change_x -= 1
        if PLAYER.blit_change_x < -1:
          PLAYER.blit_change_x += 1
        if -1 < PLAYER.blit_change_x < 1:
          PLAYER.blit_change_x = 0
      if PLAYER.blit_change_y != 0:
        if PLAYER.blit_change_y > 1:
          PLAYER.blit_change_y -= 1
        if PLAYER.blit_change_y < -1:
          PLAYER.blit_change_y += 1
        if -1 < PLAYER.blit_change_y < 1:
          PLAYER.blit_change_y = 0
      percent_of_the_way_through_step = time_in_step_of_sequence / 2160
      if percent_of_the_way_through_step > 1:
        percent_of_the_way_through_step = 1
      desired_center_of_screen_x = 2634
      desired_center_of_screen_y = 900
      adjust_screen_x = -(desired_center_of_screen_x - PLAYER.x_pos + original_blit_change_x) * percent_of_the_way_through_step
      adjust_screen_y = -(desired_center_of_screen_y - PLAYER.y_pos + original_blit_change_y) * percent_of_the_way_through_step
      machine_shake_x = 0
      machine_shake_y = 0
      machine_shaky_rot = 2.5*math.sin(math.radians(time_in_step_of_sequence))
      if percent_of_the_way_through_step == 1:
        machine_shaky_rot = 0
      make_opengl_rect(MAP.GPU_image[0], MAP.GPU_image[1], (MAP.x_pos - PLAYER.x_pos + adjust_screen_x + stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif, MAP.y_pos - PLAYER.y_pos + adjust_screen_y + stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif), 0, False, (0, 0, MAP.GPU_image[0][0], MAP.GPU_image[0][1]))
      make_opengl_rect(PRETTY_MAP.GPU_image[0], PRETTY_MAP.GPU_image[1], (PRETTY_MAP.x_pos - PLAYER.x_pos + adjust_screen_x + stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif, PRETTY_MAP.y_pos - PLAYER.y_pos + adjust_screen_y + stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif), 0, False, (0, 0, PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1]))
      make_opengl_rect((screen_width, screen_height), OpenGLTextures['SHADY_PIXELS'][0][1], (0, 0), 0, False, (0, 0, screen_width, screen_height))
      make_opengl_rect_center_on_circle(OpenGLTextures['WHOLE_CLOSED_MACHINE'][0], OpenGLTextures['WHOLE_CLOSED_MACHINE'][1], (2256 + (0.5 * screen_width) + current_blit_change_x - PLAYER.x_dif + adjust_screen_x + machine_shake_x, 680 + (0.5 * screen_height) + current_blit_change_y - PLAYER.y_dif + adjust_screen_y + machine_shake_y), machine_shaky_rot, False, (0, 0, OpenGLTextures['WHOLE_CLOSED_MACHINE'][0][0], OpenGLTextures['WHOLE_CLOSED_MACHINE'][0][1]))
      if time_in_step_of_sequence >= 2700:
        step_in_sequence = 1
        time_in_step_of_sequence = 0
        PLAYER.blit_change_x = 0
        PLAYER.blit_change_y = 0
        PLAYER.x_dif = 0
        PLAYER.y_dif = 0
        MixerSounds['THE_MACHINE1'].fadeout(800)
        MixerSounds['THE_MACHINE2'].fadeout(800)
        MixerSounds['THE_MACHINE3'].fadeout(800)
    #
    if step_in_sequence == 1:
      percent_of_the_way_through_step = time_in_step_of_sequence / 1250
      adjust_screen_x = -2634
      adjust_screen_y = -900
      make_opengl_rect(OpenGLTextures['Forest_BG1'][0][0], OpenGLTextures['Forest_BG1'][0][1], (0 + adjust_screen_x + stop_scrolling_left, 0 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['Forest_BG1'][0][0][0], OpenGLTextures['Forest_BG1'][0][0][1]))
      make_opengl_rect(OpenGLTextures['Forest_BG1'][0][0], OpenGLTextures['Forest_BG1'][0][1], (2000 + adjust_screen_x + stop_scrolling_left, 0 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['Forest_BG1'][0][0][0], OpenGLTextures['Forest_BG1'][0][0][1]))
      make_opengl_rect(MAP.GPU_image[0], MAP.GPU_image[1], (MAP.x_pos + adjust_screen_x + stop_scrolling_left, MAP.y_pos + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, MAP.GPU_image[0][0], MAP.GPU_image[0][1]))
      make_opengl_rect(PRETTY_MAP.GPU_image[0], PRETTY_MAP.GPU_image[1], (PRETTY_MAP.x_pos + adjust_screen_x + stop_scrolling_left, PRETTY_MAP.y_pos + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + adjust_screen_x + stop_scrolling_left, 1132 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (1363 + adjust_screen_x + stop_scrolling_left, 1132 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
      shady_pixel_index = int(time_in_step_of_sequence // 250)
      if shady_pixel_index >= 5:
        shady_pixel_index = 5
      if shady_pixel_index <= 4:
        make_opengl_rect((screen_width, screen_height), OpenGLTextures['SHADY_PIXELS'][shady_pixel_index][1], (0, 0), 0, False, (0, 0, screen_width, screen_height))
      machine_closing_index = int(time_in_step_of_sequence // 250)
      if machine_closing_index >= 5:
        machine_closing_index = 5
      make_opengl_rect(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (2322 + adjust_screen_x + stop_scrolling_left, 926 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['THE_BALL_BACK'][0][0], OpenGLTextures['THE_BALL_BACK'][0][1]))
      make_opengl_rect(OpenGLTextures['HAMSTER_STANDING_RIGHT'][0], OpenGLTextures['HAMSTER_STANDING_RIGHT'][1], (2322 + adjust_screen_x + stop_scrolling_left, 926 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['HAMSTER_STANDING_RIGHT'][0][0], OpenGLTextures['HAMSTER_STANDING_RIGHT'][0][1]))
      make_opengl_rect(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (2322 + adjust_screen_x + stop_scrolling_left, 926 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['THE_BALL_FRONT'][0][0], OpenGLTextures['THE_BALL_FRONT'][0][1]))
      make_opengl_rect_center_on_circle(OpenGLTextures['SHEATH'][0], OpenGLTextures['SHEATH'][1], (2322 + adjust_screen_x + stop_scrolling_left, 926 + adjust_screen_y + stop_scrolling_top), 260, False, (0, 0, OpenGLTextures['SHEATH'][0][0], OpenGLTextures['SHEATH'][0][1]))
      human_eating_index = int((time_in_step_of_sequence % 450) // 150)
      make_opengl_rect(OpenGLTextures['HUMAN_EATING'][human_eating_index][0], OpenGLTextures['HUMAN_EATING'][human_eating_index][1], (2581 + adjust_screen_x + stop_scrolling_left, 745 + adjust_screen_y + stop_scrolling_top), 0, True, (0, 0, OpenGLTextures['HUMAN_EATING'][human_eating_index][0][0], OpenGLTextures['HUMAN_EATING'][human_eating_index][0][1]))
      make_opengl_rect(OpenGLTextures['THE_MACHINE_CLOSING'][machine_closing_index][0], OpenGLTextures['THE_MACHINE_CLOSING'][machine_closing_index][1], (2256 + adjust_screen_x + stop_scrolling_left, 680 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_CLOSING'][machine_closing_index][0][0], OpenGLTextures['THE_MACHINE_CLOSING'][machine_closing_index][0][1]))
      if time_in_step_of_sequence >= 1700:
        step_in_sequence = 2
        time_in_step_of_sequence = 0
      make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (2256 + 220 + adjust_screen_x + stop_scrolling_left, 680 + 236 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
      make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (2256 + 252 + adjust_screen_x + stop_scrolling_left, 680 + 236 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    #
    if step_in_sequence == 2:
      percent_of_the_way_through_step = time_in_step_of_sequence / 1250
      adjust_screen_x = -2634
      adjust_screen_y = -900
      make_opengl_rect(OpenGLTextures['Forest_BG1'][0][0], OpenGLTextures['Forest_BG1'][0][1], (0 + adjust_screen_x + stop_scrolling_left, 0 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['Forest_BG1'][0][0][0], OpenGLTextures['Forest_BG1'][0][0][1]))
      make_opengl_rect(OpenGLTextures['Forest_BG1'][0][0], OpenGLTextures['Forest_BG1'][0][1], (2000 + adjust_screen_x + stop_scrolling_left, 0 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['Forest_BG1'][0][0][0], OpenGLTextures['Forest_BG1'][0][0][1]))
      make_opengl_rect(MAP.GPU_image[0], MAP.GPU_image[1], (MAP.x_pos + adjust_screen_x + stop_scrolling_left, MAP.y_pos + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, MAP.GPU_image[0][0], MAP.GPU_image[0][1]))
      make_opengl_rect(PRETTY_MAP.GPU_image[0], PRETTY_MAP.GPU_image[1], (PRETTY_MAP.x_pos + adjust_screen_x + stop_scrolling_left, PRETTY_MAP.y_pos + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + adjust_screen_x + stop_scrolling_left, 1132 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (1363 + adjust_screen_x + stop_scrolling_left, 1132 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
      make_opengl_rect(OpenGLTextures['THE_MACHINE_CLOSING'][5][0], OpenGLTextures['THE_MACHINE_CLOSING'][5][1], (2256 + adjust_screen_x + stop_scrolling_left, 680 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_CLOSING'][5][0][0], OpenGLTextures['THE_MACHINE_CLOSING'][5][0][1]))
      make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (2256 + 220 + adjust_screen_x + stop_scrolling_left, 680 + 236 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
      make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (2256 + 252 + adjust_screen_x + stop_scrolling_left, 680 + 236 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
      make_opengl_rect(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (2322 + adjust_screen_x + stop_scrolling_left, 926 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['THE_BALL_BACK'][0][0], OpenGLTextures['THE_BALL_BACK'][0][1]))
      make_opengl_rect(OpenGLTextures['HAMSTER_STANDING_RIGHT'][0], OpenGLTextures['HAMSTER_STANDING_RIGHT'][1], (2322 + adjust_screen_x + stop_scrolling_left, 926 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['HAMSTER_STANDING_RIGHT'][0][0], OpenGLTextures['HAMSTER_STANDING_RIGHT'][0][1]))
      make_opengl_rect(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (2322 + adjust_screen_x + stop_scrolling_left, 926 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['THE_BALL_FRONT'][0][0], OpenGLTextures['THE_BALL_FRONT'][0][1]))
      make_opengl_rect_center_on_circle(OpenGLTextures['SHEATH'][0], OpenGLTextures['SHEATH'][1], (2322 + adjust_screen_x + stop_scrolling_left, 926 + adjust_screen_y + stop_scrolling_top), 225, False, (0, 0, OpenGLTextures['SHEATH'][0][0], OpenGLTextures['SHEATH'][0][1]))
      if time_in_step_of_sequence <= 800:
        human_grossed_index = 0
      if 800 <= time_in_step_of_sequence <= 1100:
        human_grossed_index = 1
      if 1100 < time_in_step_of_sequence <=  4000:
        index_decider = time_in_step_of_sequence % 400
        if 0 <= index_decider <= 200:
          human_grossed_index = 2
        if 200 < index_decider <= 400:
          human_grossed_index = 1
      if 0 <= time_in_step_of_sequence <= 4000:
        make_opengl_rect(OpenGLTextures['HUMAN_GROSSED'][human_grossed_index][0], OpenGLTextures['HUMAN_GROSSED'][human_grossed_index][1], (2581 + adjust_screen_x + stop_scrolling_left, 745 + adjust_screen_y + stop_scrolling_top), 0, True, (0, 0, OpenGLTextures['HUMAN_GROSSED'][human_grossed_index][0][0], OpenGLTextures['HUMAN_GROSSED'][human_grossed_index][0][1]))
      if 1100 <= time_in_step_of_sequence <= 4000:
        make_opengl_rect(OpenGLTextures['EwwIHateHamsterOs'][0], OpenGLTextures['EwwIHateHamsterOs'][1], (2423 + adjust_screen_x + stop_scrolling_left, 789 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['EwwIHateHamsterOs'][0][0], OpenGLTextures['EwwIHateHamsterOs'][0][1]))
      if 4000 <= time_in_step_of_sequence <= 6900:
        index_decider = time_in_step_of_sequence % 400
        if 0 <= index_decider <= 200:
          human_excited_index = 0
        if 200 < index_decider <= 400:
          human_excited_index = 1
        make_opengl_rect(OpenGLTextures['HUMAN_EXCITED'][human_excited_index][0], OpenGLTextures['HUMAN_EXCITED'][human_excited_index][1], (2581 + adjust_screen_x + stop_scrolling_left, 745 + adjust_screen_y + stop_scrolling_top), 0, True, (0, 0, OpenGLTextures['HUMAN_EXCITED'][human_excited_index][0][0], OpenGLTextures['HUMAN_EXCITED'][human_excited_index][0][1]))
      if 4200 <= time_in_step_of_sequence <= 6700:
        make_opengl_rect(OpenGLTextures['ImBack'][0], OpenGLTextures['ImBack'][1], (2483 + adjust_screen_x + stop_scrolling_left, 804 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['ImBack'][0][0], OpenGLTextures['ImBack'][0][1]))
      if 800 <= time_in_step_of_sequence:
        start_y = 890
        end_y = 939
        total_added_y = end_y - start_y
        milliseconds_to_fall = 250
        current_added_y = total_added_y * ((time_in_step_of_sequence - 800) / milliseconds_to_fall)
        if current_added_y > total_added_y:
          current_added_y = total_added_y
        make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (2593 + adjust_screen_x + stop_scrolling_left, 890 + current_added_y + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
      if time_in_step_of_sequence >= 6900:
        step_in_sequence = 3
        time_in_step_of_sequence = 0
    #
    if step_in_sequence == 3:
      if not played_water_jet_sound_yet:
        MixerSounds['LOUD_WATER_JET'].play()
        played_water_jet_sound_yet = True
      if time_in_step_of_sequence > 1003:
        time_in_step_of_sequence = 1003
      delta_milliseconds = won_delta_milliseconds
      percent_of_the_way_through_step = time_in_step_of_sequence / 1003
      adjust_screen_x = -2634
      adjust_screen_y = -900
      delta_x = 277
      current_added_x = 277 * percent_of_the_way_through_step
      delta_y = 76
      hmax_time = 691
      current_added_y = -(0 + (276.3 * (time_in_step_of_sequence / 1000)) - ((400 * (time_in_step_of_sequence / 1000)**2) / 2))
      current_vel_y = 276.3 - (400 * (time_in_step_of_sequence / 1000))
      my_piston1.Cover_x_pos = 0
      my_piston1.Cover_y_pos = 0
      PLAYER.x_pos = 2322 + current_added_x
      PLAYER.y_pos = 926 + current_added_y
      adjust_water_jet_pos_x = PLAYER.x_pos + adjust_screen_x
      adjust_water_jet_pos_y = PLAYER.y_pos + adjust_screen_y
      my_piston1.extension = 0
      my_piston1.is_touching_wall = [False, False, False, False, False, False]
      if 0 <= time_in_step_of_sequence <= 200:
        my_piston1.is_touching_wall = [False, False, False, False, False, True]
        my_piston1.extension = 11 + (35 * math.sin(math.radians(time_in_step_of_sequence * 1.8)))
      if 200 < time_in_step_of_sequence:
        MixerSounds['LOUD_WATER_JET'].fadeout(75)
      my_piston1.extension_float = my_piston1.extension
      regular_update_PushPiston(my_piston1)
      my_piston1.number_of_pixels_to_move += won_delta_milliseconds / 4
      my_piston1.cropped_region[0] = (486 - ((round(my_piston1.number_of_pixels_to_move))%243))%243
      my_piston1.cropped_region[2] = my_piston1.extension
      make_opengl_rect(OpenGLTextures['Forest_BG1'][0][0], OpenGLTextures['Forest_BG1'][0][1], (0 + adjust_screen_x + stop_scrolling_left, 0 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['Forest_BG1'][0][0][0], OpenGLTextures['Forest_BG1'][0][0][1]))
      make_opengl_rect(OpenGLTextures['Forest_BG1'][0][0], OpenGLTextures['Forest_BG1'][0][1], (2000 + adjust_screen_x + stop_scrolling_left, 0 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['Forest_BG1'][0][0][0], OpenGLTextures['Forest_BG1'][0][0][1]))
      make_opengl_rect(MAP.GPU_image[0], MAP.GPU_image[1], (MAP.x_pos + adjust_screen_x + stop_scrolling_left, MAP.y_pos + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, MAP.GPU_image[0][0], MAP.GPU_image[0][1]))
      make_opengl_rect(PRETTY_MAP.GPU_image[0], PRETTY_MAP.GPU_image[1], (PRETTY_MAP.x_pos + adjust_screen_x + stop_scrolling_left, PRETTY_MAP.y_pos + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + adjust_screen_x + stop_scrolling_left, 1132 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (1363 + adjust_screen_x + stop_scrolling_left, 1132 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
      make_opengl_rect(OpenGLTextures['THE_MACHINE_CLOSING'][5][0], OpenGLTextures['THE_MACHINE_CLOSING'][5][1], (2256 + adjust_screen_x + stop_scrolling_left, 680 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_CLOSING'][5][0][0], OpenGLTextures['THE_MACHINE_CLOSING'][5][0][1]))
      make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (2256 + 220 + adjust_screen_x + stop_scrolling_left, 680 + 236 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
      make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (2256 + 252 + adjust_screen_x + stop_scrolling_left, 680 + 236 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
      make_opengl_rect(OpenGLTextures['HUMAN_STANDING'][0][0], OpenGLTextures['HUMAN_STANDING'][0][1], (2581 + adjust_screen_x + stop_scrolling_left, 745 + adjust_screen_y + stop_scrolling_top), 0, True, (0, 0, OpenGLTextures['HUMAN_STANDING'][0][0][0], OpenGLTextures['HUMAN_STANDING'][0][0][1]))
      make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (2593 + adjust_screen_x + stop_scrolling_left, 939 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
      make_opengl_rect(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (2322 + current_added_x + adjust_screen_x + stop_scrolling_left, 926 + current_added_y + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['THE_BALL_BACK'][0][0], OpenGLTextures['THE_BALL_BACK'][0][1]))
      hamster_flying_index = 3
      if 400 >= current_vel_y >= 200:
        hamster_flying_index = 0
      if 200 > current_vel_y >= 0:
        hamster_flying_index = 1
      if 0 > current_vel_y >= 200:
        hamster_flying_index = 3
      make_opengl_rect(OpenGLTextures['HAMSTER_FLYING_RIGHT'][hamster_flying_index][0], OpenGLTextures['HAMSTER_FLYING_RIGHT'][hamster_flying_index][1], (2322 + current_added_x + adjust_screen_x + stop_scrolling_left, 926 + current_added_y + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['HAMSTER_FLYING_RIGHT'][hamster_flying_index][0][0], OpenGLTextures['HAMSTER_FLYING_RIGHT'][hamster_flying_index][0][1]))
      make_opengl_rect(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (2322 + current_added_x + adjust_screen_x + stop_scrolling_left, 926 + current_added_y + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['THE_BALL_FRONT'][0][0], OpenGLTextures['THE_BALL_FRONT'][0][1]))
      make_opengl_rect_center_on_circle(OpenGLTextures['SHEATH'][0], OpenGLTextures['SHEATH'][1], (2322 + current_added_x + adjust_screen_x + stop_scrolling_left, 926 + current_added_y + adjust_screen_y + stop_scrolling_top), 225, False, (0, 0, OpenGLTextures['SHEATH'][0][0], OpenGLTextures['SHEATH'][0][1]))
      if my_piston1.extension != 0:
        make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (my_piston1.Cover_x_pos + adjust_water_jet_pos_x + stop_scrolling_left+34, my_piston1.Cover_y_pos + adjust_water_jet_pos_y + stop_scrolling_top+34), my_sheath.rotation, False, (my_piston1.cropped_region[0], my_piston1.cropped_region[1], my_piston1.cropped_region[0]+my_piston1.cropped_region[2], my_piston1.cropped_region[3]))
      if 0 <= time_in_step_of_sequence <= 200:
        make_opengl_rect_center_on_circle(my_piston1.GPU_current_Splash[0], my_piston1.GPU_current_Splash[1], (my_piston1.Splash_x_pos + adjust_water_jet_pos_x + stop_scrolling_left, my_piston1.Splash_y_pos + adjust_water_jet_pos_y + stop_scrolling_top), my_sheath.rotation+90, False, (0, 0, my_piston1.SplashRect[2], my_piston1.SplashRect[3]))
      if time_in_step_of_sequence >= 1003:
        step_in_sequence = 4
        time_in_step_of_sequence = 0
    #
    if step_in_sequence == 4:
      MixerSounds['THE_MACHINE1'].stop()
      MixerSounds['THE_MACHINE2'].stop()
      MixerSounds['THE_MACHINE3'].stop()
      adjust_screen_x = -2634
      adjust_screen_y = -900
      make_opengl_rect(OpenGLTextures['Forest_BG1'][0][0], OpenGLTextures['Forest_BG1'][0][1], (0 + adjust_screen_x + stop_scrolling_left, 0 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['Forest_BG1'][0][0][0], OpenGLTextures['Forest_BG1'][0][0][1]))
      make_opengl_rect(OpenGLTextures['Forest_BG1'][0][0], OpenGLTextures['Forest_BG1'][0][1], (2000 + adjust_screen_x + stop_scrolling_left, 0 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['Forest_BG1'][0][0][0], OpenGLTextures['Forest_BG1'][0][0][1]))
      make_opengl_rect(MAP.GPU_image[0], MAP.GPU_image[1], (MAP.x_pos + adjust_screen_x + stop_scrolling_left, MAP.y_pos + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, MAP.GPU_image[0][0], MAP.GPU_image[0][1]))
      make_opengl_rect(PRETTY_MAP.GPU_image[0], PRETTY_MAP.GPU_image[1], (PRETTY_MAP.x_pos + adjust_screen_x + stop_scrolling_left, PRETTY_MAP.y_pos + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + adjust_screen_x + stop_scrolling_left, 1132 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (1363 + adjust_screen_x + stop_scrolling_left, 1132 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
      make_opengl_rect(OpenGLTextures['THE_MACHINE_CLOSING'][5][0], OpenGLTextures['THE_MACHINE_CLOSING'][5][1], (2256 + adjust_screen_x + stop_scrolling_left, 680 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_CLOSING'][5][0][0], OpenGLTextures['THE_MACHINE_CLOSING'][5][0][1]))
      make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (2256 + 220 + adjust_screen_x + stop_scrolling_left, 680 + 236 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
      make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (2256 + 252 + adjust_screen_x + stop_scrolling_left, 680 + 236 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
      holding_talking_index = 0
      if 200 <= time_in_step_of_sequence <= 3200:
        holding_talking_index = int((time_in_step_of_sequence % 400) // 200)
      make_opengl_rect(OpenGLTextures['HUMAN_HOLDING_TALKING'][holding_talking_index][0], OpenGLTextures['HUMAN_HOLDING_TALKING'][holding_talking_index][1], (2581 + adjust_screen_x + stop_scrolling_left, 745 + adjust_screen_y + stop_scrolling_top), 0, True, (0, 0, OpenGLTextures['HUMAN_HOLDING_TALKING'][holding_talking_index][0][0], OpenGLTextures['HUMAN_HOLDING_TALKING'][holding_talking_index][0][1]))
      make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (2593 + adjust_screen_x + stop_scrolling_left, 939 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
      make_opengl_rect(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (2599 + adjust_screen_x + stop_scrolling_left, 850 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['THE_BALL_BACK'][0][0], OpenGLTextures['THE_BALL_BACK'][0][1]))
      make_opengl_rect(OpenGLTextures['HAMSTER_STANDING_RIGHT'][0], OpenGLTextures['HAMSTER_STANDING_RIGHT'][1], (2599 + adjust_screen_x + stop_scrolling_left, 850 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['HAMSTER_STANDING_RIGHT'][0][0], OpenGLTextures['HAMSTER_STANDING_RIGHT'][0][1]))
      make_opengl_rect(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (2599 + adjust_screen_x + stop_scrolling_left, 850 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['THE_BALL_FRONT'][0][0], OpenGLTextures['THE_BALL_FRONT'][0][1]))
      make_opengl_rect_center_on_circle(OpenGLTextures['SHEATH'][0], OpenGLTextures['SHEATH'][1], (2599 + adjust_screen_x + stop_scrolling_left, 850 + adjust_screen_y + stop_scrolling_top), 225, False, (0, 0, OpenGLTextures['SHEATH'][0][0], OpenGLTextures['SHEATH'][0][1]))
      heart_index1 = int((time_in_step_of_sequence % 900) // 100)
      make_opengl_rect(OpenGLTextures['HEARTS'][heart_index1][0], OpenGLTextures['HEARTS'][heart_index1][1], (2580 + adjust_screen_x + stop_scrolling_left, 704 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['HEARTS'][heart_index1][0][0], OpenGLTextures['HEARTS'][heart_index1][0][1]))
      heart_index2 = int(((time_in_step_of_sequence + 180) % 900) // 100)
      make_opengl_rect((23, 21), OpenGLTextures['HEARTS'][heart_index2][1], (2545 + adjust_screen_x + stop_scrolling_left, 804 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, 23, 21))
      heart_index3 = int(((time_in_step_of_sequence + 360) % 900) // 100)
      make_opengl_rect((23, 21), OpenGLTextures['HEARTS'][heart_index3][1], (2569 + adjust_screen_x + stop_scrolling_left, 872 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, 23, 21))
      heart_index4 = int(((time_in_step_of_sequence + 540) % 900) // 100)
      make_opengl_rect((23, 21), OpenGLTextures['HEARTS'][heart_index4][1], (2676 + adjust_screen_x + stop_scrolling_left, 872 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, 23, 21))
      heart_index5 = int(((time_in_step_of_sequence + 720) % 900) // 100)
      make_opengl_rect((23, 21), OpenGLTextures['HEARTS'][heart_index5][1], (2699 + adjust_screen_x + stop_scrolling_left, 804 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, 23, 21))
      if 200 <= time_in_step_of_sequence <= 3200:
        make_opengl_rect(OpenGLTextures['ILoveYou'][0], OpenGLTextures['ILoveYou'][1], (2469 + adjust_screen_x + stop_scrolling_left, 804 + adjust_screen_y + stop_scrolling_top), 0, False, (0, 0, OpenGLTextures['ILoveYou'][0][0], OpenGLTextures['ILoveYou'][0][1]))
      if 8000 <= time_in_step_of_sequence:
        shady_pixel_index = int((time_in_step_of_sequence - 8000) // 250)
        if shady_pixel_index > 4:
          shady_pixel_index = 4
        shady_mapping = [4, 3, 2, 1, 0]
        shady_pixel_index = shady_mapping[shady_pixel_index]
        make_opengl_rect((screen_width, screen_height), OpenGLTextures['SHADY_PIXELS'][shady_pixel_index][1], (0, 0), 0, False, (0, 0, screen_width, screen_height))
      if time_in_step_of_sequence >= 9100:
        step_in_sequence = 5
        time_in_step_of_sequence = 0
    #
    if step_in_sequence == 5:
      MixerSounds['THE_MACHINE1'].stop()
      MixerSounds['THE_MACHINE2'].stop()
      MixerSounds['THE_MACHINE3'].stop()
      make_opengl_rect((screen_width, screen_height), OpenGLTextures['SHADY_PIXELS'][0][1], (0, 0), 0, False, (0, 0, screen_width, screen_height))
      move_credits_down_time = (time_in_step_of_sequence / 500)
      if move_credits_down_time > 1:
        move_credits_down_time = 1
      credits_added_y = screen_height * move_credits_down_time
      make_opengl_rect((screen_width, screen_height), OpenGLTextures['CREDITS'][1], (0, credits_added_y - screen_height), 0, False, (0, 0, screen_width, screen_height))
      if move_credits_down_time == 1:
        for k, v in Currently_pressed_controls.pressed_controls.items():
          if v:
            step_in_sequence = 6
            time_in_step_of_sequence = 0
    #
    if step_in_sequence == 6:
      MixerSounds['THE_MACHINE1'].stop()
      MixerSounds['THE_MACHINE2'].stop()
      MixerSounds['THE_MACHINE3'].stop()
      make_opengl_rect((screen_width, screen_height), OpenGLTextures['SHADY_PIXELS'][0][1], (0, 0), 0, False, (0, 0, screen_width, screen_height))
      move_credits_down_time = (time_in_step_of_sequence / 500)
      if move_credits_down_time > 1:
        move_credits_down_time = 1
      credits_added_y = screen_height * move_credits_down_time
      make_opengl_rect((screen_width, screen_height), OpenGLTextures['CREDITS'][1], (0, 0 - credits_added_y), 0, False, (0, 0, screen_width, screen_height))
      if time_in_step_of_sequence > 550:
        step_in_sequence = 7
        time_in_step_of_sequence = 0
        #My_cached_info.return_to_main_menu = True
        #break
    #
    if step_in_sequence == 7:
      MixerSounds['THE_MACHINE1'].stop()
      MixerSounds['THE_MACHINE2'].stop()
      MixerSounds['THE_MACHINE3'].stop()
      pygame.mixer.stop()
      character_spacing_x = 0
      whole_skip_string = 'YOUR FINAL PLAYTIME IS'
      for SingleCharacter in whole_skip_string:
        if SingleCharacter != ' ':
          SingleCharacter = SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 5, OpenGLTextures[SingleCharacter][0][1] * 5), OpenGLTextures[SingleCharacter][1])
          #make_opengl_rect(current_character_image[0], current_character_image[1], (16 + character_spacing_x, 16), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          character_spacing_x += current_character_image[0][0] + 5
        if SingleCharacter == ' ':
          character_spacing_x += 15
      words_width = character_spacing_x
      starting_letter_x_pos = (screen_width - words_width) / 2
      character_spacing_x = 0
      whole_skip_string = 'YOUR FINAL PLAYTIME IS'
      for SingleCharacter in whole_skip_string:
        if SingleCharacter != ' ':
          SingleCharacter = SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 5, OpenGLTextures[SingleCharacter][0][1] * 5), OpenGLTextures[SingleCharacter][1])
          make_opengl_rect(current_character_image[0], current_character_image[1], (starting_letter_x_pos + character_spacing_x, (2 / 5) * screen_height), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          character_spacing_x += current_character_image[0][0] + 5
        if SingleCharacter == ' ':
          character_spacing_x += 15
      character_spacing_x = 0
      whole_skip_string = milliseconds_to_time_string(My_cached_info.play_time)
      for SingleCharacter in whole_skip_string:
        if SingleCharacter != ' ':
          SingleCharacter = SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 5, OpenGLTextures[SingleCharacter][0][1] * 5), OpenGLTextures[SingleCharacter][1])
          #make_opengl_rect(current_character_image[0], current_character_image[1], (16 + character_spacing_x, 16), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          character_spacing_x += current_character_image[0][0] + 5
        if SingleCharacter == ' ':
          character_spacing_x += 15
      words_width = character_spacing_x
      starting_letter_x_pos = (screen_width - words_width) / 2
      character_spacing_x = 0
      for SingleCharacter in whole_skip_string:
        if SingleCharacter != ' ':
          SingleCharacter = SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 5, OpenGLTextures[SingleCharacter][0][1] * 5), OpenGLTextures[SingleCharacter][1])
          make_opengl_rect(current_character_image[0], current_character_image[1], (starting_letter_x_pos + character_spacing_x, ((2 / 5) * screen_height) + 40), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          character_spacing_x += current_character_image[0][0] + 5
        if SingleCharacter == ' ':
          character_spacing_x += 15
      for k, v in Currently_pressed_controls.pressed_controls.items():
        if v:
          My_cached_info.return_to_main_menu = True
          break
      if My_cached_info.return_to_main_menu:
        break
    #
    #
    if 0 < step_in_sequence <= 4:
      current_hotkey_string = get_hotkey_button_string('PAUSE')
      character_spacing_x = 0
      whole_skip_string = 'PRESS '
      for SingleCharacter in whole_skip_string:
        if SingleCharacter != ' ':
          SingleCharacter = 'B' + SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3, OpenGLTextures[SingleCharacter][0][1] * 3), OpenGLTextures[SingleCharacter][1])
          make_opengl_rect(current_character_image[0], current_character_image[1], (16 + character_spacing_x, 16), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          character_spacing_x += current_character_image[0][0] + 3
        if SingleCharacter == ' ':
          character_spacing_x += 9
      whole_skip_string = current_hotkey_string
      for SingleCharacter in whole_skip_string:
        if SingleCharacter != ' ':
          SingleCharacter = 'R' + SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3, OpenGLTextures[SingleCharacter][0][1] * 3), OpenGLTextures[SingleCharacter][1])
          make_opengl_rect(current_character_image[0], current_character_image[1], (16 + character_spacing_x, 16), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          character_spacing_x += current_character_image[0][0] + 3
        if SingleCharacter == ' ':
          character_spacing_x += 9
      whole_skip_string = ' TO SKIP CUTSCENE'
      for SingleCharacter in whole_skip_string:
        if SingleCharacter != ' ':
          SingleCharacter = 'B' + SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3, OpenGLTextures[SingleCharacter][0][1] * 3), OpenGLTextures[SingleCharacter][1])
          make_opengl_rect(current_character_image[0], current_character_image[1], (16 + character_spacing_x, 16), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          character_spacing_x += current_character_image[0][0] + 3
        if SingleCharacter == ' ':
          character_spacing_x += 9
    #
    #
    #glFlush()
    pygame.display.flip()
    #
    #
    #
    clock.tick(60)
    won_curr_time = pygame.time.get_ticks()
    won_fps = (1 / (won_curr_time - won_prev_time))*1000
    pygame.display.set_caption("{0}".format(title))
    won_delta_milliseconds = won_curr_time - won_prev_time
    if won_delta_milliseconds > 30:
      won_delta_milliseconds = 30
    won_millisecond_counter += won_delta_milliseconds
    won_prev_time = won_curr_time
    frames_this_frame_float = (60 / won_fps)
    frames_this_frame_remainder += frames_this_frame_float - int(frames_this_frame_float)
    elapsed_fps_float += frames_this_frame_float
    frames_this_frame = int(frames_this_frame_float)
    if frames_this_frame_remainder >= 1:
      frames_this_frame_remainder %= 1
      frames_this_frame += 1


def draw_intro_sequence():
  if not My_cached_info.PlayingForestTheme:
    pygame.mixer.music.load(My_cached_info.ForestThemePath)
    pygame.mixer.music.play(-1)
    My_cached_info.PlayingForestTheme = True
    My_cached_info.PlayingSewerTheme = False
  My_cached_info.frame_in_intro += 1
  My_cached_info.milliseconds_in_intro_stage += delta_milliseconds
  if Currently_pressed_controls.pressed_controls['PAUSE']:
    My_cached_info.stage_in_intro = 17
    My_cached_info.milliseconds_in_intro_stage = 20000
  #
  make_opengl_rect(OpenGLTextures['Forest_BG1'][0][0], OpenGLTextures['Forest_BG1'][0][1], (0 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, -1473 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['Forest_BG1'][0][0][0], OpenGLTextures['Forest_BG1'][0][0][1]))
  make_opengl_rect(OpenGLTextures['Forest_BG1'][0][0], OpenGLTextures['Forest_BG1'][0][1], (2000 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, -1473 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['Forest_BG1'][0][0][0], OpenGLTextures['Forest_BG1'][0][0][1]))
  make_opengl_rect(OpenGLTextures['Forest_BG3'][0][0], OpenGLTextures['Forest_BG3'][0][1], (0 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 2651 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['Forest_BG3'][0][0][0], OpenGLTextures['Forest_BG3'][0][0][1]))
  make_opengl_rect(OpenGLTextures['Forest_BG3'][0][0], OpenGLTextures['Forest_BG3'][0][1], (2000 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 2651 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['Forest_BG3'][0][0][0], OpenGLTextures['Forest_BG3'][0][0][1]))
  make_opengl_rect(OpenGLTextures['Forest_BG4'][0][0], OpenGLTextures['Forest_BG4'][0][1], (0 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 2564 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['Forest_BG4'][0][0][0], OpenGLTextures['Forest_BG4'][0][0][1]))
  make_opengl_rect(OpenGLTextures['Forest_BG4'][0][0], OpenGLTextures['Forest_BG4'][0][1], (2000 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 2564 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['Forest_BG4'][0][0][0], OpenGLTextures['Forest_BG4'][0][0][1]))
  make_opengl_rect(OpenGLTextures['Forest_BG5'][0][0], OpenGLTextures['Forest_BG5'][0][1], (0 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 2383 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['Forest_BG5'][0][0][0], OpenGLTextures['Forest_BG5'][0][0][1]))
  make_opengl_rect(OpenGLTextures['Forest_BG5'][0][0], OpenGLTextures['Forest_BG5'][0][1], (2000 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 2383 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['Forest_BG5'][0][0][0], OpenGLTextures['Forest_BG5'][0][0][1]))
  make_opengl_rect(OpenGLTextures['Forest_BG6'][0][0], OpenGLTextures['Forest_BG6'][0][1], (0 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 2116 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['Forest_BG6'][0][0][0], OpenGLTextures['Forest_BG6'][0][0][1]))
  make_opengl_rect(OpenGLTextures['Forest_BG6'][0][0], OpenGLTextures['Forest_BG6'][0][1], (2000 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 2116 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['Forest_BG6'][0][0][0], OpenGLTextures['Forest_BG6'][0][0][1]))
  make_opengl_rect(OpenGLTextures['Forest_BG7'][0][0], OpenGLTextures['Forest_BG7'][0][1], (0 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1780 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['Forest_BG7'][0][0][0], OpenGLTextures['Forest_BG7'][0][0][1]))
  make_opengl_rect(OpenGLTextures['Forest_BG7'][0][0], OpenGLTextures['Forest_BG7'][0][1], (2000 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1780 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['Forest_BG7'][0][0][0], OpenGLTextures['Forest_BG7'][0][0][1]))
  make_opengl_rect(OpenGLTextures['Forest_BG12'][0][0], OpenGLTextures['Forest_BG12'][0][1], (0 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1246 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['Forest_BG12'][0][0][0], OpenGLTextures['Forest_BG12'][0][0][1]))
  make_opengl_rect(OpenGLTextures['Forest_BG12'][0][0], OpenGLTextures['Forest_BG12'][0][1], (2000 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1246 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['Forest_BG12'][0][0][0], OpenGLTextures['Forest_BG12'][0][0][1]))
  #
  if My_cached_info.stage_in_intro == 0: # talking out loud
    if 0 <= My_cached_info.milliseconds_in_intro_stage < 50:
      pygame.mixer.stop()
    hamster_x_pos, hamster_y_pos = 2604 + ((1 / 2) * screen_width), 926 + ((1 / 2) * screen_height)
    draw_map_prettymap_background()
    make_opengl_rect(OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif, hamster_y_pos + current_blit_change_y - PLAYER.y_dif), 45, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['HAMSTER_STANDING_RIGHT'][0], OpenGLTextures['HAMSTER_STANDING_RIGHT'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif, hamster_y_pos + current_blit_change_y - PLAYER.y_dif), 0, True, (0, 0, PLAYER.rect[2], PLAYER.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif, hamster_y_pos + current_blit_change_y - PLAYER.y_dif), 45, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (1957 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 939 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
    human_talking_index = round((My_cached_info.milliseconds_in_intro_stage % 500) // 250)
    make_opengl_rect(OpenGLTextures['HUMAN_TALKING'][human_talking_index][0], OpenGLTextures['HUMAN_TALKING'][human_talking_index][1], (My_cached_info.intro_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, My_cached_info.intro_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HUMAN_TALKING'][human_talking_index][0][0], OpenGLTextures['HUMAN_TALKING'][human_talking_index][0][1]))
    dialogue_offset_x, dialogue_offset_y = 45, 6
    if 500 <= My_cached_info.milliseconds_in_intro_stage <= 3000:
      make_opengl_rect(OpenGLTextures['IThinkIveCompletedTheMachine'][0], OpenGLTextures['IThinkIveCompletedTheMachine'][1], (My_cached_info.intro_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif + dialogue_offset_x, My_cached_info.intro_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif + dialogue_offset_y), 0, False, (0, 0, OpenGLTextures['IThinkIveCompletedTheMachine'][0][0], OpenGLTextures['IThinkIveCompletedTheMachine'][0][1]))
    if 3200 <= My_cached_info.milliseconds_in_intro_stage <= 5700:
      make_opengl_rect(OpenGLTextures['IShouldBeAbleToCommunicateWithYou'][0], OpenGLTextures['IShouldBeAbleToCommunicateWithYou'][1], (My_cached_info.intro_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif + dialogue_offset_x, My_cached_info.intro_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif + dialogue_offset_y), 0, False, (0, 0, OpenGLTextures['IShouldBeAbleToCommunicateWithYou'][0][0], OpenGLTextures['IShouldBeAbleToCommunicateWithYou'][0][1]))
    if 5900 <= My_cached_info.milliseconds_in_intro_stage <= 8400:
      make_opengl_rect(OpenGLTextures['OnceWereBothInside'][0], OpenGLTextures['OnceWereBothInside'][1], (My_cached_info.intro_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif + dialogue_offset_x, My_cached_info.intro_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif + dialogue_offset_y), 0, False, (0, 0, OpenGLTextures['OnceWereBothInside'][0][0], OpenGLTextures['OnceWereBothInside'][0][1]))
    if My_cached_info.milliseconds_in_intro_stage >= 8700:
      My_cached_info.stage_in_intro = 1
      My_cached_info.milliseconds_in_intro_stage = 0
    return
  #
  if My_cached_info.stage_in_intro == 1: # move left
    hamster_x_pos, hamster_y_pos = 2604 + ((1 / 2) * screen_width), 926 + ((1 / 2) * screen_height)
    draw_map_prettymap_background()
    make_opengl_rect(OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif, hamster_y_pos + current_blit_change_y - PLAYER.y_dif), 45, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['HAMSTER_STANDING_RIGHT'][0], OpenGLTextures['HAMSTER_STANDING_RIGHT'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif, hamster_y_pos + current_blit_change_y - PLAYER.y_dif), 0, True, (0, 0, PLAYER.rect[2], PLAYER.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif, hamster_y_pos + current_blit_change_y - PLAYER.y_dif), 45, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (1957 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 939 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
    human_walking_index = round((My_cached_info.milliseconds_in_intro_stage % 900) // 150)
    if human_walking_index != 1 and human_walking_index != 4:
      My_cached_info.can_play_human_walking_sound_during_intro = True
    if My_cached_info.can_play_human_walking_sound_during_intro:
      if human_walking_index == 1 or human_walking_index == 4:
        MixerSounds['HUMAN_STEP2'].stop()
        MixerSounds['HUMAN_STEP2'].set_volume((My_cached_info.current_sound_loudness * MixerSoundsLoudness['HUMAN_STEP2']) / 2)
        MixerSounds['HUMAN_STEP2'].play()
        My_cached_info.can_play_human_walking_sound_during_intro = False
    make_opengl_rect(OpenGLTextures['HUMAN_WALKING'][human_walking_index][0], OpenGLTextures['HUMAN_WALKING'][human_walking_index][1], (My_cached_info.intro_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, My_cached_info.intro_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, True, (0, 0, OpenGLTextures['HUMAN_WALKING'][human_walking_index][0][0], OpenGLTextures['HUMAN_WALKING'][human_walking_index][0][1]))
    percent_of_the_way_through_stage = My_cached_info.milliseconds_in_intro_stage / 756
    start_x = 2347 + (114 / 2)
    start_y = 769 + (250 / 2)
    goal_x = 2294 + (114 / 2)
    goal_y = 745 + (250 / 2)
    angle_to_move = 90 + 65.63754698468782
    total_distance_to_move = 58.180752831155424
    My_cached_info.intro_x = start_x + (total_distance_to_move * percent_of_the_way_through_stage * math.cos(math.radians(angle_to_move)))
    My_cached_info.intro_y = start_y + (total_distance_to_move * percent_of_the_way_through_stage * -math.sin(math.radians(angle_to_move)))
    if 756 <= My_cached_info.milliseconds_in_intro_stage:
      My_cached_info.stage_in_intro = 2
      My_cached_info.milliseconds_in_intro_stage = 0
      My_cached_info.intro_x = goal_x
      My_cached_info.intro_y = goal_y
      My_cached_info.can_play_human_walking_sound_during_intro = True
    return
  #
  if My_cached_info.stage_in_intro == 2: # standing in machine, machine door closes
    hamster_x_pos, hamster_y_pos = 2604 + ((1 / 2) * screen_width), 926 + ((1 / 2) * screen_height)
    draw_map_prettymap_background()
    machine_door_index = 5
    if My_cached_info.milliseconds_in_intro_stage >= 800:
      adjusted_time = My_cached_info.milliseconds_in_intro_stage - 800
      machine_door_index = 5 - round(adjusted_time // 200)
      if machine_door_index < 0:
        machine_door_index = 0
    make_opengl_rect(OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][1]))
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (1957 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 939 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
    shady_image_index = machine_door_index
    if shady_image_index != 5:
      shady_image = ((OpenGLTextures['SHADY_PIXELS'][shady_image_index][0][0] * screen_width, OpenGLTextures['SHADY_PIXELS'][shady_image_index][0][1] * screen_height), OpenGLTextures['SHADY_PIXELS'][shady_image_index][1])
      make_opengl_rect(shady_image[0], shady_image[1], (0, 0), 0, False, (0, 0, shady_image[0][0], shady_image[0][1]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif, hamster_y_pos + current_blit_change_y - PLAYER.y_dif), 45, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['HAMSTER_STANDING_RIGHT'][0], OpenGLTextures['HAMSTER_STANDING_RIGHT'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif, hamster_y_pos + current_blit_change_y - PLAYER.y_dif), 0, True, (0, 0, PLAYER.rect[2], PLAYER.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif, hamster_y_pos + current_blit_change_y - PLAYER.y_dif), 45, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect(OpenGLTextures['HUMAN_STANDING'][0][0], OpenGLTextures['HUMAN_STANDING'][0][1], (My_cached_info.intro_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, My_cached_info.intro_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HUMAN_STANDING'][0][0][0], OpenGLTextures['HUMAN_STANDING'][0][0][1]))
    make_opengl_rect(OpenGLTextures['THE_MACHINE_CLOSING'][machine_door_index][0], OpenGLTextures['THE_MACHINE_CLOSING'][machine_door_index][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_CLOSING'][machine_door_index][0][0], OpenGLTextures['THE_MACHINE_CLOSING'][machine_door_index][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    if My_cached_info.milliseconds_in_intro_stage >= 1500:
      if My_cached_info.play_intro_machine_sound:
        My_cached_info.play_intro_machine_sound = False
        MixerSounds['THE_MACHINE1'].play(loops = -1, fade_ms = 300)
        MixerSounds['THE_MACHINE2'].play(loops = -1, fade_ms = 300)
        MixerSounds['THE_MACHINE3'].play(loops = -1, fade_ms = 300)
    if My_cached_info.milliseconds_in_intro_stage >= 1800:
      My_cached_info.stage_in_intro = 3
      My_cached_info.milliseconds_in_intro_stage = 0
    return
  #
  if My_cached_info.stage_in_intro == 3: # transfer starting
    hamster_x_pos, hamster_y_pos = 2604 + ((1 / 2) * screen_width), 926 + ((1 / 2) * screen_height)
    shady_image_index = 0
    shady_image = ((OpenGLTextures['SHADY_PIXELS'][shady_image_index][0][0] * screen_width, OpenGLTextures['SHADY_PIXELS'][shady_image_index][0][1] * screen_height), OpenGLTextures['SHADY_PIXELS'][shady_image_index][1])
    make_opengl_rect(shady_image[0], shady_image[1], (0, 0), 0, False, (0, 0, shady_image[0][0], shady_image[0][1]))
    make_opengl_rect(OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif, hamster_y_pos + current_blit_change_y - PLAYER.y_dif), 45, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['HAMSTER_STANDING_RIGHT'][0], OpenGLTextures['HAMSTER_STANDING_RIGHT'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif, hamster_y_pos + current_blit_change_y - PLAYER.y_dif), 0, True, (0, 0, PLAYER.rect[2], PLAYER.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif, hamster_y_pos + current_blit_change_y - PLAYER.y_dif), 45, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect(OpenGLTextures['HUMAN_STANDING'][0][0], OpenGLTextures['HUMAN_STANDING'][0][1], (My_cached_info.intro_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, My_cached_info.intro_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HUMAN_STANDING'][0][0][0], OpenGLTextures['HUMAN_STANDING'][0][0][1]))
    make_opengl_rect(OpenGLTextures['THE_MACHINE_CLOSING'][0][0], OpenGLTextures['THE_MACHINE_CLOSING'][0][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_CLOSING'][0][0][0], OpenGLTextures['THE_MACHINE_CLOSING'][0][0][1]))
    if My_cached_info.milliseconds_in_intro_stage > 2300:
      make_opengl_rect(OpenGLTextures['JUST_THE_DAMAGE'][0], OpenGLTextures['JUST_THE_DAMAGE'][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['JUST_THE_DAMAGE'][0][0], OpenGLTextures['JUST_THE_DAMAGE'][0][1]))
    smoke_rotation_added1 = 15 * math.cos(math.radians((My_cached_info.milliseconds_in_intro_stage / 5) % 360))
    smoke_rotation_added2 = 15 * math.cos(math.radians(((My_cached_info.milliseconds_in_intro_stage + 700) / 5) % 360))
    smoke_rotation_added3 = 15 * math.cos(math.radians(((My_cached_info.milliseconds_in_intro_stage + 1000) / 5) % 360))
    smoke_rotation_added4 = 15 * math.cos(math.radians(((My_cached_info.milliseconds_in_intro_stage + 1600) / 5) % 360))
    if 1000 <= My_cached_info.milliseconds_in_intro_stage <= 2200:
      smoke_growth_index = (My_cached_info.milliseconds_in_intro_stage - 1000) // 200
      if smoke_growth_index > 5:
        smoke_growth_index = 5
      make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_growth_index][0], OpenGLTextures['SMOKE'][smoke_growth_index][1], (2430 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 656 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke_rotation_added1, False, (0, 0, OpenGLTextures['SMOKE'][smoke_growth_index][0][0], OpenGLTextures['SMOKE'][smoke_growth_index][0][1]))
      make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_growth_index][0], OpenGLTextures['SMOKE'][smoke_growth_index][1], (2584 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 716 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke_rotation_added2, False, (0, 0, OpenGLTextures['SMOKE'][smoke_growth_index][0][0], OpenGLTextures['SMOKE'][smoke_growth_index][0][1]))
      make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_growth_index][0], OpenGLTextures['SMOKE'][smoke_growth_index][1], (2627 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 725 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke_rotation_added3, False, (0, 0, OpenGLTextures['SMOKE'][smoke_growth_index][0][0], OpenGLTextures['SMOKE'][smoke_growth_index][0][1]))
      big_smoke = ((OpenGLTextures['SMOKE'][smoke_growth_index][0][0] * 1.1, OpenGLTextures['SMOKE'][smoke_growth_index][0][1] * 1.1), OpenGLTextures['SMOKE'][smoke_growth_index][1])
      make_opengl_rect_center_on_circle(big_smoke[0], big_smoke[1], (2458 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 930 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke_rotation_added4, False, (0, 0, big_smoke[0][0], big_smoke[0][1]))
    if 2200 < My_cached_info.milliseconds_in_intro_stage < 8000:
      smoke_growth_index = 5
      make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_growth_index][0], OpenGLTextures['SMOKE'][smoke_growth_index][1], (2430 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 656 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke_rotation_added1, False, (0, 0, OpenGLTextures['SMOKE'][smoke_growth_index][0][0], OpenGLTextures['SMOKE'][smoke_growth_index][0][1]))
      make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_growth_index][0], OpenGLTextures['SMOKE'][smoke_growth_index][1], (2584 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 716 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke_rotation_added2, False, (0, 0, OpenGLTextures['SMOKE'][smoke_growth_index][0][0], OpenGLTextures['SMOKE'][smoke_growth_index][0][1]))
      make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_growth_index][0], OpenGLTextures['SMOKE'][smoke_growth_index][1], (2627 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 725 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke_rotation_added3, False, (0, 0, OpenGLTextures['SMOKE'][smoke_growth_index][0][0], OpenGLTextures['SMOKE'][smoke_growth_index][0][1]))
      big_smoke = ((OpenGLTextures['SMOKE'][smoke_growth_index][0][0] * 1.1, OpenGLTextures['SMOKE'][smoke_growth_index][0][1] * 1.1), OpenGLTextures['SMOKE'][smoke_growth_index][1])
      make_opengl_rect_center_on_circle(big_smoke[0], big_smoke[1], (2458 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 930 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke_rotation_added4, False, (0, 0, big_smoke[0][0], big_smoke[0][1]))
    if 8000 < My_cached_info.milliseconds_in_intro_stage <= 9200:
      smoke_growth_index = (1200 - (My_cached_info.milliseconds_in_intro_stage - 8000)) // 200
      if smoke_growth_index > 5:
        smoke_growth_index = 5
      if smoke_growth_index < 0:
        smoke_growth_index = 0
      make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_growth_index][0], OpenGLTextures['SMOKE'][smoke_growth_index][1], (2430 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 656 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke_rotation_added1, False, (0, 0, OpenGLTextures['SMOKE'][smoke_growth_index][0][0], OpenGLTextures['SMOKE'][smoke_growth_index][0][1]))
      make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_growth_index][0], OpenGLTextures['SMOKE'][smoke_growth_index][1], (2584 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 716 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke_rotation_added2, False, (0, 0, OpenGLTextures['SMOKE'][smoke_growth_index][0][0], OpenGLTextures['SMOKE'][smoke_growth_index][0][1]))
      make_opengl_rect_center_on_circle(OpenGLTextures['SMOKE'][smoke_growth_index][0], OpenGLTextures['SMOKE'][smoke_growth_index][1], (2627 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 725 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke_rotation_added3, False, (0, 0, OpenGLTextures['SMOKE'][smoke_growth_index][0][0], OpenGLTextures['SMOKE'][smoke_growth_index][0][1]))
      big_smoke = ((OpenGLTextures['SMOKE'][smoke_growth_index][0][0] * 1.1, OpenGLTextures['SMOKE'][smoke_growth_index][0][1] * 1.1), OpenGLTextures['SMOKE'][smoke_growth_index][1])
      make_opengl_rect_center_on_circle(big_smoke[0], big_smoke[1], (2458 + ((1/2)*screen_width) + current_blit_change_x - PLAYER.x_dif, 930 + ((1/2)*screen_height) + current_blit_change_y - PLAYER.y_dif), smoke_rotation_added4, False, (0, 0, big_smoke[0][0], big_smoke[0][1]))
    dialogue_x, dialogue_y = 2347 + ((1 / 2) * screen_width), 862 + ((1 / 2) * screen_height)
    if 1000 <= My_cached_info.milliseconds_in_intro_stage <= 3500:
      make_opengl_rect(OpenGLTextures['IThinkItsWorking'][0], OpenGLTextures['IThinkItsWorking'][1], (dialogue_x + current_blit_change_x - PLAYER.x_dif, dialogue_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['IThinkItsWorking'][0][0], OpenGLTextures['IThinkItsWorking'][0][1]))
    if 4500 <= My_cached_info.milliseconds_in_intro_stage <= 7000:
      make_opengl_rect(OpenGLTextures['WowYouReallyLikeHamsterOs'][0], OpenGLTextures['WowYouReallyLikeHamsterOs'][1], (dialogue_x + current_blit_change_x - PLAYER.x_dif, dialogue_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['WowYouReallyLikeHamsterOs'][0][0], OpenGLTextures['WowYouReallyLikeHamsterOs'][0][1]))
    if 8000 <= My_cached_info.milliseconds_in_intro_stage <= 10500:
      make_opengl_rect(OpenGLTextures['WaitIDontRememberBeingThisShort'][0], OpenGLTextures['WaitIDontRememberBeingThisShort'][1], (dialogue_x + current_blit_change_x - PLAYER.x_dif, dialogue_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['WaitIDontRememberBeingThisShort'][0][0], OpenGLTextures['WaitIDontRememberBeingThisShort'][0][1]))
    if 10700 <= My_cached_info.milliseconds_in_intro_stage:
      My_cached_info.stage_in_intro = 4
      My_cached_info.milliseconds_in_intro_stage = 0
    return
  #
  if My_cached_info.stage_in_intro == 4: # doors open
    if not My_cached_info.play_intro_machine_sound:
      My_cached_info.play_intro_machine_sound = True
      MixerSounds['THE_MACHINE1'].fadeout(600)
      MixerSounds['THE_MACHINE2'].fadeout(600)
      MixerSounds['THE_MACHINE3'].fadeout(600)
    hamster_x_pos, hamster_y_pos = 2604 + ((1 / 2) * screen_width), 926 + ((1 / 2) * screen_height)
    percentage_of_the_way_through_this_stage = My_cached_info.milliseconds_in_intro_stage / 1000
    start_x = 2294 + (114 / 2)
    start_y = 745 + (250 / 2)
    goal_x = hamster_x_pos - ((1 / 2) * screen_width) + 34
    goal_y = hamster_y_pos - ((1 / 2) * screen_height) + 34
    total_distance_to_travel = math.sqrt(((goal_x - start_x)**2) +((goal_y - start_y)**2))
    angle_to_travel = math.degrees(math.atan2((goal_y - start_y), (goal_x - start_x)))
    My_cached_info.intro_x = start_x + (percentage_of_the_way_through_this_stage * total_distance_to_travel * math.cos(math.radians(angle_to_travel)))
    My_cached_info.intro_y = start_y + (percentage_of_the_way_through_this_stage * total_distance_to_travel * math.sin(math.radians(angle_to_travel)))
    offset_images_x = My_cached_info.early_last_intro_x - My_cached_info.intro_x
    offset_images_y = My_cached_info.early_last_intro_y - My_cached_info.intro_y
    My_cached_info.early_last_intro_x = My_cached_info.intro_x
    My_cached_info.early_last_intro_y = My_cached_info.intro_y
    draw_map_prettymap_background()
    machine_door_index = 0
    adjusted_time = My_cached_info.milliseconds_in_intro_stage
    machine_door_index = round(adjusted_time // 200)
    if machine_door_index < 0:
      machine_door_index = 0
    if machine_door_index > 5:
      machine_door_index = 5
    make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (1957 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + offset_images_x, 939 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + offset_images_y), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + offset_images_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + offset_images_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + offset_images_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + offset_images_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    shady_image_index = machine_door_index
    if shady_image_index != 5:
      shady_image = ((OpenGLTextures['SHADY_PIXELS'][shady_image_index][0][0] * screen_width, OpenGLTextures['SHADY_PIXELS'][shady_image_index][0][1] * screen_height), OpenGLTextures['SHADY_PIXELS'][shady_image_index][1])
      make_opengl_rect(shady_image[0], shady_image[1], (0, 0), 0, False, (0, 0, shady_image[0][0], shady_image[0][1]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif + offset_images_x, hamster_y_pos + current_blit_change_y - PLAYER.y_dif + offset_images_y), 45, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['HAMSTER_STANDING_RIGHT'][0], OpenGLTextures['HAMSTER_STANDING_RIGHT'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif + offset_images_x, hamster_y_pos + current_blit_change_y - PLAYER.y_dif + offset_images_y), 0, True, (0, 0, PLAYER.rect[2], PLAYER.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif + offset_images_x, hamster_y_pos + current_blit_change_y - PLAYER.y_dif + offset_images_y), 45, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect(OpenGLTextures['HUMAN_STANDING'][0][0], OpenGLTextures['HUMAN_STANDING'][0][1], (start_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, start_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HUMAN_STANDING'][0][0][0], OpenGLTextures['HUMAN_STANDING'][0][0][1]))
    make_opengl_rect(OpenGLTextures['THE_MACHINE_CLOSING'][machine_door_index][0], OpenGLTextures['THE_MACHINE_CLOSING'][machine_door_index][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif + offset_images_x, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif + offset_images_y), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_CLOSING'][machine_door_index][0][0], OpenGLTextures['THE_MACHINE_CLOSING'][machine_door_index][0][1]))
    make_opengl_rect(OpenGLTextures['JUST_THE_DAMAGE'][0], OpenGLTextures['JUST_THE_DAMAGE'][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif + offset_images_x, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif + offset_images_y), 0, False, (0, 0, OpenGLTextures['JUST_THE_DAMAGE'][0][0], OpenGLTextures['JUST_THE_DAMAGE'][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif + offset_images_x, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif + offset_images_y), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif + offset_images_x, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif + offset_images_y), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    if 1000 <= My_cached_info.milliseconds_in_intro_stage:
      My_cached_info.stage_in_intro = 5
      My_cached_info.milliseconds_in_intro_stage = 0
      My_cached_info.intro_x = goal_x
      My_cached_info.intro_y = goal_y
      My_cached_info.first_frame_in_intro_step = True
  #
  if (My_cached_info.stage_in_intro == 5) and not My_cached_info.first_frame_in_intro_step: # human realizes they are hamster
    hamster_x_pos, hamster_y_pos = My_cached_info.intro_x + ((1 / 2) * screen_width) - 34, My_cached_info.intro_y + ((1 / 2) * screen_height) - 34
    human_x, human_y = 2294 + (114 / 2), 745 + (250 / 2)
    show_walk = False
    if (6000 - 2373 - 756) <= My_cached_info.milliseconds_in_intro_stage <= (6000 - 2373):
      show_walk = True
      percent_of_the_way_through_this_step = (My_cached_info.milliseconds_in_intro_stage - (6000 - 2373 - 756)) / 756
      human_start_x = 2294 + (114 / 2)
      human_start_y = 745 + (250 / 2)
      goal_x = 2347 + (114 / 2)
      goal_y = 769 + (250 / 2)
      angle_to_move = ((90 + 65.63754698468782) + 180) % 360
      total_distance_to_move = 58.180752831155424
      human_x = human_start_x + (total_distance_to_move * percent_of_the_way_through_this_step * math.cos(math.radians(angle_to_move)))
      human_y = human_start_y + (total_distance_to_move * percent_of_the_way_through_this_step * -math.sin(math.radians(angle_to_move)))
    if (6000 - 2373) < My_cached_info.milliseconds_in_intro_stage <= 6000:
      show_walk = True
      percent_of_the_way_through_stage = (My_cached_info.milliseconds_in_intro_stage - (6000 - 2373)) / 2373
      human_start_x = 2347 + (114 / 2)
      goal_x = 2566 + (114 / 2)
      human_x = human_start_x + (219 * percent_of_the_way_through_stage)
      human_y = 769 + (250 / 2)
    draw_map_prettymap_background()
    make_opengl_rect(OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][1]))
    make_opengl_rect(OpenGLTextures['JUST_THE_DAMAGE'][0], OpenGLTextures['JUST_THE_DAMAGE'][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['JUST_THE_DAMAGE'][0][0], OpenGLTextures['JUST_THE_DAMAGE'][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif, hamster_y_pos + current_blit_change_y - PLAYER.y_dif), 45, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['HAMSTER_STANDING_RIGHT'][0], OpenGLTextures['HAMSTER_STANDING_RIGHT'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif, hamster_y_pos + current_blit_change_y - PLAYER.y_dif), 0, True, (0, 0, PLAYER.rect[2], PLAYER.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif, hamster_y_pos + current_blit_change_y - PLAYER.y_dif), 45, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (1957 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 939 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
    if not show_walk:
      make_opengl_rect(OpenGLTextures['HUMAN_STANDING'][0][0], OpenGLTextures['HUMAN_STANDING'][0][1], (human_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, human_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HUMAN_STANDING'][0][0][0], OpenGLTextures['HUMAN_STANDING'][0][0][1]))
    if show_walk:
      human_walking_index = round((My_cached_info.milliseconds_in_intro_stage % 900) // 150)
      if human_walking_index != 1 and human_walking_index != 4:
        My_cached_info.can_play_human_walking_sound_during_intro = True
      if My_cached_info.can_play_human_walking_sound_during_intro:
        if human_walking_index == 1 or human_walking_index == 4:
          MixerSounds['HUMAN_STEP2'].stop()
          MixerSounds['HUMAN_STEP2'].set_volume((My_cached_info.current_sound_loudness * MixerSoundsLoudness['HUMAN_STEP2']) / 2)
          MixerSounds['HUMAN_STEP2'].play()
          My_cached_info.can_play_human_walking_sound_during_intro = False
      make_opengl_rect(OpenGLTextures['HUMAN_WALKING'][human_walking_index][0], OpenGLTextures['HUMAN_WALKING'][human_walking_index][1], (human_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, human_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HUMAN_WALKING'][human_walking_index][0][0], OpenGLTextures['HUMAN_WALKING'][human_walking_index][0][1]))
    dialogue_offset_x, dialogue_offset_y = -250, -17
    if 500 <= My_cached_info.milliseconds_in_intro_stage <= 3000:
      make_opengl_rect(OpenGLTextures['OhNo'][0], OpenGLTextures['OhNo'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif + dialogue_offset_x, hamster_y_pos + current_blit_change_y - PLAYER.y_dif + dialogue_offset_y), 0, False, (0, 0, OpenGLTextures['OhNo'][0][0], OpenGLTextures['OhNo'][0][1]))
    if 3300 < My_cached_info.milliseconds_in_intro_stage <= 5800:
      make_opengl_rect(OpenGLTextures['IveTransformedIntoAHamster'][0], OpenGLTextures['IveTransformedIntoAHamster'][1], (hamster_x_pos + current_blit_change_x - PLAYER.x_dif + dialogue_offset_x, hamster_y_pos + current_blit_change_y - PLAYER.y_dif + dialogue_offset_y), 0, False, (0, 0, OpenGLTextures['IveTransformedIntoAHamster'][0][0], OpenGLTextures['IveTransformedIntoAHamster'][0][1]))
    if My_cached_info.milliseconds_in_intro_stage >= 6000:
      My_cached_info.stage_in_intro = 6
      My_cached_info.milliseconds_in_intro_stage = 0
  #
  if My_cached_info.stage_in_intro == 6: # shaking the hamster
    hamster_x_pos, hamster_y_pos = My_cached_info.intro_x + ((1 / 2) * screen_width) - 34, My_cached_info.intro_y + ((1 / 2) * screen_height) - 34
    human_x = 2566 + (114 / 2)
    human_y = 769 + (250 / 2)
    draw_map_prettymap_background()
    make_opengl_rect(OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][1]))
    make_opengl_rect(OpenGLTextures['JUST_THE_DAMAGE'][0], OpenGLTextures['JUST_THE_DAMAGE'][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['JUST_THE_DAMAGE'][0][0], OpenGLTextures['JUST_THE_DAMAGE'][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (1957 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 939 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
    adjusted_shake_time = My_cached_info.milliseconds_in_intro_stage % 720
    if 0 <= adjusted_shake_time < 180:
      human_shaking_index = 0
      adjust_hamster_y = 141
    if 180 <= adjusted_shake_time < 360:
      human_shaking_index = 1
      adjust_hamster_y = 124
    if 360 <= adjusted_shake_time < 540:
      human_shaking_index = 2
      adjust_hamster_y = 107
    if 540 <= adjusted_shake_time <= 720:
      human_shaking_index = 1
      adjust_hamster_y = 124
    make_opengl_rect(OpenGLTextures['HUMAN_SHAKING'][human_shaking_index][0], OpenGLTextures['HUMAN_SHAKING'][human_shaking_index][1], (human_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, human_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HUMAN_SHAKING'][human_shaking_index][0][0], OpenGLTextures['HUMAN_SHAKING'][human_shaking_index][0][1]))
    adjusted_hamster_time = My_cached_info.milliseconds_in_intro_stage % 1440
    if 0 <= adjusted_hamster_time < 360:
      hamster_shaking_index = 0
      hamster_flipped = False
    if 360 <= adjusted_hamster_time < 720:
      hamster_shaking_index = 4
      hamster_flipped = False
    if 720 <= adjusted_hamster_time < 1080:
      hamster_shaking_index = 4
      hamster_flipped = True
    if 1080 <= adjusted_hamster_time < 1440:
      hamster_shaking_index = 0
      hamster_flipped = True
    adjust_hamster_x = 28
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (human_x + adjust_hamster_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, human_y + adjust_hamster_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 45, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['HAMSTER_FLYING_RIGHT'][hamster_shaking_index][0], OpenGLTextures['HAMSTER_FLYING_RIGHT'][hamster_shaking_index][1], (human_x + adjust_hamster_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, human_y + adjust_hamster_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, hamster_flipped, (0, 0, OpenGLTextures['HAMSTER_FLYING_RIGHT'][hamster_shaking_index][0][0], OpenGLTextures['HAMSTER_FLYING_RIGHT'][hamster_shaking_index][0][1]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (human_x + adjust_hamster_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, human_y + adjust_hamster_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 45, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    if 200 <= My_cached_info.milliseconds_in_intro_stage <= 2500:
      make_opengl_rect(OpenGLTextures['Oww'][0], OpenGLTextures['Oww'][1], (50 + human_x + adjust_hamster_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, -28 + human_y + adjust_hamster_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['Oww'][0][0], OpenGLTextures['Oww'][0][1]))
    if 2800 <= My_cached_info.milliseconds_in_intro_stage <= 5300:
      make_opengl_rect(OpenGLTextures['ThisIsAwful'][0], OpenGLTextures['ThisIsAwful'][1], (50 + human_x + adjust_hamster_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, -28 + human_y + adjust_hamster_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['ThisIsAwful'][0][0], OpenGLTextures['ThisIsAwful'][0][1]))
    if My_cached_info.milliseconds_in_intro_stage >= 5500:
      # hamster_data (723.5, 348.0)
      My_cached_info.stage_in_intro = 7
      My_cached_info.milliseconds_in_intro_stage = 0
  #
  if My_cached_info.stage_in_intro == 7: # hamster ricochet, leg 1
    My_cached_info.intro_x = My_cached_info.intro_screen_centers[0][0]
    My_cached_info.intro_y = My_cached_info.intro_screen_centers[0][1]
    start_hamster_x = 2594 + ((1 / 2) * screen_width)
    start_hamster_y = 876 + ((1 / 2) * screen_height)
    end_hamster_x = 2704 + ((1 / 2) * screen_width)
    end_hamster_y = 816 + ((1 / 2) * screen_height)
    total_velocity = 400
    movement_angle = math.degrees(math.atan2(-(end_hamster_y - start_hamster_y), end_hamster_x - start_hamster_x))
    vel_x = total_velocity * math.cos(math.radians(movement_angle))
    vel_y = -total_velocity * math.sin(math.radians(movement_angle))
    delta_t = My_cached_info.milliseconds_in_intro_stage / 1000
    current_hamster_x = start_hamster_x + (vel_x * delta_t) + ((1 / 2) * 0 * delta_t**2)
    current_hamster_y = start_hamster_y + (vel_y * delta_t) + ((1 / 2) * 400 * delta_t**2)
    additional_rotation = 0
    human_x = 2566 + (114 / 2)
    human_y = 769 + (250 / 2)
    draw_map_prettymap_background()
    make_opengl_rect(OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][1]))
    make_opengl_rect(OpenGLTextures['JUST_THE_DAMAGE'][0], OpenGLTextures['JUST_THE_DAMAGE'][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['JUST_THE_DAMAGE'][0][0], OpenGLTextures['JUST_THE_DAMAGE'][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (1957 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 939 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
    make_opengl_rect(OpenGLTextures['HUMAN_STANDING'][0][0], OpenGLTextures['HUMAN_STANDING'][0][1], (human_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, human_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HUMAN_STANDING'][0][0][0], OpenGLTextures['HUMAN_STANDING'][0][0][1]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['HAMSTER_FLYING_RIGHT'][0][0], OpenGLTextures['HAMSTER_FLYING_RIGHT'][0][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 0 + additional_rotation, False, (0, 0, PLAYER.rect[2], PLAYER.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    My_cached_info.intro_ahhh_timer += delta_milliseconds
    adjusted_ahhh_timer = My_cached_info.intro_ahhh_timer % 700
    if 0 <= adjusted_ahhh_timer <= 400:
      make_opengl_rect(OpenGLTextures['Ahhh'][0], OpenGLTextures['Ahhh'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif + 65, current_hamster_y + current_blit_change_y - PLAYER.y_dif - 18), 0, False, (0, 0, OpenGLTextures['Ahhh'][0][0], OpenGLTextures['Ahhh'][0][1]))
    if 300 <= adjusted_ahhh_timer <= 700:
      make_opengl_rect(OpenGLTextures['AhhhReverse'][0], OpenGLTextures['AhhhReverse'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif - 102, current_hamster_y + current_blit_change_y - PLAYER.y_dif - 18), 0, False, (0, 0, OpenGLTextures['AhhhReverse'][0][0], OpenGLTextures['AhhhReverse'][0][1]))
    if My_cached_info.milliseconds_in_intro_stage >= 312:
      MixerSounds['LOUD_HIT'].play()
      My_cached_info.stage_in_intro = 8
      My_cached_info.milliseconds_in_intro_stage = 0
      My_cached_info.intro_hamster_rotation = 90
      My_cached_info.saved_hamster_x = 3471.5613674997153 - (1536 / 2) + ((1 / 2) * screen_width)
      My_cached_info.saved_hamster_y = 1267.7080540910645 - (864 / 2) + ((1 / 2) * screen_height)
  #
  if My_cached_info.stage_in_intro == 8: # hamster ricochet, leg 2
    start_hamster_x = My_cached_info.saved_hamster_x
    start_hamster_y = My_cached_info.saved_hamster_y
    end_hamster_x = 2440 + ((1 / 2) * screen_width)
    end_hamster_y = 951 + ((1 / 2) * screen_height)
    total_velocity = 400
    movement_angle = math.degrees(math.atan2(-(end_hamster_y - start_hamster_y), end_hamster_x - start_hamster_x))
    movement_angle -= 10
    vel_x = total_velocity * math.cos(math.radians(movement_angle))
    vel_y = -total_velocity * math.sin(math.radians(movement_angle))
    delta_t = My_cached_info.milliseconds_in_intro_stage / 1000
    current_hamster_x = start_hamster_x + (vel_x * delta_t) + ((1 / 2) * 0 * delta_t**2)
    current_hamster_y = start_hamster_y + (vel_y * delta_t) + ((1 / 2) * 400 * delta_t**2)
    additional_rotation = (2 * (2 * math.pi * 34 * delta_t)) + My_cached_info.intro_hamster_rotation
    human_x = 2566 + (114 / 2)
    human_y = 769 + (250 / 2)
    draw_map_prettymap_background()
    make_opengl_rect(OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][1]))
    make_opengl_rect(OpenGLTextures['JUST_THE_DAMAGE'][0], OpenGLTextures['JUST_THE_DAMAGE'][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['JUST_THE_DAMAGE'][0][0], OpenGLTextures['JUST_THE_DAMAGE'][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (1957 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 939 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
    make_opengl_rect(OpenGLTextures['HUMAN_STANDING'][0][0], OpenGLTextures['HUMAN_STANDING'][0][1], (human_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, human_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HUMAN_STANDING'][0][0][0], OpenGLTextures['HUMAN_STANDING'][0][0][1]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['ROLLING_COUNTERCLOCKWISE'][0][0], OpenGLTextures['ROLLING_COUNTERCLOCKWISE'][0][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 0 + additional_rotation, True, (0, 0, PLAYER.rect[2], PLAYER.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    My_cached_info.intro_ahhh_timer += delta_milliseconds
    adjusted_ahhh_timer = My_cached_info.intro_ahhh_timer % 700
    if 0 <= adjusted_ahhh_timer <= 400:
      make_opengl_rect(OpenGLTextures['Ahhh'][0], OpenGLTextures['Ahhh'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif + 65, current_hamster_y + current_blit_change_y - PLAYER.y_dif - 18), 0, False, (0, 0, OpenGLTextures['Ahhh'][0][0], OpenGLTextures['Ahhh'][0][1]))
    if 300 <= adjusted_ahhh_timer <= 700:
      make_opengl_rect(OpenGLTextures['AhhhReverse'][0], OpenGLTextures['AhhhReverse'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif - 102, current_hamster_y + current_blit_change_y - PLAYER.y_dif - 18), 0, False, (0, 0, OpenGLTextures['AhhhReverse'][0][0], OpenGLTextures['AhhhReverse'][0][1]))
    if My_cached_info.milliseconds_in_intro_stage >= 560:
      MixerSounds['MIDDLE_HIT'].play()
      My_cached_info.stage_in_intro = 9
      My_cached_info.milliseconds_in_intro_stage = 0
      My_cached_info.intro_hamster_rotation = additional_rotation
      My_cached_info.saved_hamster_x = 3253.8664239303175 - (1536 / 2) + ((1 / 2) * screen_width)
      My_cached_info.saved_hamster_y = 1383.2003152167422 - (864 / 2) + ((1 / 2) * screen_height)
      My_cached_info.last_intro_x = My_cached_info.intro_x
      My_cached_info.last_intro_y = My_cached_info.intro_y
      My_cached_info.first_frame_in_intro_step = True
  #
  if My_cached_info.stage_in_intro == 9: # hamster ricochet, leg 3
    percentage_through_screen_movement = (My_cached_info.milliseconds_in_intro_stage + 0) / My_cached_info.intro_screen_times[0]
    My_cached_info.intro_x = ((1 - percentage_through_screen_movement) * My_cached_info.intro_screen_centers[0][0]) + (percentage_through_screen_movement * My_cached_info.intro_screen_centers[1][0])
    My_cached_info.intro_y = ((1 - percentage_through_screen_movement) * My_cached_info.intro_screen_centers[0][1]) + (percentage_through_screen_movement * My_cached_info.intro_screen_centers[1][1])
    screen_movement_x = My_cached_info.last_intro_x - My_cached_info.intro_x
    screen_movement_y = My_cached_info.last_intro_y - My_cached_info.intro_y
    My_cached_info.last_intro_x = My_cached_info.intro_x
    My_cached_info.last_intro_y = My_cached_info.intro_y
    start_hamster_x = My_cached_info.saved_hamster_x
    start_hamster_y = My_cached_info.saved_hamster_y
    end_hamster_x = 2079 + ((1 / 2) * screen_width)
    end_hamster_y = 956 + ((1 / 2) * screen_height)
    total_velocity = 400
    movement_angle = math.degrees(math.atan2(-(end_hamster_y - start_hamster_y), end_hamster_x - start_hamster_x))
    movement_angle = 150
    vel_x = total_velocity * math.cos(math.radians(movement_angle))
    vel_y = -total_velocity * math.sin(math.radians(movement_angle))
    delta_t = My_cached_info.milliseconds_in_intro_stage / 1000
    current_hamster_x = start_hamster_x + (vel_x * delta_t) + ((1 / 2) * 0 * delta_t**2)
    current_hamster_y = start_hamster_y + (vel_y * delta_t) + ((1 / 2) * 400 * delta_t**2)
    additional_rotation = (2 * (2 * math.pi * 34 * delta_t)) + My_cached_info.intro_hamster_rotation
    human_x = 2566 + (114 / 2)
    human_y = 769 + (250 / 2)
    draw_map_prettymap_background()
    make_opengl_rect(OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][1]))
    make_opengl_rect(OpenGLTextures['JUST_THE_DAMAGE'][0], OpenGLTextures['JUST_THE_DAMAGE'][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['JUST_THE_DAMAGE'][0][0], OpenGLTextures['JUST_THE_DAMAGE'][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    if not My_cached_info.first_frame_in_intro_step:
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    if My_cached_info.first_frame_in_intro_step:
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (1957 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 939 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
    make_opengl_rect(OpenGLTextures['HUMAN_STANDING'][0][0], OpenGLTextures['HUMAN_STANDING'][0][1], (human_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, human_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HUMAN_STANDING'][0][0][0], OpenGLTextures['HUMAN_STANDING'][0][0][1]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['ROLLING_COUNTERCLOCKWISE'][0][0], OpenGLTextures['ROLLING_COUNTERCLOCKWISE'][0][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 0 + additional_rotation, True, (0, 0, PLAYER.rect[2], PLAYER.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    My_cached_info.intro_ahhh_timer += delta_milliseconds
    adjusted_ahhh_timer = My_cached_info.intro_ahhh_timer % 700
    if 0 <= adjusted_ahhh_timer <= 400:
      make_opengl_rect(OpenGLTextures['Ahhh'][0], OpenGLTextures['Ahhh'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif + 65, current_hamster_y + current_blit_change_y - PLAYER.y_dif - 18), 0, False, (0, 0, OpenGLTextures['Ahhh'][0][0], OpenGLTextures['Ahhh'][0][1]))
    if 300 <= adjusted_ahhh_timer <= 700:
      make_opengl_rect(OpenGLTextures['AhhhReverse'][0], OpenGLTextures['AhhhReverse'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif - 102, current_hamster_y + current_blit_change_y - PLAYER.y_dif - 18), 0, False, (0, 0, OpenGLTextures['AhhhReverse'][0][0], OpenGLTextures['AhhhReverse'][0][1]))
    My_cached_info.first_frame_in_intro_step = False
    if My_cached_info.milliseconds_in_intro_stage >= 1144:
      MixerSounds['LOUD_HIT'].play()
      My_cached_info.stage_in_intro = 10
      My_cached_info.milliseconds_in_intro_stage = 0
      My_cached_info.intro_hamster_rotation = additional_rotation
      My_cached_info.saved_hamster_x = 2857.5731991585585 - (1536 / 2) + ((1 / 2) * screen_width)
      My_cached_info.saved_hamster_y = 1416.1475152167422 - (864 / 2) + ((1 / 2) * screen_height)
      My_cached_info.first_frame_in_intro_step = True
  #
  if My_cached_info.stage_in_intro == 10: # hamster ricochet, leg 4
    percentage_through_screen_movement = (My_cached_info.milliseconds_in_intro_stage + 1144) / My_cached_info.intro_screen_times[0]
    My_cached_info.intro_x = ((1 - percentage_through_screen_movement) * My_cached_info.intro_screen_centers[0][0]) + (percentage_through_screen_movement * My_cached_info.intro_screen_centers[1][0])
    My_cached_info.intro_y = ((1 - percentage_through_screen_movement) * My_cached_info.intro_screen_centers[0][1]) + (percentage_through_screen_movement * My_cached_info.intro_screen_centers[1][1])
    screen_movement_x = My_cached_info.last_intro_x - My_cached_info.intro_x
    screen_movement_y = My_cached_info.last_intro_y - My_cached_info.intro_y
    My_cached_info.last_intro_x = My_cached_info.intro_x
    My_cached_info.last_intro_y = My_cached_info.intro_y
    start_hamster_x = My_cached_info.saved_hamster_x
    start_hamster_y = My_cached_info.saved_hamster_y
    end_hamster_x = 2155 + ((1 / 2) * screen_width)
    end_hamster_y = 1015 + ((1 / 2) * screen_height)
    total_velocity = 400
    movement_angle = math.degrees(math.atan2(-(end_hamster_y - start_hamster_y), end_hamster_x - start_hamster_x))
    movement_angle = 0
    vel_x = total_velocity * math.cos(math.radians(movement_angle))
    vel_y = -total_velocity * math.sin(math.radians(movement_angle))
    delta_t = My_cached_info.milliseconds_in_intro_stage / 1000
    current_hamster_x = start_hamster_x + (vel_x * delta_t) + ((1 / 2) * 0 * delta_t**2)
    current_hamster_y = start_hamster_y + (vel_y * delta_t) + ((1 / 2) * 400 * delta_t**2)
    additional_rotation = (2 * (2 * math.pi * 34 * delta_t)) + My_cached_info.intro_hamster_rotation
    human_x = 2566 + (114 / 2)
    human_y = 769 + (250 / 2)
    draw_map_prettymap_background()
    make_opengl_rect(OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][1]))
    make_opengl_rect(OpenGLTextures['JUST_THE_DAMAGE'][0], OpenGLTextures['JUST_THE_DAMAGE'][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['JUST_THE_DAMAGE'][0][0], OpenGLTextures['JUST_THE_DAMAGE'][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    if not My_cached_info.first_frame_in_intro_step:
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    if My_cached_info.first_frame_in_intro_step:
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (1957 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 939 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
    make_opengl_rect(OpenGLTextures['HUMAN_STANDING'][0][0], OpenGLTextures['HUMAN_STANDING'][0][1], (human_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, human_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HUMAN_STANDING'][0][0][0], OpenGLTextures['HUMAN_STANDING'][0][0][1]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['ROLLING_COUNTERCLOCKWISE'][0][0], OpenGLTextures['ROLLING_COUNTERCLOCKWISE'][0][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 0 + additional_rotation, True, (0, 0, PLAYER.rect[2], PLAYER.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    My_cached_info.intro_ahhh_timer += delta_milliseconds
    adjusted_ahhh_timer = My_cached_info.intro_ahhh_timer % 700
    if 0 <= adjusted_ahhh_timer <= 400:
      make_opengl_rect(OpenGLTextures['Ahhh'][0], OpenGLTextures['Ahhh'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif + 65, current_hamster_y + current_blit_change_y - PLAYER.y_dif - 18), 0, False, (0, 0, OpenGLTextures['Ahhh'][0][0], OpenGLTextures['Ahhh'][0][1]))
    if 300 <= adjusted_ahhh_timer <= 700:
      make_opengl_rect(OpenGLTextures['AhhhReverse'][0], OpenGLTextures['AhhhReverse'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif - 102, current_hamster_y + current_blit_change_y - PLAYER.y_dif - 18), 0, False, (0, 0, OpenGLTextures['AhhhReverse'][0][0], OpenGLTextures['AhhhReverse'][0][1]))
    My_cached_info.first_frame_in_intro_step = False
    if My_cached_info.milliseconds_in_intro_stage >= 169:
      MixerSounds['MIDDLE_HIT'].play()
      My_cached_info.stage_in_intro = 11
      My_cached_info.milliseconds_in_intro_stage = 0
      My_cached_info.intro_hamster_rotation = additional_rotation
      My_cached_info.saved_hamster_x = 2925.1731991585584 - (1536 / 2) + ((1 / 2) * screen_width)
      My_cached_info.saved_hamster_y = 1421.8597152167422 - (864 / 2) + ((1 / 2) * screen_height)
      My_cached_info.first_frame_in_intro_step = True
  #
  if My_cached_info.stage_in_intro == 11: # hamster ricochet, leg 5
    percentage_through_screen_movement = (My_cached_info.milliseconds_in_intro_stage + 1144 + 169) / My_cached_info.intro_screen_times[0]
    My_cached_info.intro_x = ((1 - percentage_through_screen_movement) * My_cached_info.intro_screen_centers[0][0]) + (percentage_through_screen_movement * My_cached_info.intro_screen_centers[1][0])
    My_cached_info.intro_y = ((1 - percentage_through_screen_movement) * My_cached_info.intro_screen_centers[0][1]) + (percentage_through_screen_movement * My_cached_info.intro_screen_centers[1][1])
    screen_movement_x = My_cached_info.last_intro_x - My_cached_info.intro_x
    screen_movement_y = My_cached_info.last_intro_y - My_cached_info.intro_y
    My_cached_info.last_intro_x = My_cached_info.intro_x
    My_cached_info.last_intro_y = My_cached_info.intro_y
    start_hamster_x = My_cached_info.saved_hamster_x
    start_hamster_y = My_cached_info.saved_hamster_y
    end_hamster_x = 2044 + ((1 / 2) * screen_width)
    end_hamster_y = 1086 + ((1 / 2) * screen_height)
    total_velocity = 400
    movement_angle = math.degrees(math.atan2(-(end_hamster_y - start_hamster_y), end_hamster_x - start_hamster_x))
    movement_angle = 220
    vel_x = total_velocity * math.cos(math.radians(movement_angle))
    vel_y = -total_velocity * math.sin(math.radians(movement_angle))
    delta_t = My_cached_info.milliseconds_in_intro_stage / 1000
    current_hamster_x = start_hamster_x + (vel_x * delta_t) + ((1 / 2) * 0 * delta_t**2)
    current_hamster_y = start_hamster_y + (vel_y * delta_t) + ((1 / 2) * 400 * delta_t**2)
    additional_rotation = (2 * (2 * math.pi * 34 * delta_t)) + My_cached_info.intro_hamster_rotation
    human_x = 2566 + (114 / 2)
    human_y = 769 + (250 / 2)
    draw_map_prettymap_background()
    make_opengl_rect(OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][1]))
    make_opengl_rect(OpenGLTextures['JUST_THE_DAMAGE'][0], OpenGLTextures['JUST_THE_DAMAGE'][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['JUST_THE_DAMAGE'][0][0], OpenGLTextures['JUST_THE_DAMAGE'][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    if not My_cached_info.first_frame_in_intro_step:
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    if My_cached_info.first_frame_in_intro_step:
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (1957 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 939 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
    make_opengl_rect(OpenGLTextures['HUMAN_STANDING'][0][0], OpenGLTextures['HUMAN_STANDING'][0][1], (human_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, human_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HUMAN_STANDING'][0][0][0], OpenGLTextures['HUMAN_STANDING'][0][0][1]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['ROLLING_COUNTERCLOCKWISE'][0][0], OpenGLTextures['ROLLING_COUNTERCLOCKWISE'][0][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 0 + additional_rotation, True, (0, 0, PLAYER.rect[2], PLAYER.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    My_cached_info.intro_ahhh_timer += delta_milliseconds
    adjusted_ahhh_timer = My_cached_info.intro_ahhh_timer % 700
    if 0 <= adjusted_ahhh_timer <= 400:
      make_opengl_rect(OpenGLTextures['Ahhh'][0], OpenGLTextures['Ahhh'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif + 65, current_hamster_y + current_blit_change_y - PLAYER.y_dif - 18), 0, False, (0, 0, OpenGLTextures['Ahhh'][0][0], OpenGLTextures['Ahhh'][0][1]))
    if 300 <= adjusted_ahhh_timer <= 700:
      make_opengl_rect(OpenGLTextures['AhhhReverse'][0], OpenGLTextures['AhhhReverse'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif - 102, current_hamster_y + current_blit_change_y - PLAYER.y_dif - 18), 0, False, (0, 0, OpenGLTextures['AhhhReverse'][0][0], OpenGLTextures['AhhhReverse'][0][1]))
    My_cached_info.first_frame_in_intro_step = False
    if My_cached_info.milliseconds_in_intro_stage >= 312:
      MixerSounds['MIDDLE_HIT'].play()
      My_cached_info.stage_in_intro = 12
      My_cached_info.milliseconds_in_intro_stage = 0
      My_cached_info.intro_hamster_rotation = additional_rotation
      My_cached_info.saved_hamster_x = 2829.57085265731 - (1536 / 2) + ((1 / 2) * screen_width)
      My_cached_info.saved_hamster_y = 1521.5484089056224 - (864 / 2) + ((1 / 2) * screen_height)
      My_cached_info.first_frame_in_intro_step = True
  #
  if My_cached_info.stage_in_intro == 12: # hamster ricochet, leg 6
    percentage_through_screen_movement = (My_cached_info.milliseconds_in_intro_stage + 1144 + 169 + 312) / My_cached_info.intro_screen_times[0]
    My_cached_info.intro_x = ((1 - percentage_through_screen_movement) * My_cached_info.intro_screen_centers[0][0]) + (percentage_through_screen_movement * My_cached_info.intro_screen_centers[1][0])
    My_cached_info.intro_y = ((1 - percentage_through_screen_movement) * My_cached_info.intro_screen_centers[0][1]) + (percentage_through_screen_movement * My_cached_info.intro_screen_centers[1][1])
    screen_movement_x = My_cached_info.last_intro_x - My_cached_info.intro_x
    screen_movement_y = My_cached_info.last_intro_y - My_cached_info.intro_y
    My_cached_info.last_intro_x = My_cached_info.intro_x
    My_cached_info.last_intro_y = My_cached_info.intro_y
    start_hamster_x = My_cached_info.saved_hamster_x
    start_hamster_y = My_cached_info.saved_hamster_y
    end_hamster_x = 2044 + ((1 / 2) * screen_width)
    end_hamster_y = 1086 + ((1 / 2) * screen_height)
    total_velocity = 400
    movement_angle = math.degrees(math.atan2(-(end_hamster_y - start_hamster_y), end_hamster_x - start_hamster_x))
    movement_angle = 155
    vel_x = total_velocity * math.cos(math.radians(movement_angle))
    vel_y = -total_velocity * math.sin(math.radians(movement_angle))
    delta_t = My_cached_info.milliseconds_in_intro_stage / 1000
    current_hamster_x = start_hamster_x + (vel_x * delta_t) + ((1 / 2) * 0 * delta_t**2)
    current_hamster_y = start_hamster_y + (vel_y * delta_t) + ((1 / 2) * 400 * delta_t**2)
    additional_rotation = (2.2 * (2 * math.pi * 34 * delta_t)) + My_cached_info.intro_hamster_rotation
    human_x = 2566 + (114 / 2)
    human_y = 769 + (250 / 2)
    draw_map_prettymap_background()
    make_opengl_rect(OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][1]))
    make_opengl_rect(OpenGLTextures['JUST_THE_DAMAGE'][0], OpenGLTextures['JUST_THE_DAMAGE'][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['JUST_THE_DAMAGE'][0][0], OpenGLTextures['JUST_THE_DAMAGE'][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    if not My_cached_info.first_frame_in_intro_step:
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    if My_cached_info.first_frame_in_intro_step:
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (1957 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 939 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
    make_opengl_rect(OpenGLTextures['HUMAN_STANDING'][0][0], OpenGLTextures['HUMAN_STANDING'][0][1], (human_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, human_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HUMAN_STANDING'][0][0][0], OpenGLTextures['HUMAN_STANDING'][0][0][1]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['ROLLING_COUNTERCLOCKWISE'][0][0], OpenGLTextures['ROLLING_COUNTERCLOCKWISE'][0][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 0 + additional_rotation, True, (0, 0, PLAYER.rect[2], PLAYER.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    My_cached_info.intro_ahhh_timer += delta_milliseconds
    adjusted_ahhh_timer = My_cached_info.intro_ahhh_timer % 700
    if 0 <= adjusted_ahhh_timer <= 400:
      make_opengl_rect(OpenGLTextures['Ahhh'][0], OpenGLTextures['Ahhh'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif + 65, current_hamster_y + current_blit_change_y - PLAYER.y_dif - 18), 0, False, (0, 0, OpenGLTextures['Ahhh'][0][0], OpenGLTextures['Ahhh'][0][1]))
    if 300 <= adjusted_ahhh_timer <= 700:
      make_opengl_rect(OpenGLTextures['AhhhReverse'][0], OpenGLTextures['AhhhReverse'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif - 102, current_hamster_y + current_blit_change_y - PLAYER.y_dif - 18), 0, False, (0, 0, OpenGLTextures['AhhhReverse'][0][0], OpenGLTextures['AhhhReverse'][0][1]))
    My_cached_info.first_frame_in_intro_step = False
    if My_cached_info.milliseconds_in_intro_stage >= 1573:
      MixerSounds['LOUD_HIT'].play()
      My_cached_info.stage_in_intro = 13
      My_cached_info.milliseconds_in_intro_stage = 0
      My_cached_info.intro_hamster_rotation = additional_rotation
      My_cached_info.saved_hamster_x = 2259.32199305385 - (1536 / 2) + ((1 / 2) * screen_width)
      My_cached_info.saved_hamster_y = 1750.5027986183743 - (864 / 2) + ((1 / 2) * screen_height)
      My_cached_info.first_frame_in_intro_step = True
  #
  if My_cached_info.stage_in_intro == 13: # hamster ricochet, leg 7
    percentage_through_screen_movement = (My_cached_info.milliseconds_in_intro_stage + 1144 + 169 + 312 + 1573) / My_cached_info.intro_screen_times[0]
    My_cached_info.intro_x = ((1 - percentage_through_screen_movement) * My_cached_info.intro_screen_centers[0][0]) + (percentage_through_screen_movement * My_cached_info.intro_screen_centers[1][0])
    My_cached_info.intro_y = ((1 - percentage_through_screen_movement) * My_cached_info.intro_screen_centers[0][1]) + (percentage_through_screen_movement * My_cached_info.intro_screen_centers[1][1])
    screen_movement_x = My_cached_info.last_intro_x - My_cached_info.intro_x
    screen_movement_y = My_cached_info.last_intro_y - My_cached_info.intro_y
    My_cached_info.last_intro_x = My_cached_info.intro_x
    My_cached_info.last_intro_y = My_cached_info.intro_y
    start_hamster_x = My_cached_info.saved_hamster_x
    start_hamster_y = My_cached_info.saved_hamster_y
    end_hamster_x = 2044 + ((1 / 2) * screen_width)
    end_hamster_y = 1086 + ((1 / 2) * screen_height)
    total_velocity = 300
    movement_angle = math.degrees(math.atan2(-(end_hamster_y - start_hamster_y), end_hamster_x - start_hamster_x))
    movement_angle = 150
    vel_x = total_velocity * math.cos(math.radians(movement_angle))
    vel_y = -total_velocity * math.sin(math.radians(movement_angle))
    delta_t = My_cached_info.milliseconds_in_intro_stage / 1000
    current_hamster_x = start_hamster_x + (vel_x * delta_t) + ((1 / 2) * 0 * delta_t**2)
    current_hamster_y = start_hamster_y + (vel_y * delta_t) + ((1 / 2) * 400 * delta_t**2)
    additional_rotation = (2 * (2 * math.pi * 34 * delta_t)) + My_cached_info.intro_hamster_rotation
    human_x = 2566 + (114 / 2)
    human_y = 769 + (250 / 2)
    draw_map_prettymap_background()
    make_opengl_rect(OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][1]))
    make_opengl_rect(OpenGLTextures['JUST_THE_DAMAGE'][0], OpenGLTextures['JUST_THE_DAMAGE'][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['JUST_THE_DAMAGE'][0][0], OpenGLTextures['JUST_THE_DAMAGE'][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    if not My_cached_info.first_frame_in_intro_step:
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    if My_cached_info.first_frame_in_intro_step:
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (1957 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 939 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
    make_opengl_rect(OpenGLTextures['HUMAN_STANDING'][0][0], OpenGLTextures['HUMAN_STANDING'][0][1], (human_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, human_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HUMAN_STANDING'][0][0][0], OpenGLTextures['HUMAN_STANDING'][0][0][1]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['ROLLING_COUNTERCLOCKWISE'][0][0], OpenGLTextures['ROLLING_COUNTERCLOCKWISE'][0][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 0 + additional_rotation, True, (0, 0, PLAYER.rect[2], PLAYER.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    My_cached_info.intro_ahhh_timer += delta_milliseconds
    adjusted_ahhh_timer = My_cached_info.intro_ahhh_timer % 700
    if 0 <= adjusted_ahhh_timer <= 400:
      make_opengl_rect(OpenGLTextures['Ahhh'][0], OpenGLTextures['Ahhh'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif + 65, current_hamster_y + current_blit_change_y - PLAYER.y_dif - 18), 0, False, (0, 0, OpenGLTextures['Ahhh'][0][0], OpenGLTextures['Ahhh'][0][1]))
    if 300 <= adjusted_ahhh_timer <= 700:
      make_opengl_rect(OpenGLTextures['AhhhReverse'][0], OpenGLTextures['AhhhReverse'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif - 102, current_hamster_y + current_blit_change_y - PLAYER.y_dif - 18), 0, False, (0, 0, OpenGLTextures['AhhhReverse'][0][0], OpenGLTextures['AhhhReverse'][0][1]))
    My_cached_info.first_frame_in_intro_step = False
    if My_cached_info.milliseconds_in_intro_stage >= 755:
      MixerSounds['MIDDLE_HIT'].play()
      My_cached_info.stage_in_intro = 14
      My_cached_info.milliseconds_in_intro_stage = 0
      My_cached_info.intro_hamster_rotation = additional_rotation
      My_cached_info.saved_hamster_x = 2063.1672390966746 - (1536 / 2) + ((1 / 2) * screen_width)
      My_cached_info.saved_hamster_y = 1751.2577986183742 - (864 / 2) + ((1 / 2) * screen_height)
      My_cached_info.first_frame_in_intro_step = True
  #
  if My_cached_info.stage_in_intro == 14: # hamster ricochet, leg 8
    percentage_through_screen_movement = (My_cached_info.milliseconds_in_intro_stage + 1144 + 169 + 312 + 1573 + 755) / My_cached_info.intro_screen_times[0]
    My_cached_info.intro_x = ((1 - percentage_through_screen_movement) * My_cached_info.intro_screen_centers[0][0]) + (percentage_through_screen_movement * My_cached_info.intro_screen_centers[1][0])
    My_cached_info.intro_y = ((1 - percentage_through_screen_movement) * My_cached_info.intro_screen_centers[0][1]) + (percentage_through_screen_movement * My_cached_info.intro_screen_centers[1][1])
    screen_movement_x = My_cached_info.last_intro_x - My_cached_info.intro_x
    screen_movement_y = My_cached_info.last_intro_y - My_cached_info.intro_y
    My_cached_info.last_intro_x = My_cached_info.intro_x
    My_cached_info.last_intro_y = My_cached_info.intro_y
    start_hamster_x = My_cached_info.saved_hamster_x
    start_hamster_y = My_cached_info.saved_hamster_y
    end_hamster_x = 2044 + ((1 / 2) * screen_width)
    end_hamster_y = 1086 + ((1 / 2) * screen_height)
    total_velocity = 220
    movement_angle = math.degrees(math.atan2(-(end_hamster_y - start_hamster_y), end_hamster_x - start_hamster_x))
    movement_angle = 150
    vel_x = total_velocity * math.cos(math.radians(movement_angle))
    vel_y = -total_velocity * math.sin(math.radians(movement_angle))
    delta_t = My_cached_info.milliseconds_in_intro_stage / 1000
    current_hamster_x = start_hamster_x + (vel_x * delta_t) + ((1 / 2) * 0 * delta_t**2)
    current_hamster_y = start_hamster_y + (vel_y * delta_t) + ((1 / 2) * 400 * delta_t**2)
    additional_rotation = (0.6 * (2 * math.pi * 34 * delta_t)) + My_cached_info.intro_hamster_rotation
    human_x = 2566 + (114 / 2)
    human_y = 769 + (250 / 2)
    draw_map_prettymap_background()
    make_opengl_rect(OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][1]))
    make_opengl_rect(OpenGLTextures['JUST_THE_DAMAGE'][0], OpenGLTextures['JUST_THE_DAMAGE'][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['JUST_THE_DAMAGE'][0][0], OpenGLTextures['JUST_THE_DAMAGE'][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    if not My_cached_info.first_frame_in_intro_step:
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    if My_cached_info.first_frame_in_intro_step:
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (1957 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 939 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
    make_opengl_rect(OpenGLTextures['HUMAN_STANDING'][0][0], OpenGLTextures['HUMAN_STANDING'][0][1], (human_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, human_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HUMAN_STANDING'][0][0][0], OpenGLTextures['HUMAN_STANDING'][0][0][1]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['ROLLING_COUNTERCLOCKWISE'][0][0], OpenGLTextures['ROLLING_COUNTERCLOCKWISE'][0][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 0 + additional_rotation, True, (0, 0, PLAYER.rect[2], PLAYER.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    My_cached_info.first_frame_in_intro_step = False
    if My_cached_info.milliseconds_in_intro_stage >= 546:
      My_cached_info.stage_in_intro = 15
      MixerSounds['QUIET_HIT'].play()
      My_cached_info.milliseconds_in_intro_stage = 0
      My_cached_info.intro_hamster_rotation = additional_rotation
      My_cached_info.saved_hamster_x = 1959.1402675940878 - (1536 / 2) + ((1 / 2) * screen_width)
      My_cached_info.saved_hamster_y = 1750.8209986183742 - (864 / 2) + ((1 / 2) * screen_height)
      My_cached_info.first_frame_in_intro_step = True
  #
  if My_cached_info.stage_in_intro == 15: # run away from edge
    percentage_through_screen_movement = (My_cached_info.milliseconds_in_intro_stage + 1144 + 169 + 312 + 1573 + 755 + 546) / My_cached_info.intro_screen_times[0]
    My_cached_info.intro_x = ((1 - percentage_through_screen_movement) * My_cached_info.intro_screen_centers[0][0]) + (percentage_through_screen_movement * My_cached_info.intro_screen_centers[1][0])
    My_cached_info.intro_y = ((1 - percentage_through_screen_movement) * My_cached_info.intro_screen_centers[0][1]) + (percentage_through_screen_movement * My_cached_info.intro_screen_centers[1][1])
    screen_movement_x = My_cached_info.last_intro_x - My_cached_info.intro_x
    screen_movement_y = My_cached_info.last_intro_y - My_cached_info.intro_y
    My_cached_info.last_intro_x = My_cached_info.intro_x
    My_cached_info.last_intro_y = My_cached_info.intro_y
    start_hamster_x = My_cached_info.saved_hamster_x
    start_hamster_y = My_cached_info.saved_hamster_y
    end_hamster_x = My_cached_info.saved_hamster_x - 284
    enter_x = (1607 - My_cached_info.milliseconds_in_intro_stage) / 1000
    current_hamster_x = start_hamster_x + (-284 + (110 * (enter_x)**2))
    current_hamster_y = start_hamster_y
    if 0 <= My_cached_info.milliseconds_in_intro_stage <= 800:
      end_hamster_x = My_cached_info.saved_hamster_x - 213.6
      needed_percent = My_cached_info.milliseconds_in_intro_stage / 800
      current_hamster_x = start_hamster_x - abs((start_hamster_x - end_hamster_x) * needed_percent)
    human_x = 2566 + (114 / 2)
    human_y = 769 + (250 / 2)
    adjusted_hamster_walk_time = My_cached_info.milliseconds_in_intro_stage % 400
    if 0 <= adjusted_hamster_walk_time <= 100:
      hamster_walk_index = 0
    if 100 < adjusted_hamster_walk_time <= 200:
      hamster_walk_index = 1
    if 200 < adjusted_hamster_walk_time <= 300:
      hamster_walk_index = 2
    if 300 < adjusted_hamster_walk_time <= 400:
      hamster_walk_index = 3
    delta_t = My_cached_info.milliseconds_in_intro_stage / 1000
    hamster_ball_rotation = (1 * (2 * math.pi * 34 * delta_t)) + My_cached_info.intro_hamster_rotation
    draw_map_prettymap_background()
    make_opengl_rect(OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][1]))
    make_opengl_rect(OpenGLTextures['JUST_THE_DAMAGE'][0], OpenGLTextures['JUST_THE_DAMAGE'][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['JUST_THE_DAMAGE'][0][0], OpenGLTextures['JUST_THE_DAMAGE'][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    #if not My_cached_info.first_frame_in_intro_step:
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
    make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    #if My_cached_info.first_frame_in_intro_step:
    #  make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
    #  make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (1957 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 939 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
    make_opengl_rect(OpenGLTextures['HUMAN_STANDING'][0][0], OpenGLTextures['HUMAN_STANDING'][0][1], (human_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, human_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HUMAN_STANDING'][0][0][0], OpenGLTextures['HUMAN_STANDING'][0][0][1]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + hamster_ball_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['HAMSTER_WALKING_RIGHT'][hamster_walk_index][0], OpenGLTextures['HAMSTER_WALKING_RIGHT'][hamster_walk_index][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, PLAYER.rect[2], PLAYER.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + hamster_ball_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect(OpenGLTextures['NoNoNo'][0], OpenGLTextures['NoNoNo'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif + 65, current_hamster_y + current_blit_change_y - PLAYER.y_dif - 18), 0, False, (0, 0, OpenGLTextures['NoNoNo'][0][0], OpenGLTextures['NoNoNo'][0][1]))
    My_cached_info.first_frame_in_intro_step = False
    if My_cached_info.milliseconds_in_intro_stage >= 1607:
      My_cached_info.stage_in_intro = 16
      My_cached_info.milliseconds_in_intro_stage = 0
      My_cached_info.intro_hamster_rotation = 0
      My_cached_info.saved_hamster_x = 1675.00275 - (1536 / 2) + ((1 / 2) * screen_width)
      My_cached_info.saved_hamster_y = 1751 - (864 / 2) + ((1 / 2) * screen_height)
      My_cached_info.first_frame_in_intro_step = True
  #
  if My_cached_info.stage_in_intro == 16: # falling into trash
    percentage_through_screen_movement = (My_cached_info.milliseconds_in_intro_stage) / My_cached_info.intro_screen_times[1]
    My_cached_info.intro_x = ((1 - percentage_through_screen_movement) * My_cached_info.intro_screen_centers[1][0]) + (percentage_through_screen_movement * My_cached_info.intro_screen_centers[2][0])
    My_cached_info.intro_y = ((1 - percentage_through_screen_movement) * My_cached_info.intro_screen_centers[1][1]) + (percentage_through_screen_movement * My_cached_info.intro_screen_centers[2][1])
    screen_movement_x = My_cached_info.last_intro_x - My_cached_info.intro_x
    screen_movement_y = My_cached_info.last_intro_y - My_cached_info.intro_y
    My_cached_info.last_intro_x = My_cached_info.intro_x
    My_cached_info.last_intro_y = My_cached_info.intro_y
    start_hamster_x = My_cached_info.saved_hamster_x
    start_hamster_y = My_cached_info.saved_hamster_y
    end_hamster_x = 2044 + ((1 / 2) * screen_width)
    end_hamster_y = 1086 + ((1 / 2) * screen_height)
    total_velocity = 65
    movement_angle = math.degrees(math.atan2(-(end_hamster_y - start_hamster_y), end_hamster_x - start_hamster_x))
    movement_angle = 180
    vel_x = total_velocity * math.cos(math.radians(movement_angle))
    vel_y = -total_velocity * math.sin(math.radians(movement_angle))
    delta_t = My_cached_info.milliseconds_in_intro_stage / 1000
    current_hamster_x = start_hamster_x + (vel_x * delta_t) + ((1 / 2) * 0 * delta_t**2)
    current_hamster_y = start_hamster_y + (vel_y * delta_t) + ((1 / 2) * 400 * delta_t**2)
    additional_rotation = (2 * (2 * math.pi * 34 * delta_t)) + My_cached_info.intro_hamster_rotation
    human_x = 2566 + (114 / 2)
    human_y = 769 + (250 / 2)
    draw_map_prettymap_background()
    make_opengl_rect(OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][1]))
    make_opengl_rect(OpenGLTextures['JUST_THE_DAMAGE'][0], OpenGLTextures['JUST_THE_DAMAGE'][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['JUST_THE_DAMAGE'][0][0], OpenGLTextures['JUST_THE_DAMAGE'][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    if not My_cached_info.first_frame_in_intro_step:
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    if My_cached_info.first_frame_in_intro_step:
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    make_opengl_rect(OpenGLTextures['HAMSTER_OS'][0], OpenGLTextures['HAMSTER_OS'][1], (1957 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif, 939 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HAMSTER_OS'][0][0], OpenGLTextures['HAMSTER_OS'][0][1]))
    make_opengl_rect(OpenGLTextures['HUMAN_STANDING'][0][0], OpenGLTextures['HUMAN_STANDING'][0][1], (human_x + ((1 / 2) * screen_width) - (OpenGLTextures['HUMAN_TALKING'][0][0][0] / 2) + current_blit_change_x - PLAYER.x_dif, human_y + ((1 / 2) * screen_height) - (OpenGLTextures['HUMAN_TALKING'][0][0][1] / 2) + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['HUMAN_STANDING'][0][0][0], OpenGLTextures['HUMAN_STANDING'][0][0][1]))
    make_opengl_rect(OpenGLTextures['WHOLE_GARBAGE_CAN'][0], OpenGLTextures['WHOLE_GARBAGE_CAN'][1], (GARBAGE_CAN[0].x_pos + current_blit_change_x - PLAYER.x_dif, GARBAGE_CAN[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['WHOLE_GARBAGE_CAN'][0][0], OpenGLTextures['WHOLE_GARBAGE_CAN'][0][1]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_BACK'][0], OpenGLTextures['THE_BALL_BACK'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['ROLLING_COUNTERCLOCKWISE'][0][0], OpenGLTextures['ROLLING_COUNTERCLOCKWISE'][0][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 0 + additional_rotation, False, (0, 0, PLAYER.rect[2], PLAYER.rect[3]))
    make_opengl_rect_center_on_circle(OpenGLTextures['THE_BALL_FRONT'][0], OpenGLTextures['THE_BALL_FRONT'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif, current_hamster_y + current_blit_change_y - PLAYER.y_dif), 45 + additional_rotation, False, (0, 0, my_sheath.rect[2], my_sheath.rect[3]))
    make_opengl_rect(OpenGLTextures['TRANSPARENT_GARBAGE_CAN'][0], OpenGLTextures['TRANSPARENT_GARBAGE_CAN'][1], (GARBAGE_CAN[0].x_pos + current_blit_change_x - PLAYER.x_dif, GARBAGE_CAN[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['TRANSPARENT_GARBAGE_CAN'][0][0], OpenGLTextures['TRANSPARENT_GARBAGE_CAN'][0][1]))
    adjusted_ahhh_timer = My_cached_info.milliseconds_in_intro_stage % 700
    if 0 <= adjusted_ahhh_timer <= 400:
      make_opengl_rect(OpenGLTextures['Waahh'][0], OpenGLTextures['Waahh'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif + 65, current_hamster_y + current_blit_change_y - PLAYER.y_dif - 18), 0, False, (0, 0, OpenGLTextures['Waahh'][0][0], OpenGLTextures['Waahh'][0][1]))
    if 300 <= adjusted_ahhh_timer <= 700:
      make_opengl_rect(OpenGLTextures['WaahhReverse'][0], OpenGLTextures['WaahhReverse'][1], (current_hamster_x + current_blit_change_x - PLAYER.x_dif - 195, current_hamster_y + current_blit_change_y - PLAYER.y_dif - 18), 0, False, (0, 0, OpenGLTextures['WaahhReverse'][0][0], OpenGLTextures['WaahhReverse'][0][1]))
    grass_movement_index = int((My_cached_info.milliseconds_in_intro_stage % 1040) // 260)
    make_opengl_rect(OpenGLTextures['FLOWER2'][0], OpenGLTextures['FLOWER2'][1], (1580 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2584 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, ((OpenGLTextures['FLOWER2'][0][0] / 4) * grass_movement_index, 0, (OpenGLTextures['FLOWER2'][0][0] / 4)+((OpenGLTextures['FLOWER2'][0][0] / 4) * grass_movement_index), OpenGLTextures['FLOWER2'][0][1]))
    make_opengl_rect(OpenGLTextures['FLOWER2'][0], OpenGLTextures['FLOWER2'][1], (1747 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2584 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, ((OpenGLTextures['FLOWER2'][0][0] / 4) * grass_movement_index, 0, (OpenGLTextures['FLOWER2'][0][0] / 4)+((OpenGLTextures['FLOWER2'][0][0] / 4) * grass_movement_index), OpenGLTextures['FLOWER2'][0][1]))
    make_opengl_rect(OpenGLTextures['FLOWER1'][0], OpenGLTextures['FLOWER1'][1], (170 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2634 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, ((OpenGLTextures['FLOWER1'][0][0] / 4) * grass_movement_index, 0, (OpenGLTextures['FLOWER1'][0][0] / 4)+((OpenGLTextures['FLOWER1'][0][0] / 4) * grass_movement_index), OpenGLTextures['FLOWER1'][0][1]))
    make_opengl_rect(OpenGLTextures['FLOWER1'][0], OpenGLTextures['FLOWER1'][1], (425 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2634 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, ((OpenGLTextures['FLOWER1'][0][0] / 4) * grass_movement_index, 0, (OpenGLTextures['FLOWER1'][0][0] / 4)+((OpenGLTextures['FLOWER1'][0][0] / 4) * grass_movement_index), OpenGLTextures['FLOWER1'][0][1]))
    make_opengl_rect(OpenGLTextures['FLOWER1'][0], OpenGLTextures['FLOWER1'][1], (939 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2634 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, ((OpenGLTextures['FLOWER1'][0][0] / 4) * grass_movement_index, 0, (OpenGLTextures['FLOWER1'][0][0] / 4)+((OpenGLTextures['FLOWER1'][0][0] / 4) * grass_movement_index), OpenGLTextures['FLOWER1'][0][1]))
    make_opengl_rect(OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][1], (-16 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2684 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, True, (0, 0, OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][1]))
    make_opengl_rect(OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][1], (55 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2684 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][1]))
    make_opengl_rect(OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][1], (258 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2684 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][1]))
    make_opengl_rect(OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][1], (576 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2686+9 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][1]))
    make_opengl_rect(OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][1], (798 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2686+9 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, True, (0, 0, OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][1]))
    make_opengl_rect(OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][1], (1021 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2684 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][1]))
    make_opengl_rect(OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][1], (1479 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2684 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, True, (0, 0, OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][1]))
    make_opengl_rect(OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][1], (1936 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2684 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][1]))
    My_cached_info.first_frame_in_intro_step = False
    if My_cached_info.milliseconds_in_intro_stage >= 2600:
      MixerSounds['LOUD_HIT'].play()
      My_cached_info.stage_in_intro = 17
      My_cached_info.milliseconds_in_intro_stage = 0
      My_cached_info.intro_hamster_rotation = additional_rotation
      My_cached_info.saved_hamster_x = 1959.1402675940878 - (1536 / 2) + ((1 / 2) * screen_width)
      My_cached_info.saved_hamster_y = 1750.8209986183742 - (864 / 2) + ((1 / 2) * screen_height)
      My_cached_info.first_frame_in_intro_step = True
  #
  if My_cached_info.stage_in_intro == 17: # transition to tutorial
    My_cached_info.play_time = 0
    screen_movement_x = 0
    screen_movement_y = 0
    draw_map_prettymap_background()
    make_opengl_rect(OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][0], OpenGLTextures['THE_MACHINE_DISREPAIR'][7][0][1]))
    make_opengl_rect(OpenGLTextures['JUST_THE_DAMAGE'][0], OpenGLTextures['JUST_THE_DAMAGE'][1], (THE_MACHINE[0].x_pos + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['JUST_THE_DAMAGE'][0][0], OpenGLTextures['JUST_THE_DAMAGE'][0][1]))
    make_opengl_rect(OpenGLTextures['GREEN_BUTTON'][0][0], OpenGLTextures['GREEN_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 220 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['GREEN_BUTTON'][0][0][0], OpenGLTextures['GREEN_BUTTON'][0][0][1]))
    make_opengl_rect(OpenGLTextures['RED_BUTTON'][0][0], OpenGLTextures['RED_BUTTON'][0][1], (THE_MACHINE[0].x_pos + 252 + current_blit_change_x - PLAYER.x_dif, THE_MACHINE[0].y_pos + 236 + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['RED_BUTTON'][0][0][0], OpenGLTextures['RED_BUTTON'][0][0][1]))
    if not My_cached_info.first_frame_in_intro_step:
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    if My_cached_info.first_frame_in_intro_step:
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][8][0], OpenGLTextures['DOOR_WITH_KNOB'][8][1], (1363 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][8][0][0], OpenGLTextures['DOOR_WITH_KNOB'][8][0][1]))
      make_opengl_rect(OpenGLTextures['DOOR_WITH_KNOB'][4][0], OpenGLTextures['DOOR_WITH_KNOB'][4][1], (2314 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif - screen_movement_x, 1132 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif - screen_movement_y), 0, False, (0, 0, OpenGLTextures['DOOR_WITH_KNOB'][4][0][0], OpenGLTextures['DOOR_WITH_KNOB'][4][0][1]))
    make_opengl_rect(OpenGLTextures['WHOLE_GARBAGE_CAN'][0], OpenGLTextures['WHOLE_GARBAGE_CAN'][1], (GARBAGE_CAN[0].x_pos + current_blit_change_x - PLAYER.x_dif, GARBAGE_CAN[0].y_pos + current_blit_change_y - PLAYER.y_dif), 0, False, (0, 0, OpenGLTextures['WHOLE_GARBAGE_CAN'][0][0], OpenGLTextures['WHOLE_GARBAGE_CAN'][0][1]))
    grass_movement_index = int((My_cached_info.milliseconds_in_intro_stage % 1040) // 260)
    make_opengl_rect(OpenGLTextures['FLOWER2'][0], OpenGLTextures['FLOWER2'][1], (1580 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2584 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, ((OpenGLTextures['FLOWER2'][0][0] / 4) * grass_movement_index, 0, (OpenGLTextures['FLOWER2'][0][0] / 4)+((OpenGLTextures['FLOWER2'][0][0] / 4) * grass_movement_index), OpenGLTextures['FLOWER2'][0][1]))
    make_opengl_rect(OpenGLTextures['FLOWER2'][0], OpenGLTextures['FLOWER2'][1], (1747 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2584 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, ((OpenGLTextures['FLOWER2'][0][0] / 4) * grass_movement_index, 0, (OpenGLTextures['FLOWER2'][0][0] / 4)+((OpenGLTextures['FLOWER2'][0][0] / 4) * grass_movement_index), OpenGLTextures['FLOWER2'][0][1]))
    make_opengl_rect(OpenGLTextures['FLOWER1'][0], OpenGLTextures['FLOWER1'][1], (170 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2634 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, ((OpenGLTextures['FLOWER1'][0][0] / 4) * grass_movement_index, 0, (OpenGLTextures['FLOWER1'][0][0] / 4)+((OpenGLTextures['FLOWER1'][0][0] / 4) * grass_movement_index), OpenGLTextures['FLOWER1'][0][1]))
    make_opengl_rect(OpenGLTextures['FLOWER1'][0], OpenGLTextures['FLOWER1'][1], (425 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2634 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, ((OpenGLTextures['FLOWER1'][0][0] / 4) * grass_movement_index, 0, (OpenGLTextures['FLOWER1'][0][0] / 4)+((OpenGLTextures['FLOWER1'][0][0] / 4) * grass_movement_index), OpenGLTextures['FLOWER1'][0][1]))
    make_opengl_rect(OpenGLTextures['FLOWER1'][0], OpenGLTextures['FLOWER1'][1], (939 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2634 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, ((OpenGLTextures['FLOWER1'][0][0] / 4) * grass_movement_index, 0, (OpenGLTextures['FLOWER1'][0][0] / 4)+((OpenGLTextures['FLOWER1'][0][0] / 4) * grass_movement_index), OpenGLTextures['FLOWER1'][0][1]))
    make_opengl_rect(OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][1], (-16 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2684 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, True, (0, 0, OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][1]))
    make_opengl_rect(OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][1], (55 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2684 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][1]))
    make_opengl_rect(OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][1], (258 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2684 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][1]))
    make_opengl_rect(OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][1], (576 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2686+9 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][1]))
    make_opengl_rect(OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][1], (798 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2686+9 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, True, (0, 0, OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][1]))
    make_opengl_rect(OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][1], (1021 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2684 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][1]))
    make_opengl_rect(OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][1], (1479 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2684 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, True, (0, 0, OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][1]))
    make_opengl_rect(OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][1], (1936 + ((1 / 2) * screen_width) + current_blit_change_x - PLAYER.x_dif + screen_movement_x, 2684 + ((1 / 2) * screen_height) + current_blit_change_y - PLAYER.y_dif + screen_movement_y), 0, False, (0, 0, OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][0], OpenGLTextures['FOREST_GRASS_R0'][grass_movement_index][0][1]))
    My_cached_info.first_frame_in_intro_step = False
    if My_cached_info.milliseconds_in_intro_stage >= 600:
      shady_image_index = 4 - round((My_cached_info.milliseconds_in_intro_stage - 600) // 200)
      if shady_image_index <= 0:
        shady_image_index = 0
      shady_image = ((OpenGLTextures['SHADY_PIXELS'][shady_image_index][0][0] * screen_width, OpenGLTextures['SHADY_PIXELS'][shady_image_index][0][1] * screen_height), OpenGLTextures['SHADY_PIXELS'][shady_image_index][1])
      make_opengl_rect(shady_image[0], shady_image[1], (0, 0), 0, False, (0, 0, shady_image[0][0], shady_image[0][1]))
    if My_cached_info.milliseconds_in_intro_stage >= 1700:
      everything_save_data(True, 46, '1')
      My_cached_info.leaving_intro = True
      My_cached_info.play_intro_sequence = False
  My_cached_info.first_frame_in_intro_step = False


def get_current_timing_for_grates(current_grate, current_timing):
  time_offset = - current_timing * GRATES[0].expanding_receding_time
  current_step = (My_cached_info.fake_frame_counter + time_offset) % GRATES[0].loop_periods[current_grate]
  if 0 <= current_step <= GRATES[0].waiting_time:
    return 0, 0*16
  #
  if GRATES[0].waiting_time <= current_step < (GRATES[0].waiting_time + GRATES[0].expanding_receding_time):
    return 1, (current_step - GRATES[0].waiting_time)*16
  #
  if (GRATES[0].waiting_time + GRATES[0].expanding_receding_time) <= current_step < (GRATES[0].waiting_time + GRATES[0].expanding_receding_time + GRATES[0].staying_time):
    return 2, GRATES[0].expanding_receding_time*16
  #
  if (GRATES[0].waiting_time + GRATES[0].expanding_receding_time + GRATES[0].staying_time) <= current_step <= (GRATES[0].waiting_time + (2*GRATES[0].expanding_receding_time) + GRATES[0].staying_time):
    return 3, 256 - (current_step - GRATES[0].waiting_time - GRATES[0].expanding_receding_time - GRATES[0].staying_time)*16


def blit_change_player():
  if PLAYER.x_accel > 0:
    if PLAYER.blit_change_x < 180:
      PLAYER.blit_change_x += 1*(target_fps / fps)
  if PLAYER.x_accel < 0:
    if PLAYER.blit_change_x > -180:
      PLAYER.blit_change_x -= 1*(target_fps / fps)
  if PLAYER.y_vel > 0:
    if PLAYER.blit_change_y < 90:
      PLAYER.blit_change_y += 1*(target_fps / fps)
  if PLAYER.y_vel < 0:
    if PLAYER.blit_change_y > -90:
      PLAYER.blit_change_y -= 1*(target_fps / fps)


def do_vine_noises(i):
  if MY_VINES[i].angular_vel != 0:
    avg_vine_x = statistics.mean([x for x in MY_VINES[i].x_poss]) + (MY_VINES[i].GPU_image[0][0] / 2) - ((0.5) * screen_width)
    center_of_vine_x = MY_VINES[i].x_pos + (MY_VINES[i].GPU_image[0][0] / 2) - ((0.5) * screen_width)
    if center_of_vine_x - 50 <= avg_vine_x <= center_of_vine_x + 50:
      if MY_VINES[i].allow_another_sound_to_play:
        bottom_of_vine = statistics.mean([y for y in MY_VINES[i].y_poss]) - ((1 / 2) * screen_height)
        absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
        distance_between_player_and_sound_center = find_hypotnuse(abs(absolute_center_of_player_x - avg_vine_x), abs(absolute_center_of_player_y - bottom_of_vine))
        total_vine_length = (MY_VINES[i].vine_length * MY_VINES[i].vine_segment_length) * 2
        volume_distance_multiplier = ((total_vine_length - distance_between_player_and_sound_center) / total_vine_length)
        if volume_distance_multiplier > 1:
          volume_distance_multiplier = 1
        if volume_distance_multiplier < 0:
          volume_distance_multiplier = 0
        MY_VINES[i].my_sound.set_volume(MixerSoundsLoudness['VINE_SWING'] * My_cached_info.current_sound_loudness * volume_distance_multiplier)
        MY_VINES[i].my_sound.play()
        MY_VINES[i].allow_another_sound_to_play = False
    else:
      MY_VINES[i].allow_another_sound_to_play = True


def update_vines():
  for i in range(len(MY_VINES)):
    find_next_vine_rotation(MY_VINES[i])
    for j in range(MY_VINES[i].vine_length):
      try:
        MY_VINES[i].current_images[j] = rotate_square_image(MY_VINES[i].images[j], MY_VINES[i].rotations[j])
      except:
        MY_VINES[i].current_images[j], MY_VINES[i].rects[j] = rotate_rectangular_image(MY_VINES[i].images[j], MY_VINES[i].rects[j], MY_VINES[i].rotations[j])
    find_rotated_vine_positions(MY_VINES[i])
    do_vine_noises(i)
    if MY_VINES[i].is_the_player_swinging:
      if len(MY_VINES[i].x_poss) != 1:
        my_piston2.grapple_claw_x_pos = MY_VINES[i].x_poss[MY_VINES[i].connected_segment_of_vine] - stop_scrolling_left + ((1/2) * MY_VINES[i].rect[2]) + (my_piston2.radius_from_center_of_vine_segment * math.cos(math.radians(MY_VINES[i].rotations[MY_VINES[i].connected_segment_of_vine])))
        my_piston2.grapple_claw_y_pos = MY_VINES[i].y_poss[MY_VINES[i].connected_segment_of_vine] - stop_scrolling_top + ((1/2) * MY_VINES[i].rect[3]) - (my_piston2.radius_from_center_of_vine_segment * math.sin(math.radians(MY_VINES[i].rotations[MY_VINES[i].connected_segment_of_vine])))
      if len(MY_VINES[i].x_poss) == 1:
        my_piston2.grapple_claw_x_pos = MY_VINES[i].x_poss[MY_VINES[i].connected_segment_of_vine] - stop_scrolling_left + ((1/2) * MY_VINES[i].rect[2])
        my_piston2.grapple_claw_y_pos = MY_VINES[i].y_poss[MY_VINES[i].connected_segment_of_vine] - stop_scrolling_top + MY_VINES[i].grapple_added_y_pos


def find_water_force_on_food(low_x, high_x, low_y, high_y, water_Fx, water_Fy, SingleFood):
  adjusted_x = (SingleFood.x_pos - ((1/2)*screen_width))
  adjusted_y = (SingleFood.y_pos - ((1/2)*screen_height))
  if low_x <= adjusted_x <= high_x and low_y <= adjusted_y <= high_y:
    SingleFood.y_vel *= 0.992
    how_submerged = adjusted_y - low_y
    if how_submerged > 150:
      SingleFood.y_vel = -300
    if how_submerged <= 69:
      SingleFood.Fy = -16 * how_submerged
    if how_submerged > 69:
      SingleFood.Fy = -16 * 69
    return
  else:
    return


def find_water_force(low_x, high_x, low_y, high_y, water_Fx, water_Fy, completely_submerged):
  if low_x <= PLAYER.x_pos <= high_x and low_y <= PLAYER.y_pos <= high_y:
    if not PLAYER.not_yet_on_the_board:
      PLAYER.allow_catch_the_board_points = False
    PLAYER.skip_the_rest_of_the_water = True
    PLAYER.Hamster_activities_during_frame.append('Float')
    if Currently_pressed_controls.pressed_controls['FLOAT_UP']:
      PLAYER.movement_Fy -= my_gravity * 0.6
    if Currently_pressed_controls.pressed_controls['SINK_DOWN']:
      PLAYER.movement_Fy += my_gravity * 1.5 * ((PLAYER.current_number_of_bubbles + 1) / PLAYER.max_number_of_bubbles)
    PLAYER.x_vel *= 0.992
    PLAYER.y_vel *= 0.992
    how_submerged = PLAYER.y_pos - low_y
    if completely_submerged:
      if how_submerged <= 69:
        how_submerged = 100
    PLAYER.how_submerged = how_submerged
    if how_submerged <= 69:
      PLAYER.water_Fy = -16 * how_submerged
    if how_submerged > 69:
      PLAYER.water_Fy = -16 * 69
      PLAYER.current_milliseconds_before_creating_bubble_particle += delta_milliseconds
      if PLAYER.current_milliseconds_before_creating_bubble_particle >= PLAYER.milliseconds_before_creating_bubble_particle:
        PLAYER.current_milliseconds_before_creating_bubble_particle %= PLAYER.milliseconds_before_creating_bubble_particle
        left_or_right = random.randint(0,1)
        if left_or_right == 0:
          if not ON_A_BUCKET:
            BUBBLES.append(BubbleParticle(x_pos = PLAYER.x_pos + ((1/2) * screen_width) - 12, y_pos = PLAYER.y_pos + ((1/2) * screen_height) + 45, starting_submersion = PLAYER.how_submerged, png_name = 'SINGLE_BUBBLE'))
        if left_or_right == 1:
          if not ON_A_BUCKET:
            BUBBLES.append(BubbleParticle(x_pos = PLAYER.x_pos + ((1/2) * screen_width) + 69 - 12, y_pos = PLAYER.y_pos + ((1/2) * screen_height) + 45, starting_submersion = PLAYER.how_submerged, png_name = 'SINGLE_BUBBLE'))
    PLAYER.water_Fy *= (PLAYER.current_number_of_bubbles / PLAYER.max_number_of_bubbles)
    if PLAYER.current_number_of_bubbles == 0 and not collison_with_bottom_ball_happened:
      PLAYER.Fgy /= 5
    PLAYER.water_Fx += water_Fx
    PLAYER.water_Fy += water_Fy
    return
  else:
    if not PLAYER.skip_the_rest_of_the_water:
      PLAYER.how_submerged = 0


def find_irregular_water_force(SingleIrregularlyShapedWater, water_collision_points):
  highest_water_point = min([y for (x,y) in water_collision_points])
  PLAYER.skip_the_rest_of_the_water = True
  PLAYER.Hamster_activities_during_frame.append('Float')
  if Currently_pressed_controls.pressed_controls['FLOAT_UP']:
    PLAYER.movement_Fy -= my_gravity * 0.6
  if Currently_pressed_controls.pressed_controls['SINK_DOWN']:
    PLAYER.movement_Fy += my_gravity * 1.5 * ((PLAYER.current_number_of_bubbles + 1) / PLAYER.max_number_of_bubbles)
  PLAYER.x_vel *= 0.992
  PLAYER.y_vel *= 0.992
  how_submerged = 69 - highest_water_point
  PLAYER.how_submerged = how_submerged
  if how_submerged <= 69:
    PLAYER.water_Fy = -16 * how_submerged
  if how_submerged > 69:
    PLAYER.water_Fy = -16 * 69
  PLAYER.water_Fx += SingleIrregularlyShapedWater.water_Fx
  PLAYER.water_Fy += SingleIrregularlyShapedWater.water_Fy
  return


def find_SewerPumpWater_force(SingleSewerPumpWater):
  PLAYER.Hamster_forced_spin = True
  if SingleSewerPumpWater.stage_in_spout == 1:
    if 0 <= SingleSewerPumpWater.current_rotation < 90:
      PLAYER.water_Fx += abs((SingleSewerPumpWater.vel / (0.01 / fps)) * math.cos(math.radians(SingleSewerPumpWater.current_rotation)))
      PLAYER.water_Fy -= abs((SingleSewerPumpWater.vel / (0.01 / fps)) * math.sin(math.radians(SingleSewerPumpWater.current_rotation)))
    if 90 <= SingleSewerPumpWater.current_rotation < 180:
      PLAYER.water_Fx -= abs((SingleSewerPumpWater.vel / (0.01 / fps)) * math.cos(math.radians(SingleSewerPumpWater.current_rotation)))
      PLAYER.water_Fy -= abs((SingleSewerPumpWater.vel / (0.01 / fps)) * math.sin(math.radians(SingleSewerPumpWater.current_rotation)))
    if 180 <= SingleSewerPumpWater.current_rotation < 270:
      PLAYER.water_Fx -= abs((SingleSewerPumpWater.vel / (0.01 / fps)) * math.cos(math.radians(SingleSewerPumpWater.current_rotation)))
      PLAYER.water_Fy += abs((SingleSewerPumpWater.vel / (0.01 / fps)) * math.sin(math.radians(SingleSewerPumpWater.current_rotation)))
    if 270 <= SingleSewerPumpWater.current_rotation <= 360:
      PLAYER.water_Fx += abs((SingleSewerPumpWater.vel / (0.01 / fps)) * math.cos(math.radians(SingleSewerPumpWater.current_rotation)))
      PLAYER.water_Fy += abs((SingleSewerPumpWater.vel / (0.01 / fps)) * math.sin(math.radians(SingleSewerPumpWater.current_rotation)))
  #
  if SingleSewerPumpWater.stage_in_spout == 2:
    if 0 <= SingleSewerPumpWater.current_rotation < 90:
      PLAYER.water_Fx += abs((SingleSewerPumpWater.vel / (0.1 / fps)) * math.cos(math.radians(SingleSewerPumpWater.current_rotation)))
      PLAYER.water_Fy -= abs((SingleSewerPumpWater.vel / (0.1 / fps)) * math.sin(math.radians(SingleSewerPumpWater.current_rotation)))
    if 90 <= SingleSewerPumpWater.current_rotation < 180:
      PLAYER.water_Fx -= abs((SingleSewerPumpWater.vel / (0.1 / fps)) * math.cos(math.radians(SingleSewerPumpWater.current_rotation)))
      PLAYER.water_Fy -= abs((SingleSewerPumpWater.vel / (0.1 / fps)) * math.sin(math.radians(SingleSewerPumpWater.current_rotation)))
    if 180 <= SingleSewerPumpWater.current_rotation < 270:
      PLAYER.water_Fx -= abs((SingleSewerPumpWater.vel / (0.1 / fps)) * math.cos(math.radians(SingleSewerPumpWater.current_rotation)))
      PLAYER.water_Fy += abs((SingleSewerPumpWater.vel / (0.1 / fps)) * math.sin(math.radians(SingleSewerPumpWater.current_rotation)))
    if 270 <= SingleSewerPumpWater.current_rotation <= 360:
      PLAYER.water_Fx += abs((SingleSewerPumpWater.vel / (0.1 / fps)) * math.cos(math.radians(SingleSewerPumpWater.current_rotation)))
      PLAYER.water_Fy += abs((SingleSewerPumpWater.vel / (0.1 / fps)) * math.sin(math.radians(SingleSewerPumpWater.current_rotation)))
  #
  if SingleSewerPumpWater.stage_in_spout == 3:
    if 0 <= SingleSewerPumpWater.current_rotation < 90:
      PLAYER.water_Fx += abs((SingleSewerPumpWater.vel / (0.5 / fps)) * math.cos(math.radians(SingleSewerPumpWater.current_rotation)))
      PLAYER.water_Fy -= abs((SingleSewerPumpWater.vel / (0.5 / fps)) * math.sin(math.radians(SingleSewerPumpWater.current_rotation)))
    if 90 <= SingleSewerPumpWater.current_rotation < 180:
      PLAYER.water_Fx -= abs((SingleSewerPumpWater.vel / (0.5 / fps)) * math.cos(math.radians(SingleSewerPumpWater.current_rotation)))
      PLAYER.water_Fy -= abs((SingleSewerPumpWater.vel / (0.5 / fps)) * math.sin(math.radians(SingleSewerPumpWater.current_rotation)))
    if 180 <= SingleSewerPumpWater.current_rotation < 270:
      PLAYER.water_Fx -= abs((SingleSewerPumpWater.vel / (0.5 / fps)) * math.cos(math.radians(SingleSewerPumpWater.current_rotation)))
      PLAYER.water_Fy += abs((SingleSewerPumpWater.vel / (0.5 / fps)) * math.sin(math.radians(SingleSewerPumpWater.current_rotation)))
    if 270 <= SingleSewerPumpWater.current_rotation <= 360:
      PLAYER.water_Fx += abs((SingleSewerPumpWater.vel / (0.5 / fps)) * math.cos(math.radians(SingleSewerPumpWater.current_rotation)))
      PLAYER.water_Fy += abs((SingleSewerPumpWater.vel / (0.5 / fps)) * math.sin(math.radians(SingleSewerPumpWater.current_rotation)))


def stay_in_bounds():
  if PLAYER.x_pos > MAP.rect[2] - 69: # right side
    PLAYER.FNx -= 3000
    PLAYER.x_vel = -1
  if PLAYER.x_pos < 0: # left side
    PLAYER.FNx += 3000
    PLAYER.x_vel = 1
  if PLAYER.y_pos < 0:
    PLAYER.FNy += 3000
    PLAYER.y_vel = 1
  if PLAYER.y_pos > MAP.rect[3] - 69:
    PLAYER.FNy -= 3000
    PLAYER.y_vel = -1


def update_cloud(cur_cloud):
  #
  if cur_cloud.x_pos > cur_cloud.center_x:
    cur_x_accel = -cur_cloud.x_accel
  if cur_cloud.x_pos <= cur_cloud.center_x:
    cur_x_accel = cur_cloud.x_accel
  if cur_cloud.y_pos > cur_cloud.center_y:
    cur_y_accel = -cur_cloud.y_accel
  if cur_cloud.y_pos <= cur_cloud.center_y:
    cur_y_accel = cur_cloud.y_accel
  #
  if cur_cloud.orig_x_vel > 0:
    if (cur_cloud.prev_x_pos <= cur_cloud.center_x) and (cur_cloud.x_pos > cur_cloud.center_x):
      cur_cloud.x_vel = cur_cloud.orig_x_vel
  if cur_cloud.orig_x_vel < 0:
    if (cur_cloud.prev_x_pos >= cur_cloud.center_x) and (cur_cloud.x_pos < cur_cloud.center_x):
      cur_cloud.x_vel = cur_cloud.orig_x_vel
  if cur_cloud.orig_y_vel > 0:
    if (cur_cloud.prev_y_pos <= cur_cloud.center_y) and (cur_cloud.y_pos > cur_cloud.center_y):
      cur_cloud.y_vel = cur_cloud.orig_y_vel
  if cur_cloud.orig_y_vel < 0:
    if (cur_cloud.prev_y_pos >= cur_cloud.center_y) and (cur_cloud.y_pos < cur_cloud.center_y):
      cur_cloud.y_vel = cur_cloud.orig_y_vel
  #
  cur_cloud.x_vel = cur_cloud.x_vel + (cur_x_accel * (1 / fps))
  cur_cloud.y_vel = cur_cloud.y_vel + (cur_y_accel * (1 / fps))
  cur_cloud.prev_x_pos = cur_cloud.x_pos
  cur_cloud.prev_y_pos = cur_cloud.y_pos
  cur_cloud.x_pos = cur_cloud.x_pos + (cur_cloud.x_vel * (1 / fps) + ((1 / 2) * cur_x_accel * (1 / fps)**2))
  cur_cloud.y_pos = cur_cloud.y_pos + (cur_cloud.y_vel * (1 / fps) + ((1 / 2) * cur_y_accel * (1 / fps)**2))
  if cur_cloud.is_the_player_swinging:
    my_piston2.grapple_claw_x_pos += (cur_cloud.x_pos - cur_cloud.prev_x_pos)
    my_piston2.grapple_claw_y_pos += (cur_cloud.y_pos - cur_cloud.prev_y_pos)


def update_teetertotter(cur_teetertotter):
  if cur_teetertotter.rotation == 0:
    cur_teetertotter.angular_accel += 0
  if -40 < cur_teetertotter.rotation < 0: # right side is dipping
    cur_teetertotter.angular_accel += 10
  if 0 < cur_teetertotter.rotation < 40: # left side is dipping
    cur_teetertotter.angular_accel -= 10
  if cur_teetertotter.rotation < - 40:
    cur_teetertotter.rotation = -39.999
    cur_teetertotter.angular_vel = 0
  if cur_teetertotter.rotation > 40:
    cur_teetertotter.rotation = 39.999
    cur_teetertotter.angular_vel = 0
  #
  if cur_teetertotter.is_the_push_piston_pushing:
    teeter_totter_collision_points, teeter_totter_collision_happened = find_collisions_with_offsets(my_piston1, cur_teetertotter, -(1/2) * screen_width, -(1/2) * screen_height)
    if teeter_totter_collision_happened:
      teetertotter_avg_impact_x, teetertotter_avg_impact_y = find_avg_impact_point(MAP, PLAYER, teeter_totter_collision_points)
      get_teeter_totter_piston_force(cur_teetertotter, teetertotter_avg_impact_x, teetertotter_avg_impact_y)
  #
  teeter_totter_collision_points, teeter_totter_collision_happened = find_collisions_with_offsets(PLAYER, cur_teetertotter, -(1/2) * screen_width, -(1/2) * screen_height)
  if teeter_totter_collision_happened:
    teetertotter_avg_impact_x, teetertotter_avg_impact_y = find_avg_impact_point(MAP, PLAYER, teeter_totter_collision_points)
    get_teeter_totter_piston_force(cur_teetertotter, teetertotter_avg_impact_x, teetertotter_avg_impact_y)
  #
  cur_teetertotter.angular_vel = cur_teetertotter.angular_vel + (cur_teetertotter.angular_accel * (1 / fps))
  cur_teetertotter.rotation = (cur_teetertotter.rotation + (cur_teetertotter.angular_vel * (1 / fps) + ((1 / 2) * cur_teetertotter.angular_accel * (1 / fps)**2)))
  cur_teetertotter.current_image, cur_teetertotter.cur_rect = rotate_rectangular_image(cur_teetertotter.image, cur_teetertotter.rect, cur_teetertotter.rotation)
  cur_teetertotter.angular_accel = 0
  cur_teetertotter.y_pos = cur_teetertotter.original_y_pos + (cur_teetertotter.rect[3] - (cur_teetertotter.cur_rect[3]/2))
  cur_teetertotter.x_pos = cur_teetertotter.original_x_pos + (cur_teetertotter.rect[2] - (cur_teetertotter.cur_rect[2]/2))


def get_teeter_totter_piston_force(cur_teetertotter, avg_impact_x, avg_impact_y):
  x1, y1, x2, y2 = avg_impact_x, avg_impact_y, (cur_teetertotter.cur_rect[2] / 2), (cur_teetertotter.cur_rect[3] / 2)
  try:
    slope = -((y2 - y1) / (x2 - x1))
  except:
    return
  angle_of_slope = math.degrees(math.atan(slope))
  #
  if avg_impact_x < cur_teetertotter.cur_rect[2] / 2: # piston on the left
    if angle_of_slope < cur_teetertotter.rotation: # piston on top left
      cur_teetertotter.angular_accel += 80 * abs((x2 - x1) / x2) * My_cached_info.target_fps_over_fps
      return
    if angle_of_slope > cur_teetertotter.rotation: # piston on bottom left
      cur_teetertotter.angular_accel -= 80 * abs((x2 - x1) / x2) * My_cached_info.target_fps_over_fps
      return
    if angle_of_slope == cur_teetertotter.rotation: # piston on neutral left
      return
  #
  if avg_impact_x > cur_teetertotter.cur_rect[2] / 2: # piston on the right
    if angle_of_slope < cur_teetertotter.rotation: # piston on bottom right
      cur_teetertotter.angular_accel += 80 * abs((x2 - x1) / x2) * My_cached_info.target_fps_over_fps
      return
    if angle_of_slope > cur_teetertotter.rotation: # piston on top right
      cur_teetertotter.angular_accel -= 80 * abs((x2 - x1) / x2) * My_cached_info.target_fps_over_fps
      return
    if angle_of_slope == cur_teetertotter.rotation: # piston on neutral right
      return
  #
  if avg_impact_x == cur_teetertotter.cur_rect[2] / 2: # piston on the middle
    return


def open_doors():
  for SingleDoor in range(len(DOORS)):
    if (ALLKEYS[SingleDoor].is_inserted and not DOORS[SingleDoor].is_open):
      if not DOORS[SingleDoor].is_open:
        absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
        distance_between_player_and_door = find_hypotnuse(abs(absolute_center_of_player_x - (DOORS[SingleDoor].x_pos - ((1/2)*screen_width) + (DOORS[SingleDoor].rect[2]/2))), abs(absolute_center_of_player_y - (DOORS[SingleDoor].y_pos - ((1/2)*screen_height) + (DOORS[SingleDoor].rect[3]/2))))
        if distance_between_player_and_door <= 1000:
          volume_distance_multiplier = 1 - (distance_between_player_and_door / 1000)
          if volume_distance_multiplier > 1:
            volume_distance_multiplier = 1
          if volume_distance_multiplier < 0:
            volume_distance_multiplier = 0
          DOORS[SingleDoor].sound.set_volume(MixerSoundsLoudness['DOOR'] * My_cached_info.current_sound_loudness * volume_distance_multiplier)
          if not DOORS[SingleDoor].playing_sound:
            if DOORS[SingleDoor].door_type != 3:
              DOORS[SingleDoor].sound.play(-1)
              DOORS[SingleDoor].playing_sound = True
      #
      if DOORS[SingleDoor].door_type == 1:
        if not DOORS[SingleDoor].is_open:
          if DOORS[SingleDoor].x_pos < DOORS[SingleDoor].is_open_x:
            DOORS[SingleDoor].x_pos += abs(DOORS[SingleDoor].is_open_x - DOORS[SingleDoor].original_x_pos) / 60
          if DOORS[SingleDoor].x_pos > DOORS[SingleDoor].is_open_x:
            DOORS[SingleDoor].x_pos -= abs(DOORS[SingleDoor].is_open_x - DOORS[SingleDoor].original_x_pos) / 60
          if DOORS[SingleDoor].y_pos < DOORS[SingleDoor].is_open_y:
            DOORS[SingleDoor].y_pos += abs(DOORS[SingleDoor].is_open_y - DOORS[SingleDoor].original_y_pos) / 60
          if DOORS[SingleDoor].y_pos > DOORS[SingleDoor].is_open_y:
            DOORS[SingleDoor].y_pos -= abs(DOORS[SingleDoor].is_open_y - DOORS[SingleDoor].original_y_pos) / 60
          if DOORS[SingleDoor].x_pos - 5 < DOORS[SingleDoor].is_open_x < DOORS[SingleDoor].x_pos + 5 and DOORS[SingleDoor].y_pos - 5 < DOORS[SingleDoor].is_open_y < DOORS[SingleDoor].y_pos + 5:
            if MAP.region == 'Forest':
              if not DOORS[SingleDoor].is_open:
                everything_save_data(True, 102, '1')
            DOORS[SingleDoor].is_open = True
            DOORS[SingleDoor].x_pos = DOORS[SingleDoor].is_open_x
            DOORS[SingleDoor].y_pos = DOORS[SingleDoor].is_open_y
            DOORS[SingleDoor].sound.fadeout(150)
            DOORS[SingleDoor].playing_sound = False
      #
      if DOORS[SingleDoor].door_type == 2:
        if not DOORS[SingleDoor].is_open:
          if DOORS[SingleDoor].rotation <= 90:
            DOORS[SingleDoor].rotation += 1
            DOORS[SingleDoor].current_LeftImage, DOORS[SingleDoor].LeftRect = rotate_rectangular_image(DOORS[SingleDoor].LeftImage, DOORS[SingleDoor].LeftRect, -DOORS[SingleDoor].rotation)
            DOORS[SingleDoor].LeftImage_x_pos = DOORS[SingleDoor].original_x_pos - (16 * abs(math.sin(math.radians(DOORS[SingleDoor].rotation))))
            DOORS[SingleDoor].LeftImage_y_pos = DOORS[SingleDoor].original_y_pos + (16 * abs(math.sin(math.radians(DOORS[SingleDoor].rotation))))
            DOORS[SingleDoor].current_RightImage, DOORS[SingleDoor].RightRect = rotate_rectangular_image(DOORS[SingleDoor].RightImage, DOORS[SingleDoor].RightRect, DOORS[SingleDoor].rotation)
            DOORS[SingleDoor].RightImage_x_pos = DOORS[SingleDoor].original_x_pos + 73 + (73 - (73 * abs(math.cos(math.radians(DOORS[SingleDoor].rotation)))))
            DOORS[SingleDoor].RightImage_y_pos = DOORS[SingleDoor].original_y_pos + (16 * abs(math.sin(math.radians(DOORS[SingleDoor].rotation))))
          if DOORS[SingleDoor].rotation >= 90:
            DOORS[SingleDoor].is_open = True
            DOORS[SingleDoor].rotation = 90
            DOORS[SingleDoor].current_LeftImage, DOORS[SingleDoor].LeftRect = rotate_rectangular_image(DOORS[SingleDoor].LeftImage, DOORS[SingleDoor].LeftRect, DOORS[SingleDoor].rotation+180)
            DOORS[SingleDoor].LeftImage_x_pos = DOORS[SingleDoor].original_x_pos - 16
            DOORS[SingleDoor].LeftImage_y_pos = DOORS[SingleDoor].original_y_pos + 16
            DOORS[SingleDoor].current_RightImage, DOORS[SingleDoor].RightRect = rotate_rectangular_image(DOORS[SingleDoor].RightImage, DOORS[SingleDoor].RightRect, DOORS[SingleDoor].rotation)
            DOORS[SingleDoor].RightImage_x_pos = DOORS[SingleDoor].original_x_pos + 146
            DOORS[SingleDoor].RightImage_y_pos = DOORS[SingleDoor].original_y_pos + 16
            DOORS[SingleDoor].sound.fadeout(150)
            DOORS[SingleDoor].playing_sound = False
      #
    if DOORS[SingleDoor].door_type == 3:
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      distance_between_player_and_door = find_hypotnuse(abs(absolute_center_of_player_x - (DOORS[SingleDoor].x_pos - ((1/2)*screen_width) + (DOORS[SingleDoor].rect[2]/2))), abs(absolute_center_of_player_y - (DOORS[SingleDoor].y_pos - ((1/2)*screen_height) + (DOORS[SingleDoor].rect[3]/2))))
      volume_distance_multiplier = 1 - (distance_between_player_and_door / 1000)
      if volume_distance_multiplier > 1:
        volume_distance_multiplier = 1
      if volume_distance_multiplier < 0:
        volume_distance_multiplier = 0
      DOORS[SingleDoor].sound.set_volume(MixerSoundsLoudness['DOOR'] * My_cached_info.current_sound_loudness * volume_distance_multiplier)
      if not DOORS[SingleDoor].playing_sound:
        if (DOORS[SingleDoor].y_pos != DOORS[SingleDoor].is_open_y) and (DOORS[SingleDoor].y_pos != DOORS[SingleDoor].original_y_pos):
          DOORS[SingleDoor].sound.play(-1)
          DOORS[SingleDoor].playing_sound = True
      if DOORS[SingleDoor].playing_sound:
        if (DOORS[SingleDoor].y_pos == DOORS[SingleDoor].is_open_y) or (DOORS[SingleDoor].y_pos == DOORS[SingleDoor].original_y_pos):
          DOORS[SingleDoor].sound.fadeout(150)
          DOORS[SingleDoor].playing_sound = False
      #
      if DOORS[SingleDoor].is_really_open:
        if DOORS[SingleDoor].x_pos < DOORS[SingleDoor].is_open_x:
          DOORS[SingleDoor].x_pos += abs(DOORS[SingleDoor].is_open_x - DOORS[SingleDoor].original_x_pos) / 60
        if DOORS[SingleDoor].x_pos > DOORS[SingleDoor].is_open_x:
          DOORS[SingleDoor].x_pos -= abs(DOORS[SingleDoor].is_open_x - DOORS[SingleDoor].original_x_pos) / 60
        if DOORS[SingleDoor].y_pos < DOORS[SingleDoor].is_open_y:
          DOORS[SingleDoor].y_pos += abs(DOORS[SingleDoor].is_open_y - DOORS[SingleDoor].original_y_pos) / 60
        if DOORS[SingleDoor].y_pos > DOORS[SingleDoor].is_open_y:
          DOORS[SingleDoor].y_pos -= abs(DOORS[SingleDoor].is_open_y - DOORS[SingleDoor].original_y_pos) / 60
        if DOORS[SingleDoor].x_pos - 5 < DOORS[SingleDoor].is_open_x < DOORS[SingleDoor].x_pos + 5 and DOORS[SingleDoor].y_pos - 5 < DOORS[SingleDoor].is_open_y < DOORS[SingleDoor].y_pos + 5:
          DOORS[SingleDoor].is_open = True
          DOORS[SingleDoor].x_pos = DOORS[SingleDoor].is_open_x
          DOORS[SingleDoor].y_pos = DOORS[SingleDoor].is_open_y
        continue
      if BEETLE_FRIEND.WhichButton == 9 or (DOORS[SingleDoor].x_pos - 70) < (PLAYER.x_pos + ((1/2)*screen_width)) < (DOORS[SingleDoor].x_pos + 70 + 16):
        if DOORS[SingleDoor].x_pos < DOORS[SingleDoor].is_open_x:
          DOORS[SingleDoor].x_pos += abs(DOORS[SingleDoor].is_open_x - DOORS[SingleDoor].original_x_pos) / 60
        if DOORS[SingleDoor].x_pos > DOORS[SingleDoor].is_open_x:
          DOORS[SingleDoor].x_pos -= abs(DOORS[SingleDoor].is_open_x - DOORS[SingleDoor].original_x_pos) / 60
        if DOORS[SingleDoor].y_pos < DOORS[SingleDoor].is_open_y:
          DOORS[SingleDoor].y_pos += abs(DOORS[SingleDoor].is_open_y - DOORS[SingleDoor].original_y_pos) / 60
        if DOORS[SingleDoor].y_pos > DOORS[SingleDoor].is_open_y:
          DOORS[SingleDoor].y_pos -= abs(DOORS[SingleDoor].is_open_y - DOORS[SingleDoor].original_y_pos) / 60
        if DOORS[SingleDoor].x_pos - 5 < DOORS[SingleDoor].is_open_x < DOORS[SingleDoor].x_pos + 5 and DOORS[SingleDoor].y_pos - 5 < DOORS[SingleDoor].is_open_y < DOORS[SingleDoor].y_pos + 5:
          DOORS[SingleDoor].is_open = True
          DOORS[SingleDoor].x_pos = DOORS[SingleDoor].is_open_x
          DOORS[SingleDoor].y_pos = DOORS[SingleDoor].is_open_y
      if BEETLE_FRIEND.WhichButton == 0:
        if not (DOORS[SingleDoor].x_pos - 70) < (PLAYER.x_pos + ((1/2)*screen_width)) < (DOORS[SingleDoor].x_pos + 70 + 16):
          if DOORS[SingleDoor].y_pos > DOORS[SingleDoor].original_y_pos:
            DOORS[SingleDoor].y_pos -= abs(DOORS[SingleDoor].is_open_y - DOORS[SingleDoor].original_y_pos) / 60
          if DOORS[SingleDoor].y_pos < DOORS[SingleDoor].original_y_pos:
            DOORS[SingleDoor].y_pos += abs(DOORS[SingleDoor].is_open_y - DOORS[SingleDoor].original_y_pos) / 60
        if DOORS[SingleDoor].x_pos - 5 < DOORS[SingleDoor].original_x_pos < DOORS[SingleDoor].x_pos + 5 and DOORS[SingleDoor].y_pos - 5 < DOORS[SingleDoor].original_y_pos < DOORS[SingleDoor].y_pos + 5:
          DOORS[SingleDoor].is_open = False
          DOORS[SingleDoor].x_pos = DOORS[SingleDoor].original_x_pos
          DOORS[SingleDoor].y_pos = DOORS[SingleDoor].original_y_pos


def find_next_ant_pos(my_ant):
  if my_ant.rotation == 0:
    my_ant.x_pos += my_ant.vel
  if 0 < my_ant.rotation < 90:
    my_ant.x_pos += abs(my_ant.vel * math.cos(math.radians(my_ant.rotation)))
    my_ant.y_pos -= abs(my_ant.vel * math.sin(math.radians(my_ant.rotation)))
  if my_ant.rotation == 90:
    my_ant.y_pos -= my_ant.vel
  if 90 < my_ant.rotation < 180:
    my_ant.x_pos -= abs(my_ant.vel * math.cos(math.radians(my_ant.rotation)))
    my_ant.y_pos -= abs(my_ant.vel * math.sin(math.radians(my_ant.rotation)))
  if my_ant.rotation == 180:
    my_ant.x_pos -= my_ant.vel
  if 180 < my_ant.rotation < 270:
    my_ant.x_pos -= abs(my_ant.vel * math.cos(math.radians(my_ant.rotation)))
    my_ant.y_pos += abs(my_ant.vel * math.sin(math.radians(my_ant.rotation)))
  if my_ant.rotation == 270:
    my_ant.y_pos += my_ant.vel
  if 270 < my_ant.rotation < 360:
    my_ant.x_pos += abs(my_ant.vel * math.cos(math.radians(my_ant.rotation)))
    my_ant.y_pos += abs(my_ant.vel * math.sin(math.radians(my_ant.rotation)))


def find_ant_rotation_angle(SingleAnt, object_x_pos, object_y_pos):
  center_x, center_y = SingleAnt.x_pos + SingleAnt.rect[2], SingleAnt.x_pos + SingleAnt.rect[3]
  if SingleAnt.x_pos == object_x_pos:
    if object_y_pos >= SingleAnt.y_pos:
      SingleAnt.rotation = 270
      return
    if object_y_pos < SingleAnt.y_pos:
      SingleAnt.rotation = 90
      return
  if SingleAnt.y_pos == object_y_pos:
    if object_x_pos >= SingleAnt.x_pos:
      SingleAnt.rotation = 0
      return
    if object_x_pos < SingleAnt.x_pos:
      SingleAnt.rotation = 180
      return
  if SingleAnt.x_pos > object_x_pos: # ant turn left
    if SingleAnt.y_pos >= object_y_pos: # ant turn up, 90 - 180
      SingleAnt.rotation = math.degrees(math.atan(abs(SingleAnt.x_pos - object_x_pos) / abs(SingleAnt.y_pos - object_y_pos))) + 90
      return
    if SingleAnt.y_pos < object_y_pos: # ant turn down, 180 - 270
      SingleAnt.rotation = 270 - math.degrees(math.atan(abs(SingleAnt.x_pos - object_x_pos) / abs(SingleAnt.y_pos - object_y_pos)))
      return
  if SingleAnt.x_pos < object_x_pos: # ant turn right
    if SingleAnt.y_pos >= object_y_pos: # ant turn up, 0 - 90
      SingleAnt.rotation = 90 - math.degrees(math.atan(abs(SingleAnt.x_pos - object_x_pos) / abs(SingleAnt.y_pos - object_y_pos)))
      return
    if SingleAnt.y_pos < object_y_pos: # ant turn down, 270 - 360
      SingleAnt.rotation = math.degrees(math.atan(abs(SingleAnt.x_pos - object_x_pos) / abs(SingleAnt.y_pos - object_y_pos))) + 270
      return


def find_ant_carrying_key_pos(SingleAnt, SingleKey):
  center_x, center_y = SingleAnt.x_pos + (SingleAnt.rect[2] / 2), SingleAnt.y_pos + (SingleAnt.rect[3] / 2)
  if SingleAnt.rotation == 0:
    SingleKey.x_pos = center_x + SingleAnt.rect[2]
    SingleKey.y_pos = center_y
    return
  if 0 < SingleAnt.rotation < 90:
    SingleKey.x_pos = center_x + ((SingleAnt.rect[2] / 2) * abs(math.cos(math.radians(SingleAnt.rotation)))) - (SingleKey.rect[2] / 2)
    SingleKey.y_pos = center_y - ((SingleAnt.rect[3] / 2) * abs(math.sin(math.radians(SingleAnt.rotation)))) - (SingleKey.rect[3] / 2)
    return
  if SingleAnt.rotation == 90:
    SingleKey.x_pos = center_x
    SingleKey.y_pos = center_y - SingleAnt.rect[3]
    return
  if 90 < SingleAnt.rotation < 180:
    SingleKey.x_pos = center_x - ((SingleAnt.rect[2] / 2) * abs(math.cos(math.radians(SingleAnt.rotation)))) - (SingleKey.rect[2] / 2)
    SingleKey.y_pos = center_y - ((SingleAnt.rect[3] / 2) * abs(math.sin(math.radians(SingleAnt.rotation)))) - (SingleKey.rect[3] / 2)
    return
  if SingleAnt.rotation == 180:
    SingleKey.x_pos = center_x - SingleAnt.rect[2]
    SingleKey.y_pos = center_y
    return
  if 180 < SingleAnt.rotation < 270:
    SingleKey.x_pos = center_x - ((SingleAnt.rect[2] / 2) * abs(math.cos(math.radians(SingleAnt.rotation)))) - (SingleKey.rect[2] / 2)
    SingleKey.y_pos = center_y + ((SingleAnt.rect[3] / 2) * abs(math.sin(math.radians(SingleAnt.rotation)))) - (SingleKey.rect[3] / 2)
    return
  if SingleAnt.rotation == 270:
    SingleKey.x_pos = center_x
    SingleKey.y_pos = center_y + SingleAnt.rect[3]
    return
  if 270 < SingleAnt.rotation <= 360:
    SingleKey.x_pos = center_x + ((SingleAnt.rect[2] / 2) * abs(math.cos(math.radians(SingleAnt.rotation)))) - (SingleKey.rect[2] / 2)
    SingleKey.y_pos = center_y + ((SingleAnt.rect[3] / 2) * abs(math.sin(math.radians(SingleAnt.rotation)))) - (SingleKey.rect[3] / 2)
    return


def find_ant_carrying_beetle_pos(SingleAnt):
  center_x, center_y = SingleAnt.x_pos + (SingleAnt.rect[2] / 2), SingleAnt.y_pos + (SingleAnt.rect[3] / 2)
  if SingleAnt.rotation == 0:
    BEETLE_FRIEND.x_pos = center_x + SingleAnt.rect[2]
    BEETLE_FRIEND.y_pos = center_y
    return
  if 0 < SingleAnt.rotation < 90:
    BEETLE_FRIEND.x_pos = center_x + ((SingleAnt.rect[2] / 2) * abs(math.cos(math.radians(SingleAnt.rotation)))) - (BEETLE_FRIEND.rect[2] / 2)
    BEETLE_FRIEND.y_pos = center_y - ((SingleAnt.rect[3] / 2) * abs(math.sin(math.radians(SingleAnt.rotation)))) - (BEETLE_FRIEND.rect[3] / 2)
    return
  if SingleAnt.rotation == 90:
    BEETLE_FRIEND.x_pos = center_x
    BEETLE_FRIEND.y_pos = center_y - SingleAnt.rect[3]
    return
  if 90 < SingleAnt.rotation < 180:
    BEETLE_FRIEND.x_pos = center_x - ((SingleAnt.rect[2] / 2) * abs(math.cos(math.radians(SingleAnt.rotation)))) - (BEETLE_FRIEND.rect[2] / 2)
    BEETLE_FRIEND.y_pos = center_y - ((SingleAnt.rect[3] / 2) * abs(math.sin(math.radians(SingleAnt.rotation)))) - (BEETLE_FRIEND.rect[3] / 2)
    return
  if SingleAnt.rotation == 180:
    BEETLE_FRIEND.x_pos = center_x - SingleAnt.rect[2]
    BEETLE_FRIEND.y_pos = center_y
    return
  if 180 < SingleAnt.rotation < 270:
    BEETLE_FRIEND.x_pos = center_x - ((SingleAnt.rect[2] / 2) * abs(math.cos(math.radians(SingleAnt.rotation)))) - (BEETLE_FRIEND.rect[2] / 2)
    BEETLE_FRIEND.y_pos = center_y + ((SingleAnt.rect[3] / 2) * abs(math.sin(math.radians(SingleAnt.rotation)))) - (BEETLE_FRIEND.rect[3] / 2)
    return
  if SingleAnt.rotation == 270:
    BEETLE_FRIEND.x_pos = center_x
    BEETLE_FRIEND.y_pos = center_y + SingleAnt.rect[3]
    return
  if 270 < SingleAnt.rotation <= 360:
    BEETLE_FRIEND.x_pos = center_x + ((SingleAnt.rect[2] / 2) * abs(math.cos(math.radians(SingleAnt.rotation)))) - (BEETLE_FRIEND.rect[2] / 2)
    BEETLE_FRIEND.y_pos = center_y + ((SingleAnt.rect[3] / 2) * abs(math.sin(math.radians(SingleAnt.rotation)))) - (BEETLE_FRIEND.rect[3] / 2)
    return


def update_ants():
  for SingleAnt in ANTS:
    update_ant(SingleAnt)


def update_ant(SingleAnt):
  global KEY_GRABBED_BY_PLAYER
  absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
  distance_between_player_and_ant = find_hypotnuse(abs(absolute_center_of_player_x - (SingleAnt.x_pos - ((1/2)*screen_width) + (SingleAnt.rect[2]/2))), abs(absolute_center_of_player_y - (SingleAnt.y_pos - ((1/2)*screen_height) + (SingleAnt.rect[3]/2))))
  for _ in range(1):
    if distance_between_player_and_ant <= 500:
      volume_distance_multiplier = 1 - (distance_between_player_and_ant / 500)
      if volume_distance_multiplier > 1:
        volume_distance_multiplier = 1
      if volume_distance_multiplier < 0:
        volume_distance_multiplier = 0
      SingleAnt.sound.set_volume(MixerSoundsLoudness['ANT'] * My_cached_info.current_sound_loudness * volume_distance_multiplier)
      if not SingleAnt.currently_playing_sound and My_cached_info.number_of_ant_sounds_being_played <= 4:
        My_cached_info.number_of_ant_sounds_being_played += 1
        SingleAnt.sound.play(-1)
        SingleAnt.currently_playing_sound = True
    else:
      if SingleAnt.currently_playing_sound:
        My_cached_info.number_of_ant_sounds_being_played -= 1
        SingleAnt.sound.stop()
        SingleAnt.currently_playing_sound = False
  orig_vel = SingleAnt.vel
  orig_orig_vel = SingleAnt.orig_vel
  SingleAnt.orig_vel *= My_cached_info.target_fps_over_fps
  SingleAnt.vel *= My_cached_info.target_fps_over_fps
  SingleAnt.time_since_last_search += delta_milliseconds
  SingleAnt.time_since_last_image_update += delta_milliseconds
  do_other_updates = False
  if SingleAnt.time_since_last_image_update > (80 + SingleAnt.random_image_update_time):
    do_other_updates = True
    SingleAnt.time_since_last_image_update = 0
    allow_update = True
    if SingleAnt.current_ant_frame == 1:
      allow_update = False
      SingleAnt.current_ant_frame = 2
      SingleAnt.current_image = SingleAnt.image2
      SingleAnt.GPU_current_image = SingleAnt.GPU_image2
    if SingleAnt.current_ant_frame == 2 and allow_update:
      SingleAnt.current_image = SingleAnt.image1
      SingleAnt.GPU_current_image = SingleAnt.GPU_image1
      SingleAnt.current_ant_frame = 1
  ant_col_points, ant_col_happened = find_collisions_with_offsets_with_map(MAP, SingleAnt, -(1/2) * screen_width, -(1/2) * screen_height)
#
  if (SingleAnt.is_searching or SingleAnt.found_a_misplaced_object) and SingleAnt.ant_type != 2:
    if SingleAnt.x_pos < SingleAnt.boundaries[0]:
      #SingleAnt.rotation = 0
      #SingleAnt.x_pos += SingleAnt.vel
      SingleAnt.is_searching = True
      SingleAnt.found_a_misplaced_object = False
      SingleAnt.vel = orig_vel
      SingleAnt.orig_vel = orig_orig_vel
      SingleAnt.returning_home = True
      #return
    if SingleAnt.x_pos > SingleAnt.boundaries[1]:
      #SingleAnt.rotation = 180
      #SingleAnt.x_pos -= SingleAnt.vel
      SingleAnt.is_searching = True
      SingleAnt.found_a_misplaced_object = False
      SingleAnt.vel = orig_vel
      SingleAnt.orig_vel = orig_orig_vel
      SingleAnt.returning_home = True
      #return
    if SingleAnt.y_pos < SingleAnt.boundaries[2]:
      #SingleAnt.rotation = 270
      #SingleAnt.y_pos += SingleAnt.vel
      SingleAnt.is_searching = True
      SingleAnt.found_a_misplaced_object = False
      SingleAnt.vel = orig_vel
      SingleAnt.orig_vel = orig_orig_vel
      SingleAnt.returning_home = True
      #return
    if SingleAnt.y_pos > SingleAnt.boundaries[3]:
      #SingleAnt.rotation = 90
      #SingleAnt.y_pos -= SingleAnt.vel
      SingleAnt.is_searching = True
      SingleAnt.found_a_misplaced_object = False
      SingleAnt.vel = orig_vel
      SingleAnt.orig_vel = orig_orig_vel
      SingleAnt.returning_home = True
      #return
#
  if SingleAnt.ant_type == 1:
    if SingleAnt.returning_home:
      SingleAnt.vel = SingleAnt.orig_vel
      direction_to_move = math.degrees(math.atan2(-(SingleAnt.orig_y_pos - SingleAnt.y_pos), (SingleAnt.orig_x_pos - SingleAnt.x_pos)))
      SingleAnt.x_pos += SingleAnt.vel * math.cos(math.radians(direction_to_move))
      SingleAnt.y_pos -= SingleAnt.vel * math.sin(math.radians(direction_to_move))
      if SingleAnt.orig_x_pos - (2 * SingleAnt.vel) <= SingleAnt.x_pos <= SingleAnt.orig_x_pos + (2 * SingleAnt.vel):
        if SingleAnt.orig_y_pos - (2 * SingleAnt.vel) <= SingleAnt.y_pos <= SingleAnt.orig_y_pos + (2 * SingleAnt.vel):
          SingleAnt.returning_home = False
      SingleAnt.rotation = direction_to_move
      SingleAnt.vel = orig_vel
      SingleAnt.orig_vel = orig_orig_vel
      return
#
    if SingleAnt.is_searching:
      SingleAnt.vel = SingleAnt.orig_vel
      if ant_col_happened:
        collisions_with_ant = list(set(ant_col_points))
        absolute_collision_points = [(i+SingleAnt.x_pos-((1/2) * screen_width), j+SingleAnt.y_pos-((1/2) * screen_height)) for [i, j] in collisions_with_ant]
        pixel_colors = check_pixels_for_color_exhaustive(absolute_collision_points, (255, 255, 0, 255))
        non_yellow_points = list(set(absolute_collision_points) - set(pixel_colors))
        if non_yellow_points == []:
          ant_col_happened = False
        if non_yellow_points != []:
          collisions_with_ant = [(i - SingleAnt.x_pos, j - SingleAnt.y_pos) for (i, j) in non_yellow_points]
        if ant_col_happened:
          avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, ant_col_points)
          avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
          SingleAnt.rotation = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
      if do_other_updates:
        SingleAnt.rotation += (random.randint(0,20) - 10)
        SingleAnt.rotation = SingleAnt.rotation % 360
      SingleAnt.currently_displayed_image = rotate_square_image(SingleAnt.current_image, SingleAnt.rotation)
      find_next_ant_pos(SingleAnt)
      if SingleAnt.y_pos - ((1/2) * screen_height) + 64 > MAP.rect[3] - 10:
        SingleAnt.rotation = 90
      if SingleAnt.y_pos - ((1/2) * screen_height) < 10:
        SingleAnt.rotation = 270
      if SingleAnt.x_pos - ((1/2) * screen_width) + 64 > MAP.rect[2] - 10:
        SingleAnt.rotation = 180
      if SingleAnt.x_pos - ((1/2) * screen_width) < 10:
        SingleAnt.rotation = 0
      if do_other_updates and (SingleAnt.time_since_last_search > 800):
        SingleAnt.time_since_last_search = 0
        index_being_checked = random.randint(0,len(ALLKEYS)-1)
        key_being_checked_for_misplacement = ALLKEYS[index_being_checked]
        if not key_being_checked_for_misplacement.is_inserted:
          if not ALLKEYS[index_being_checked].is_grabbed_by_ant and ALLKEYS[index_being_checked].key_type != 3:
            if key_being_checked_for_misplacement.x_pos != key_being_checked_for_misplacement.original_x_pos or key_being_checked_for_misplacement.y_pos != key_being_checked_for_misplacement.original_y_pos:
              if (key_being_checked_for_misplacement.x_pos - SingleAnt.check_x_range < SingleAnt.x_pos < key_being_checked_for_misplacement.x_pos + SingleAnt.check_x_range) and (key_being_checked_for_misplacement.y_pos - SingleAnt.check_y_range < SingleAnt.y_pos < key_being_checked_for_misplacement.y_pos + SingleAnt.check_y_range):
                SingleAnt.found_a_misplaced_object = True
                SingleAnt.is_searching = False
                SingleAnt.misplaced_object_index = index_being_checked
      SingleAnt.vel = orig_vel
      SingleAnt.orig_vel = orig_orig_vel
      return
#
    if SingleAnt.found_a_misplaced_object:
      if ALLKEYS[SingleAnt.misplaced_object_index].is_inserted or ALLKEYS[SingleAnt.misplaced_object_index].is_grabbed_by_ant:
        SingleAnt.is_searching = True
        SingleAnt.found_a_misplaced_object = False
      distance_between_object_and_ant = find_hypotnuse(SingleAnt.x_pos - ALLKEYS[SingleAnt.misplaced_object_index].x_pos, SingleAnt.y_pos - ALLKEYS[SingleAnt.misplaced_object_index].y_pos)
      if distance_between_object_and_ant < (SingleAnt.rect[2] / 2):
        SingleAnt.found_a_misplaced_object = False
        SingleAnt.is_returning_object = True
        ALLKEYS[SingleAnt.misplaced_object_index].is_grabbed_by_ant = True
        if ALLKEYS[SingleAnt.misplaced_object_index].is_grabbed_by_player:
          KEY_GRABBED_BY_PLAYER = False
          ALLKEYS[SingleAnt.misplaced_object_index].is_grabbed_by_player = False
          my_piston2.grapple_claw_x_pos, my_piston2.grapple_claw_y_pos = 0, 0
        ALLKEYS[SingleAnt.misplaced_object_index].cooldown_before_grabbing_again = 20
        ALLKEYS[SingleAnt.misplaced_object_index].is_grabbed_by_which_ant = ANTS.index(SingleAnt)
        SingleAnt.vel = orig_vel
        SingleAnt.orig_vel = orig_orig_vel
        return
      if distance_between_object_and_ant > SingleAnt.search_radius or ALLKEYS[SingleAnt.misplaced_object_index].is_grabbed_by_ant:
        SingleAnt.found_a_misplaced_object = False
        SingleAnt.is_searching = True
      if distance_between_object_and_ant <= SingleAnt.search_radius:
        find_ant_rotation_angle(SingleAnt, ALLKEYS[SingleAnt.misplaced_object_index].x_pos, ALLKEYS[SingleAnt.misplaced_object_index].y_pos)
        find_next_ant_pos(SingleAnt)
      SingleAnt.currently_displayed_image = rotate_square_image(SingleAnt.current_image, SingleAnt.rotation)
      SingleAnt.vel = orig_vel
      SingleAnt.orig_vel = orig_orig_vel
      return
#
    if SingleAnt.is_returning_object:
      if ALLKEYS[SingleAnt.misplaced_object_index].is_inserted:
        SingleAnt.is_searching = True
        SingleAnt.is_returning_object = False
      if SingleAnt.vel == SingleAnt.orig_vel:
        SingleAnt.vel *= SingleAnt.vel_multiplier
      distance_between_original_pos_and_ant = find_hypotnuse(SingleAnt.x_pos - ALLKEYS[SingleAnt.misplaced_object_index].original_x_pos, SingleAnt.y_pos - ALLKEYS[SingleAnt.misplaced_object_index].original_y_pos)
      if distance_between_original_pos_and_ant < (SingleAnt.rect[2] / 2):
        SingleAnt.is_searching = True
        SingleAnt.is_returning_object = False
        ALLKEYS[SingleAnt.misplaced_object_index].x_pos = ALLKEYS[SingleAnt.misplaced_object_index].original_x_pos
        ALLKEYS[SingleAnt.misplaced_object_index].y_pos = ALLKEYS[SingleAnt.misplaced_object_index].original_y_pos
        ALLKEYS[SingleAnt.misplaced_object_index].is_grabbed_by_which_ant = -1
        ALLKEYS[SingleAnt.misplaced_object_index].is_grabbed_by_ant = False
        SingleAnt.vel = orig_vel
        SingleAnt.orig_vel = orig_orig_vel
        SingleAnt.vel = SingleAnt.orig_vel
        return
      ALLKEYS[SingleAnt.misplaced_object_index].is_grabbed_by_ant = True
      find_ant_rotation_angle(SingleAnt, ALLKEYS[SingleAnt.misplaced_object_index].original_x_pos, ALLKEYS[SingleAnt.misplaced_object_index].original_y_pos)
      find_next_ant_pos(SingleAnt)
      SingleAnt.currently_displayed_image = rotate_square_image(SingleAnt.current_image, SingleAnt.rotation)
      find_ant_carrying_key_pos(SingleAnt, ALLKEYS[SingleAnt.misplaced_object_index])
      SingleAnt.vel = orig_vel
      SingleAnt.orig_vel = orig_orig_vel
      return
#
#
  if SingleAnt.ant_type == 2:
    if SingleAnt.is_searching:
      SingleAnt.vel = SingleAnt.orig_vel
      if ant_col_happened:
        collisions_with_ant = list(set(ant_col_points))
        absolute_collision_points = [(i+SingleAnt.x_pos-((1/2) * screen_width), j+SingleAnt.y_pos-((1/2) * screen_height)) for [i, j] in collisions_with_ant]
        pixel_colors = check_pixels_for_color_exhaustive(absolute_collision_points, (255, 255, 0, 255))
        non_yellow_points = list(set(absolute_collision_points) - set(pixel_colors))
        if non_yellow_points == []:
          ant_col_happened = False
        if non_yellow_points != []:
          collisions_with_ant = [(i - SingleAnt.x_pos, j - SingleAnt.y_pos) for (i, j) in non_yellow_points]
        if ant_col_happened:
          avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, ant_col_points)
          avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
          SingleAnt.rotation = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
      if do_other_updates:
        SingleAnt.rotation += (random.randint(0,20) - 10)
        SingleAnt.rotation = SingleAnt.rotation % 360
      SingleAnt.currently_displayed_image = rotate_square_image(SingleAnt.current_image, SingleAnt.rotation)
      find_next_ant_pos(SingleAnt)
      if SingleAnt.y_pos - ((1/2) * screen_height) + 64 > MAP.rect[3] - 10:
        SingleAnt.rotation = 90
      if SingleAnt.y_pos - ((1/2) * screen_height) < 10:
        SingleAnt.rotation = 270
      if SingleAnt.x_pos - ((1/2) * screen_width) + 64 > MAP.rect[2] - 10:
        SingleAnt.rotation = 180
      if SingleAnt.x_pos - ((1/2) * screen_width) < 10:
        SingleAnt.rotation = 0
      if BEETLE_FRIEND.stage_in_movement == 5 and BEETLE_FRIEND.substep > 21 and BEETLE_FRIEND.eaten == 0:
        if (0 < PLAYER.x_pos < 2250) and (5300 < PLAYER.y_pos < 6000):
          SingleAnt.found_a_misplaced_object = True
          SingleAnt.is_searching = False
      SingleAnt.vel = orig_vel
      SingleAnt.orig_vel = orig_orig_vel
      return
#
    if SingleAnt.found_a_misplaced_object:
      distance_between_object_and_ant = find_hypotnuse(SingleAnt.x_pos - BEETLE_FRIEND.x_pos, SingleAnt.y_pos - BEETLE_FRIEND.y_pos)
      if distance_between_object_and_ant < (SingleAnt.rect[2] / 2):
        SingleAnt.found_a_misplaced_object = False
        SingleAnt.is_returning_object = True
      find_ant_rotation_angle(SingleAnt, BEETLE_FRIEND.x_pos, BEETLE_FRIEND.y_pos)
      find_next_ant_pos(SingleAnt)
      SingleAnt.currently_displayed_image = rotate_square_image(SingleAnt.current_image, SingleAnt.rotation)
      SingleAnt.vel = orig_vel
      SingleAnt.orig_vel = orig_orig_vel
      return
#
    if SingleAnt.is_returning_object:
      BEETLE_FRIEND.eaten = 1
      if SingleAnt.vel == SingleAnt.orig_vel:
        SingleAnt.vel *= SingleAnt.vel_multiplier
      distance_between_original_pos_and_ant = find_hypotnuse(SingleAnt.x_pos - QueenAnt.x_pos - 615 + ((1/2)*BEETLE_FRIEND.rect[2]), SingleAnt.y_pos - QueenAnt.y_pos - 200 + ((1/2)*BEETLE_FRIEND.rect[3]))
      if distance_between_original_pos_and_ant < (SingleAnt.rect[2] / 2):
        BEETLE_FRIEND.eaten = 2
        SingleAnt.is_searching = True
        SingleAnt.is_returning_object = False
        SingleAnt.vel = orig_vel
        SingleAnt.orig_vel = orig_orig_vel
        SingleAnt.vel = SingleAnt.orig_vel
        return
      find_ant_rotation_angle(SingleAnt, QueenAnt.x_pos + 615 - ((1/2)*BEETLE_FRIEND.rect[2]), QueenAnt.y_pos + 200 - ((1/2)*BEETLE_FRIEND.rect[3]))
      find_next_ant_pos(SingleAnt)
      SingleAnt.currently_displayed_image = rotate_square_image(SingleAnt.current_image, SingleAnt.rotation)
      find_ant_carrying_beetle_pos(SingleAnt)
      SingleAnt.vel = orig_vel
      SingleAnt.orig_vel = orig_orig_vel
      return


def update_football_ants():
  if ANT_GRABBED_PLAYER:
    my_piston2.grapple_claw_x_pos, my_piston2.grapple_claw_y_pos = 0, 0
    GRAPPLED_TO_PLATFORM = False
    my_piston2.extension = 0
    Marker.x_pos, Marker.y_pos = 0, 0
    my_piston2.connected_to_map = False
    regular_piston_sheath_update()
    regular_update_GrapplePiston(my_piston2)
  for SingleAnt in ANTS:
    update_football_ant(SingleAnt)


def update_PlayerMoverAnts():
  if ANT_GRABBED_PLAYER:
    my_piston2.grapple_claw_x_pos, my_piston2.grapple_claw_y_pos = 0, 0
    GRAPPLED_TO_PLATFORM = False
    my_piston2.extension = 0
    Marker.x_pos, Marker.y_pos = 0, 0
    my_piston2.connected_to_map = False
    regular_piston_sheath_update()
    regular_update_GrapplePiston(my_piston2)
  for SingleAnt in PLAYER_MOVER_ANTS:
    update_PlayerMoverAnt(SingleAnt)



ANT_GRABBED_PLAYER = False


def update_football_ant(SingleAnt):
  absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
  distance_between_player_and_ant = find_hypotnuse(abs(absolute_center_of_player_x - (SingleAnt.x_pos - ((1/2)*screen_width) + (SingleAnt.rect[2]/2))), abs(absolute_center_of_player_y - (SingleAnt.y_pos - ((1/2)*screen_height) + (SingleAnt.rect[3]/2))))
  for _ in range(1):
    if distance_between_player_and_ant <= 500:
      volume_distance_multiplier = 1 - (distance_between_player_and_ant / 500)
      if volume_distance_multiplier > 1:
        volume_distance_multiplier = 1
      if volume_distance_multiplier < 0:
        volume_distance_multiplier = 0
      SingleAnt.sound.set_volume(MixerSoundsLoudness['ANT'] * My_cached_info.current_sound_loudness * volume_distance_multiplier)
      if not SingleAnt.currently_playing_sound and My_cached_info.number_of_ant_sounds_being_played <= 4:
        My_cached_info.number_of_ant_sounds_being_played += 1
        SingleAnt.sound.play(-1)
        SingleAnt.currently_playing_sound = True
    else:
      if SingleAnt.currently_playing_sound:
        My_cached_info.number_of_ant_sounds_being_played -= 1
        SingleAnt.sound.stop()
        SingleAnt.currently_playing_sound = False
  orig_vel = SingleAnt.vel
  SingleAnt.vel *= My_cached_info.target_fps_over_fps
  SingleAnt.time_since_last_search += delta_milliseconds
  SingleAnt.time_since_last_image_update += delta_milliseconds
  global ANT_GRABBED_PLAYER, GRAPPLED_TO_PLATFORM
  do_other_updates = False
  if SingleAnt.time_since_last_image_update > (80 + SingleAnt.random_image_update_time):
    SingleAnt.time_since_last_image_update = 0
    do_other_updates = True
    allow_update = True
    if SingleAnt.current_ant_frame == 1:
      allow_update = False
      SingleAnt.current_ant_frame = 2
      SingleAnt.current_image = SingleAnt.image2
      SingleAnt.GPU_current_image = SingleAnt.GPU_image2
    if SingleAnt.current_ant_frame == 2 and allow_update:
      SingleAnt.current_image = SingleAnt.image1
      SingleAnt.GPU_current_image = SingleAnt.GPU_image1
      SingleAnt.current_ant_frame = 1
  relative_player_x, relative_player_y = PLAYER.x_pos + ((1/2) * screen_width), PLAYER.y_pos + ((1/2) * screen_height)
  ant_col_points, ant_col_happened = find_collisions_with_offsets_with_map(MAP, SingleAnt, -(1/2) * screen_width, -(1/2) * screen_height)
#
  if SingleAnt.is_searching:
    if ANT_GRABBED_PLAYER:
      SingleAnt.is_searching = True
      SingleAnt.found_a_misplaced_object = False
      SingleAnt.rotation = 90
    if ant_col_happened:
      collisions_with_ant = list(set(ant_col_points))
      absolute_collision_points = [(i+SingleAnt.x_pos-((1/2) * screen_width), j+SingleAnt.y_pos-((1/2) * screen_height)) for [i, j] in collisions_with_ant]
      pixel_colors = check_pixels_for_color_exhaustive(absolute_collision_points, (255, 255, 0, 255))
      non_yellow_points = list(set(absolute_collision_points) - set(pixel_colors))
      if non_yellow_points == []:
        ant_col_happened = False
      if non_yellow_points != []:
        collisions_with_ant = [(i - SingleAnt.x_pos, j - SingleAnt.y_pos) for (i, j) in non_yellow_points]
      if ant_col_happened:
        avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, ant_col_points)
        avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
        SingleAnt.rotation = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
    if do_other_updates:
      SingleAnt.rotation += (random.randint(0,20) - 10)
      SingleAnt.rotation = SingleAnt.rotation % 360
    SingleAnt.currently_displayed_image = rotate_square_image(SingleAnt.current_image, SingleAnt.rotation)
    find_next_ant_pos(SingleAnt)
    if SingleAnt.y_pos - ((1/2) * screen_height) + 64 > MAP.rect[3] - 10:
      SingleAnt.rotation = 90
    if SingleAnt.y_pos - ((1/2) * screen_height) < 10:
      SingleAnt.rotation = 270
    if SingleAnt.x_pos - ((1/2) * screen_width) + 64 > MAP.rect[2] - 10:
      SingleAnt.rotation = 180
    if SingleAnt.x_pos - ((1/2) * screen_width) < 10:
      SingleAnt.rotation = 0
    if do_other_updates and (SingleAnt.time_since_last_search > 800):
      SingleAnt.time_since_last_search = 0
      if (relative_player_x - 1500 < SingleAnt.x_pos < relative_player_x + 1500) and (relative_player_y - 1500 < SingleAnt.y_pos < relative_player_y + 1500):
        SingleAnt.found_a_misplaced_object = True
        SingleAnt.is_searching = False
    SingleAnt.vel = orig_vel
    return
#
  if SingleAnt.found_a_misplaced_object:
    if ANT_GRABBED_PLAYER:
      SingleAnt.is_searching = True
      SingleAnt.found_a_misplaced_object = False
      SingleAnt.vel = orig_vel
      return
    distance_between_object_and_ant = find_hypotnuse(SingleAnt.x_pos - relative_player_x, SingleAnt.y_pos - relative_player_y)
    if distance_between_object_and_ant < (SingleAnt.rect[2] / 2):
      SingleAnt.found_a_misplaced_object = False
      SingleAnt.is_returning_object = True
      SingleAnt.vel = orig_vel
      SingleAnt.vel *= 3
      return
    if distance_between_object_and_ant > 1500:
      SingleAnt.found_a_misplaced_object = False
      SingleAnt.is_searching = True
    if distance_between_object_and_ant <= 1500:
      find_ant_rotation_angle(SingleAnt, relative_player_x, relative_player_y)
      find_next_ant_pos(SingleAnt)
    SingleAnt.currently_displayed_image = rotate_square_image(SingleAnt.current_image, SingleAnt.rotation)
    SingleAnt.vel = orig_vel
    return
#
  if SingleAnt.is_returning_object:
    ANT_GRABBED_PLAYER = True
    distance_between_original_pos_and_ant = find_hypotnuse(SingleAnt.x_pos - 1328 - ((1/2) * screen_width), SingleAnt.y_pos - 4841 - ((1/2) * screen_height))
    if distance_between_original_pos_and_ant < (SingleAnt.rect[2] / 2):
      SingleAnt.is_searching = True
      SingleAnt.is_returning_object = False
      PLAYER.x_pos = 1328
      PLAYER.y_pos = 4841
      PLAYER.x_vel, PLAYER.y_vel = 0, 0
      SingleAnt.vel = orig_vel
      SingleAnt.vel /= 3
      for AnAnt in ANTS:
        which_direction = random.randint(0,2)
        if which_direction == 0:
          AnAnt.rotation = 270
      ANT_GRABBED_PLAYER = False
      return
    find_ant_rotation_angle(SingleAnt, 1328 + ((1/2) * screen_width), 4841 + ((1/2) * screen_height))
    find_next_ant_pos(SingleAnt)
    SingleAnt.currently_displayed_image = rotate_square_image(SingleAnt.current_image, SingleAnt.rotation)
    find_ant_carrying_key_pos(SingleAnt, PLAYER)
    PLAYER.x_pos = PLAYER.x_pos - ((1/2) * screen_width)
    PLAYER.y_pos = PLAYER.y_pos - ((1/2) * screen_height)
    SingleAnt.vel = orig_vel
    return


def update_PlayerMoverAnt(SingleAnt):
  global ANT_GRABBED_PLAYER, GRAPPLED_TO_PLATFORM
  absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
  distance_between_player_and_ant = find_hypotnuse(abs(absolute_center_of_player_x - (SingleAnt.x_pos - ((1/2)*screen_width) + (SingleAnt.rect[2]/2))), abs(absolute_center_of_player_y - (SingleAnt.y_pos - ((1/2)*screen_height) + (SingleAnt.rect[3]/2))))
  for _ in range(1):
    if distance_between_player_and_ant <= 500:
      volume_distance_multiplier = 1 - (distance_between_player_and_ant / 500)
      if volume_distance_multiplier > 1:
        volume_distance_multiplier = 1
      if volume_distance_multiplier < 0:
        volume_distance_multiplier = 0
      SingleAnt.sound.set_volume(MixerSoundsLoudness['ANT'] * My_cached_info.current_sound_loudness * volume_distance_multiplier)
      if not SingleAnt.currently_playing_sound and My_cached_info.number_of_ant_sounds_being_played <= 4:
        My_cached_info.number_of_ant_sounds_being_played += 1
        SingleAnt.sound.play(-1)
        SingleAnt.currently_playing_sound = True
    else:
      if SingleAnt.currently_playing_sound:
        My_cached_info.number_of_ant_sounds_being_played -= 1
        SingleAnt.sound.stop()
        SingleAnt.currently_playing_sound = False
  orig_vel = SingleAnt.vel
  SingleAnt.vel *= My_cached_info.target_fps_over_fps
  SingleAnt.time_since_last_search += delta_milliseconds
  SingleAnt.time_since_last_image_update += delta_milliseconds
  do_other_updates = False
  if SingleAnt.time_since_last_image_update > (80 + SingleAnt.random_image_update_time):
    SingleAnt.time_since_last_image_update = 0
    do_other_updates = True
    allow_update = True
    if SingleAnt.current_ant_frame == 1:
      allow_update = False
      SingleAnt.current_ant_frame = 2
      SingleAnt.current_image = SingleAnt.image2
      SingleAnt.GPU_current_image = SingleAnt.GPU_image2
    if SingleAnt.current_ant_frame == 2 and allow_update:
      SingleAnt.current_image = SingleAnt.image1
      SingleAnt.GPU_current_image = SingleAnt.GPU_image1
      SingleAnt.current_ant_frame = 1
  relative_player_x, relative_player_y = PLAYER.x_pos + ((1/2) * screen_width), PLAYER.y_pos + ((1/2) * screen_height)
  ant_col_points, ant_col_happened = find_collisions_with_offsets_with_map(MAP, SingleAnt, -(1/2) * screen_width, -(1/2) * screen_height)
#
  if SingleAnt.is_searching:
    if ANT_GRABBED_PLAYER:
      SingleAnt.is_searching = True
      SingleAnt.found_a_misplaced_object = False
      SingleAnt.rotation = 90
    if ant_col_happened:
      collisions_with_ant = list(set(ant_col_points))
      absolute_collision_points = [(i+SingleAnt.x_pos-((1/2) * screen_width), j+SingleAnt.y_pos-((1/2) * screen_height)) for [i, j] in collisions_with_ant]
      pixel_colors = check_pixels_for_color_exhaustive(absolute_collision_points, (255, 255, 0, 255))
      non_yellow_points = list(set(absolute_collision_points) - set(pixel_colors))
      if non_yellow_points == []:
        ant_col_happened = False
      if non_yellow_points != []:
        collisions_with_ant = [(i - SingleAnt.x_pos, j - SingleAnt.y_pos) for (i, j) in non_yellow_points]
      if ant_col_happened:
        avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, ant_col_points)
        avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
        SingleAnt.rotation = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
    if do_other_updates:
      SingleAnt.rotation += (random.randint(0,20) - 10)
      SingleAnt.rotation = SingleAnt.rotation % 360
    SingleAnt.currently_displayed_image = rotate_square_image(SingleAnt.current_image, SingleAnt.rotation)
    find_next_ant_pos(SingleAnt)
    if SingleAnt.y_pos - ((1/2) * screen_height) + 64 > MAP.rect[3] - 10:
      SingleAnt.rotation = 90
    if SingleAnt.y_pos - ((1/2) * screen_height) < 10:
      SingleAnt.rotation = 270
    if SingleAnt.x_pos - ((1/2) * screen_width) + 64 > MAP.rect[2] - 10:
      SingleAnt.rotation = 180
    if SingleAnt.x_pos - ((1/2) * screen_width) < 10:
      SingleAnt.rotation = 0
    if do_other_updates and (SingleAnt.time_since_last_search > 800):
      if (relative_player_x - SingleAnt.vision_range_x < SingleAnt.x_pos < relative_player_x + SingleAnt.vision_range_x) and (relative_player_y - SingleAnt.vision_range_y < SingleAnt.y_pos < relative_player_y + SingleAnt.vision_range_y):
        for SingleRange in SingleAnt.ignore_pickup_range:
          if (SingleRange[0] <= PLAYER.x_pos <= SingleRange[1]) and (SingleRange[2] <= PLAYER.y_pos <= SingleRange[3]):
            SingleAnt.vel = orig_vel
            return
        SingleAnt.found_a_misplaced_object = True
        SingleAnt.is_searching = False
    SingleAnt.vel = orig_vel
    return
#
  if SingleAnt.found_a_misplaced_object:
    if ANT_GRABBED_PLAYER:
      SingleAnt.is_searching = True
      SingleAnt.found_a_misplaced_object = False
      SingleAnt.vel = orig_vel
      return
    distance_between_object_and_ant = find_hypotnuse(SingleAnt.x_pos - relative_player_x, SingleAnt.y_pos - relative_player_y)
    if distance_between_object_and_ant < (SingleAnt.rect[2] / 2):
      SingleAnt.found_a_misplaced_object = False
      SingleAnt.is_returning_object = True
      PLAYER.x_vel = 399
      SingleAnt.vel = orig_vel
      SingleAnt.vel *= SingleAnt.vel_multiplier
      return
    if distance_between_object_and_ant > find_hypotnuse(SingleAnt.vision_range_x, SingleAnt.vision_range_y):
      SingleAnt.found_a_misplaced_object = False
      SingleAnt.is_searching = True
    if distance_between_object_and_ant <= find_hypotnuse(SingleAnt.vision_range_x, SingleAnt.vision_range_y):
      find_ant_rotation_angle(SingleAnt, relative_player_x, relative_player_y)
      find_next_ant_pos(SingleAnt)
    SingleAnt.currently_displayed_image = rotate_square_image(SingleAnt.current_image, SingleAnt.rotation)
    SingleAnt.vel = orig_vel
    return
#
  if SingleAnt.is_returning_object:
    ANT_GRABBED_PLAYER = True
    global KEY_GRABBED_BY_PLAYER
    KEY_GRABBED_BY_PLAYER = False
    my_piston2.grapple_claw_x_pos = 0
    my_piston2.grapple_claw_y_pos = 0
    for SingleKey in ALLKEYS:
      if SingleKey.key_type == 3:
        if SingleKey.is_grabbed_by_player:
          SingleKey.key_type = 1
      SingleKey.is_grabbed_by_player = False
      SingleKey.cooldown_before_grabbing_again = 8
      if SingleKey.key_type == 2:
        SingleKey.rotation = find_relative_key_rotation(SingleKey)%360
    distance_between_original_pos_and_ant = find_hypotnuse(SingleAnt.x_pos - SingleAnt.x_dest - ((1/2) * screen_width), SingleAnt.y_pos - SingleAnt.y_dest - ((1/2) * screen_height))
    if MAP.region == 'TheDoor7':
      if distance_between_original_pos_and_ant < (screen_height / 1.33) + 30:
        ELEVATORS[0].x_pos = 1200+((1/2) * screen_width)
        ELEVATORS[0].y_pos = 572+((1/2) * screen_height)
        ELEVATORS[0].activated = 0
        ELEVATORS[0].current_floor = 2
        ELEVATORS[0].open_right = False
        ELEVATORS[0].open_left = True
        ELEVATORS[0].PlatformLeftTop_x_pos = ELEVATORS[0].x_pos + 1
        ELEVATORS[0].PlatformLeftTop_y_pos = ELEVATORS[0].y_pos + 1
        ELEVATORS[0].PlatformMiddleTop_x_pos = ELEVATORS[0].x_pos + 600 + 1
        ELEVATORS[0].PlatformMiddleTop_y_pos = ELEVATORS[0].y_pos + 1
        ELEVATORS[0].PlatformRightTop_x_pos = ELEVATORS[0].x_pos + 1200 + 1
        ELEVATORS[0].PlatformRightTop_y_pos = ELEVATORS[0].y_pos + 1
        ELEVATORS[0].PlatformLeftBottom_x_pos = ELEVATORS[0].x_pos + 1
        ELEVATORS[0].PlatformLeftBottom_y_pos = ELEVATORS[0].y_pos + 494 + 1
        ELEVATORS[0].PlatformMiddleBottom_x_pos = ELEVATORS[0].x_pos + 600 + 1
        ELEVATORS[0].PlatformMiddleBottom_y_pos = ELEVATORS[0].y_pos + 494 + 1
        ELEVATORS[0].PlatformRightBottom_x_pos = ELEVATORS[0].x_pos + 1200 + 1
        ELEVATORS[0].PlatformRightBottom_y_pos = ELEVATORS[0].y_pos + 494 + 1
        ELEVATORS[0].LeftMiddlePlatform_x_pos = ELEVATORS[0].x_pos + 356 + 1
        ELEVATORS[0].LeftMiddlePlatform_y_pos = ELEVATORS[0].y_pos + 247 + 1
        ELEVATORS[0].RightMiddlePlatform_x_pos = ELEVATORS[0].x_pos + 966 + 1
        ELEVATORS[0].RightMiddlePlatform_y_pos = ELEVATORS[0].y_pos + 247 + 1
        ELEVATORS[0].DownPeg1_x_pos = ELEVATORS[0].x_pos + 893 + 1
        ELEVATORS[0].DownPeg1_y_pos = ELEVATORS[0].y_pos + 47 + 1
        ELEVATORS[0].DownPeg2_x_pos = ELEVATORS[0].x_pos + 679 + 1
        ELEVATORS[0].DownPeg2_y_pos = ELEVATORS[0].y_pos + 294 + 1
        ELEVATORS[0].DownPeg3_x_pos = ELEVATORS[0].x_pos + 1107 + 1
        ELEVATORS[0].DownPeg3_y_pos = ELEVATORS[0].y_pos + 294 + 1
        ELEVATORS[0].UpPeg1_x_pos = ELEVATORS[0].x_pos + 496 + 1
        ELEVATORS[0].UpPeg1_y_pos = ELEVATORS[0].y_pos + 219 + 1 - 20
        ELEVATORS[0].UpPeg2_x_pos = ELEVATORS[0].x_pos + 1290 + 1
        ELEVATORS[0].UpPeg2_y_pos = ELEVATORS[0].y_pos + 219 + 1 - 20
        ELEVATORS[0].UpPeg3_x_pos = ELEVATORS[0].x_pos + 465 + 1
        ELEVATORS[0].UpPeg3_y_pos = ELEVATORS[0].y_pos + 466 + 1 - 20
        ELEVATORS[0].UpPeg4_x_pos = ELEVATORS[0].x_pos + 893 + 1
        ELEVATORS[0].UpPeg4_y_pos = ELEVATORS[0].y_pos + 466 + 1 - 20
        ELEVATORS[0].UpPeg5_x_pos = ELEVATORS[0].x_pos + 1321 + 1
        ELEVATORS[0].UpPeg5_y_pos = ELEVATORS[0].y_pos + 466 + 1 - 20
        ELEVATORS[0].LeftDoor_x_pos = ELEVATORS[0].x_pos + 16 + 1
        ELEVATORS[0].LeftDoor_y_pos = ELEVATORS[0].y_pos + 47 + 1
        ELEVATORS[0].RightDoor_x_pos = ELEVATORS[0].x_pos + 1749 + 1
        ELEVATORS[0].RightDoor_y_pos = ELEVATORS[0].y_pos + 47 + 1
    if distance_between_original_pos_and_ant < (SingleAnt.rect[2] / 2):
      SingleAnt.is_searching = True
      SingleAnt.is_returning_object = False
      PLAYER.x_pos = SingleAnt.x_dest
      PLAYER.y_pos = SingleAnt.y_dest
      PLAYER.x_vel, PLAYER.y_vel = 0.001, 0
      SingleAnt.vel = orig_vel
      SingleAnt.vel /= SingleAnt.vel_multiplier
      ANT_GRABBED_PLAYER = False
      return
    find_ant_rotation_angle(SingleAnt, SingleAnt.x_dest + ((1/2) * screen_width), SingleAnt.y_dest + ((1/2) * screen_height))
    find_next_ant_pos(SingleAnt)
    SingleAnt.currently_displayed_image = rotate_square_image(SingleAnt.current_image, SingleAnt.rotation)
    find_ant_carrying_key_pos(SingleAnt, PLAYER)
    PLAYER.x_pos = PLAYER.x_pos - ((1/2) * screen_width)
    PLAYER.y_pos = PLAYER.y_pos - ((1/2) * screen_height)
    SingleAnt.vel = orig_vel
    return



def find_squirrel_direction(SingleSquirrel, cur_x, cur_y, destination_x, destination_y):
  if cur_x == destination_x:
    if cur_y >= destination_y:
      return 90
    if cur_y < destination_y:
      return 270
  if cur_y == destination_y:
    if cur_x >= destination_x:
      return 180
    if cur_x < destination_x:
      return 0
  if destination_x > cur_x and destination_y < cur_y:
    return math.degrees(math.atan(abs(abs(cur_y - destination_y) / abs(cur_x - destination_x))))
  if destination_x < cur_x and destination_y < cur_y:
    return 180 - math.degrees(math.atan(abs(abs(cur_y - destination_y) / abs(cur_x - destination_x))))
  if destination_x < cur_x and destination_y > cur_y:
    return 180 + math.degrees(math.atan(abs(abs(cur_y - destination_y) / abs(cur_x - destination_x))))
  if destination_x > cur_x and destination_y > cur_y:
    return 360 - math.degrees(math.atan(abs(abs(cur_y - destination_y) / abs(cur_x - destination_x))))


def get_next_squirrel_pos(SingleSquirrel, cur_rot):
  if cur_rot == 0:
    SingleSquirrel.x_pos += SingleSquirrel.vel
    if SingleSquirrel.player_grappled_to_squirrel:
      my_piston2.grapple_claw_x_pos += SingleSquirrel.vel
      if my_piston2.extension != 0 and Currently_pressed_controls.pressed_controls['DETACH_GRAPPLING_HOOK']:
        PLAYER.x_vel += SingleSquirrel.vel * 50
        SingleSquirrel.player_grappled_to_squirrel = False
    return
  if cur_rot == 90:
    SingleSquirrel.y_pos -= SingleSquirrel.vel
    if SingleSquirrel.player_grappled_to_squirrel:
      my_piston2.grapple_claw_y_pos -= SingleSquirrel.vel
      if my_piston2.extension != 0 and Currently_pressed_controls.pressed_controls['DETACH_GRAPPLING_HOOK']:
        PLAYER.y_vel -= SingleSquirrel.vel * 50
        SingleSquirrel.player_grappled_to_squirrel = False
    return
  if cur_rot == 180:
    SingleSquirrel.x_pos -= SingleSquirrel.vel
    if SingleSquirrel.player_grappled_to_squirrel:
      my_piston2.grapple_claw_x_pos -= SingleSquirrel.vel
      if my_piston2.extension != 0 and Currently_pressed_controls.pressed_controls['DETACH_GRAPPLING_HOOK']:
        PLAYER.x_vel -= SingleSquirrel.vel * 50
        SingleSquirrel.player_grappled_to_squirrel = False
    return
  if cur_rot == 270:
    SingleSquirrel.y_pos += SingleSquirrel.vel
    if SingleSquirrel.player_grappled_to_squirrel:
      my_piston2.grapple_claw_y_pos += SingleSquirrel.vel
      if my_piston2.extension != 0 and Currently_pressed_controls.pressed_controls['DETACH_GRAPPLING_HOOK']:
        PLAYER.y_vel += SingleSquirrel.vel * 50
        SingleSquirrel.player_grappled_to_squirrel = False
    return
  if 0 < cur_rot < 90:
    SingleSquirrel.x_pos += SingleSquirrel.vel * abs(math.cos(math.radians(cur_rot)))
    SingleSquirrel.y_pos -= SingleSquirrel.vel * abs(math.sin(math.radians(cur_rot)))
    if SingleSquirrel.player_grappled_to_squirrel:
      my_piston2.grapple_claw_x_pos += SingleSquirrel.vel * abs(math.cos(math.radians(cur_rot)))
      my_piston2.grapple_claw_y_pos -= SingleSquirrel.vel * abs(math.sin(math.radians(cur_rot)))
      if my_piston2.extension != 0 and Currently_pressed_controls.pressed_controls['DETACH_GRAPPLING_HOOK']:
        PLAYER.x_vel += SingleSquirrel.vel * abs(math.cos(math.radians(cur_rot))) * 50
        PLAYER.y_vel -= SingleSquirrel.vel * abs(math.sin(math.radians(cur_rot))) * 50
        SingleSquirrel.player_grappled_to_squirrel = False
    return
  if 90 < cur_rot < 180:
    SingleSquirrel.x_pos -= SingleSquirrel.vel * abs(math.cos(math.radians(cur_rot)))
    SingleSquirrel.y_pos -= SingleSquirrel.vel * abs(math.sin(math.radians(cur_rot)))
    if SingleSquirrel.player_grappled_to_squirrel:
      my_piston2.grapple_claw_x_pos -= SingleSquirrel.vel * abs(math.cos(math.radians(cur_rot)))
      my_piston2.grapple_claw_y_pos -= SingleSquirrel.vel * abs(math.sin(math.radians(cur_rot)))
      if my_piston2.extension != 0 and Currently_pressed_controls.pressed_controls['DETACH_GRAPPLING_HOOK']:
        PLAYER.x_vel -= SingleSquirrel.vel * abs(math.cos(math.radians(cur_rot))) * 50
        PLAYER.y_vel -= SingleSquirrel.vel * abs(math.sin(math.radians(cur_rot))) * 50
        SingleSquirrel.player_grappled_to_squirrel = False
    return
  if 180 < cur_rot < 270:
    SingleSquirrel.x_pos -= SingleSquirrel.vel * abs(math.cos(math.radians(cur_rot)))
    SingleSquirrel.y_pos += SingleSquirrel.vel * abs(math.sin(math.radians(cur_rot)))
    if SingleSquirrel.player_grappled_to_squirrel:
      my_piston2.grapple_claw_x_pos -= SingleSquirrel.vel * abs(math.cos(math.radians(cur_rot)))
      my_piston2.grapple_claw_y_pos += SingleSquirrel.vel * abs(math.sin(math.radians(cur_rot)))
      if my_piston2.extension != 0 and Currently_pressed_controls.pressed_controls['DETACH_GRAPPLING_HOOK']:
        PLAYER.x_vel -= SingleSquirrel.vel * abs(math.cos(math.radians(cur_rot))) * 50
        PLAYER.y_vel += SingleSquirrel.vel * abs(math.sin(math.radians(cur_rot))) * 50
        SingleSquirrel.player_grappled_to_squirrel = False
    return
  if 270 < cur_rot < 360:
    SingleSquirrel.x_pos += SingleSquirrel.vel * abs(math.cos(math.radians(cur_rot)))
    SingleSquirrel.y_pos += SingleSquirrel.vel * abs(math.sin(math.radians(cur_rot)))
    if SingleSquirrel.player_grappled_to_squirrel:
      my_piston2.grapple_claw_x_pos += SingleSquirrel.vel * abs(math.cos(math.radians(cur_rot)))
      my_piston2.grapple_claw_y_pos += SingleSquirrel.vel * abs(math.sin(math.radians(cur_rot)))
      if my_piston2.extension != 0 and Currently_pressed_controls.pressed_controls['DETACH_GRAPPLING_HOOK']:
        PLAYER.x_vel += SingleSquirrel.vel * abs(math.cos(math.radians(cur_rot))) * 50
        PLAYER.y_vel += SingleSquirrel.vel * abs(math.sin(math.radians(cur_rot))) * 50
        SingleSquirrel.player_grappled_to_squirrel = False
    return


def update_squirrels():
  for SingleSquirrel in SQUIRRELS:
    orig_vel = SingleSquirrel.vel
    SingleSquirrel.vel *= My_cached_info.target_fps_over_fps
    if curr_time >= SingleSquirrel.update_image_at_milliseconds:
      SingleSquirrel.update_image_at_milliseconds = curr_time + (8*13)
      SingleSquirrel.current_image_number += 1
      if SingleSquirrel.current_image_number == 3:
        SingleSquirrel.current_image_number = 0
      SingleSquirrel.current_image = SingleSquirrel.images[SingleSquirrel.current_image_number]
      SingleSquirrel.GPU_current_image = SingleSquirrel.GPU_images[SingleSquirrel.current_image_number]
      SingleSquirrel.current_image = rotate_square_image(SingleSquirrel.current_image, SingleSquirrel.rotate_squirrel)
    if SingleSquirrel.current_cooldown_counter < SingleSquirrel.cooldown_before_moving_again:
      SingleSquirrel.current_cooldown_counter += delta_milliseconds
      SingleSquirrel.current_image_number = 0
      SingleSquirrel.current_image = SingleSquirrel.images[SingleSquirrel.current_image_number]
      SingleSquirrel.GPU_current_image = SingleSquirrel.GPU_images[SingleSquirrel.current_image_number]
      SingleSquirrel.current_image = rotate_square_image(SingleSquirrel.current_image, SingleSquirrel.rotate_squirrel)
      SingleSquirrel.vel = orig_vel
      continue
    if SingleSquirrel.moving_to_xy1:
      cur_rot = find_squirrel_direction(SingleSquirrel, SingleSquirrel.x_pos, SingleSquirrel.y_pos, SingleSquirrel.start_pos[0], SingleSquirrel.start_pos[1])
      get_next_squirrel_pos(SingleSquirrel, cur_rot)
      if SingleSquirrel.x_pos - SingleSquirrel.vel < SingleSquirrel.start_pos[0] < SingleSquirrel.x_pos + SingleSquirrel.vel and SingleSquirrel.y_pos - SingleSquirrel.vel < SingleSquirrel.start_pos[1] < SingleSquirrel.y_pos + SingleSquirrel.vel:
        SingleSquirrel.x_pos = SingleSquirrel.start_pos[0]
        SingleSquirrel.y_pos = SingleSquirrel.start_pos[1]
        SingleSquirrel.moving_to_xy2 = True
        SingleSquirrel.moving_to_xy1 = False
        SingleSquirrel.current_cooldown_counter = 0
      SingleSquirrel.vel = orig_vel
      continue
    if SingleSquirrel.moving_to_xy2:
      cur_rot = find_squirrel_direction(SingleSquirrel, SingleSquirrel.x_pos, SingleSquirrel.y_pos, SingleSquirrel.end_pos[0], SingleSquirrel.end_pos[1])
      get_next_squirrel_pos(SingleSquirrel, cur_rot)
      if SingleSquirrel.x_pos - SingleSquirrel.vel < SingleSquirrel.end_pos[0] < SingleSquirrel.x_pos + SingleSquirrel.vel and SingleSquirrel.y_pos - SingleSquirrel.vel < SingleSquirrel.end_pos[1] < SingleSquirrel.y_pos + SingleSquirrel.vel:
        SingleSquirrel.x_pos = SingleSquirrel.end_pos[0]
        SingleSquirrel.y_pos = SingleSquirrel.end_pos[1]
        SingleSquirrel.moving_to_xy2 = False
        SingleSquirrel.moving_to_xy1 = True
        SingleSquirrel.current_cooldown_counter = 0
      SingleSquirrel.vel = orig_vel
      continue


def get_next_Hawk_frame():
  absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
  distance_between_player_and_Hawk = find_hypotnuse(abs(absolute_center_of_player_x - (Hawk.x_pos - ((1/2)*screen_width) + (Hawk.rect[2]/2))), abs(absolute_center_of_player_y - (Hawk.y_pos - ((1/2)*screen_height) + (Hawk.rect[3]/2))))
  volume_distance_multiplier = 1 - (distance_between_player_and_Hawk / 800)
  if volume_distance_multiplier > 1:
    volume_distance_multiplier = 1
  if volume_distance_multiplier < 0:
    volume_distance_multiplier = 0
  MixerSounds['HAWK'].set_volume(MixerSoundsLoudness['HAWK'] * My_cached_info.current_sound_loudness * volume_distance_multiplier)
  if Hawk.my_step == 1: # Hawk is waiting at nest
    if Hawk.current_frame == 300:
      Hawk.current_frame = 1
      Hawk.my_step = 2
      return
    if Hawk.current_frame % 30 == 0:
      Hawk.image = Hawk.images[2]
      Hawk.GPU_current_image = Hawk.GPU_images[2]
    if (Hawk.current_frame + 15) % 30 == 0:
      Hawk.image = Hawk.images[3]
      Hawk.GPU_current_image = Hawk.GPU_images[3]
    Hawk.current_frame += 1
#
  if Hawk.my_step == 2: # Hawk is moving toward player
    if Hawk.current_frame == 1:
      Hawk.next_location_x = PLAYER.x_pos + ((1/2) * screen_width) - (Hawk.rect[2]/2)
      Hawk.next_location_y = PLAYER.y_pos + ((1/2) * screen_height) - (Hawk.rect[3]/2)
      Hawk.delta_x = Hawk.next_location_x - Hawk.x_pos
      Hawk.delta_y = Hawk.next_location_y - Hawk.y_pos
      Hawk.total_distance_to_cover = find_hypotnuse(Hawk.delta_x, Hawk.delta_y)
      Hawk.current_frame += 1
      return
    if -5 + Hawk.next_location_x < Hawk.x_pos < 5 + Hawk.next_location_x and -5 + Hawk.next_location_y < Hawk.y_pos < 5 + Hawk.next_location_y:
      Hawk.current_frame = 1
      Hawk.my_step = 3
      return
    if frame_counter != 1:
      Hawk.x_pos += Hawk.delta_x / (Hawk.total_distance_to_cover / 6)
      Hawk.y_pos += Hawk.delta_y / (Hawk.total_distance_to_cover / 6)
      if Hawk.delta_x >= 0 and (Hawk.current_frame % 20) == 1:
        Hawk.image = Hawk.images[2]
        Hawk.GPU_current_image = Hawk.GPU_images[2]
      if Hawk.delta_x >= 0 and ((Hawk.current_frame + 10) % 20) == 1:
        Hawk.image = Hawk.images[3]
        Hawk.GPU_current_image = Hawk.GPU_images[3]
        MixerSounds['HAWK'].play()
      if Hawk.delta_x < 0 and (Hawk.current_frame % 20) == 1:
        Hawk.image = Hawk.images[0]
        Hawk.GPU_current_image = Hawk.GPU_images[0]
      if Hawk.delta_x < 0 and ((Hawk.current_frame + 10) % 20) == 1:
        Hawk.image = Hawk.images[1]
        Hawk.GPU_current_image = Hawk.GPU_images[1]
        MixerSounds['HAWK'].play()
      Hawk.current_frame += 1
#
  if Hawk.my_step == 3: # Hawk waits at player location
    if ((Hawk.current_frame + 0) % 32) == 1:
      Hawk.image = Hawk.images[2]
      Hawk.GPU_current_image = Hawk.GPU_images[2]
    if ((Hawk.current_frame + 8) % 32) == 1:
      Hawk.image = Hawk.images[3]
      Hawk.GPU_current_image = Hawk.GPU_images[3]
      MixerSounds['HAWK'].play()
    if ((Hawk.current_frame + 16) % 32) == 1:
      Hawk.image = Hawk.images[0]
      Hawk.GPU_current_image = Hawk.GPU_images[0]
    if ((Hawk.current_frame + 24) % 32) == 1:
      Hawk.image = Hawk.images[1]
      Hawk.GPU_current_image = Hawk.GPU_images[1]
      MixerSounds['HAWK'].play()
    Hawk.current_frame += 1
    if Hawk.current_frame == 300:
      Hawk.current_frame = 1
      Hawk.my_step = 4
      return
#
  if Hawk.my_step == 4: # Hawk returns to nest
    if Hawk.current_frame == 1:
      Hawk.next_location_x = 2600 - 600 + ((1/2) * screen_width)
      Hawk.next_location_y = 2200 - 300 + ((1/2) * screen_height)
      Hawk.delta_x = Hawk.next_location_x - Hawk.x_pos
      Hawk.delta_y = Hawk.next_location_y - Hawk.y_pos
      Hawk.total_distance_to_cover = find_hypotnuse(Hawk.delta_x, Hawk.delta_y)
      Hawk.current_frame += 1
      return
    if -5 + Hawk.next_location_x < Hawk.x_pos < 5 + Hawk.next_location_x and -5 + Hawk.next_location_y < Hawk.y_pos < 5 + Hawk.next_location_y:
      Hawk.current_frame = 1
      Hawk.my_step = 1
      Hawk.image = Hawk.images[1]
      return
    if frame_counter != 1:
      Hawk.x_pos += Hawk.delta_x / (Hawk.total_distance_to_cover / 6)
      Hawk.y_pos += Hawk.delta_y / (Hawk.total_distance_to_cover / 6)
      if Hawk.delta_x >= 0 and (Hawk.current_frame % 20) == 1:
        Hawk.image = Hawk.images[2]
        Hawk.GPU_current_image = Hawk.GPU_images[2]
      if Hawk.delta_x >= 0 and ((Hawk.current_frame + 10) % 20) == 1:
        Hawk.image = Hawk.images[3]
        Hawk.GPU_current_image = Hawk.GPU_images[3]
        MixerSounds['HAWK'].play()
      if Hawk.delta_x < 0 and (Hawk.current_frame % 20) == 1:
        Hawk.image = Hawk.images[0]
        Hawk.GPU_current_image = Hawk.GPU_images[0]
      if Hawk.delta_x < 0 and ((Hawk.current_frame + 10) % 20) == 1:
        Hawk.image = Hawk.images[1]
        Hawk.GPU_current_image = Hawk.GPU_images[1]
        MixerSounds['HAWK'].play()
      Hawk.current_frame += 1
      return


def update_Hawk():
  if 1930 < PLAYER.x_pos < 3220 and 1520 < PLAYER.y_pos < 4180: # Hawk is active
    Hawk.nesting = False
    get_next_Hawk_frame()
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    distance_between_player_and_Hawk = find_hypotnuse(abs(absolute_center_of_player_x - Hawk.x_pos + ((1/2)*screen_width) - (Hawk.rect[2]/2)), abs(absolute_center_of_player_y - Hawk.y_pos + ((1/2)*screen_height) - (Hawk.rect[3]/2)))
    if distance_between_player_and_Hawk < (34 + 144):
      Hawk.current_image = Hawk.image
      hawk_collision_points, hawk_collision_happened = find_collisions_with_offsets(Hawk, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
      if hawk_collision_happened:
        if PLAYER.x_vel == 0 or PLAYER.y_vel == 0:
          PLAYER.x_vel += 1
          PLAYER.y_vel += 1
        avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, hawk_collision_points)
        avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
        normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
        current_motion = find_motion_angle(MAP, PLAYER)
        cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        for i in range(len(MY_VINES)):
          MY_VINES[i].is_the_player_swinging = False
        my_piston2.connected_to_map = False
        my_piston2.connected_to_vine = False
        KEY_GRABBED_BY_PLAYER = False
        for ACloud in CLOUDS:
          ACloud.connected_to_cloud = False
          ACloud.is_the_player_swinging = False
        for SingleKey in ALLKEYS:
          SingleKey.is_grabbed_by_player = False
        GRAPPLED_TO_PLATFORM = False
        Marker.x_pos, Marker.y_pos, Marker.prev_x_pos, Marker.prev_y_pos, my_piston2.grapple_claw_x_pos, my_piston2.grapple_claw_y_pos = 0, 0, 0, 0, 0, 0
        regular_piston_sheath_update()
        regular_update_GrapplePiston(my_piston2)
    my_piston1.x_pos, my_piston1.y_pos = PLAYER.x_pos - 241, PLAYER.y_pos - 241
    my_piston2.x_pos, my_piston2.y_pos = PLAYER.x_pos - 241, PLAYER.y_pos - 241
  else:
    if Hawk.my_step == 1:
      if 0 <= (My_cached_info.fake_frame_counter % 30) <= 15:
        Hawk.current_frame = 2
        Hawk.image = Hawk.images[2]
        Hawk.GPU_current_image = Hawk.GPU_images[2]
      if 15 < (My_cached_info.fake_frame_counter % 30) <= 30:
        Hawk.current_frame = 3
        Hawk.image = Hawk.images[3]
        Hawk.GPU_current_image = Hawk.GPU_images[3]
    if Hawk.my_step != 1:
      get_next_Hawk_frame()


def update_QueenAnt():
  #QueenAnt.milliseconds_since_started_existing += delta_milliseconds
  if BEETLE_FRIEND.eaten == 2:
    QueenAnt.beetle_frames_since_entering += 1
    BEETLE_FRIEND.x_pos -= 0.15*0.5
    BEETLE_FRIEND.y_pos -= 0.3*0.5
    QueenAnt.current_image = QueenAnt.images[((My_cached_info.fake_frame_counter % 20) // 10) + 7]
    QueenAnt.GPU_current_image = QueenAnt.GPU_images[((My_cached_info.fake_frame_counter % 20) // 10) + 7]
    if not QueenAnt.playing_sound1:
      MixerSounds['QUEEN_ANT_CHOMP'].play(-1)
      QueenAnt.playing_sound1 = True
    QueenAnt.playing_sound2 = True
    #if not QueenAnt.playing_sound2:
    #  if QueenAnt.beetle_frames_since_entering > 11:
    #    MixerSounds['QUEEN_ANT_CHOMP'].play(-1)
    #    QueenAnt.playing_sound2 = True
    if QueenAnt.beetle_frames_since_entering > 300:
      BEETLE_FRIEND.eaten = 3
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      MixerSounds['QUEEN_ANT_CHOMP'].stop()
      QueenAnt.playing_sound1 = False
      QueenAnt.playing_sound2 = False
  if QueenAnt.mouth_col:
    for _ in range(My_cached_info.whole_number_of_frames_this_frame):
      QueenAnt.frames_since_entering += 1
      PLAYER.x_pos = QueenAnt.x_pos + 560 - 34 - ((1/2)*screen_width) - (QueenAnt.frames_since_entering * 0.15)
      PLAYER.y_pos = QueenAnt.y_pos + 153 - 34 - ((1/2)*screen_height) - (QueenAnt.frames_since_entering * 0.3)
      QueenAnt.current_image = QueenAnt.images[((My_cached_info.fake_frame_counter % 20) // 10) + 7]
      QueenAnt.GPU_current_image = QueenAnt.GPU_images[((My_cached_info.fake_frame_counter % 20) // 10) + 7]
    return
  if BEETLE_FRIEND.eaten != 2:
    QueenAnt.current_image = QueenAnt.images[(My_cached_info.fake_frame_counter%120) // 10]
    QueenAnt.GPU_current_image = QueenAnt.GPU_images[(My_cached_info.fake_frame_counter%120) // 10]
  absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
  distance_between_player_and_QueenAnt = find_hypotnuse(abs(absolute_center_of_player_x - QueenAnt.x_pos + ((1/2)*screen_width) - (QueenAnt.rect[2]/2)), abs(absolute_center_of_player_y - QueenAnt.y_pos + ((1/2)*screen_height) - (QueenAnt.rect[3]/2)))
  if distance_between_player_and_QueenAnt <= 1300:
    ant_chomp_loudness = My_cached_info.current_sound_loudness * MixerSoundsLoudness['QUEEN_ANT_CHOMP'] * ((1300 - distance_between_player_and_QueenAnt) / 1300)
    if ant_chomp_loudness > (My_cached_info.current_sound_loudness * MixerSoundsLoudness['QUEEN_ANT_CHOMP']):
      ant_chomp_loudness = (My_cached_info.current_sound_loudness * MixerSoundsLoudness['QUEEN_ANT_CHOMP'])
    if ant_chomp_loudness < 0:
      ant_chomp_loudness = 0
    MixerSounds['QUEEN_ANT_CHOMP'].set_volume(ant_chomp_loudness)
  if distance_between_player_and_QueenAnt < (34 + 400):
    QueenAnt_collision_points, QueenAnt_collision_happened = find_collisions_with_offsets(QueenAnt, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
    if QueenAnt_collision_happened:
      if not QueenAnt.mouth_col:
        QueenAntMouth_collision_points, QueenAntMouth_collision_happened = find_collisions_with_offsets_mask(QueenAnt, pygame.mask.from_surface(QueenAnt.mouth_current_image), PLAYER, (1/2) * screen_width, (1/2) * screen_height)
        if QueenAntMouth_collision_happened:
          if BEETLE_FRIEND.eaten >= 3:
            QueenAnt.milliseconds_since_player_was_eaten += delta_milliseconds
            if not QueenAnt.playing_sound1:
              MixerSounds['QUEEN_ANT_CHOMP'].play(-1)
            if not QueenAnt.playing_sound2:
              if QueenAnt.milliseconds_since_player_was_eaten > 149:
                MixerSounds['QUEEN_ANT_CHOMP'].play(-1)
            PLAYER.x_vel, PLAYER.y_vel = 0, 0
            PLAYER.x_pos = QueenAnt.x_pos + 557 - 34 - ((1/2)*screen_width)
            PLAYER.y_pos = QueenAnt.y_pos + 153 - 34 - ((1/2)*screen_height)
            QueenAnt.mouth_col = True
            return
      QueenAntButt_collision_points, QueenAntButt_collision_happened = find_collisions_with_offsets_mask(QueenAnt, pygame.mask.from_surface(QueenAnt.butt_current_image), PLAYER, (1/2) * screen_width, (1/2) * screen_height)
      if not QueenAntButt_collision_happened:
        QueenAnt.allowed_to_poop = False
      if QueenAntButt_collision_happened:
        if QueenAnt.allowed_to_poop:
          for _ in range(My_cached_info.whole_number_of_frames_this_frame):
            PLAYER.x_vel, PLAYER.y_vel = 0, 0
            PLAYER.y_pos = 5735
            PLAYER.x_pos -= 0.75
            PLAYER.piston_Fx = 0
            PLAYER.piston_Fy = 0
            return
      avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, QueenAnt_collision_points)
      avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
      normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
      current_motion = find_motion_angle(MAP, PLAYER)
      cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
  absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
  if 526 <= absolute_center_of_player_x <= 942:
    if 5758 <= absolute_center_of_player_y <= 5931:
      if absolute_center_of_player_x >= 710:
        PLAYER.FNx += 2000
      if absolute_center_of_player_x <= 710:
        PLAYER.FNx -= 2000
  return


def update_MovingBouncies():
  if MOVING_BOUNCIES != []:
    for SingleMovingBouncy in MOVING_BOUNCIES:
      SingleMovingBouncy.x_pos = SingleMovingBouncy.orig_x_pos + SingleMovingBouncy.path_x[SingleMovingBouncy.which_iteration_in_path_x]
      SingleMovingBouncy.y_pos = SingleMovingBouncy.orig_y_pos + SingleMovingBouncy.path_y[SingleMovingBouncy.which_iteration_in_path_y]
      SingleMovingBouncy.rotation = SingleMovingBouncy.orig_rotation + SingleMovingBouncy.path_rotation[SingleMovingBouncy.which_iteration_in_path_rotation]
      SingleMovingBouncy.current_image = rotate_square_image(SingleMovingBouncy.image, SingleMovingBouncy.rotation)
      SingleMovingBouncy.current_rotation = SingleMovingBouncy.rotation
      SingleMovingBouncy.which_iteration_in_path_x += 1
      SingleMovingBouncy.which_iteration_in_path_y += 1
      SingleMovingBouncy.which_iteration_in_path_rotation += 1
      if SingleMovingBouncy.which_iteration_in_path_x == len(SingleMovingBouncy.path_x):
        SingleMovingBouncy.which_iteration_in_path_x = 0
      if SingleMovingBouncy.which_iteration_in_path_y == len(SingleMovingBouncy.path_y):
        SingleMovingBouncy.which_iteration_in_path_y = 0
      if SingleMovingBouncy.which_iteration_in_path_rotation == len(SingleMovingBouncy.path_rotation):
        SingleMovingBouncy.which_iteration_in_path_rotation = 0
      SingleMovingBouncy.collision_circle_x = SingleMovingBouncy.x_pos + (SingleMovingBouncy.rect[2]/2) - ((1/2) * screen_width)
      SingleMovingBouncy.collision_circle_y = SingleMovingBouncy.y_pos + (SingleMovingBouncy.rect[3]/2) - ((1/2) * screen_height)


def find_relative_player_rotation():
  center_x, center_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
  if center_x == 2400 and center_y == 2400:
    return 0
  if center_y == 2400:
    if center_x > 2400:
      return 0
    if center_x < 2400:
      return 180
  if center_x == 2400:
    if center_y > 2400:
      return 270
    if center_y < 2400:
      return 90
  relative_x, relative_y = center_x - 2400, center_y - 2400
  if center_x > 2400 and center_y < 2400:
    return abs(math.degrees(math.atan(abs(relative_y) / abs(relative_x))))
  if center_x < 2400 and center_y < 2400:
    return 180 - abs(math.degrees(math.atan(abs(relative_y) / abs(relative_x))))
  if center_x < 2400 and center_y > 2400:
    return 180 + abs(math.degrees(math.atan(abs(relative_y) / abs(relative_x))))
  if center_x > 2400 and center_y > 2400:
    return 360 - abs(math.degrees(math.atan(abs(relative_y) / abs(relative_x))))


def find_relative_key_rotation(SingleKey):
  center_x, center_y = SingleKey.x_pos + 34 - ((1/2)*screen_width), SingleKey.y_pos + 34 - ((1/2)*screen_height)
  if center_x == 2400 and center_y == 2400:
    return 0
  if center_y == 2400:
    if center_x > 2400:
      return 0
    if center_x < 2400:
      return 180
  if center_x == 2400:
    if center_y > 2400:
      return 270
    if center_y < 2400:
      return 90
  relative_x, relative_y = center_x - 2400, center_y - 2400
  if center_x > 2400 and center_y < 2400:
    return abs(math.degrees(math.atan(abs(relative_y) / abs(relative_x))))
  if center_x < 2400 and center_y < 2400:
    return 180 - abs(math.degrees(math.atan(abs(relative_y) / abs(relative_x))))
  if center_x < 2400 and center_y > 2400:
    return 180 + abs(math.degrees(math.atan(abs(relative_y) / abs(relative_x))))
  if center_x > 2400 and center_y > 2400:
    return 360 - abs(math.degrees(math.atan(abs(relative_y) / abs(relative_x))))


def find_flying_key_pos(SingleKey):
  if SingleKey.rotation == 0:
    SingleKey.x_pos = 2400 + SingleKey.flying_radius + ((1/2)*screen_width) - ((1/2)*SingleKey.rect[2])
    SingleKey.y_pos = 2400 + ((1/2)*screen_height) - ((1/2)*SingleKey.rect[3])
    return
  if 0 < SingleKey.rotation < 90:
    SingleKey.x_pos = 2400 + abs(SingleKey.flying_radius * math.cos(math.radians(SingleKey.rotation))) + ((1/2)*screen_width) - ((1/2)*SingleKey.rect[2])
    SingleKey.y_pos = 2400 - abs(SingleKey.flying_radius * math.sin(math.radians(SingleKey.rotation))) + ((1/2)*screen_height) - ((1/2)*SingleKey.rect[3])
    return
  if SingleKey.rotation == 90:
    SingleKey.x_pos = 2400 + ((1/2)*screen_width) - ((1/2)*SingleKey.rect[2])
    SingleKey.y_pos = 2400 - SingleKey.flying_radius + ((1/2)*screen_height) - ((1/2)*SingleKey.rect[3])
    return
  if 90 < SingleKey.rotation < 180:
    SingleKey.x_pos = 2400 - abs(SingleKey.flying_radius * math.cos(math.radians(SingleKey.rotation))) + ((1/2)*screen_width) - ((1/2)*SingleKey.rect[2])
    SingleKey.y_pos = 2400 - abs(SingleKey.flying_radius * math.sin(math.radians(SingleKey.rotation))) + ((1/2)*screen_height) - ((1/2)*SingleKey.rect[3])
    return
  if SingleKey.rotation == 180:
    SingleKey.x_pos = 2400 - SingleKey.flying_radius + ((1/2)*screen_width) - ((1/2)*SingleKey.rect[2])
    SingleKey.y_pos = 2400 + ((1/2)*screen_height) - ((1/2)*SingleKey.rect[3])
    return
  if 180 < SingleKey.rotation < 270:
    SingleKey.x_pos = 2400 - abs(SingleKey.flying_radius * math.cos(math.radians(SingleKey.rotation))) + ((1/2)*screen_width) - ((1/2)*SingleKey.rect[2])
    SingleKey.y_pos = 2400 + abs(SingleKey.flying_radius * math.sin(math.radians(SingleKey.rotation))) + ((1/2)*screen_height) - ((1/2)*SingleKey.rect[3])
    return
  if SingleKey.rotation == 270:
    SingleKey.x_pos = 2400 + ((1/2)*screen_width) - ((1/2)*SingleKey.rect[2])
    SingleKey.y_pos = 2400 + SingleKey.flying_radius + ((1/2)*screen_height) - ((1/2)*SingleKey.rect[3])
    return
  if 270 < SingleKey.rotation < 360:
    SingleKey.x_pos = 2400 + abs(SingleKey.flying_radius * math.cos(math.radians(SingleKey.rotation))) + ((1/2)*screen_width) - ((1/2)*SingleKey.rect[2])
    SingleKey.y_pos = 2400 + abs(SingleKey.flying_radius * math.sin(math.radians(SingleKey.rotation))) + ((1/2)*screen_height) - ((1/2)*SingleKey.rect[3])
    return


def find_next_key_angle(SingleKey, new_x, new_y):
  if SingleKey.x_pos == new_x and SingleKey.y_pos == new_y:
    return
  if SingleKey.x_pos == new_x:
    if SingleKey.y_pos > new_y:
      return 90
    if SingleKey.y_pos < new_y:
      return 270
  if SingleKey.y_pos == new_y:
    if SingleKey.x_pos > new_x:
      return 180
    if SingleKey.x_pos < new_x:
      return 0
  x_dif, y_dif = abs(SingleKey.x_pos - new_x), abs(SingleKey.y_pos - new_y)
  if (new_x > SingleKey.x_pos) and (new_y < SingleKey.y_pos):
    return abs(math.degrees(math.atan(y_dif / x_dif)))
  if (new_x < SingleKey.x_pos) and (new_y < SingleKey.y_pos):
    return 180 - abs(math.degrees(math.atan(y_dif / x_dif)))
  if (new_x < SingleKey.x_pos) and (new_y > SingleKey.y_pos):
    return 180 + abs(math.degrees(math.atan(y_dif / x_dif)))
  if (new_x > SingleKey.x_pos) and (new_y > SingleKey.y_pos):
    return 360 - abs(math.degrees(math.atan(y_dif / x_dif)))


def find_next_key_pos(SingleKey, cur_rot):
  cur_rot = cur_rot % 360
  if (cur_rot == 0) or (cur_rot == 360):
    SingleKey.x_pos += SingleKey.vel
  if 0 < cur_rot < 90:
    SingleKey.x_pos += abs(SingleKey.vel*math.cos(math.radians(cur_rot)))
    SingleKey.y_pos -= abs(SingleKey.vel*math.sin(math.radians(cur_rot)))
  if cur_rot == 90:
    SingleKey.y_pos -= SingleKey.vel
  if 90 < cur_rot < 180:
    SingleKey.x_pos -= abs(SingleKey.vel*math.cos(math.radians(cur_rot)))
    SingleKey.y_pos -= abs(SingleKey.vel*math.sin(math.radians(cur_rot)))
  if cur_rot == 180:
    SingleKey.x_pos -= SingleKey.vel
  if 180 < cur_rot < 270:
    SingleKey.x_pos -= abs(SingleKey.vel*math.cos(math.radians(cur_rot)))
    SingleKey.y_pos += abs(SingleKey.vel*math.sin(math.radians(cur_rot)))
  if cur_rot == 270:
    SingleKey.y_pos += SingleKey.vel
  if 270 < cur_rot < 360:
    SingleKey.x_pos += abs(SingleKey.vel*math.cos(math.radians(cur_rot)))
    SingleKey.y_pos += abs(SingleKey.vel*math.sin(math.radians(cur_rot)))


def update_keys():
  for SingleKey in ALLKEYS:
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    distance_between_player_and_key = find_hypotnuse(abs(absolute_center_of_player_x - (SingleKey.x_pos - ((1/2)*screen_width) + (SingleKey.rect[2]/2))), abs(absolute_center_of_player_y - (SingleKey.y_pos - ((1/2)*screen_height) + (SingleKey.rect[3]/2))))
    volume_distance_multiplier = 1 - (distance_between_player_and_key / 500)
    if volume_distance_multiplier > 1:
      volume_distance_multiplier = 1
    if volume_distance_multiplier < 0:
      volume_distance_multiplier = 0
    SingleKey.key_sound.set_volume(MixerSoundsLoudness['KEY'] * My_cached_info.current_sound_loudness * volume_distance_multiplier)
    SingleKey.image_rotation = 0
    if SingleKey.key_type == 1:
      if 0 <= (My_cached_info.fake_frame_counter % 12) < 12:
        if 12 <= (My_cached_info.fake_frame_counter % 24) <= 24:
          SingleKey.image = SingleKey.images[0]
          SingleKey.GPU_image = SingleKey.GPU_images[0]
          if SingleKey.can_play_sound:
            if volume_distance_multiplier > 0:
              SingleKey.key_sound.play()
          SingleKey.can_play_sound = False
        else:
          SingleKey.image = SingleKey.images[1]
          SingleKey.GPU_image = SingleKey.GPU_images[1]
          SingleKey.can_play_sound = True
      if SingleKey.is_grabbed_by_player:
        if 270 <= my_sheath.rotation%360 <= 360 or 0 <= my_sheath.rotation%360 <= 90:
          SingleKey.current_image = rotate_square_image(SingleKey.image, my_sheath.rotation)
          SingleKey.image_rotation = my_sheath.rotation
          continue
        if 90 < my_sheath.rotation%360 < 270:
          SingleKey.current_image = rotate_square_image(SingleKey.image, my_sheath.rotation+180)
          SingleKey.image_rotation = my_sheath.rotation + 180
          continue
      if SingleKey.is_grabbed_by_ant:
        my_rot = ANTS[SingleKey.is_grabbed_by_which_ant].rotation%360
        SingleKey.image_rotation = my_rot
        if 270 <= my_rot <= 360 or 0 <= my_rot <= 90:
          SingleKey.current_image = rotate_square_image(SingleKey.image, my_rot)
          SingleKey.image_rotation = my_rot
          continue
        if 90 < my_rot < 270:
          SingleKey.current_image = rotate_square_image(SingleKey.image, my_rot+180)
          SingleKey.image_rotation = my_rot + 180
          continue
      if SingleKey.is_inserted:
        SingleKey.current_image = SingleKey.images[0]
        SingleKey.GPU_current_image = SingleKey.GPU_images[0]
        SingleKey.image_rotation = 0
      else:
        SingleKey.current_image = SingleKey.image
        SingleKey.GPU_current_image = SingleKey.GPU_image
        SingleKey.image_rotation = 0
    #
    if SingleKey.key_type == 2:
      orig_vel = SingleKey.vel
      orig_x_vel = SingleKey.x_vel
      orig_y_vel = SingleKey.y_vel
      SingleKey.vel *= My_cached_info.target_fps_over_fps
      SingleKey.x_vel *= My_cached_info.target_fps_over_fps
      SingleKey.y_vel *= My_cached_info.target_fps_over_fps
      if 0 <= (My_cached_info.fake_frame_counter % 12) < 12:
        if 12 <= (My_cached_info.fake_frame_counter % 24) <= 24:
          SingleKey.image = SingleKey.images[0]
          SingleKey.GPU_image = SingleKey.GPU_images[0]
          if SingleKey.can_play_sound:
            if volume_distance_multiplier > 0:
              SingleKey.key_sound.play()
          SingleKey.can_play_sound = False
        else:
          SingleKey.image = SingleKey.images[1]
          SingleKey.GPU_image = SingleKey.GPU_images[1]
          SingleKey.can_play_sound = True
      if SingleKey.is_grabbed_by_player:
        if 270 <= my_sheath.rotation%360 <= 360 or 0 <= my_sheath.rotation%360 <= 90:
          SingleKey.current_image = rotate_square_image(SingleKey.image, my_sheath.rotation)
          SingleKey.image_rotation = my_sheath.rotation
          SingleKey.vel = orig_vel
          SingleKey.x_vel = orig_x_vel
          SingleKey.y_vel = orig_y_vel
          continue
        if 90 < my_sheath.rotation%360 < 270:
          SingleKey.current_image = rotate_square_image(SingleKey.image, my_sheath.rotation+180)
          SingleKey.image_rotation = my_sheath.rotation + 180
          SingleKey.vel = orig_vel
          SingleKey.x_vel = orig_x_vel
          SingleKey.y_vel = orig_y_vel
          continue
      if SingleKey.is_inserted:
        SingleKey.current_image = SingleKey.images[0]
      else:
        if SingleKey.flying_radius == 0:
          SingleKey.flying_radius = find_hypotnuse(2400 - SingleKey.x_pos + ((1/2)*screen_width), 2400 - SingleKey.y_pos + ((1/2)*screen_height)) - 34
        SingleKey.rotation = SingleKey.rotation%360
        SingleKey.orig_rotation = SingleKey.rotation
        relative_player_rotation = find_relative_player_rotation()
        relative_key_rotation = find_relative_key_rotation(SingleKey)
        current_angle_difference = find_angle_difference(relative_key_rotation, relative_player_rotation)
        if abs(current_angle_difference) > 110:
          SingleKey.allowed_to_move = False
          SingleKey.rotation = SingleKey.orig_rotation
          find_flying_key_pos(SingleKey)
          SingleKey.current_image = SingleKey.image
          SingleKey.vel = orig_vel
          SingleKey.x_vel = orig_x_vel
          SingleKey.y_vel = orig_y_vel
          continue
        if (110 > current_angle_difference > 0) and SingleKey.allowed_to_move: # key fly counterclockwise
          SingleKey.rotation += SingleKey.vel / SingleKey.flying_radius
          if 270 < SingleKey.rotation <= 360:
            SingleKey.current_image = rotate_square_image(SingleKey.image, -abs(90*((360 - SingleKey.rotation) / 90)))
            SingleKey.image_rotation = -abs(90*((360 - SingleKey.rotation) / 90))
          if 0 < SingleKey.rotation < 90:
            SingleKey.current_image = rotate_square_image(SingleKey.image, abs(90*((0 - SingleKey.rotation) / 90)))
            SingleKey.image_rotation = abs(90*((0 - SingleKey.rotation) / 90))
          if 90 < SingleKey.rotation <= 180:
            SingleKey.current_image = rotate_square_image(SingleKey.image, 90 +abs(90*((SingleKey.rotation - 90) / 90)))
            SingleKey.image_rotation = 90 +abs(90*((SingleKey.rotation - 90) / 90))
          if 180 < SingleKey.rotation <= 270:
            SingleKey.current_image = rotate_square_image(SingleKey.image, 180 +abs(90*((180 + SingleKey.rotation) / 90)))
            SingleKey.image_rotation = 180 +abs(90*((180 + SingleKey.rotation) / 90))
          find_flying_key_pos(SingleKey)
          SingleKey.allowed_to_move = True
          SingleKey.vel = orig_vel
          SingleKey.x_vel = orig_x_vel
          SingleKey.y_vel = orig_y_vel
          continue
        if -110 < current_angle_difference < 0 and SingleKey.allowed_to_move: # key fly clockwise
          SingleKey.rotation -= SingleKey.vel / SingleKey.flying_radius
          if (270 < SingleKey.rotation <= 360):
            SingleKey.current_image = rotate_square_image(SingleKey.image, 180 -abs(90*((360 - SingleKey.rotation) / 90)))
            SingleKey.image_rotation = 180 -abs(90*((360 - SingleKey.rotation) / 90))
          if 0 < SingleKey.rotation <= 90:
            SingleKey.current_image = rotate_square_image(SingleKey.image, 180 +abs(90*((0 - SingleKey.rotation) / 90)))
            SingleKey.image_rotation = 180 +abs(90*((0 - SingleKey.rotation) / 90))
          if 90 < SingleKey.rotation <= 180:
            SingleKey.current_image = rotate_square_image(SingleKey.image, -90 +abs(90*((SingleKey.rotation - 90) / 90)))
            SingleKey.image_rotation = -90 +abs(90*((SingleKey.rotation - 90) / 90))
          if 180 < SingleKey.rotation < 270:
            SingleKey.current_image = rotate_square_image(SingleKey.image, -0 +abs(90*((180 + SingleKey.rotation) / 90)))
            SingleKey.image_rotation = -0 +abs(90*((180 + SingleKey.rotation) / 90))
          find_flying_key_pos(SingleKey)
          SingleKey.allowed_to_move = True
          SingleKey.vel = orig_vel
          SingleKey.x_vel = orig_x_vel
          SingleKey.y_vel = orig_y_vel
          continue
        if abs(current_angle_difference) <= 100:
          SingleKey.allowed_to_move = True
          SingleKey.current_image = SingleKey.image
          SingleKey.vel = orig_vel
          SingleKey.x_vel = orig_x_vel
          SingleKey.y_vel = orig_y_vel
          continue
        else:
          SingleKey.current_image = SingleKey.image
          SingleKey.vel = orig_vel
          SingleKey.x_vel = orig_x_vel
          SingleKey.y_vel = orig_y_vel
          continue
    #
    if SingleKey.key_type == 3:
      orig_vel = SingleKey.vel
      orig_x_vel = SingleKey.x_vel
      orig_y_vel = SingleKey.y_vel
      SingleKey.vel *= My_cached_info.target_fps_over_fps
      SingleKey.x_vel *= My_cached_info.target_fps_over_fps
      SingleKey.y_vel *= My_cached_info.target_fps_over_fps
      dist_multiplier = 0.5
      xdist = (PLAYER.x_pos + PLAYER.rect[2]) - (SingleKey.x_pos + SingleKey.rect[2] - ((1/2)*screen_width))
      ydist = (PLAYER.y_pos + PLAYER.rect[3]) - (SingleKey.y_pos + SingleKey.rect[3] - ((1/2)*screen_height))
      distance_between_player_and_key = find_hypotnuse(xdist, ydist)
      if 0 <= (My_cached_info.fake_frame_counter % 12) < 12:
        if 12 <= (My_cached_info.fake_frame_counter % 24) <= 24:
          SingleKey.image = SingleKey.images[0]
          SingleKey.GPU_image = SingleKey.GPU_images[0]
          if SingleKey.can_play_sound:
            if volume_distance_multiplier > 0:
              SingleKey.key_sound.play()
          SingleKey.can_play_sound = False
        else:
          SingleKey.image = SingleKey.images[1]
          SingleKey.GPU_image = SingleKey.GPU_images[1]
          SingleKey.can_play_sound = True
      if SingleKey.is_grabbed_by_player:
        if 270 <= my_sheath.rotation%360 <= 360 or 0 <= my_sheath.rotation%360 <= 90:
          SingleKey.current_image = rotate_square_image(SingleKey.image, my_sheath.rotation)
          SingleKey.image_rotation = my_sheath.rotation
          SingleKey.vel = orig_vel
          SingleKey.x_vel = orig_x_vel
          SingleKey.y_vel = orig_y_vel
          continue
        if 90 < my_sheath.rotation%360 < 270:
          SingleKey.current_image = rotate_square_image(SingleKey.image, my_sheath.rotation+180)
          SingleKey.image_rotation = my_sheath.rotation + 180
          SingleKey.vel = orig_vel
          SingleKey.x_vel = orig_x_vel
          SingleKey.y_vel = orig_y_vel
          continue
      if SingleKey.is_inserted:
        SingleKey.current_image = SingleKey.images[0]
      else:
        SingleKey.current_image = SingleKey.image
      #
      if SingleKey.cur_xy_pos == 0:
        if (SingleKey.x_pos, SingleKey.y_pos) == SingleKey.xy_poses[SingleKey.cur_xy_pos]:
          if distance_between_player_and_key < 500:
            if abs(ydist) >= abs(xdist)*dist_multiplier:
              SingleKey.cur_xy_pos = random.randint(1,2)
            else:
              SingleKey.cur_xy_pos = 3
        else:
          cur_rot = find_next_key_angle(SingleKey, SingleKey.xy_poses[SingleKey.cur_xy_pos][0], SingleKey.xy_poses[SingleKey.cur_xy_pos][1])
          find_next_key_pos(SingleKey, cur_rot)
          distance_between_key_and_destination = find_hypotnuse(abs(SingleKey.x_pos - SingleKey.xy_poses[SingleKey.cur_xy_pos][0]), abs(SingleKey.y_pos - SingleKey.xy_poses[SingleKey.cur_xy_pos][1]))
          if distance_between_key_and_destination < SingleKey.vel:
            SingleKey.x_pos, SingleKey.y_pos = SingleKey.xy_poses[SingleKey.cur_xy_pos][0], SingleKey.xy_poses[SingleKey.cur_xy_pos][1]
          SingleKey.current_image = rotate_square_image(SingleKey.current_image, cur_rot - 90)
          SingleKey.image_rotation = cur_rot - 90
        SingleKey.vel = orig_vel
        SingleKey.x_vel = orig_x_vel
        SingleKey.y_vel = orig_y_vel
        continue
      #
      if SingleKey.cur_xy_pos == 1:
        if (SingleKey.x_pos, SingleKey.y_pos) == SingleKey.xy_poses[SingleKey.cur_xy_pos]:
          if distance_between_player_and_key < 500:
            if abs(ydist) >= abs(xdist)*dist_multiplier:
              SingleKey.cur_xy_pos = random.randint(0,1)
              if SingleKey.cur_xy_pos == 1:
                SingleKey.cur_xy_pos = 2
            else:
              SingleKey.cur_xy_pos = 4
        else:
          cur_rot = find_next_key_angle(SingleKey, SingleKey.xy_poses[SingleKey.cur_xy_pos][0], SingleKey.xy_poses[SingleKey.cur_xy_pos][1])
          find_next_key_pos(SingleKey, cur_rot)
          distance_between_key_and_destination = find_hypotnuse(abs(SingleKey.x_pos - SingleKey.xy_poses[SingleKey.cur_xy_pos][0]), abs(SingleKey.y_pos - SingleKey.xy_poses[SingleKey.cur_xy_pos][1]))
          if distance_between_key_and_destination < SingleKey.vel:
            SingleKey.x_pos, SingleKey.y_pos = SingleKey.xy_poses[SingleKey.cur_xy_pos][0], SingleKey.xy_poses[SingleKey.cur_xy_pos][1]
          SingleKey.current_image = rotate_square_image(SingleKey.current_image, cur_rot - 90)
          SingleKey.image_rotation = cur_rot - 90
        SingleKey.vel = orig_vel
        SingleKey.x_vel = orig_x_vel
        SingleKey.y_vel = orig_y_vel
        continue
      #
      if SingleKey.cur_xy_pos == 2:
        if (SingleKey.x_pos, SingleKey.y_pos) == SingleKey.xy_poses[SingleKey.cur_xy_pos]:
          if distance_between_player_and_key < 500:
            if abs(ydist) >= abs(xdist)*dist_multiplier:
              SingleKey.cur_xy_pos = random.randint(0,1)
            else:
              SingleKey.cur_xy_pos = 5
        else:
          cur_rot = find_next_key_angle(SingleKey, SingleKey.xy_poses[SingleKey.cur_xy_pos][0], SingleKey.xy_poses[SingleKey.cur_xy_pos][1])
          find_next_key_pos(SingleKey, cur_rot)
          distance_between_key_and_destination = find_hypotnuse(abs(SingleKey.x_pos - SingleKey.xy_poses[SingleKey.cur_xy_pos][0]), abs(SingleKey.y_pos - SingleKey.xy_poses[SingleKey.cur_xy_pos][1]))
          if distance_between_key_and_destination < SingleKey.vel:
            SingleKey.x_pos, SingleKey.y_pos = SingleKey.xy_poses[SingleKey.cur_xy_pos][0], SingleKey.xy_poses[SingleKey.cur_xy_pos][1]
          SingleKey.current_image = rotate_square_image(SingleKey.current_image, cur_rot - 90)
          SingleKey.image_rotation = cur_rot - 90
        SingleKey.vel = orig_vel
        SingleKey.x_vel = orig_x_vel
        SingleKey.y_vel = orig_y_vel
        continue
      #
      if SingleKey.cur_xy_pos == 3:
        if (SingleKey.x_pos, SingleKey.y_pos) == SingleKey.xy_poses[SingleKey.cur_xy_pos]:
          if distance_between_player_and_key < 500:
            if abs(ydist) >= abs(xdist)*dist_multiplier:
              SingleKey.cur_xy_pos = random.randint(4,5)
            else:
              SingleKey.cur_xy_pos = 0
        else:
          cur_rot = find_next_key_angle(SingleKey, SingleKey.xy_poses[SingleKey.cur_xy_pos][0], SingleKey.xy_poses[SingleKey.cur_xy_pos][1])
          find_next_key_pos(SingleKey, cur_rot)
          distance_between_key_and_destination = find_hypotnuse(abs(SingleKey.x_pos - SingleKey.xy_poses[SingleKey.cur_xy_pos][0]), abs(SingleKey.y_pos - SingleKey.xy_poses[SingleKey.cur_xy_pos][1]))
          if distance_between_key_and_destination < SingleKey.vel:
            SingleKey.x_pos, SingleKey.y_pos = SingleKey.xy_poses[SingleKey.cur_xy_pos][0], SingleKey.xy_poses[SingleKey.cur_xy_pos][1]
          SingleKey.current_image = rotate_square_image(SingleKey.current_image, cur_rot - 90)
          SingleKey.image_rotation = cur_rot - 90
        SingleKey.vel = orig_vel
        SingleKey.x_vel = orig_x_vel
        SingleKey.y_vel = orig_y_vel
        continue
      #
      if SingleKey.cur_xy_pos == 4:
        if (SingleKey.x_pos, SingleKey.y_pos) == SingleKey.xy_poses[SingleKey.cur_xy_pos]:
          if distance_between_player_and_key < 500:
            if abs(ydist) >= abs(xdist)*dist_multiplier:
              SingleKey.cur_xy_pos = random.randint(3,4)
              if SingleKey.cur_xy_pos == 4:
                SingleKey.cur_xy_pos = 5
            else:
              SingleKey.cur_xy_pos = 1
        else:
          cur_rot = find_next_key_angle(SingleKey, SingleKey.xy_poses[SingleKey.cur_xy_pos][0], SingleKey.xy_poses[SingleKey.cur_xy_pos][1])
          find_next_key_pos(SingleKey, cur_rot)
          distance_between_key_and_destination = find_hypotnuse(abs(SingleKey.x_pos - SingleKey.xy_poses[SingleKey.cur_xy_pos][0]), abs(SingleKey.y_pos - SingleKey.xy_poses[SingleKey.cur_xy_pos][1]))
          if distance_between_key_and_destination < SingleKey.vel:
            SingleKey.x_pos, SingleKey.y_pos = SingleKey.xy_poses[SingleKey.cur_xy_pos][0], SingleKey.xy_poses[SingleKey.cur_xy_pos][1]
          SingleKey.current_image = rotate_square_image(SingleKey.current_image, cur_rot - 90)
          SingleKey.image_rotation = cur_rot - 90
        SingleKey.vel = orig_vel
        SingleKey.x_vel = orig_x_vel
        SingleKey.y_vel = orig_y_vel
        continue
      #
      if SingleKey.cur_xy_pos == 5:
        if (SingleKey.x_pos, SingleKey.y_pos) == SingleKey.xy_poses[SingleKey.cur_xy_pos]:
          if distance_between_player_and_key < 500:
            if abs(ydist) >= abs(xdist)*dist_multiplier:
              SingleKey.cur_xy_pos = random.randint(3,4)
            else:
              SingleKey.cur_xy_pos = 2
        else:
          cur_rot = find_next_key_angle(SingleKey, SingleKey.xy_poses[SingleKey.cur_xy_pos][0], SingleKey.xy_poses[SingleKey.cur_xy_pos][1])
          find_next_key_pos(SingleKey, cur_rot)
          distance_between_key_and_destination = find_hypotnuse(abs(SingleKey.x_pos - SingleKey.xy_poses[SingleKey.cur_xy_pos][0]), abs(SingleKey.y_pos - SingleKey.xy_poses[SingleKey.cur_xy_pos][1]))
          if distance_between_key_and_destination < SingleKey.vel:
            SingleKey.x_pos, SingleKey.y_pos = SingleKey.xy_poses[SingleKey.cur_xy_pos][0], SingleKey.xy_poses[SingleKey.cur_xy_pos][1]
          SingleKey.current_image = rotate_square_image(SingleKey.current_image, cur_rot - 90)
          SingleKey.image_rotation = cur_rot - 90
        SingleKey.vel = orig_vel
        SingleKey.x_vel = orig_x_vel
        SingleKey.y_vel = orig_y_vel
        continue


def update_elevator(SingleElevator):
  if SingleElevator.activated == 0:
    if SingleElevator.x_pos == SingleElevator.x1 and SingleElevator.y_pos == SingleElevator.y1:
      if SingleElevator.left_door_open_at_bottom:
        SingleElevator.current_image = SingleElevator.images[((SingleElevator.number_of_frames - 1) // 2)]
        SingleElevator.GPU_current_image = SingleElevator.GPU_images[((SingleElevator.number_of_frames - 1) // 2)]
      if SingleElevator.right_door_open_at_bottom:
        SingleElevator.current_image = SingleElevator.images[int(SingleElevator.number_of_frames - 1)]
        SingleElevator.GPU_current_image = SingleElevator.GPU_images[int(SingleElevator.number_of_frames - 1)]
    if SingleElevator.x_pos == SingleElevator.x2 and SingleElevator.y_pos == SingleElevator.y2:
      if SingleElevator.left_door_open_at_top:
        SingleElevator.current_image = SingleElevator.images[((SingleElevator.number_of_frames - 1) // 2)]
        SingleElevator.GPU_current_image = SingleElevator.GPU_images[((SingleElevator.number_of_frames - 1) // 2)]
      if SingleElevator.right_door_open_at_top:
        SingleElevator.current_image = SingleElevator.images[int(SingleElevator.number_of_frames - 1)]
        SingleElevator.GPU_current_image = SingleElevator.GPU_images[int(SingleElevator.number_of_frames - 1)]
    if SingleElevator.x_pos + SingleElevator.wasted_left_space + 20 - ((1/2)*screen_width) <= PLAYER.x_pos <= SingleElevator.x_pos + SingleElevator.rect[2] - SingleElevator.wasted_right_space - 69 - 20 - ((1/2)*screen_width) and SingleElevator.y_pos + SingleElevator.wasted_top_space - 20 - ((1/2)*screen_height) <= PLAYER.y_pos <= SingleElevator.y_pos + SingleElevator.rect[3] - SingleElevator.wasted_bottom_space - ((1/2)*screen_height):
      SingleElevator.activated = 1
      SingleElevator.player_is_inside = True
      return
    else:
      return
  #
  if SingleElevator.activated == 1:
    if SingleElevator.x_pos + SingleElevator.wasted_left_space - 10 - ((1/2)*screen_width) <= PLAYER.x_pos <= SingleElevator.x_pos + SingleElevator.rect[2] - SingleElevator.wasted_right_space - 69 + 10 - ((1/2)*screen_width) and SingleElevator.y_pos + SingleElevator.wasted_top_space - 20 - ((1/2)*screen_height) <= PLAYER.y_pos <= SingleElevator.y_pos + SingleElevator.rect[3] - SingleElevator.wasted_bottom_space - ((1/2)*screen_height):
      SingleElevator.player_is_inside = True
      if SingleElevator.how_open_left == 0 and SingleElevator.how_open_right == 0:
        SingleElevator.current_image = SingleElevator.images[0]
        SingleElevator.GPU_current_image = SingleElevator.GPU_images[0]
        if SingleElevator.current_floor == 1:
          if SingleElevator.y_pos > SingleElevator.y2:
            SingleElevator.y_pos -= SingleElevator.vel
            PLAYER.y_pos -= SingleElevator.vel
          if SingleElevator.y_pos < SingleElevator.y2:
            SingleElevator.y_pos += SingleElevator.vel
            PLAYER.y_pos += SingleElevator.vel
          if SingleElevator.y_pos - SingleElevator.vel <= SingleElevator.y2 <= SingleElevator.y_pos + SingleElevator.vel:
            SingleElevator.x_pos, SingleElevator.y_pos = SingleElevator.x2, SingleElevator.y2
            SingleElevator.activated = 2
            SingleElevator.current_floor = 2
        if SingleElevator.current_floor == 2:
          if SingleElevator.y_pos > SingleElevator.y1:
            SingleElevator.y_pos -= SingleElevator.vel
            PLAYER.y_pos -= SingleElevator.vel
          if SingleElevator.y_pos < SingleElevator.y1:
            SingleElevator.y_pos += SingleElevator.vel
            PLAYER.y_pos += SingleElevator.vel
          if SingleElevator.y_pos - SingleElevator.vel <= SingleElevator.y1 <= SingleElevator.y_pos + SingleElevator.vel:
            SingleElevator.x_pos, SingleElevator.y_pos = SingleElevator.x1, SingleElevator.y1
            SingleElevator.activated = 2
            SingleElevator.current_floor = 1
        return
      if SingleElevator.how_open_left != 0:
        SingleElevator.current_image = SingleElevator.images[SingleElevator.how_open_left]
        SingleElevator.GPU_current_image = SingleElevator.GPU_images[SingleElevator.how_open_left]
        SingleElevator.how_open_left -= 1
        return
      if SingleElevator.how_open_right != 0:
        SingleElevator.current_image = SingleElevator.images[SingleElevator.how_open_right + ((SingleElevator.number_of_frames - 1) // 2)]
        SingleElevator.GPU_current_image = SingleElevator.GPU_images[SingleElevator.how_open_right + ((SingleElevator.number_of_frames - 1) // 2)]
        SingleElevator.how_open_right -= 1
        return
    else:
      if SingleElevator.current_floor == 1:
        if SingleElevator.left_door_open_at_bottom:
          if SingleElevator.how_open_left != ((SingleElevator.number_of_frames - 1) // 2):
            SingleElevator.how_open_left += 1
            SingleElevator.current_image = SingleElevator.images[SingleElevator.how_open_left]
            SingleElevator.GPU_current_image = SingleElevator.GPU_images[SingleElevator.how_open_left]
            return
        if SingleElevator.right_door_open_at_bottom:
          if SingleElevator.how_open_right != ((SingleElevator.number_of_frames - 1) // 2):
            SingleElevator.how_open_right += 1
            SingleElevator.current_image = SingleElevator.images[SingleElevator.how_open_right + ((SingleElevator.number_of_frames - 1) // 2)]
            SingleElevator.GPU_current_image = SingleElevator.GPU_images[SingleElevator.how_open_right + ((SingleElevator.number_of_frames - 1) // 2)]
            return
      if SingleElevator.current_floor == 2:
        if SingleElevator.left_door_open_at_top:
          if SingleElevator.how_open_left != ((SingleElevator.number_of_frames - 1) // 2):
            SingleElevator.how_open_left += 1
            SingleElevator.current_image = SingleElevator.images[SingleElevator.how_open_left]
            SingleElevator.GPU_current_image = SingleElevator.GPU_images[SingleElevator.how_open_left]
            return
        if SingleElevator.right_door_open_at_top:
          if SingleElevator.how_open_right != ((SingleElevator.number_of_frames - 1) // 2):
            SingleElevator.how_open_right += 1
            SingleElevator.current_image = SingleElevator.images[SingleElevator.how_open_right + ((SingleElevator.number_of_frames - 1) // 2)]
            SingleElevator.GPU_current_image = SingleElevator.GPU_images[SingleElevator.how_open_right + ((SingleElevator.number_of_frames - 1) // 2)]
            return
      SingleElevator.activated = 0
      return
  #
  if SingleElevator.activated == 2:
    if SingleElevator.current_floor == 1:
      if SingleElevator.left_door_open_at_bottom:
        if SingleElevator.how_open_left != ((SingleElevator.number_of_frames - 1) // 2):
          SingleElevator.how_open_left += 1
          SingleElevator.current_image = SingleElevator.images[SingleElevator.how_open_left]
          SingleElevator.GPU_current_image = SingleElevator.GPU_images[SingleElevator.how_open_left]
      if SingleElevator.right_door_open_at_bottom:
        if SingleElevator.how_open_right != ((SingleElevator.number_of_frames - 1) // 2):
          SingleElevator.how_open_right += 1
          SingleElevator.current_image = SingleElevator.images[SingleElevator.how_open_right + ((SingleElevator.number_of_frames - 1) // 2)]
          SingleElevator.GPU_current_image = SingleElevator.GPU_images[SingleElevator.how_open_right + ((SingleElevator.number_of_frames - 1) // 2)]
    if SingleElevator.current_floor == 2:
      if SingleElevator.left_door_open_at_top:
        if SingleElevator.how_open_left != ((SingleElevator.number_of_frames - 1) // 2):
          SingleElevator.how_open_left += 1
          SingleElevator.current_image = SingleElevator.images[SingleElevator.how_open_left]
          SingleElevator.GPU_current_image = SingleElevator.GPU_images[SingleElevator.how_open_left]
      if SingleElevator.right_door_open_at_top:
        if SingleElevator.how_open_right != ((SingleElevator.number_of_frames - 1) // 2):
          SingleElevator.how_open_right += 1
          SingleElevator.current_image = SingleElevator.images[SingleElevator.how_open_right + ((SingleElevator.number_of_frames - 1) // 2)]
          SingleElevator.GPU_current_image = SingleElevator.GPU_images[SingleElevator.how_open_right + ((SingleElevator.number_of_frames - 1) // 2)]
    if SingleElevator.x_pos + SingleElevator.wasted_left_space - 10 - ((1/2)*screen_width) <= PLAYER.x_pos <= SingleElevator.x_pos + SingleElevator.rect[2] - SingleElevator.wasted_right_space - 69 + 10 - ((1/2)*screen_width) and SingleElevator.y_pos + SingleElevator.wasted_top_space - 20 - ((1/2)*screen_height) <= PLAYER.y_pos <= SingleElevator.y_pos + SingleElevator.rect[3] - SingleElevator.wasted_bottom_space - ((1/2)*screen_height):
      return
    else:
      if SingleElevator.current_floor == 1:
        if SingleElevator.left_door_open_at_bottom:
          if SingleElevator.how_open_left != ((SingleElevator.number_of_frames - 1) // 2):
            SingleElevator.how_open_left += 1
            SingleElevator.current_image = SingleElevator.images[SingleElevator.how_open_left]
            SingleElevator.GPU_current_image = SingleElevator.GPU_images[SingleElevator.how_open_left]
            return
        if SingleElevator.right_door_open_at_bottom:
          if SingleElevator.how_open_right != ((SingleElevator.number_of_frames - 1) // 2):
            SingleElevator.how_open_right += 1
            SingleElevator.current_image = SingleElevator.images[SingleElevator.how_open_right + ((SingleElevator.number_of_frames - 1) // 2)]
            SingleElevator.GPU_current_image = SingleElevator.GPU_images[SingleElevator.how_open_right + ((SingleElevator.number_of_frames - 1) // 2)]
            return
      if SingleElevator.current_floor == 2:
        if SingleElevator.left_door_open_at_top:
          if SingleElevator.how_open_left != ((SingleElevator.number_of_frames - 1) // 2):
            SingleElevator.how_open_left += 1
            SingleElevator.current_image = SingleElevator.images[SingleElevator.how_open_left]
            SingleElevator.GPU_current_image = SingleElevator.GPU_images[SingleElevator.how_open_left]
            return
        if SingleElevator.right_door_open_at_top:
          if SingleElevator.how_open_right != ((SingleElevator.number_of_frames - 1) // 2):
            SingleElevator.how_open_right += 1
            SingleElevator.current_image = SingleElevator.images[SingleElevator.how_open_right + ((SingleElevator.number_of_frames - 1) // 2)]
            SingleElevator.GPU_current_image = SingleElevator.GPU_images[SingleElevator.how_open_right + ((SingleElevator.number_of_frames - 1) // 2)]
            return
      SingleElevator.activated = 0


def update_big_elevator(SingleElevator):
  if SingleElevator.activated == 0:
    if SingleElevator.playing_sound:
      SingleElevator.playing_sound = False
      MixerSounds['ELEVATOR'].fadeout(400)
    if SingleElevator.x_pos == SingleElevator.x1 and SingleElevator.y_pos == SingleElevator.y1:
      if SingleElevator.left_door_open_at_bottom:
        SingleElevator.LeftDoor_current_image = SingleElevator.DoorImages[((SingleElevator.number_of_frames - 1) // 2)]
        SingleElevator.GPU_LeftDoor_current_image = SingleElevator.GPU_DoorImages[((SingleElevator.number_of_frames - 1) // 2)]
      if SingleElevator.right_door_open_at_bottom:
        SingleElevator.RightDoor_current_image = SingleElevator.DoorImages[((SingleElevator.number_of_frames - 1) // 2)]
        SingleElevator.GPU_RightDoor_current_image = SingleElevator.GPU_DoorImages[((SingleElevator.number_of_frames - 1) // 2)]
    if SingleElevator.x_pos == SingleElevator.x2 and SingleElevator.y_pos == SingleElevator.y2:
      if SingleElevator.left_door_open_at_top:
        SingleElevator.LeftDoor_current_image = SingleElevator.DoorImages[((SingleElevator.number_of_frames - 1) // 2)]
        SingleElevator.GPU_LeftDoor_current_image = SingleElevator.GPU_DoorImages[((SingleElevator.number_of_frames - 1) // 2)]
      if SingleElevator.right_door_open_at_top:
        SingleElevator.RightDoor_current_image = SingleElevator.DoorImages[((SingleElevator.number_of_frames - 1) // 2)]
        SingleElevator.GPU_RightDoor_current_image = SingleElevator.GPU_DoorImages[((SingleElevator.number_of_frames - 1) // 2)]
    if SingleElevator.x_pos + SingleElevator.wasted_left_space + 20 - ((1/2)*screen_width) <= PLAYER.x_pos <= SingleElevator.x_pos + 1800 - SingleElevator.wasted_right_space - 69 - 20 - ((1/2)*screen_width) and SingleElevator.y_pos + SingleElevator.wasted_top_space - 20 - ((1/2)*screen_height) <= PLAYER.y_pos <= SingleElevator.y_pos + 541 - SingleElevator.wasted_bottom_space - ((1/2)*screen_height):
      if my_piston2.grapple_claw_x_pos != 0:
        SingleElevator.activated = 1
        SingleElevator.player_is_inside = True
        if MAP.region == 'TheDoor7':
          if not PLAYER_MOVER_ANTS[0].is_returning_object:
            PLAYER_MOVER_ANTS[0].x_pos = 2064+((1/2) * screen_width)
            PLAYER_MOVER_ANTS[0].y_pos = 1250+((1/2) * screen_height)
          ANTS[0].x_pos = 2064+((1/2) * screen_width)
          ANTS[0].y_pos = 1250+((1/2) * screen_height)
        return
    else:
      return
  #
  if SingleElevator.activated == 1:
    if SingleElevator.x_pos + SingleElevator.wasted_left_space - 10 - ((1/2)*screen_width) <= PLAYER.x_pos <= SingleElevator.x_pos + 1800 - SingleElevator.wasted_right_space - 69 + 10 - ((1/2)*screen_width) and SingleElevator.y_pos + SingleElevator.wasted_top_space - 20 - ((1/2)*screen_height) <= PLAYER.y_pos <= SingleElevator.y_pos + 541 - SingleElevator.wasted_bottom_space - ((1/2)*screen_height):
      SingleElevator.player_is_inside = True
      if SingleElevator.how_open_left == 0 and SingleElevator.how_open_right == 0:
        SingleElevator.RightDoor_current_image = SingleElevator.DoorImages[0]
        SingleElevator.LeftDoor_current_image = SingleElevator.DoorImages[0]
        SingleElevator.GPU_RightDoor_current_image = SingleElevator.GPU_DoorImages[0]
        SingleElevator.GPU_LeftDoor_current_image = SingleElevator.GPU_DoorImages[0]
        if SingleElevator.current_floor == 1:
          if SingleElevator.y_pos > SingleElevator.y2:
            update_big_elevator_positions(-SingleElevator.vel)
            PLAYER.y_pos -= SingleElevator.vel
            for SingleAnt in PLAYER_MOVER_ANTS:
              SingleAnt.y_pos -= SingleElevator.vel
            for SingleKey in ALLKEYS:
              SingleKey.y_pos -= SingleElevator.vel
            for SingleAnt in ANTS:
              SingleAnt.y_pos -= SingleElevator.vel
          if SingleElevator.y_pos < SingleElevator.y2:
            update_big_elevator_positions(SingleElevator.vel)
            PLAYER.y_pos += SingleElevator.vel
            for SingleAnt in PLAYER_MOVER_ANTS:
              SingleAnt.y_pos += SingleElevator.vel
            for SingleKey in ALLKEYS:
              SingleKey.y_pos += SingleElevator.vel
            for SingleAnt in ANTS:
              SingleAnt.y_pos += SingleElevator.vel
          if SingleElevator.y_pos - SingleElevator.vel <= SingleElevator.y2 <= SingleElevator.y_pos + SingleElevator.vel:
            SingleElevator.x_pos, SingleElevator.y_pos = SingleElevator.x2, SingleElevator.y2
            SingleElevator.PlatformLeftTop_y_pos = SingleElevator.y_pos + 1
            SingleElevator.PlatformMiddleTop_y_pos = SingleElevator.y_pos + 1
            SingleElevator.PlatformRightTop_y_pos = SingleElevator.y_pos + 1
            SingleElevator.PlatformLeftBottom_y_pos = SingleElevator.y_pos + 494 + 1
            SingleElevator.PlatformMiddleBottom_y_pos = SingleElevator.y_pos + 494 + 1
            SingleElevator.PlatformRightBottom_y_pos = SingleElevator.y_pos + 494 + 1
            SingleElevator.LeftMiddlePlatform_y_pos = SingleElevator.y_pos + 247 + 1
            SingleElevator.RightMiddlePlatform_y_pos = SingleElevator.y_pos + 247 + 1
            SingleElevator.DownPeg1_y_pos = SingleElevator.y_pos + 47 + 1
            SingleElevator.DownPeg2_y_pos = SingleElevator.y_pos + 294 + 1
            SingleElevator.DownPeg3_y_pos = SingleElevator.y_pos + 294 + 1
            SingleElevator.UpPeg1_y_pos = SingleElevator.y_pos + 219 + 1 - 20
            SingleElevator.UpPeg2_y_pos = SingleElevator.y_pos + 219 + 1 - 20
            SingleElevator.UpPeg3_y_pos = SingleElevator.y_pos + 466 + 1 - 20
            SingleElevator.UpPeg4_y_pos = SingleElevator.y_pos + 466 + 1 - 20
            SingleElevator.UpPeg5_y_pos = SingleElevator.y_pos + 466 + 1 - 20
            SingleElevator.LeftDoor_y_pos = SingleElevator.y_pos + 47 + 1
            SingleElevator.RightDoor_y_pos = SingleElevator.y_pos + 47 + 1
            SingleElevator.activated = 2
            SingleElevator.current_floor = 2
        if SingleElevator.current_floor == 2:
          if SingleElevator.y_pos > SingleElevator.y1:
            update_big_elevator_positions(-SingleElevator.vel)
            PLAYER.y_pos -= SingleElevator.vel
            for SingleAnt in PLAYER_MOVER_ANTS:
              SingleAnt.y_pos -= SingleElevator.vel
            for SingleKey in ALLKEYS:
              SingleKey.y_pos -= SingleElevator.vel
            for SingleAnt in ANTS:
              SingleAnt.y_pos -= SingleElevator.vel
          if SingleElevator.y_pos < SingleElevator.y1:
            update_big_elevator_positions(SingleElevator.vel)
            PLAYER.y_pos += SingleElevator.vel
            for SingleAnt in PLAYER_MOVER_ANTS:
              SingleAnt.y_pos += SingleElevator.vel
            for SingleKey in ALLKEYS:
              SingleKey.y_pos += SingleElevator.vel
            for SingleAnt in ANTS:
              SingleAnt.y_pos += SingleElevator.vel
          if SingleElevator.y_pos - SingleElevator.vel <= SingleElevator.y1 <= SingleElevator.y_pos + SingleElevator.vel:
            SingleElevator.x_pos, SingleElevator.y_pos = SingleElevator.x1, SingleElevator.y1
            SingleElevator.PlatformLeftTop_y_pos = SingleElevator.y_pos + 1
            SingleElevator.PlatformMiddleTop_y_pos = SingleElevator.y_pos + 1
            SingleElevator.PlatformRightTop_y_pos = SingleElevator.y_pos + 1
            SingleElevator.PlatformLeftBottom_y_pos = SingleElevator.y_pos + 494 + 1
            SingleElevator.PlatformMiddleBottom_y_pos = SingleElevator.y_pos + 494 + 1
            SingleElevator.PlatformRightBottom_y_pos = SingleElevator.y_pos + 494 + 1
            SingleElevator.LeftMiddlePlatform_y_pos = SingleElevator.y_pos + 247 + 1
            SingleElevator.RightMiddlePlatform_y_pos = SingleElevator.y_pos + 247 + 1
            SingleElevator.DownPeg1_y_pos = SingleElevator.y_pos + 47 + 1
            SingleElevator.DownPeg2_y_pos = SingleElevator.y_pos + 294 + 1
            SingleElevator.DownPeg3_y_pos = SingleElevator.y_pos + 294 + 1
            SingleElevator.UpPeg1_y_pos = SingleElevator.y_pos + 219 + 1 - 20
            SingleElevator.UpPeg2_y_pos = SingleElevator.y_pos + 219 + 1 - 20
            SingleElevator.UpPeg3_y_pos = SingleElevator.y_pos + 466 + 1 - 20
            SingleElevator.UpPeg4_y_pos = SingleElevator.y_pos + 466 + 1 - 20
            SingleElevator.UpPeg5_y_pos = SingleElevator.y_pos + 466 + 1 - 20
            SingleElevator.LeftDoor_y_pos = SingleElevator.y_pos + 47 + 1
            SingleElevator.RightDoor_y_pos = SingleElevator.y_pos + 47 + 1
            SingleElevator.activated = 2
            SingleElevator.current_floor = 1
        return
      if SingleElevator.how_open_left != 0:
        SingleElevator.LeftDoor_current_image = SingleElevator.DoorImages[SingleElevator.how_open_left]
        SingleElevator.GPU_LeftDoor_current_image = SingleElevator.GPU_DoorImages[SingleElevator.how_open_left]
        SingleElevator.how_open_left -= 1
        return
      if SingleElevator.how_open_right != 0:
        SingleElevator.RightDoor_current_image = SingleElevator.DoorImages[SingleElevator.how_open_right]
        SingleElevator.GPU_RightDoor_current_image = SingleElevator.GPU_DoorImages[SingleElevator.how_open_right]
        SingleElevator.how_open_right -= 1
        return
    else:
      if SingleElevator.current_floor == 1:
        if SingleElevator.left_door_open_at_bottom:
          if SingleElevator.how_open_left != ((SingleElevator.number_of_frames - 1) // 2):
            SingleElevator.how_open_left += 1
            SingleElevator.LeftDoor_current_image = SingleElevator.DoorImages[SingleElevator.how_open_left]
            SingleElevator.GPU_LeftDoor_current_image = SingleElevator.GPU_DoorImages[SingleElevator.how_open_left]
            return
        if SingleElevator.right_door_open_at_bottom:
          if SingleElevator.how_open_right != ((SingleElevator.number_of_frames - 1) // 2):
            SingleElevator.how_open_right += 1
            SingleElevator.RightDoor_current_image = SingleElevator.DoorImages[SingleElevator.how_open_right]
            SingleElevator.GPU_RightDoor_current_image = SingleElevator.GPU_DoorImages[SingleElevator.how_open_right]
            return
      if SingleElevator.current_floor == 2:
        if SingleElevator.left_door_open_at_top:
          if SingleElevator.how_open_left != ((SingleElevator.number_of_frames - 1) // 2):
            SingleElevator.how_open_left += 1
            SingleElevator.LeftDoor_current_image = SingleElevator.DoorImages[SingleElevator.how_open_left]
            SingleElevator.GPU_LeftDoor_current_image = SingleElevator.GPU_DoorImages[SingleElevator.how_open_left]
            return
        if SingleElevator.right_door_open_at_top:
          if SingleElevator.how_open_right != ((SingleElevator.number_of_frames - 1) // 2):
            SingleElevator.how_open_right += 1
            SingleElevator.RightDoor_current_image = SingleElevator.DoorImages[SingleElevator.how_open_right]
            SingleElevator.GPU_RightDoor_current_image = SingleElevator.GPU_DoorImages[SingleElevator.how_open_right]
            return
      SingleElevator.activated = 0
      return
  #
  if SingleElevator.activated == 2:
    if SingleElevator.playing_sound:
      SingleElevator.playing_sound = False
      MixerSounds['ELEVATOR'].fadeout(400)
    if SingleElevator.current_floor == 1:
      if SingleElevator.left_door_open_at_bottom:
        if SingleElevator.how_open_left != ((SingleElevator.number_of_frames - 1) // 2):
          SingleElevator.how_open_left += 1
          SingleElevator.LeftDoor_current_image = SingleElevator.DoorImages[SingleElevator.how_open_left]
          SingleElevator.GPU_LeftDoor_current_image = SingleElevator.GPU_DoorImages[SingleElevator.how_open_left]
      if SingleElevator.right_door_open_at_bottom:
        if SingleElevator.how_open_right != ((SingleElevator.number_of_frames - 1) // 2):
          SingleElevator.how_open_right += 1
          SingleElevator.RightDoor_current_image = SingleElevator.DoorImages[SingleElevator.how_open_right]
          SingleElevator.GPU_RightDoor_current_image = SingleElevator.GPU_DoorImages[SingleElevator.how_open_right]
    if SingleElevator.current_floor == 2:
      if SingleElevator.left_door_open_at_top:
        if SingleElevator.how_open_left != ((SingleElevator.number_of_frames - 1) // 2):
          SingleElevator.how_open_left += 1
          SingleElevator.LeftDoor_current_image = SingleElevator.DoorImages[SingleElevator.how_open_left]
          SingleElevator.GPU_LeftDoor_current_image = SingleElevator.GPU_DoorImages[SingleElevator.how_open_left]
      if SingleElevator.right_door_open_at_top:
        if SingleElevator.how_open_right != ((SingleElevator.number_of_frames - 1) // 2):
          SingleElevator.how_open_right += 1
          SingleElevator.RightDoor_current_image = SingleElevator.DoorImages[SingleElevator.how_open_right]
          SingleElevator.GPU_RightDoor_current_image = SingleElevator.GPU_DoorImages[SingleElevator.how_open_right]
    if SingleElevator.x_pos + SingleElevator.wasted_left_space - 10 - ((1/2)*screen_width) <= PLAYER.x_pos <= SingleElevator.x_pos + 1800 - SingleElevator.wasted_right_space - 69 + 10 - ((1/2)*screen_width) and SingleElevator.y_pos + SingleElevator.wasted_top_space - 20 - ((1/2)*screen_height) <= PLAYER.y_pos <= SingleElevator.y_pos + 541 - SingleElevator.wasted_bottom_space - ((1/2)*screen_height):
      return
    else:
      if SingleElevator.current_floor == 1:
        if SingleElevator.left_door_open_at_bottom:
          if SingleElevator.how_open_left != ((SingleElevator.number_of_frames - 1) // 2):
            SingleElevator.how_open_left += 1
            SingleElevator.LeftDoor_current_image = SingleElevator.DoorImages[SingleElevator.how_open_left]
            SingleElevator.GPU_LeftDoor_current_image = SingleElevator.GPU_DoorImages[SingleElevator.how_open_left]
            return
        if SingleElevator.right_door_open_at_bottom:
          if SingleElevator.how_open_right != ((SingleElevator.number_of_frames - 1) // 2):
            SingleElevator.how_open_right += 1
            SingleElevator.RightDoor_current_image = SingleElevator.DoorImages[SingleElevator.how_open_right]
            SingleElevator.GPU_RightDoor_current_image = SingleElevator.GPU_DoorImages[SingleElevator.how_open_right]
            return
      if SingleElevator.current_floor == 2:
        if SingleElevator.left_door_open_at_top:
          if SingleElevator.how_open_left != ((SingleElevator.number_of_frames - 1) // 2):
            SingleElevator.how_open_left += 1
            SingleElevator.LeftDoor_current_image = SingleElevator.DoorImages[SingleElevator.how_open_left]
            SingleElevator.GPU_LeftDoor_current_image = SingleElevator.GPU_DoorImages[SingleElevator.how_open_left]
            return
        if SingleElevator.right_door_open_at_top:
          if SingleElevator.how_open_right != ((SingleElevator.number_of_frames - 1) // 2):
            SingleElevator.how_open_right += 1
            SingleElevator.RightDoor_current_image = SingleElevator.DoorImages[SingleElevator.how_open_right]
            SingleElevator.GPU_RightDoor_current_image = SingleElevator.GPU_DoorImages[SingleElevator.how_open_right]
            return
      SingleElevator.activated = 0


def update_big_elevator_positions(pos_change):
  if not ELEVATORS[0].playing_sound:
    ELEVATORS[0].playing_sound = True
    MixerSounds['ELEVATOR'].play(-1, fade_ms = 400)
  ELEVATORS[0].y_pos += pos_change
  ELEVATORS[0].PlatformLeftTop_y_pos += pos_change
  ELEVATORS[0].PlatformMiddleTop_y_pos += pos_change
  ELEVATORS[0].PlatformRightTop_y_pos += pos_change
  ELEVATORS[0].PlatformLeftBottom_y_pos += pos_change
  ELEVATORS[0].PlatformMiddleBottom_y_pos += pos_change
  ELEVATORS[0].PlatformRightBottom_y_pos += pos_change
  ELEVATORS[0].LeftMiddlePlatform_y_pos += pos_change
  ELEVATORS[0].RightMiddlePlatform_y_pos += pos_change
  ELEVATORS[0].DownPeg1_y_pos += pos_change
  ELEVATORS[0].DownPeg2_y_pos += pos_change
  ELEVATORS[0].DownPeg3_y_pos += pos_change
  ELEVATORS[0].UpPeg1_y_pos += pos_change
  ELEVATORS[0].UpPeg2_y_pos += pos_change
  ELEVATORS[0].UpPeg3_y_pos += pos_change
  ELEVATORS[0].UpPeg4_y_pos += pos_change
  ELEVATORS[0].UpPeg5_y_pos += pos_change
  ELEVATORS[0].LeftDoor_y_pos += pos_change
  ELEVATORS[0].RightDoor_y_pos += pos_change


def update_elevators():
  if ELEVATORS != []:
    for SingleElevator in ELEVATORS:
      update_elevator(SingleElevator)


def update_leaves():
  if LEAVES != []:
    for SingleLeaf in LEAVES:
      update_leaf(SingleLeaf)


def update_leaf(SingleLeaf):
  if SingleLeaf.accumulated_y_pos >= SingleLeaf.expiry_y_pos - ((1/2) * SingleLeaf.rect[3]):
    SingleLeaf.currently_grapplable = False
    if SingleLeaf.player_grappled_to_leaf:
      SingleLeaf.player_grappled_to_leaf = False
      my_piston2.grapple_claw_x_pos, my_piston2.grapple_claw_y_pos = 0, 0
      Marker.x_pos, Marker.y_pos = 0, 0
    if SingleLeaf.wait_frames_before_beginning_to_disappear != 0:
      SingleLeaf.wait_frames_before_beginning_to_disappear -= 1
      return
    else:
      if frame_counter % 10 == 0:
        SingleLeaf.frames_before_disappearing += 1
      SingleLeaf.current_image = SingleLeaf.images[SingleLeaf.frames_before_disappearing]
      SingleLeaf.GPU_current_image = SingleLeaf.GPU_images[SingleLeaf.frames_before_disappearing]
      SingleLeaf.current_image = rotate_square_image(SingleLeaf.current_image, SingleLeaf.rotation)
      if SingleLeaf.frames_before_disappearing == len(SingleLeaf.images) - 1:
        SingleLeaf.y_pos = SingleLeaf.orig_y_pos
        SingleLeaf.accumulated_y_pos = 0
        SingleLeaf.frames_before_disappearing = 0
        SingleLeaf.wait_frames_before_beginning_to_disappear = SingleLeaf.orig_wait_frames_before_beginning_to_disappear
        #SingleLeaf.cur_x_path = 0
        #SingleLeaf.cur_y_path = 0
        #SingleLeaf.cur_rot_path = 0
      return
  SingleLeaf.currently_grapplable = True
  SingleLeaf.accumulated_y_pos += SingleLeaf.falling_speed
  SingleLeaf.x_pos = SingleLeaf.orig_x_pos + SingleLeaf.x_path[SingleLeaf.cur_x_path]
  SingleLeaf.y_pos = SingleLeaf.orig_y_pos + SingleLeaf.y_path[SingleLeaf.cur_y_path] + SingleLeaf.accumulated_y_pos
  SingleLeaf.rotation = SingleLeaf.orig_rotation + SingleLeaf.rot_path[SingleLeaf.cur_rot_path]
  if SingleLeaf.player_grappled_to_leaf:
    my_piston2.grapple_claw_x_pos = SingleLeaf.x_pos + ((1/2)*SingleLeaf.rect[2]) - ((1/2)*screen_width)
    my_piston2.grapple_claw_y_pos = SingleLeaf.y_pos + ((1/2)*SingleLeaf.rect[3]) - ((1/2)*screen_height)
  if SingleLeaf.cur_x_path == len(SingleLeaf.x_path) - 1:
    SingleLeaf.cur_x_path = 0
  else:
    SingleLeaf.cur_x_path += 1
  if SingleLeaf.cur_y_path == len(SingleLeaf.y_path) - 1:
    SingleLeaf.cur_y_path = 0
  else:
    SingleLeaf.cur_y_path += 1
  if SingleLeaf.cur_rot_path == len(SingleLeaf.rot_path) - 1:
    SingleLeaf.cur_rot_path = 0
  else:
    SingleLeaf.cur_rot_path += 1
  SingleLeaf.current_image = rotate_square_image(SingleLeaf.images[0], SingleLeaf.rotation)
  SingleLeaf.GPU_current_image = SingleLeaf.GPU_images[0]


def specific_animation_rules():
  if PLAYER.on_a_surf_board or PLAYER.not_yet_on_the_board:
    PLAYER.flipped = not SURF_BOARDS[PLAYER.on_which_surf_board].currently_flipping_image
    PLAYER.Hamster_image_rotation = (my_sheath.rotation + 90) % 360
    PLAYER.ball_image_rotation = PLAYER.ball_image_rotation_getting_on_surf_board + PLAYER.Hamster_image_rotation


def update_hamster_animation():
  #
  #PLAYER.previous_ball_image_rotation = PLAYER.ball_image_rotation
  cloud_ball_rotation = False
  if STANDING_ON_CLOUD:
    cloud_ball_rotation = True
  if not cloud_ball_rotation:
    PLAYER.ball_image_rotation += (PLAYER.change_in_x_pos / PLAYER.circumference) * My_cached_info.target_fps_over_fps
    PLAYER.ball_image_rotation = PLAYER.ball_image_rotation % 360
  if cloud_ball_rotation:
    PLAYER.ball_image_rotation += (PLAYER.cloud_change_in_x_pos / PLAYER.circumference) * My_cached_info.target_fps_over_fps
    PLAYER.ball_image_rotation = PLAYER.ball_image_rotation % 360
  if 'Fly' in PLAYER.Hamster_activities_during_frame and not 'Float' in PLAYER.Hamster_activities_during_frame and not 'Rolling_Right' in PLAYER.Hamster_activities_during_previous_frames[0] and not 'Rolling_Left' in PLAYER.Hamster_activities_during_previous_frames[0] and not 'Walk_Left' in PLAYER.Hamster_activities_during_previous_frames[0] and not 'Walk_Right' in PLAYER.Hamster_activities_during_previous_frames[0] and not PLAYER.Hamster_forced_spin and (-5 <= PLAYER.Hamster_image_rotation <= 5):
    PLAYER.Hamster_image_rotation = 0
    if PLAYER.x_vel > 10:
      if PLAYER.y_vel < -30:
        if PLAYER.y_vel > -150:
          PLAYER.current_Hamster_image = PLAYER.GPU_HamsterFlyingRight[1]
          PLAYER.flipped = False
          return
        if PLAYER.y_vel < -150:
          PLAYER.current_Hamster_image = PLAYER.GPU_HamsterFlyingRight[0]
          PLAYER.flipped = False
          return
      if PLAYER.y_vel > 30:
        if PLAYER.y_vel < 150:
          PLAYER.current_Hamster_image = PLAYER.GPU_HamsterFlyingRight[3]
          PLAYER.flipped = False
          return
        if PLAYER.y_vel > 150:
          PLAYER.current_Hamster_image = PLAYER.GPU_HamsterFlyingRight[4]
          PLAYER.flipped = False
          return
    if PLAYER.x_vel < -10:
      if PLAYER.y_vel < -30:
        if PLAYER.y_vel > -150:
          PLAYER.current_Hamster_image = PLAYER.GPU_HamsterFlyingRight[1]
          PLAYER.flipped = True
          return
        if PLAYER.y_vel < -150:
          PLAYER.current_Hamster_image = PLAYER.GPU_HamsterFlyingRight[0]
          PLAYER.flipped = True
          return
      if PLAYER.y_vel > 30:
        if PLAYER.y_vel < 150:
          PLAYER.current_Hamster_image = PLAYER.GPU_HamsterFlyingRight[3]
          PLAYER.flipped = True
          return
        if PLAYER.y_vel > 150:
          PLAYER.current_Hamster_image = PLAYER.GPU_HamsterFlyingRight[4]
          PLAYER.flipped = True
          return
    return
  #
  if ('Float' in PLAYER.Hamster_activities_during_frame) and not (PLAYER.on_a_surf_board or PLAYER.not_yet_on_the_board):
    PLAYER.current_milliseconds_before_next_float_animation += delta_milliseconds
    PLAYER.Hamster_image_rotation = 0
    if 15 >= PLAYER.how_submerged:
      PLAYER.adjust_y_pos = -15 + 11
    if 15 < PLAYER.how_submerged < 42:
      PLAYER.adjust_y_pos = -PLAYER.how_submerged + 11
    if PLAYER.how_submerged >= 42:
      PLAYER.adjust_y_pos = -42 + 11
    if PLAYER.x_vel < -10:
      if PLAYER.current_milliseconds_before_next_float_animation >= PLAYER.milliseconds_before_next_float_animation:
        PLAYER.current_milliseconds_before_next_float_animation = PLAYER.current_milliseconds_before_next_float_animation % PLAYER.milliseconds_before_next_float_animation
        PLAYER.current_float_image_index += 1
        if PLAYER.current_float_image_index >= 4:
          PLAYER.current_float_image_index = 0
        PLAYER.current_Hamster_image = PLAYER.GPU_HamsterFloatRight[PLAYER.current_float_image_index]
      PLAYER.flipped = True
    if PLAYER.x_vel > 10:
      if PLAYER.current_milliseconds_before_next_float_animation >= PLAYER.milliseconds_before_next_float_animation:
        PLAYER.current_milliseconds_before_next_float_animation = PLAYER.current_milliseconds_before_next_float_animation % PLAYER.milliseconds_before_next_float_animation
        PLAYER.current_float_image_index += 1
        if PLAYER.current_float_image_index >= 4:
          PLAYER.current_float_image_index = 0
        PLAYER.current_Hamster_image = PLAYER.GPU_HamsterFloatRight[PLAYER.current_float_image_index]
      PLAYER.flipped = False
    return
  #
  if 'Walk_Left' in PLAYER.Hamster_activities_during_frame and not 'Rolling_Left' in PLAYER.Hamster_activities_during_previous_frames[0]:
    if 0 <= abs(PLAYER.x_vel) <= 390:
      if not 'Rolling_Right' in PLAYER.Hamster_activities_during_previous_frames[0]:
        PLAYER.Hamster_image_rotation = 0
        PLAYER.current_milliseconds_before_next_walk_animation += delta_milliseconds
        if PLAYER.current_milliseconds_before_next_walk_animation >= PLAYER.milliseconds_before_next_walk_animation:
          PLAYER.current_milliseconds_before_next_walk_animation %= PLAYER.milliseconds_before_next_walk_animation
          PLAYER.current_walk_image_index += 1
          if PLAYER.current_walk_image_index >= 4:
            PLAYER.current_walk_image_index = 0
        PLAYER.current_Hamster_image = PLAYER.GPU_HamsterWalkingRight[PLAYER.current_walk_image_index]
        PLAYER.flipped = True
        return
  if (-390 > PLAYER.x_vel) or (PLAYER.Hamster_forced_spin and PLAYER.x_vel < 0):
    PLAYER.Hamster_activities_during_frame.append('Rolling_Left')
    PLAYER.Hamster_image_rotation += (PLAYER.change_in_x_pos / PLAYER.circumference) * My_cached_info.target_fps_over_fps
    PLAYER.Hamster_image_rotation = PLAYER.Hamster_image_rotation % 360
    PLAYER.current_Hamster_image = PLAYER.GPU_RollingClockwise[0]
    PLAYER.flipped = True
    return
  if -0 >= PLAYER.x_vel >= -390:
    if 'Rolling_Left' in PLAYER.Hamster_activities_during_previous_frames[0]:
      PLAYER.Hamster_image_rotation += 5 * My_cached_info.target_fps_over_fps
      PLAYER.Hamster_image_rotation = PLAYER.Hamster_image_rotation % 360
      if (-5 <= PLAYER.Hamster_image_rotation <= 5) or (-50 <= PLAYER.x_vel <= 50):
        PLAYER.Hamster_image_rotation = 0
        PLAYER.current_Hamster_image = PLAYER.GPU_RollingClockwise[0]
        PLAYER.flipped = True
        return
      else:
        PLAYER.Hamster_activities_during_frame.append('Rolling_Left')
        PLAYER.current_Hamster_image = PLAYER.GPU_RollingClockwise[0]
        PLAYER.flipped = True
        return
  #
  if 'Walk_Right' in PLAYER.Hamster_activities_during_frame and not 'Rolling_Right' in PLAYER.Hamster_activities_during_previous_frames[0]:
    if 0 <= abs(PLAYER.x_vel) <= 390:
      PLAYER.Hamster_image_rotation = 0
      PLAYER.current_milliseconds_before_next_walk_animation += delta_milliseconds
      if PLAYER.current_milliseconds_before_next_walk_animation >= PLAYER.milliseconds_before_next_walk_animation:
        PLAYER.current_milliseconds_before_next_walk_animation %= PLAYER.milliseconds_before_next_walk_animation
        PLAYER.current_walk_image_index += 1
        if PLAYER.current_walk_image_index >= 4:
          PLAYER.current_walk_image_index = 0
      PLAYER.current_Hamster_image = PLAYER.GPU_HamsterWalkingRight[PLAYER.current_walk_image_index]
      PLAYER.flipped = False
      return
  if 390 < PLAYER.x_vel or (PLAYER.Hamster_forced_spin and PLAYER.x_vel > 0):
    PLAYER.Hamster_activities_during_frame.append('Rolling_Right')
    PLAYER.Hamster_image_rotation += (PLAYER.change_in_x_pos / PLAYER.circumference) * My_cached_info.target_fps_over_fps
    PLAYER.Hamster_image_rotation = PLAYER.Hamster_image_rotation % 360
    PLAYER.current_Hamster_image = PLAYER.GPU_RollingClockwise[0]
    PLAYER.flipped = False
    return
  if 0 <= PLAYER.x_vel <= 390:
    if 'Rolling_Right' in PLAYER.Hamster_activities_during_previous_frames[0]:
      PLAYER.Hamster_image_rotation -= 5 * My_cached_info.target_fps_over_fps
      PLAYER.Hamster_image_rotation = PLAYER.Hamster_image_rotation % 360
      if (-5 <= PLAYER.Hamster_image_rotation <= 5) or (-50 <= PLAYER.x_vel <= 50):
        PLAYER.Hamster_image_rotation = 0
        PLAYER.current_Hamster_image = PLAYER.GPU_RollingClockwise[0]
        PLAYER.flipped = False
        return
      else:
        PLAYER.Hamster_activities_during_frame.append('Rolling_Right')
        PLAYER.current_Hamster_image = PLAYER.GPU_RollingClockwise[0]
        PLAYER.flipped = False
        return
  if PLAYER.x_vel > 0:
    PLAYER.Hamster_image_rotation = 0
    PLAYER.current_Hamster_image = PLAYER.GPU_HamsterStandingRight
    PLAYER.flipped = False
    return
  if PLAYER.x_vel < 0:
    PLAYER.Hamster_image_rotation = 0
    PLAYER.current_Hamster_image = PLAYER.GPU_HamsterStandingRight
    PLAYER.flipped = True
    return


def update_tools():
  global TOOLS
  for SingleTool in TOOLS:
    if not SingleTool.collected:
      for _ in range(My_cached_info.whole_number_of_frames_this_frame):
        SingleTool.place_in_float_y_pos += 1
        if SingleTool.place_in_float_y_pos == 360:
          SingleTool.place_in_float_y_pos = 0
      SingleTool.y_pos = SingleTool.orig_y_pos + SingleTool.float_y_pos[SingleTool.place_in_float_y_pos]
      distance_between_player_and_bubble = find_hypotnuse(PLAYER.x_pos - SingleTool.x_pos + ((1/2)*screen_width), PLAYER.y_pos - SingleTool.y_pos + ((1/2)*screen_height))
      if distance_between_player_and_bubble < (34 + 34):
        SingleTool.collected = True
        My_cached_info.play_tool_sequence = True
        SingleTool.initial_upgrade_angle_of_approach = angle_between_player_and_bubble(SingleTool)
        SingleTool.current_angle_around_player = SingleTool.initial_upgrade_angle_of_approach
        find_bubble_direction_to_fly(SingleTool)
        if SingleTool.png_name == 'SCREW_DRIVER':
          PLAYER.collected_screw_driver = True
          everything_save_data(True, 16, '1')
        if SingleTool.png_name == 'WIRE_CUTTER':
          PLAYER.collected_wire_cutter = True
          everything_save_data(True, 17, '1')
        if SingleTool.png_name == 'WRENCH':
          PLAYER.collected_wrench = True
          everything_save_data(True, 18, '1')


def angle_between_player_and_bubble(SingleBubble):
  new_PLAYER_x_pos = PLAYER.x_pos + ((1/2)*screen_width)
  new_PLAYER_y_pos = PLAYER.y_pos + ((1/2)*screen_height)
  return (math.degrees(math.atan2(new_PLAYER_y_pos - SingleBubble.y_pos, -(new_PLAYER_x_pos - SingleBubble.x_pos)))) % 360


def find_bubble_direction_to_fly(SingleBubble):
  new_PLAYER_x_pos = PLAYER.x_pos + ((1/2)*screen_width)
  new_PLAYER_y_pos = PLAYER.y_pos + ((1/2)*screen_height)
  if new_PLAYER_y_pos >= SingleBubble.y_pos: # bubble above player
    if PLAYER.x_vel >= 0:
      SingleBubble.fly_counter_clockwise = True
      return
    if PLAYER.x_vel < 0:
      SingleBubble.fly_clockwise = True
      return
  else: # bubble below player
    if PLAYER.x_vel >= 0:
      SingleBubble.fly_clockwise = True
      return
    if PLAYER.x_vel < 0:
      SingleBubble.fly_counter_clockwise = True
      return


def update_upgrades():
  global UPGRADES, PLAY_UPGRADE_CUTSCENE
  for SingleUpgrade in UPGRADES:
    if not SingleUpgrade.collected:
      for _ in range(My_cached_info.whole_number_of_frames_this_frame):
        SingleUpgrade.place_in_float_y_pos += 1
        if SingleUpgrade.place_in_float_y_pos == 360:
          SingleUpgrade.place_in_float_y_pos = 0
      SingleUpgrade.number_of_pixels_to_move += delta_milliseconds / 6
      SingleUpgrade.y_pos = SingleUpgrade.orig_y_pos + SingleUpgrade.float_y_pos[SingleUpgrade.place_in_float_y_pos]
      SingleUpgrade.piston_y_pos = SingleUpgrade.y_pos + 14
      SingleUpgrade.grapple_y_pos = SingleUpgrade.y_pos + 31
      SingleUpgrade.PistonImage_current = SingleUpgrade.PistonImage.subsurface(((frame_counter*2)%242, 0, 34, 9))
      SingleUpgrade.GrappleImage_current = SingleUpgrade.GrappleImage.subsurface((15, 0, 24, 26))
      SingleUpgrade.push_piston_ltwh = [(486 - ((round(SingleUpgrade.number_of_pixels_to_move))%243))%243, 0, 34, 9]
      SingleUpgrade.grapple_piston_ltwh = [15, 0, 24, 26]
      distance_between_player_and_bubble = find_hypotnuse(PLAYER.x_pos - SingleUpgrade.x_pos + ((1/2)*screen_width), PLAYER.y_pos - SingleUpgrade.y_pos + ((1/2)*screen_height))
      if distance_between_player_and_bubble < (34 + 34):
        SingleUpgrade.initial_upgrade_angle_of_approach = angle_between_player_and_bubble(SingleUpgrade)
        SingleUpgrade.current_angle_around_player = SingleUpgrade.initial_upgrade_angle_of_approach
        find_bubble_direction_to_fly(SingleUpgrade)
        SingleUpgrade.collected = True
        #my_piston1.maximum_extension += 5
        #my_piston2.maximum_extension += 5
        My_cached_info.playing_upgrade_sequence = True
        if my_piston1.maximum_extension >= 240:
          my_piston1.maximum_extension = 240
        if my_piston2.maximum_extension >= 240:
          my_piston2.maximum_extension = 240
        PLAY_UPGRADE_CUTSCENE = True
        if MAP.region == 'TheDoor1':
          PLAYER.CollectedUpgrades[0] = True
          everything_save_data(True, 27, '1')
        if MAP.region == 'TheDoor2':
          PLAYER.CollectedUpgrades[1] = True
          everything_save_data(True, 28, '1')
        if MAP.region == 'TheDoor3':
          PLAYER.CollectedUpgrades[2] = True
          everything_save_data(True, 29, '1')
        if MAP.region == 'TheDoor4':
          PLAYER.CollectedUpgrades[3] = True
          everything_save_data(True, 30, '1')
        if MAP.region == 'TheDoor5':
          PLAYER.CollectedUpgrades[4] = True
          everything_save_data(True, 31, '1')
        if MAP.region == 'TheDoor6':
          pass
        if MAP.region == 'TheDoor7':
          PLAYER.CollectedUpgrades[5] = True
          everything_save_data(True, 32, '1')
        if MAP.region == 'TheDoor8':
          PLAYER.CollectedUpgrades[6] = True
          everything_save_data(True, 33, '1')
        if MAP.region == 'TheDoor9':
          PLAYER.CollectedUpgrades[7] = True
          everything_save_data(True, 34, '1')
        if MAP.region == 'TheDoor10':
          PLAYER.CollectedUpgrades[8] = True
          everything_save_data(True, 35, '1')
        if MAP.region == 'TheDoor11':
          PLAYER.CollectedUpgrades[9] = True
          everything_save_data(True, 36, '1')
        if MAP.region == 'TheDoor12':
          PLAYER.CollectedUpgrades[10] = True
          everything_save_data(True, 37, '1')
        if MAP.region == 'TheDoor13':
          PLAYER.CollectedUpgrades[11] = True
          everything_save_data(True, 38, '1')
        #
        total_collected_upgrades = 0
        for SingleUpgradeCollected in PLAYER.CollectedUpgrades:
          if SingleUpgradeCollected:
            total_collected_upgrades += 1
        my_piston1.maximum_extension = maximum_piston_length_dict[str(total_collected_upgrades)]
        my_piston2.maximum_extension = maximum_piston_length_dict[str(total_collected_upgrades)]

def update_Beetle():
  #
  if MAP.region == 'Town':
    distance_between_player_and_beetle = find_hypotnuse(PLAYER.x_pos + 34 - BEETLE_FRIEND.x_pos + ((1/2)*screen_width) - ((1/2)*BEETLE_FRIEND.rect[2]), PLAYER.y_pos + 34 - BEETLE_FRIEND.y_pos + ((1/2)*screen_height) - ((1/2)*BEETLE_FRIEND.rect[3]))
    BEETLE_FRIEND.ShowingWhichDialogue = 0
    BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
    BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
    BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
    if distance_between_player_and_beetle < 220:
      BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant += delta_milliseconds
      if 200 <= BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant < 2700:
        BEETLE_FRIEND.ShowingWhichDialogue = 45
      if 2900 <= BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant < 5400:
        BEETLE_FRIEND.ShowingWhichDialogue = 46
      if 5600 <= BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant:
        BEETLE_FRIEND.ShowingWhichDialogue = 47
    return
  #
  if MAP.region == 'TheDoor6':
    distance_between_player_and_beetle = find_hypotnuse(PLAYER.x_pos + 34 - BEETLE_FRIEND.x_pos + ((1/2)*screen_width) - ((1/2)*BEETLE_FRIEND.rect[2]), PLAYER.y_pos + 34 - BEETLE_FRIEND.y_pos + ((1/2)*screen_height) - ((1/2)*BEETLE_FRIEND.rect[3]))
    if BEETLE_FRIEND.beetle_position_in_ant_queen == 1:
      if PLAYER.x_pos < 4000:
        BEETLE_FRIEND.beetle_position_in_ant_queen = 2
        BEETLE_FRIEND.x_pos = 330 + ((1/2)*screen_width)
        BEETLE_FRIEND.y_pos = 2146 + ((1/2)*screen_height)
        BEETLE_FRIEND.rotation = 5
        BEETLE_FRIEND.flipped = False
        BEETLE_FRIEND.image_flipped = False
        BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant = 0
        return
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.image_flipped = True
      if distance_between_player_and_beetle < 500:
        BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant += delta_milliseconds
        if 200 <= BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant < 4200:
          if 200 <= BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant < 1200:
            BEETLE_FRIEND.ShowingWhichDialogue = 33
          if 1200 <= BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant < 2200:
            BEETLE_FRIEND.ShowingWhichDialogue = 34
          if 2200 <= BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant < 3200:
            BEETLE_FRIEND.ShowingWhichDialogue = 35
          if 3200 <= BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant <= 4200:
            BEETLE_FRIEND.ShowingWhichDialogue = 36
        if 4400 <= BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant <= 6400:
          BEETLE_FRIEND.ShowingWhichDialogue = 37
        if 6600 <= BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant <= 8600:
          BEETLE_FRIEND.ShowingWhichDialogue = 38
        if 8800 <= BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant <= 10800:
          BEETLE_FRIEND.ShowingWhichDialogue = 39
        if 11000 <= BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant:
          BEETLE_FRIEND.ShowingWhichDialogue = 40
      return
  #
    if BEETLE_FRIEND.beetle_position_in_ant_queen == 2:
      if TOOLS == []:
        wire_cutter = Tools(x_pos = 306 + ((1/2)*screen_width), y_pos = 2030 + ((1/2)*screen_height), png_name = 'WIRE_CUTTER')
        TOOLS.append(wire_cutter)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandRightImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandRightImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      if distance_between_player_and_beetle < 500:
        BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant += delta_milliseconds
        if 200 <= BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant < 2200:
          BEETLE_FRIEND.ShowingWhichDialogue = 41
        if 2400 <= BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant < 4400:
          BEETLE_FRIEND.ShowingWhichDialogue = 42
        if 4600 <= BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant < 6600:
          BEETLE_FRIEND.ShowingWhichDialogue = 43
        if 6800 <= BEETLE_FRIEND.milliseconds_talking_with_beetle_in_queen_ant:
          BEETLE_FRIEND.ShowingWhichDialogue = 44
      return
  #
  if BEETLE_FRIEND.eaten != 0:
    if BEETLE_FRIEND.eaten == 1 or BEETLE_FRIEND.eaten == 2:
      BEETLE_FRIEND.ShowingWhichDialogue = 31
      BEETLE_FRIEND.rotation = 135
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 72) // 3]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 72) // 3]
    return
  distance_between_player_and_beetle = find_hypotnuse(PLAYER.x_pos + 34 - BEETLE_FRIEND.x_pos + ((1/2)*screen_width) - ((1/2)*BEETLE_FRIEND.rect[2]), PLAYER.y_pos + 34 - BEETLE_FRIEND.y_pos + ((1/2)*screen_height) - ((1/2)*BEETLE_FRIEND.rect[3]))
  if BEETLE_FRIEND.time_since_last_substep == -1:
    BEETLE_FRIEND.time_since_last_substep = 0
  BEETLE_FRIEND.time_since_last_step = 0
  BEETLE_FRIEND.time_since_last_substep += 1
  #
  #
  #
  if BEETLE_FRIEND.stage_in_movement == 1: # Beetle standing in cage
    BEETLE_FRIEND.image_flipped = False
    if ALLKEYS[1].is_inserted:
      BEETLE_FRIEND.stage_in_movement = 2
      BEETLE_FRIEND.substep = 0
      BEETLE_FRIEND.time_since_last_substep = -1
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      BEETLE_FRIEND.frame_at_last_stage_in_movement = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      return
    if not BEETLE_FRIEND.flipped:
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandRightImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandRightImages[(My_cached_info.fake_frame_counter % 84) // 7]
    if BEETLE_FRIEND.flipped:
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandRightImages[(My_cached_info.fake_frame_counter % 84) // 7]
    BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
    if 0 <= distance_between_player_and_beetle <= 400:
      BEETLE_FRIEND.ShowingWhichDialogue = 1
    else:
      BEETLE_FRIEND.ShowingWhichDialogue = 0
    return
  #
  #
  if BEETLE_FRIEND.stage_in_movement == 2: # Walking out of cage
    if ALLKEYS[3].is_grabbed_by_player:
      BEETLE_FRIEND.substep = 31
      BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
    if BEETLE_FRIEND.substep == 0:
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.x_pos >= (1246 + ((1/2)*screen_width)):
        BEETLE_FRIEND.substep = 1
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if not BEETLE_FRIEND.flipped:
        BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
        BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      if BEETLE_FRIEND.flipped:
        BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
        BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      if 0 <= distance_between_player_and_beetle <= 400:
        if ((My_cached_info.fake_frame_counter - 40) > BEETLE_FRIEND.frame_at_last_stage_in_movement) and BEETLE_FRIEND.substep == 0:
          BEETLE_FRIEND.ShowingWhichDialogue = 2
      BEETLE_FRIEND.x_pos += 2
      return
    #
    if BEETLE_FRIEND.substep == 1: # look up
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 28:
        BEETLE_FRIEND.substep = 2
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation += 0.1
      BEETLE_FRIEND.y_pos -= 68*abs(math.sin(math.radians(BEETLE_FRIEND.rotation)) - math.sin(math.radians(BEETLE_FRIEND.rotation - 0.1)))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.RightLookUp[(BEETLE_FRIEND.time_since_last_substep % 30) // 5]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_RightLookUp[(BEETLE_FRIEND.time_since_last_substep % 30) // 5]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 2: # wait
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 65:
        BEETLE_FRIEND.substep = 3
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.RightLookUp[5]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_RightLookUp[5]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 3: # look down
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 28:
        BEETLE_FRIEND.substep = 4
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation -= 0.1
      BEETLE_FRIEND.y_pos += 68*abs(math.sin(math.radians(BEETLE_FRIEND.rotation)) - math.sin(math.radians(BEETLE_FRIEND.rotation - 0.1)))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.RightLookUp[5 - ((BEETLE_FRIEND.time_since_last_substep % 30) // 5)]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_RightLookUp[5 - ((BEETLE_FRIEND.time_since_last_substep % 30) // 5)]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 4: # crouch down to jump
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 34:
        BEETLE_FRIEND.substep = 5
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.y_pos += (14 / 36)
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.RightJump[(BEETLE_FRIEND.time_since_last_substep % 36) // 4]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_RightJump[(BEETLE_FRIEND.time_since_last_substep % 36) // 4]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 5: # stand up to jump
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 16:
        BEETLE_FRIEND.substep = 6
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation += 1.8
      BEETLE_FRIEND.y_pos -= 3
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.RightJump[8 - ((BEETLE_FRIEND.time_since_last_substep % 18) // 2)]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_RightJump[8 - ((BEETLE_FRIEND.time_since_last_substep % 18) // 2)]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 6: # moving up in the air
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 28:
        BEETLE_FRIEND.substep = 7
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2.6
      BEETLE_FRIEND.y_pos -= 3.6
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.RightInTheAir[(BEETLE_FRIEND.time_since_last_substep % 30) // 3]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_RightInTheAir[(BEETLE_FRIEND.time_since_last_substep % 30) // 3]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 7: # moving down in the air
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 28:
        BEETLE_FRIEND.substep = 8
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2.6
      BEETLE_FRIEND.y_pos += 0.2
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.RightInTheAir[9 - ((BEETLE_FRIEND.time_since_last_substep % 30) // 3)]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_RightInTheAir[9 - ((BEETLE_FRIEND.time_since_last_substep % 30) // 3)]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 8: # walking up slope, leg 1
      if BEETLE_FRIEND.time_since_last_substep == 1:
        BEETLE_FRIEND.x_pos, BEETLE_FRIEND.y_pos, BEETLE_FRIEND.rotation = 1998.7999999999947 - 600 + ((1/2)*screen_width), 4896.011780639595 - 350 + ((1/2)*screen_height), 35.6
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 150:
        BEETLE_FRIEND.substep = 9
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(29.5))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(29.5))
      if My_cached_info.fake_frame_counter % 2 == 0:
        BEETLE_FRIEND.rotation += 0.2
      if My_cached_info.fake_frame_counter % 2 == 1:
        BEETLE_FRIEND.rotation -= 0.2
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 9: # walking up slope, leg 2
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 150:
        BEETLE_FRIEND.substep = 10
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep < 30:
        if BEETLE_FRIEND.time_since_last_substep % 2 == 0:
          BEETLE_FRIEND.rotation -= 0.55
          BEETLE_FRIEND.y_pos += 0.55
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(20.7))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(20.7))
      if My_cached_info.fake_frame_counter % 2 == 0:
        BEETLE_FRIEND.rotation += 0.2
      if My_cached_info.fake_frame_counter % 2 == 1:
        BEETLE_FRIEND.rotation -= 0.2
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 10: # walking up slope, leg 3
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 380:
        BEETLE_FRIEND.substep = 11
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep < 30:
        if BEETLE_FRIEND.time_since_last_substep % 2 == 0:
          BEETLE_FRIEND.rotation -= 0.1
          BEETLE_FRIEND.y_pos += 0.12
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(15.7))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(15.7))
      if My_cached_info.fake_frame_counter % 2 == 0:
        BEETLE_FRIEND.rotation += 0.2
      if My_cached_info.fake_frame_counter % 2 == 1:
        BEETLE_FRIEND.rotation -= 0.2
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 11: # looking at the first room
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 130:
        BEETLE_FRIEND.substep = 12
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
        BEETLE_FRIEND.ShowingWhichDialogue = 0
        return
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandRightImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandRightImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 3
      return
    #
    if BEETLE_FRIEND.substep == 12: # turning down slope in first room
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 90:
        BEETLE_FRIEND.substep = 13
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep > 25:
        BEETLE_FRIEND.ShowingWhichDialogue = 4
      BEETLE_FRIEND.x_pos += 1.2
      BEETLE_FRIEND.y_pos += 0.465
      BEETLE_FRIEND.rotation -= 0.465
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 13: # walking in first room, leg 1
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 90:
        BEETLE_FRIEND.substep = 14
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(29.1))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(29.1))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 14: # walking in first room, leg 2
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 90:
        BEETLE_FRIEND.substep = 15
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(23.1))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(23.1))
      if BEETLE_FRIEND.time_since_last_substep < 50:
        BEETLE_FRIEND.rotation += 0.12
        BEETLE_FRIEND.y_pos -= 0.05
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 15: # walking in first room, leg 3
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 150:
        BEETLE_FRIEND.substep = 16
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(15.1))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(15.1))
      if BEETLE_FRIEND.time_since_last_substep < 50:
        BEETLE_FRIEND.rotation += 0.05
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 16: # walking in first room, leg 4
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 230:
        BEETLE_FRIEND.substep = 17
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(7.1))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(7.1))
      BEETLE_FRIEND.rotation += 0.05
      BEETLE_FRIEND.y_pos += 0.05
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 17: # walking in first room, leg 5
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 400:
        BEETLE_FRIEND.substep = 18
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
        BEETLE_FRIEND.rotation = 5
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(2.1))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(2.1))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 18: # walking in first room, leg 6
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 240:
        BEETLE_FRIEND.substep = 19
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 19: # walking in first room, leg 7
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 240:
        BEETLE_FRIEND.substep = 20
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(6.2))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(6.2))
      BEETLE_FRIEND.rotation += 0.032
      BEETLE_FRIEND.y_pos += 0.04
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 20: # walking in first room, leg 8
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 50:
        BEETLE_FRIEND.substep = 21
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(10))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(10))
      BEETLE_FRIEND.rotation += 0.07
      BEETLE_FRIEND.y_pos += 0.07
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 21: # walking in first room, leg 9
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 50:
        BEETLE_FRIEND.substep = 22
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(17))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(17))
      BEETLE_FRIEND.rotation += 0.12
      BEETLE_FRIEND.y_pos += 0.12
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 22: # walking in first room, leg 10
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 50:
        BEETLE_FRIEND.substep = 23
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(24))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(24))
      BEETLE_FRIEND.rotation += 0.15
      BEETLE_FRIEND.y_pos += 0.10
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 23: # walking in first room, leg 11
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 50:
        BEETLE_FRIEND.substep = 24
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(34))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(34))
      BEETLE_FRIEND.rotation += 0.18
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 24: # walking in first room, leg 12
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 50:
        BEETLE_FRIEND.substep = 25
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(45))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(45))
      BEETLE_FRIEND.rotation += 0.21
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 25: # walking in first room, leg 13
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 50:
        BEETLE_FRIEND.substep = 26
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(55))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(55))
      BEETLE_FRIEND.rotation += 0.16
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 26: # walking in first room, leg 14
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 20:
        BEETLE_FRIEND.substep = 27
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(35))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(35))
      BEETLE_FRIEND.rotation -= 0.75
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 27: # walking in first room, leg 15
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 30:
        BEETLE_FRIEND.substep = 28
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(5))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(5))
      BEETLE_FRIEND.rotation -= 0.9
      BEETLE_FRIEND.y_pos += 0.8
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 28: # talking in front of door
      BEETLE_FRIEND.image_flipped = False
      if DOORS[3].is_open:
        BEETLE_FRIEND.x_pos = 6998.564001966768 - (1536 / 2) + ((1/2)*screen_width)
        BEETLE_FRIEND.y_pos = 4579.0 - (864 / 2) + ((1/2)*screen_height)
        BEETLE_FRIEND.rotation = 5
        BEETLE_FRIEND.stage_in_movement = 3
        BEETLE_FRIEND.substep = 0
        BEETLE_FRIEND.time_since_last_substep = 112
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter - 112
        BEETLE_FRIEND.red_door_opened_prematurely = True
        return
      if BEETLE_FRIEND.time_since_last_substep > 1150:
        BEETLE_FRIEND.substep = 29
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
        BEETLE_FRIEND.y_pos = 4447 - 300 + ((1/2)*screen_height)
        BEETLE_FRIEND.rotation = -5
        return
      if 0+100 <= BEETLE_FRIEND.time_since_last_substep < 150+100:
        BEETLE_FRIEND.ShowingWhichDialogue = 5
      if 125+100 <= BEETLE_FRIEND.time_since_last_substep < 150+100:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      if 150+100 <= BEETLE_FRIEND.time_since_last_substep < 300+100:
        BEETLE_FRIEND.ShowingWhichDialogue = 6
      if 275+100 <= BEETLE_FRIEND.time_since_last_substep < 300+100:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      if 300+100 <= BEETLE_FRIEND.time_since_last_substep < 450+100:
        BEETLE_FRIEND.ShowingWhichDialogue = 7
      if 425+100 <= BEETLE_FRIEND.time_since_last_substep < 450+100:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      if 450+100 <= BEETLE_FRIEND.time_since_last_substep < 600+100:
        BEETLE_FRIEND.ShowingWhichDialogue = 8
      if 575+100 <= BEETLE_FRIEND.time_since_last_substep < 600+100:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      if 600+100 <= BEETLE_FRIEND.time_since_last_substep < 750+100:
        BEETLE_FRIEND.ShowingWhichDialogue = 9
      if 725+100 <= BEETLE_FRIEND.time_since_last_substep < 750+100:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      if 750+100 <= BEETLE_FRIEND.time_since_last_substep < 900+100:
        BEETLE_FRIEND.ShowingWhichDialogue = 10
      if 875+100 <= BEETLE_FRIEND.time_since_last_substep < 900+100:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      if 900+100 <= BEETLE_FRIEND.time_since_last_substep < 1050+100:
        BEETLE_FRIEND.ShowingWhichDialogue = 11
      if 1025+100 <= BEETLE_FRIEND.time_since_last_substep < 1050+100:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandRightImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandRightImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 29: # walk left after talking by door
      BEETLE_FRIEND.image_flipped = True
      if BEETLE_FRIEND.time_since_last_substep > 110:
        BEETLE_FRIEND.substep = 30
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos -= 2
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 30: # asking hamster friend to open door
      BEETLE_FRIEND.image_flipped = True
      if BEETLE_FRIEND.time_since_last_substep > 700:
        BEETLE_FRIEND.substep = 31
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if 100 <= BEETLE_FRIEND.time_since_last_substep < 400:
        BEETLE_FRIEND.ShowingWhichDialogue = 12
      if 350 <= BEETLE_FRIEND.time_since_last_substep < 400:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      if 400 <= BEETLE_FRIEND.time_since_last_substep < 700:
        BEETLE_FRIEND.ShowingWhichDialogue = 13
      if 650 <= BEETLE_FRIEND.time_since_last_substep < 700:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 31: # asking hamster friend to open door
      BEETLE_FRIEND.image_flipped = True
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      BEETLE_FRIEND.x_pos, BEETLE_FRIEND.y_pos = 6606.564001966768 - 600 + ((1/2)*screen_width), 4447.0 - 300 + ((1/2)*screen_height)
      BEETLE_FRIEND.rotation = -5
      if ALLKEYS[3].is_inserted:
        BEETLE_FRIEND.stage_in_movement = 3
        BEETLE_FRIEND.substep = 0
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
        BEETLE_FRIEND.rotation = 5
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
  #
  #
  if BEETLE_FRIEND.stage_in_movement == 3: # walking past the red door, first room, center of AntHill
    if (7665 <= PLAYER.x_pos <= 9115) and (3985 <= PLAYER.y_pos <= 5045):
      BEETLE_FRIEND.substep = 27
    if BEETLE_FRIEND.substep == 0: # 1st leg after red door
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 130:
        BEETLE_FRIEND.substep = 1
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep == 25:
        BEETLE_FRIEND.ShowingWhichDialogue = 14
      BEETLE_FRIEND.x_pos += 2
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      if BEETLE_FRIEND.red_door_opened_prematurely:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 1: # 2nd leg after red door
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 60:
        BEETLE_FRIEND.substep = 2
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(7.2))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(7.2))
      BEETLE_FRIEND.rotation += 0.21
      BEETLE_FRIEND.y_pos -= 0.21
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      if BEETLE_FRIEND.red_door_opened_prematurely:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 2: # 3rd leg after red door
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 60:
        BEETLE_FRIEND.substep = 3
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(9))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(9))
      BEETLE_FRIEND.rotation += 0.04
      BEETLE_FRIEND.y_pos -= 0.04
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      if BEETLE_FRIEND.red_door_opened_prematurely:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 3: # 4th leg after red door
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 120:
        BEETLE_FRIEND.substep = 4
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
        BEETLE_FRIEND.ShowingWhichDialogue = 15
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(16))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(16))
      BEETLE_FRIEND.rotation += 0.01
      BEETLE_FRIEND.y_pos -= 0.01
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      if BEETLE_FRIEND.red_door_opened_prematurely:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 4: # 5th leg after red door
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 64:
        BEETLE_FRIEND.substep = 5
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(23))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(23))
      BEETLE_FRIEND.rotation += 0.07
      BEETLE_FRIEND.y_pos -= 0.07
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      if BEETLE_FRIEND.red_door_opened_prematurely:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 5: # 6th leg after red door
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 30:
        BEETLE_FRIEND.substep = 6
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(14))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(14))
      BEETLE_FRIEND.rotation -= 0.29
      BEETLE_FRIEND.y_pos += 0.29
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      if BEETLE_FRIEND.red_door_opened_prematurely:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 6: # 7th leg after red door
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 140:
        BEETLE_FRIEND.substep = 7
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep == 45:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(25))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(25))
      BEETLE_FRIEND.rotation += 0.18
      BEETLE_FRIEND.y_pos -= 0.145
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      if BEETLE_FRIEND.red_door_opened_prematurely:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 7: # 8th leg after red door
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 40:
        BEETLE_FRIEND.substep = 8
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 1.86*math.cos(math.radians(8))
      BEETLE_FRIEND.y_pos -= 1.86*math.sin(math.radians(8))
      BEETLE_FRIEND.rotation -= 0.65
      BEETLE_FRIEND.y_pos += 0.4
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 8: # 9th leg after red door
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 20:
        BEETLE_FRIEND.substep = 9
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(8))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(8))
      BEETLE_FRIEND.rotation -= 0.7
      BEETLE_FRIEND.y_pos += 0.75
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 9: # standing in 2nd room
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 60:
        BEETLE_FRIEND.substep = 10
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandRightImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandRightImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 10: # look up
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 28:
        BEETLE_FRIEND.substep = 11
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation += 0.1
      BEETLE_FRIEND.y_pos -= 68*abs(math.sin(math.radians(BEETLE_FRIEND.rotation)) - math.sin(math.radians(BEETLE_FRIEND.rotation - 0.1)))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.RightLookUp[(BEETLE_FRIEND.time_since_last_substep % 30) // 5]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_RightLookUp[(BEETLE_FRIEND.time_since_last_substep % 30) // 5]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 11: # wait
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 55:
        BEETLE_FRIEND.substep = 12
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.RightLookUp[5]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_RightLookUp[5]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 12: # look down
      BEETLE_FRIEND.image_flipped = False
      fence_door_might_be_open = False
      if BEETLE_FRIEND.time_since_last_substep > 28:
        BEETLE_FRIEND.substep = 13
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
        BEETLE_FRIEND.rotation = - 15
        BEETLE_FRIEND.y_pos -= 25
        fence_door_might_be_open = True
      BEETLE_FRIEND.rotation -= 0.1
      BEETLE_FRIEND.y_pos += 68*abs(math.sin(math.radians(BEETLE_FRIEND.rotation)) - math.sin(math.radians(BEETLE_FRIEND.rotation - 0.1)))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.RightLookUp[5 - ((BEETLE_FRIEND.time_since_last_substep % 30) // 5)]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_RightLookUp[5 - ((BEETLE_FRIEND.time_since_last_substep % 30) // 5)]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      if fence_door_might_be_open:
        if DOORS[6].is_open:
          BEETLE_FRIEND.stage_in_movement = 6
          BEETLE_FRIEND.substep = 0
      return
    #
    if BEETLE_FRIEND.substep == 13: # standing left in 2nd room
      BEETLE_FRIEND.image_flipped = True
      if BEETLE_FRIEND.time_since_last_substep > 20:
        BEETLE_FRIEND.substep = 14
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 14: # look up left
      BEETLE_FRIEND.image_flipped = True
      if BEETLE_FRIEND.time_since_last_substep > 28:
        BEETLE_FRIEND.substep = 15
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation -= 0.1
      #BEETLE_FRIEND.y_pos += 68*abs(math.sin(math.radians(BEETLE_FRIEND.rotation)) - math.sin(math.radians(BEETLE_FRIEND.rotation - 0.1)))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.LeftLookUp[(BEETLE_FRIEND.time_since_last_substep % 30) // 5]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_LeftLookUp[(BEETLE_FRIEND.time_since_last_substep % 30) // 5]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 15: # wait left
      BEETLE_FRIEND.image_flipped = True
      if BEETLE_FRIEND.time_since_last_substep > 55:
        BEETLE_FRIEND.substep = 16
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.LeftLookUp[5]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_LeftLookUp[5]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 16: # look down left
      BEETLE_FRIEND.image_flipped = True
      if BEETLE_FRIEND.time_since_last_substep > 28:
        BEETLE_FRIEND.substep = 17
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation += 0.1
      #BEETLE_FRIEND.y_pos -= 68*abs(math.sin(math.radians(BEETLE_FRIEND.rotation)) - math.sin(math.radians(BEETLE_FRIEND.rotation - 0.1)))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.LeftLookUp[5 - ((BEETLE_FRIEND.time_since_last_substep % 30) // 5)]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_LeftLookUp[5 - ((BEETLE_FRIEND.time_since_last_substep % 30) // 5)]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 17: # crouch down to jump
      BEETLE_FRIEND.image_flipped = True
      if BEETLE_FRIEND.time_since_last_substep > 34:
        BEETLE_FRIEND.substep = 18
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.y_pos += (14 / 36)
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.LeftJump[(BEETLE_FRIEND.time_since_last_substep % 36) // 4]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_LeftJump[(BEETLE_FRIEND.time_since_last_substep % 36) // 4]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 18: # stand up to jump
      BEETLE_FRIEND.image_flipped = True
      if BEETLE_FRIEND.time_since_last_substep > 16:
        BEETLE_FRIEND.substep = 19
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation -= 1.8
      BEETLE_FRIEND.y_pos -= 3
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.LeftJump[8 - ((BEETLE_FRIEND.time_since_last_substep % 18) // 2)]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_LeftJump[8 - ((BEETLE_FRIEND.time_since_last_substep % 18) // 2)]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 19: # moving up in the air
      BEETLE_FRIEND.image_flipped = True
      if BEETLE_FRIEND.time_since_last_substep > 58:
        BEETLE_FRIEND.substep = 20
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos -= 0.1
      BEETLE_FRIEND.y_pos -= 3.6
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.LeftInTheAir[(BEETLE_FRIEND.time_since_last_substep % 30) // 3]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_LeftInTheAir[(BEETLE_FRIEND.time_since_last_substep % 30) // 3]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 20: # moving down in the air
      BEETLE_FRIEND.image_flipped = True
      if BEETLE_FRIEND.time_since_last_substep > 48:
        BEETLE_FRIEND.substep = 21
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
        BEETLE_FRIEND.rotation = -5
      BEETLE_FRIEND.x_pos -= 0.1
      BEETLE_FRIEND.y_pos += 2
      BEETLE_FRIEND.rotation += 0.9
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.LeftInTheAir[9 - ((BEETLE_FRIEND.time_since_last_substep % 30) // 3)]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_LeftInTheAir[9 - ((BEETLE_FRIEND.time_since_last_substep % 30) // 3)]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 21: # standing left in 2nd room
      BEETLE_FRIEND.image_flipped = True
      if BEETLE_FRIEND.time_since_last_substep > 100:
        BEETLE_FRIEND.substep = 22
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 22: # standing left in 2nd room
      BEETLE_FRIEND.image_flipped = True
      if BEETLE_FRIEND.time_since_last_substep > 100:
        if distance_between_player_and_beetle < 300:
          BEETLE_FRIEND.substep = 23
          BEETLE_FRIEND.time_since_last_substep = -1
          BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
          BEETLE_FRIEND.ShowingWhichDialogue = 16
      BEETLE_FRIEND.x_pos, BEETLE_FRIEND.y_pos = 7284.437167228389 + ((1/2)*screen_width), 3679.0717373141556 + ((1/2)*screen_height)
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 23: # wait
      BEETLE_FRIEND.image_flipped = True
      if BEETLE_FRIEND.time_since_last_substep > 40:
        BEETLE_FRIEND.substep = 24
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 24: # preparing to press button
      BEETLE_FRIEND.image_flipped = True
      if BEETLE_FRIEND.time_since_last_substep > 40:
        BEETLE_FRIEND.substep = 25
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
        BEETLE_FRIEND.ShowingWhichDialogue = 0
        return
      if BEETLE_FRIEND.time_since_last_substep > 31:
        BEETLE_FRIEND.WhichButton += 1
      BEETLE_FRIEND.x_pos -= 2
      BEETLE_FRIEND.y_pos -= 2.2
      BEETLE_FRIEND.rotation -= 1.7
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 25: # button is pressed
      BEETLE_FRIEND.image_flipped = True
      if BEETLE_FRIEND.time_since_last_substep > 30:
        BEETLE_FRIEND.ShowingWhichDialogue = 32
      if BEETLE_FRIEND.time_since_last_substep > 500:
        BEETLE_FRIEND.substep = 26
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 26: # unpressing button
      BEETLE_FRIEND.image_flipped = True
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      if BEETLE_FRIEND.time_since_last_substep > 40:
        BEETLE_FRIEND.substep = 22
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
        return
      if BEETLE_FRIEND.time_since_last_substep > 31:
        BEETLE_FRIEND.WhichButton -= 1
      BEETLE_FRIEND.x_pos += 2
      BEETLE_FRIEND.y_pos += 2.2
      BEETLE_FRIEND.rotation += 1.7
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 27: # standing by double door (door #7)
      BEETLE_FRIEND.image_flipped = True
      if not (7665 <= PLAYER.x_pos <= 9115) or not (3985 <= PLAYER.y_pos <= 5045):
        BEETLE_FRIEND.substep = 22
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if ALLKEYS[6].is_inserted:
        BEETLE_FRIEND.substep = 0
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.stage_in_movement = 4
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
        return
      BEETLE_FRIEND.x_pos = 8723 + ((1/2)*screen_width)
      BEETLE_FRIEND.y_pos = 3958 + ((1/2)*screen_height)
      BEETLE_FRIEND.rotation = -5
      if False:
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
        BEETLE_FRIEND.ShowingWhichDialogue = 0
        return
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
  # 
  if BEETLE_FRIEND.stage_in_movement == 4: # entering brown door
    if BEETLE_FRIEND.substep == 0:
      BEETLE_FRIEND.image_flipped = True
      if BEETLE_FRIEND.time_since_last_substep > 64:
        BEETLE_FRIEND.substep = 1
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(0))
      BEETLE_FRIEND.y_pos += 0*math.sin(math.radians(0))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 1: # brown door right angle, leg 1
      BEETLE_FRIEND.ShowingWhichDialogue = 17
      if BEETLE_FRIEND.time_since_last_substep > 30:
        BEETLE_FRIEND.substep = 2
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation += 0.75
      BEETLE_FRIEND.y_pos += 0.3
      BEETLE_FRIEND.x_pos -= 0.2*math.cos(math.radians(15))
      BEETLE_FRIEND.y_pos += 0.7*math.sin(math.radians(15))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 2: # brown door right angle, leg 2
      if BEETLE_FRIEND.time_since_last_substep > 30:
        BEETLE_FRIEND.substep = 3
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation += 0.75
      BEETLE_FRIEND.y_pos += 0.2
      BEETLE_FRIEND.x_pos -= 0.2*math.cos(math.radians(30))
      BEETLE_FRIEND.y_pos += 0.7*math.sin(math.radians(30))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 3: # brown door right angle, leg 3
      if BEETLE_FRIEND.time_since_last_substep > 30:
        BEETLE_FRIEND.substep = 4
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation += 0.75
      BEETLE_FRIEND.y_pos += 0.15
      BEETLE_FRIEND.x_pos += 0.7
      BEETLE_FRIEND.y_pos += 0.7*math.sin(math.radians(45))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 4: # brown door right angle, leg 4
      if BEETLE_FRIEND.time_since_last_substep > 30:
        BEETLE_FRIEND.substep = 5
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation += 0.5
      BEETLE_FRIEND.y_pos += 0.15
      BEETLE_FRIEND.x_pos += 0.55
      BEETLE_FRIEND.y_pos += 0.7*math.sin(math.radians(80))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 5: # after brown door, leg 1
      if BEETLE_FRIEND.time_since_last_substep > 60:
        BEETLE_FRIEND.substep = 6
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep > 30:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      BEETLE_FRIEND.y_pos += 2
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 6: # after brown door, leg 2
      BEETLE_FRIEND.ShowingWhichDialogue = 18
      if BEETLE_FRIEND.time_since_last_substep > 95:
        BEETLE_FRIEND.substep = 7
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation -= 0.35
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(56))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(56))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 7: # after brown door, leg 3
      if BEETLE_FRIEND.time_since_last_substep > 55:
        BEETLE_FRIEND.substep = 8
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation -= 0.6
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(48))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(48))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 8: # after brown door, leg 4
      if BEETLE_FRIEND.time_since_last_substep > 153:
        BEETLE_FRIEND.substep = 9
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep < 30:
        BEETLE_FRIEND.rotation -= 0.3
      if BEETLE_FRIEND.time_since_last_substep > 70:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      if BEETLE_FRIEND.time_since_last_substep > 100:
        BEETLE_FRIEND.ShowingWhichDialogue = 19
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(8))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(8))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 9: # after brown door, leg 5
      if BEETLE_FRIEND.time_since_last_substep > 15:
        BEETLE_FRIEND.substep = 10
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation += 1.05
      BEETLE_FRIEND.y_pos -= 1
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(34))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(34))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 10: # after brown door, leg 6
      if BEETLE_FRIEND.time_since_last_substep > 25:
        BEETLE_FRIEND.substep = 11
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation += 1.02
      BEETLE_FRIEND.y_pos -= 1
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(56))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(56))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 11: # after brown door, leg 7
      if BEETLE_FRIEND.time_since_last_substep > 100:
        BEETLE_FRIEND.substep = 12
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep < 45:
        BEETLE_FRIEND.rotation += 0.57
        BEETLE_FRIEND.y_pos -= 0.5
        BEETLE_FRIEND.x_pos += 0.43
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(77))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(77))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 12: # after brown door, leg 8
      if BEETLE_FRIEND.time_since_last_substep > 85:
        BEETLE_FRIEND.substep = 13
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep > 15:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      if BEETLE_FRIEND.time_since_last_substep > 45:
        BEETLE_FRIEND.ShowingWhichDialogue = 20
      BEETLE_FRIEND.rotation -= 0.16
      BEETLE_FRIEND.y_pos += 0.16
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(58))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(58))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 13: # after brown door, leg 9
      if BEETLE_FRIEND.time_since_last_substep > 75:
        BEETLE_FRIEND.substep = 14
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation -= 0.57
      BEETLE_FRIEND.y_pos += 0.5
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(35))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(35))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 14: # after brown door, leg 10
      if BEETLE_FRIEND.time_since_last_substep > 532:
        BEETLE_FRIEND.substep = 15
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep > 100:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      if BEETLE_FRIEND.time_since_last_substep > 130:
        BEETLE_FRIEND.ShowingWhichDialogue = 21
      if BEETLE_FRIEND.time_since_last_substep > 380:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      if BEETLE_FRIEND.time_since_last_substep < 25:
        BEETLE_FRIEND.rotation -= 0.69
        BEETLE_FRIEND.y_pos += 1.2
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(4.8))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(4.8))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 15: # after brown door, leg 11
      if BEETLE_FRIEND.time_since_last_substep > 250:
        BEETLE_FRIEND.substep = 16
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep < 50:
        BEETLE_FRIEND.rotation += 0.45
        BEETLE_FRIEND.y_pos -= 0.5
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(24))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(24))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 16: # after brown door, leg 12
      if BEETLE_FRIEND.time_since_last_substep > 270:
        BEETLE_FRIEND.substep = 17
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep < 50:
        BEETLE_FRIEND.rotation -= 0.25
        BEETLE_FRIEND.y_pos += 0.25
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(17))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(17))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 17: # after brown door, leg 13
      if BEETLE_FRIEND.time_since_last_substep > 70:
        BEETLE_FRIEND.substep = 18
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep < 50:
        BEETLE_FRIEND.rotation += 0.26
        BEETLE_FRIEND.y_pos -= 0.5
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(27))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(27))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 18: # wait
      if BEETLE_FRIEND.time_since_last_substep > 30:
        BEETLE_FRIEND.substep = 19
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 19: # crouch down to jump
      if BEETLE_FRIEND.time_since_last_substep > 34:
        BEETLE_FRIEND.substep = 20
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.y_pos += (14 / 36)
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.LeftJump[(BEETLE_FRIEND.time_since_last_substep % 36) // 4]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_LeftJump[(BEETLE_FRIEND.time_since_last_substep % 36) // 4]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 20: # stand up to jump
      if BEETLE_FRIEND.time_since_last_substep > 16:
        BEETLE_FRIEND.substep = 21
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos -= 2
      BEETLE_FRIEND.y_pos -= 3
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.LeftJump[8 - ((BEETLE_FRIEND.time_since_last_substep % 18) // 2)]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_LeftJump[8 - ((BEETLE_FRIEND.time_since_last_substep % 18) // 2)]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 21: # moving up in the air
      if BEETLE_FRIEND.time_since_last_substep > 10:
        BEETLE_FRIEND.substep = 22
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos -= 2
      BEETLE_FRIEND.y_pos -= 2.6
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.LeftInTheAir[(BEETLE_FRIEND.time_since_last_substep % 10) // 1]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_LeftInTheAir[(BEETLE_FRIEND.time_since_last_substep % 10) // 1]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 22: # moving down in the air
      if BEETLE_FRIEND.time_since_last_substep > 124:
        BEETLE_FRIEND.substep = 0
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.stage_in_movement = 5
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation -= 0.15
      BEETLE_FRIEND.x_pos -= 2
      BEETLE_FRIEND.y_pos += 2
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.LeftInTheAir[9 - ((BEETLE_FRIEND.time_since_last_substep % 100) // 10)]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_LeftInTheAir[9 - ((BEETLE_FRIEND.time_since_last_substep % 100) // 10)]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
  #
  if BEETLE_FRIEND.stage_in_movement == 5: # after jump
    if BEETLE_FRIEND.substep == 0: # wait
      BEETLE_FRIEND.x_pos = 5963.595789499332 - 600 + ((1/2)*screen_width)
      BEETLE_FRIEND.y_pos = 5914.264040635504 - 300 + ((1/2)*screen_height)
      BEETLE_FRIEND.rotation = 2.900000000000386
      if BEETLE_FRIEND.time_since_last_substep > 15:
        BEETLE_FRIEND.substep = 1
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 1: # walk after jump, leg 1
      if BEETLE_FRIEND.time_since_last_substep > 110:
        BEETLE_FRIEND.substep = 2
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation -= 0.06
      BEETLE_FRIEND.y_pos += 0
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(8))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(8))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 2: # walk after jump, leg 2
      BEETLE_FRIEND.ShowingWhichDialogue = 23
      if BEETLE_FRIEND.time_since_last_substep > 100:
        BEETLE_FRIEND.substep = 3
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation -= 0.16
      BEETLE_FRIEND.y_pos += 0.08
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(18))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(18))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 3: # walk after jump, leg 3
      if BEETLE_FRIEND.time_since_last_substep > 189:
        BEETLE_FRIEND.substep = 4
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep < 110:
        BEETLE_FRIEND.rotation -= 0.17
        BEETLE_FRIEND.y_pos += 0.15
      if BEETLE_FRIEND.time_since_last_substep > 150:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(35))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(35))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 4: # walk after jump, leg 4
      BEETLE_FRIEND.ShowingWhichDialogue = 24
      if BEETLE_FRIEND.time_since_last_substep > 75:
        BEETLE_FRIEND.substep = 5
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation += 0.3
      BEETLE_FRIEND.y_pos += 0.13
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(16))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(16))
      if BEETLE_FRIEND.time_since_last_substep > 55:
        PLAYER.y_pos += 1.5
        BEETLE_FRIEND.rotation -= 0.3
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 5: # walk after jump, leg 5
      if BEETLE_FRIEND.time_since_last_substep > 220:
        BEETLE_FRIEND.substep = 6
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep < 60:
        BEETLE_FRIEND.rotation -= 0.2
        BEETLE_FRIEND.y_pos += 0.03
      if BEETLE_FRIEND.time_since_last_substep > 150:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(27))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(27))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 6: # walk after jump, leg 6
      BEETLE_FRIEND.ShowingWhichDialogue = 25
      if BEETLE_FRIEND.time_since_last_substep > 240:
        BEETLE_FRIEND.substep = 7
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep < 60:
        BEETLE_FRIEND.rotation += 0.15
        BEETLE_FRIEND.y_pos -= 0.1
      if BEETLE_FRIEND.time_since_last_substep > 215:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(16))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(16))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 7: # walk after jump, leg 7
      BEETLE_FRIEND.ShowingWhichDialogue = 26
      if BEETLE_FRIEND.time_since_last_substep > 125:
        BEETLE_FRIEND.substep = 8
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation -= 0.1
      BEETLE_FRIEND.y_pos -= 0.02
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(23))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(23))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 8: # walk after jump, leg 8
      if BEETLE_FRIEND.time_since_last_substep > 90:
        BEETLE_FRIEND.substep = 9
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep < 30:
        BEETLE_FRIEND.rotation += 1.3
        BEETLE_FRIEND.y_pos += 0.5
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(13))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(13))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 9: # walk after jump, leg 9
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      if BEETLE_FRIEND.time_since_last_substep > 50:
        BEETLE_FRIEND.substep = 10
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation += 0.6
      BEETLE_FRIEND.y_pos -= 0.5
      BEETLE_FRIEND.x_pos -= 0.5*math.cos(math.radians(40))
      BEETLE_FRIEND.y_pos += 0.5*math.sin(math.radians(40))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 10: # walk after jump, leg 10
      if BEETLE_FRIEND.time_since_last_substep > 50:
        BEETLE_FRIEND.substep = 11
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation += 0.6
      BEETLE_FRIEND.x_pos += 0.2
      BEETLE_FRIEND.y_pos -= 0.2
      BEETLE_FRIEND.x_pos -= 0.5*math.cos(math.radians(85))
      BEETLE_FRIEND.y_pos += 0.5*math.sin(math.radians(85))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 11: # walk after jump, leg 11
      if BEETLE_FRIEND.time_since_last_substep > 130:
        BEETLE_FRIEND.substep = 12
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation += 0.6
      BEETLE_FRIEND.x_pos += 0.25
      BEETLE_FRIEND.y_pos += 0.2
      BEETLE_FRIEND.x_pos += 0.5*math.cos(math.radians(60))
      BEETLE_FRIEND.y_pos += 0.5*math.sin(math.radians(60))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 12: # walk after jump, leg 12
      if BEETLE_FRIEND.time_since_last_substep > 150:
        BEETLE_FRIEND.substep = 13
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(30))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(30))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 13: # walk after jump, leg 13
      if BEETLE_FRIEND.time_since_last_substep > 75:
        BEETLE_FRIEND.substep = 14
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation -= 0.44
      BEETLE_FRIEND.x_pos += 0.54
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(60))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(60))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 14: # walk after jump, leg 14
      if BEETLE_FRIEND.time_since_last_substep > 50:
        BEETLE_FRIEND.substep = 15
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation -= 0.5
      if BEETLE_FRIEND.rotation%360>90:
        BEETLE_FRIEND.x_pos += 0.4
      BEETLE_FRIEND.y_pos += 2
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 15: # walk after jump, leg 15
      if BEETLE_FRIEND.time_since_last_substep > 65:
        BEETLE_FRIEND.substep = 16
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation -= 0.5
      BEETLE_FRIEND.x_pos += 0.3
      BEETLE_FRIEND.y_pos += 0.1
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(50))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(50))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 16: # walk after jump, leg 16
      if BEETLE_FRIEND.time_since_last_substep > 113:
        BEETLE_FRIEND.substep = 17
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation -= 0.25
      BEETLE_FRIEND.y_pos += 0.35
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(28))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(28))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 17: # walk after jump, leg 17
      BEETLE_FRIEND.ShowingWhichDialogue = 27
      if BEETLE_FRIEND.time_since_last_substep > 290:
        BEETLE_FRIEND.substep = 18
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep < 50:
        BEETLE_FRIEND.rotation -= 0.45
        BEETLE_FRIEND.y_pos += 0.9
      if BEETLE_FRIEND.time_since_last_substep > 50:
        BEETLE_FRIEND.y_pos -= 20 * (1/180)
      if BEETLE_FRIEND.time_since_last_substep > 260:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(3))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(3))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 18: # walk after jump, leg 18
      BEETLE_FRIEND.ShowingWhichDialogue = 28
      if BEETLE_FRIEND.time_since_last_substep > 133:
        BEETLE_FRIEND.substep = 19
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep < 25:
        BEETLE_FRIEND.rotation += 0.7
        BEETLE_FRIEND.y_pos -= 0.6
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(17))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(17))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 19: # walk after jump, leg 19
      if BEETLE_FRIEND.time_since_last_substep > 150:
        BEETLE_FRIEND.substep = 20
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep < 25:
        BEETLE_FRIEND.rotation -= 0.75
        BEETLE_FRIEND.y_pos += 0.7
      if BEETLE_FRIEND.time_since_last_substep > 120:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(4))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(4))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 20: # walk after jump, leg 20
      BEETLE_FRIEND.ShowingWhichDialogue = 29
      if BEETLE_FRIEND.time_since_last_substep > 259:
        BEETLE_FRIEND.substep = 21
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep < 205:
        BEETLE_FRIEND.rotation -= 8.75*(1/205)
      if BEETLE_FRIEND.time_since_last_substep > 230:
        BEETLE_FRIEND.ShowingWhichDialogue = 0
      BEETLE_FRIEND.x_pos -= 2*math.cos(math.radians(3.5))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(3.5))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 21: # walk after jump, leg 21
      BEETLE_FRIEND.ShowingWhichDialogue = 30
      if BEETLE_FRIEND.time_since_last_substep > 80:
        BEETLE_FRIEND.substep = 22
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.y_pos += 0.07
      if BEETLE_FRIEND.rotation < -5: 
        BEETLE_FRIEND.rotation += 0.4
      if BEETLE_FRIEND.rotation > -5:
        BEETLE_FRIEND.rotation = -5
      BEETLE_FRIEND.x_pos -= 2
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkLeftImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 22: # wait
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandLeftImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
  #
  #
  if BEETLE_FRIEND.stage_in_movement == 6: # fence door is already open
    if BEETLE_FRIEND.substep == 0: # walk to fence door 1
      if BEETLE_FRIEND.time_since_last_substep == 1:
        BEETLE_FRIEND.x_pos = 8063.237167228428 - 768 + ((1/2)*screen_width)
        BEETLE_FRIEND.y_pos = 4287.746068643168 - 432 + ((1/2)*screen_height)
        BEETLE_FRIEND.rotation = 1.1500000000002464
      if BEETLE_FRIEND.time_since_last_substep > 120:
        BEETLE_FRIEND.substep = 1
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep > 30:
        BEETLE_FRIEND.rotation -= 0.1
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(10))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(10))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 1: # walk to fence door 2
      if BEETLE_FRIEND.time_since_last_substep > 63:
        BEETLE_FRIEND.substep = 2
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation += 0.15
      BEETLE_FRIEND.y_pos += 0.15
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(5))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(5))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 2: # walk to fence door 3
      if BEETLE_FRIEND.time_since_last_substep > 72:
        BEETLE_FRIEND.substep = 3
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if BEETLE_FRIEND.time_since_last_substep > 25:
        BEETLE_FRIEND.rotation -= 0.3
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(5))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(5))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 3: # walk to fence door 4
      if BEETLE_FRIEND.time_since_last_substep > 20:
        BEETLE_FRIEND.substep = 4
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation += 0.7
      if (((BEETLE_FRIEND.rotation % 360) > 100) or ((BEETLE_FRIEND.rotation % 360) < 7)):
        BEETLE_FRIEND.y_pos += 0.7
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(12.5))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(12.5))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 4: # walk to fence door 5
      if BEETLE_FRIEND.time_since_last_substep > 25:
        BEETLE_FRIEND.substep = 5
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation += 0.4
      BEETLE_FRIEND.y_pos -= 0.4
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(12.5))
      BEETLE_FRIEND.y_pos -= 2*math.sin(math.radians(12.5))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 5: # walk to fence door 6
      if BEETLE_FRIEND.time_since_last_substep > 45:
        BEETLE_FRIEND.substep = 6
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.rotation -= 0.4
      if BEETLE_FRIEND.time_since_last_substep < 30:
        BEETLE_FRIEND.y_pos += 0.09
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(12.8))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(12.8))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 6: # walk to fence door 7
      if BEETLE_FRIEND.time_since_last_substep > 118:
        BEETLE_FRIEND.substep = 7
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if ((BEETLE_FRIEND.rotation % 360) > 100) or ((BEETLE_FRIEND.rotation % 360) < 7):
        BEETLE_FRIEND.rotation += 0.4
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(0))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(0))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 7: # walk to fence door 8
      if BEETLE_FRIEND.time_since_last_substep > 68:
        BEETLE_FRIEND.substep = 8
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      if ((BEETLE_FRIEND.rotation % 360) > 1.5):
        BEETLE_FRIEND.rotation -= 0.4
        BEETLE_FRIEND.y_pos += 0.1
      BEETLE_FRIEND.x_pos += 2*math.cos(math.radians(6.7))
      BEETLE_FRIEND.y_pos += 2*math.sin(math.radians(6.7))
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_WalkRightImages[(My_cached_info.fake_frame_counter % 168) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      return
    #
    if BEETLE_FRIEND.substep == 8: # wait
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 30:
        BEETLE_FRIEND.substep = 9
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.StandRightImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_StandRightImages[(My_cached_info.fake_frame_counter % 84) // 7]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 9: # crouch down to jump
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 34:
        BEETLE_FRIEND.substep = 10
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.y_pos += (14 / 36)
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.RightJump[(BEETLE_FRIEND.time_since_last_substep % 36) // 4]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_RightJump[(BEETLE_FRIEND.time_since_last_substep % 36) // 4]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 10: # stand up to jump
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 16:
        BEETLE_FRIEND.substep = 11
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 2
      BEETLE_FRIEND.y_pos -= 3
      BEETLE_FRIEND.rotation += 0.18
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.RightJump[8 - ((BEETLE_FRIEND.time_since_last_substep % 18) // 2)]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_RightJump[8 - ((BEETLE_FRIEND.time_since_last_substep % 18) // 2)]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 11: # moving up in the air
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 50:
        BEETLE_FRIEND.substep = 12
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 4
      BEETLE_FRIEND.y_pos -= 2
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.RightInTheAir[(BEETLE_FRIEND.time_since_last_substep % 30) // 3]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_RightInTheAir[(BEETLE_FRIEND.time_since_last_substep % 30) // 3]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 12: # moving down in the air
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 46:
        BEETLE_FRIEND.substep = 13
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
      BEETLE_FRIEND.x_pos += 3.5
      BEETLE_FRIEND.y_pos += 3.03
      BEETLE_FRIEND.current_image = BEETLE_FRIEND.RightInTheAir[9 - ((BEETLE_FRIEND.time_since_last_substep % 30) // 3)]
      BEETLE_FRIEND.GPU_current_image = BEETLE_FRIEND.GPU_RightInTheAir[9 - ((BEETLE_FRIEND.time_since_last_substep % 30) // 3)]
      BEETLE_FRIEND.current_image_rotated, BEETLE_FRIEND.rect = rotate_rectangular_image(BEETLE_FRIEND.current_image, BEETLE_FRIEND.rect, BEETLE_FRIEND.rotation)
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return
    #
    if BEETLE_FRIEND.substep == 13: # standing by brown door
      BEETLE_FRIEND.image_flipped = False
      if BEETLE_FRIEND.time_since_last_substep > 1:
        BEETLE_FRIEND.stage_in_movement = 3
        BEETLE_FRIEND.substep = 27
        BEETLE_FRIEND.time_since_last_substep = -1
        BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter
        BEETLE_FRIEND.x_pos = 8723 + ((1/2)*screen_width)
        BEETLE_FRIEND.y_pos = 3958 + ((1/2)*screen_height)
        BEETLE_FRIEND.rotation = -5
      BEETLE_FRIEND.ShowingWhichDialogue = 0
      return


def update_roots():
  for SingleRoot in ROOTS:
    update_root(SingleRoot)
    saved_last_accumulated_damage = SingleRoot.last_accumulated_damage
    SingleRoot.last_accumulated_damage = SingleRoot.accumulated_damage
    if SingleRoot.is_solid:
      if saved_last_accumulated_damage < SingleRoot.accumulated_damage:
        if not SingleRoot.playing_shaky_sound:
          SingleRoot.shaky_root_sound.play(-1)
          SingleRoot.playing_shaky_sound = True
      else:
        SingleRoot.shaky_root_sound.stop()
        SingleRoot.playing_shaky_sound = False


def update_root(SingleRoot):
  try:
    SingleRoot.RootBase_image = SingleRoot.RootBase_images[(SingleRoot.accumulated_damage - 1) // ((SingleRoot.allowable_damage) // len(SingleRoot.RootBase_images))]
    SingleRoot.GPU_RootBase_image = SingleRoot.GPU_RootBase_images[(SingleRoot.accumulated_damage - 1) // ((SingleRoot.allowable_damage) // len(SingleRoot.RootBase_images))]
  except:
    pass
  if SingleRoot.accumulated_damage <= 0:
    SingleRoot.accumulated_damage = 0
    SingleRoot.RootBase_image = SingleRoot.RootBase_images[0]
    SingleRoot.GPU_RootBase_image = SingleRoot.GPU_RootBase_images[0]
  #
  if SingleRoot.accumulated_damage >= SingleRoot.allowable_damage:
    if not SingleRoot.playing_breaky_root_sound:
      SingleRoot.playing_breaky_root_sound = True
      MixerSounds['BREAKY_ROOT'].play()
    if SingleRoot.playing_shaky_sound:
      SingleRoot.shaky_root_sound.stop()
      SingleRoot.playing_shaky_sound = False
    SingleRoot.currently_falling = True
    if SingleRoot.time_of_contact <= My_cached_info.fake_frame_counter - SingleRoot.time_to_finish_regrowth: # fully regrown
      SingleRoot.accumulated_damage = 0
      SingleRoot.currently_falling = False
      SingleRoot.is_solid = True
      SingleRoot.playing_breaky_root_sound = False
      return
    if (SingleRoot.time_of_contact + SingleRoot.time_to_finish_regrowth) < My_cached_info.fake_frame_counter:
      SingleRoot.time_of_contact = My_cached_info.fake_frame_counter
    if SingleRoot.currently_falling:
      if SingleRoot.time_of_contact == My_cached_info.fake_frame_counter:
        SingleRoot.currently_falling = True
      if SingleRoot.time_of_contact <= My_cached_info.fake_frame_counter < SingleRoot.time_of_contact + SingleRoot.time_to_finish_regrowth:
  #
        if SingleRoot.time_of_contact <= My_cached_info.fake_frame_counter <= SingleRoot.time_of_contact + SingleRoot.time_before_falling: # delay before falling
          return
  #
        if SingleRoot.time_of_contact + SingleRoot.time_before_falling <= My_cached_info.fake_frame_counter <= SingleRoot.time_of_contact + SingleRoot.time_before_falling + 52: # falling and fading animation
          if SingleRoot.grapple_connected:
            Marker.x_pos, Marker.y_pos, Marker.prev_x_pos, Marker.prev_y_pos, my_piston2.grapple_claw_x_pos, my_piston2.grapple_claw_y_pos = 0, 0, 0, 0, 0, 0
            regular_piston_sheath_update()
            regular_update_GrapplePiston(my_piston2)
            RELEASED_GRAPPLE_LAST_FRAME = True
            SingleRoot.grapple_connected = False
          SingleRoot.is_solid = False
          SingleRoot.actual_current_image = SingleRoot.FadingRootAnimation[(My_cached_info.fake_frame_counter - (SingleRoot.time_of_contact + SingleRoot.time_before_falling)) // 4]
          SingleRoot.GPU_actual_current_image = SingleRoot.GPU_FadingRootAnimation[(My_cached_info.fake_frame_counter - (SingleRoot.time_of_contact + SingleRoot.time_before_falling)) // 4]
          return
  #
        if SingleRoot.time_of_contact + SingleRoot.time_before_falling + 52 <= My_cached_info.fake_frame_counter < SingleRoot.time_of_contact + SingleRoot.time_to_start_regrowth: # waiting before regrowing
          SingleRoot.actual_current_image = SingleRoot.FadingRootAnimation[13]
          SingleRoot.GPU_actual_current_image = SingleRoot.GPU_FadingRootAnimation[13]
          total_time_in_this_event = (SingleRoot.time_of_contact + SingleRoot.time_to_start_regrowth) - (SingleRoot.time_of_contact + SingleRoot.time_before_falling + 52)
          current_time_in_this_event = My_cached_info.fake_frame_counter - (SingleRoot.time_of_contact + SingleRoot.time_before_falling + 52)
          SingleRoot.RootBase_image = SingleRoot.RootBase_images[abs((len(SingleRoot.RootBase_images) - 1) - (current_time_in_this_event // (total_time_in_this_event // len(SingleRoot.RootBase_images))))]
          SingleRoot.GPU_RootBase_image = SingleRoot.GPU_RootBase_images[abs((len(SingleRoot.RootBase_images) - 1) - (current_time_in_this_event // (total_time_in_this_event // len(SingleRoot.RootBase_images))))]
          return
  #
        if SingleRoot.time_of_contact + SingleRoot.time_to_start_regrowth <= My_cached_info.fake_frame_counter < SingleRoot.time_of_contact + SingleRoot.time_to_finish_regrowth: # currently regrowing
          SingleRoot.RootBase_image = SingleRoot.RootBase_images[0]
          SingleRoot.GPU_RootBase_image = SingleRoot.GPU_RootBase_images[0]
          if SingleRoot.grapple_connected:
            if not SingleRoot.flipped:
              my_piston2.grapple_claw_x_pos -= 2 * My_cached_info.target_fps_over_fps
              PLAYER.x_pos -= 2 * My_cached_info.target_fps_over_fps
            if SingleRoot.flipped:
              my_piston2.grapple_claw_x_pos += 2 * My_cached_info.target_fps_over_fps
              PLAYER.x_pos += 2 * My_cached_info.target_fps_over_fps
          SingleRoot.is_solid = True
          try:
            SingleRoot.actual_current_image = SingleRoot.RegrowthAnimation[(My_cached_info.fake_frame_counter - (SingleRoot.time_of_contact + SingleRoot.time_to_start_regrowth)) // 5]
            SingleRoot.current_image = SingleRoot.RegrowthCollision[(My_cached_info.fake_frame_counter - (SingleRoot.time_of_contact + SingleRoot.time_to_start_regrowth)) // 5]
            SingleRoot.GPU_actual_current_image = SingleRoot.GPU_RegrowthAnimation[(My_cached_info.fake_frame_counter - (SingleRoot.time_of_contact + SingleRoot.time_to_start_regrowth)) // 5]
            SingleRoot.GPU_current_image = SingleRoot.GPU_RegrowthCollision[(My_cached_info.fake_frame_counter - (SingleRoot.time_of_contact + SingleRoot.time_to_start_regrowth)) // 5]
          except:
            pass
          return
  #
  else:
    if SingleRoot.damaged_this_frame:
      SingleRoot.actual_current_image = SingleRoot.Shaky[(My_cached_info.fake_frame_counter % 24) // 6]
      SingleRoot.GPU_actual_current_image = SingleRoot.GPU_Shaky[(My_cached_info.fake_frame_counter % 24) // 6]
    if SingleRoot.grapple_connected:
      if not SingleRoot.damaged_this_frame:
        SingleRoot.actual_current_image = SingleRoot.Shaky[(My_cached_info.fake_frame_counter % 24) // 6]
        SingleRoot.GPU_actual_current_image = SingleRoot.GPU_Shaky[(My_cached_info.fake_frame_counter % 24) // 6]
        SingleRoot.accumulated_damage += 2 * My_cached_info.target_fps_over_fps
        SingleRoot.damaged_this_frame = True
    if not SingleRoot.damaged_this_frame:
      SingleRoot.actual_current_image = SingleRoot.Shaky[0]
      SingleRoot.GPU_actual_current_image = SingleRoot.GPU_Shaky[0]
    SingleRoot.damaged_this_frame = False
    SingleRoot.accumulated_damage -= 1 * My_cached_info.target_fps_over_fps
    if SingleRoot.accumulated_damage < 0:
      SingleRoot.accumulated_damage = 0
    SingleRoot.currently_falling = True
    SingleRoot.time_of_contact = My_cached_info.fake_frame_counter


def update_dripdrops():
  for SingleDripDrop in DRIPDROPS:
    update_dripdrop(SingleDripDrop)


def update_dripdrop(SingleDripDrop):
  if SingleDripDrop.stage_in_dripdrop == 0: # dripping
    SingleDripDrop.allowed_to_make_sound = True
    try:
      SingleDripDrop.actual_current_image = SingleDripDrop.drip[round(SingleDripDrop.substep) // 2]
      SingleDripDrop.GPU_actual_current_image = SingleDripDrop.GPU_drip[round(SingleDripDrop.substep) // 2]
    except:
      pass
    SingleDripDrop.substep += 1 * My_cached_info.target_fps_over_fps
    if (SingleDripDrop.substep // 2) > len(SingleDripDrop.drip)-1:
      SingleDripDrop.stage_in_dripdrop = 1
      SingleDripDrop.substep = 0
    return
  #
  if SingleDripDrop.stage_in_dripdrop == 1: # falling
    try:
      SingleDripDrop.actual_current_image = SingleDripDrop.Animation_images[(round(SingleDripDrop.substep) % 20) // 5]
      SingleDripDrop.GPU_actual_current_image = SingleDripDrop.GPU_Animation_images[(round(SingleDripDrop.substep) % 20) // 5]
    except:
      pass
    SingleDripDrop.substep += 1 * My_cached_info.target_fps_over_fps
    SingleDripDrop.vel = SingleDripDrop.vel + (SingleDripDrop.accel * (1 / fps))
    if SingleDripDrop.vel > SingleDripDrop.max_vel:
      SingleDripDrop.vel = SingleDripDrop.max_vel
    SingleDripDrop.y_pos = SingleDripDrop.y_pos + (SingleDripDrop.vel * (1 / fps) + ((1 / 2) * SingleDripDrop.accel * (1 / fps)**2))
    if SingleDripDrop.y_pos >= SingleDripDrop.end_y_pos:
      SingleDripDrop.y_pos = SingleDripDrop.end_y_pos
      SingleDripDrop.stage_in_dripdrop = 2
      SingleDripDrop.substep = 0
      SingleDripDrop.vel = 0
    return
  #
  if SingleDripDrop.stage_in_dripdrop == 2: # dropping
    if SingleDripDrop.allowed_to_make_sound:
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      distance_between_player_and_SingleDripDrop = find_hypotnuse(abs(absolute_center_of_player_x - (SingleDripDrop.x_pos - ((1/2)*screen_width) + (SingleDripDrop.rect[2]/2))), abs(absolute_center_of_player_y - (SingleDripDrop.y_pos - ((1/2)*screen_height) + (SingleDripDrop.rect[3]/2))))
      if distance_between_player_and_SingleDripDrop <= 600:
        DripDrop_loudness_distance_multiplier = ((600 - distance_between_player_and_SingleDripDrop) / 600)
        if DripDrop_loudness_distance_multiplier > 1:
          DripDrop_loudness_distance_multiplier = 1
        if DripDrop_loudness_distance_multiplier < 0:
          DripDrop_loudness_distance_multiplier = 0
        drip_drop_loudness = My_cached_info.current_sound_loudness * MixerSoundsLoudness['DRIP_DROP'] * DripDrop_loudness_distance_multiplier
        MixerSounds['DRIP_DROP'].set_volume(drip_drop_loudness)
        MixerSounds['DRIP_DROP'].play()
        SingleDripDrop.allowed_to_make_sound = False
    if SingleDripDrop.substep == 0:
      SingleDripDrop.x_pos -= 16
    try:
      SingleDripDrop.actual_current_image = SingleDripDrop.drop[round(SingleDripDrop.substep)]
      SingleDripDrop.GPU_actual_current_image = SingleDripDrop.GPU_drop[round(SingleDripDrop.substep)]
    except:
      pass
    SingleDripDrop.substep += 1 * My_cached_info.target_fps_over_fps
    if SingleDripDrop.substep > len(SingleDripDrop.drop)-1:
      SingleDripDrop.y_pos = SingleDripDrop.start_y_pos
      SingleDripDrop.x_pos += 16
      if SingleDripDrop.phantom_dropping:
        SingleDripDrop.substep = 0
        SingleDripDrop.phantom_dropping = False
        SingleDripDrop.stage_in_dripdrop = 3
        return
      SingleDripDrop.vel = SingleDripDrop.start_vel
      SingleDripDrop.stage_in_dripdrop = 0
      SingleDripDrop.substep = 0
    return
  #
  if SingleDripDrop.stage_in_dripdrop == 3: # phantom falling
    SingleDripDrop.phantom_vel = SingleDripDrop.phantom_vel + (SingleDripDrop.accel * (1 / fps))
    if SingleDripDrop.phantom_vel > SingleDripDrop.max_vel:
      SingleDripDrop.phantom_vel = SingleDripDrop.max_vel
    SingleDripDrop.phantom_y_pos = SingleDripDrop.phantom_y_pos + (SingleDripDrop.phantom_vel * (1 / fps) + ((1 / 2) * SingleDripDrop.accel * (1 / fps)**2))
    if SingleDripDrop.phantom_y_pos >= SingleDripDrop.end_y_pos:
      SingleDripDrop.stage_in_dripdrop = 0
      SingleDripDrop.substep = 0
      SingleDripDrop.vel = SingleDripDrop.start_vel
    return


def update_background(SingleBackground):
  SingleBackground.number_of_milliseconds_since_updating_image += delta_milliseconds
  if SingleBackground.special_directions == 1:
    if (((PLAYER.x_dif == 0) and (PLAYER.y_dif == 0)) or PLAYER.changed_region_last_frame):
      SingleBackground.current_images = []
      SingleBackground.GPU_current_images = []
      SingleBackground.current_x_poses = []
      SingleBackground.current_y_poses = []
      if SingleBackground.number_of_milliseconds_since_updating_image >= SingleBackground.iteration_speed:
        SingleBackground.number_of_milliseconds_since_updating_image %= SingleBackground.iteration_speed
        SingleBackground.current_image_number += 1
        if SingleBackground.current_image_number == len(SingleBackground.GPU_images):
          SingleBackground.current_image_number = 0
      #SingleBackground.image = SingleBackground.images[SingleBackground.current_image_number]
      SingleBackground.GPU_image = SingleBackground.GPU_images[SingleBackground.current_image_number]
      number_long = (screen_width // SingleBackground.GPU_images[0][0][0]) + 1
      number_tall = (screen_height // SingleBackground.GPU_images[0][0][1]) + 1
      SingleBackground.x_pos -= (SingleBackground.scroll_speed_x * ((PLAYER.prev_x_pos[-1] - PLAYER.prev_x_pos[-2]) / (1 / fps))) * My_cached_info.target_fps_over_fps
      SingleBackground.y_pos -= (SingleBackground.scroll_speed_y * ((PLAYER.prev_y_pos[-1] - PLAYER.prev_y_pos[-2]) / (1 / fps))) * My_cached_info.target_fps_over_fps
      SingleBackground.x_pos = SingleBackground.x_pos - ((SingleBackground.x_pos // SingleBackground.GPU_images[0][0][0]) * SingleBackground.GPU_images[0][0][0])
      SingleBackground.y_pos = SingleBackground.y_pos - ((SingleBackground.y_pos // SingleBackground.GPU_images[0][0][1]) * SingleBackground.GPU_images[0][0][1])
      if not SingleBackground.scroll_leftright:
        SingleBackground.x_pos = - PLAYER.x_pos + ((1/2)*screen_width) + PLAYER.blit_change_x
        if SingleBackground.x_pos >= 0:
          number_long += 1
      if not SingleBackground.scroll_updown:
        SingleBackground.y_pos = - PLAYER.y_pos + ((1/2)*screen_height) + PLAYER.blit_change_y
        if SingleBackground.y_pos >= 0:
          number_tall += 1
      if SingleBackground.scroll_leftright:
        if SingleBackground.x_pos <= screen_width:
          number_long += 1
      if SingleBackground.scroll_updown:
        if SingleBackground.y_pos <= screen_height:
          number_tall += 1
      long_start, tall_start = 0, 0
      if SingleBackground.scroll_leftright:
        long_start -= 1
      if SingleBackground.scroll_updown:
        tall_start -= 1
      if SingleBackground.permanent_add_x != 0:
        number_long = 1
      if SingleBackground.permanent_add_y != 0:
        number_tall = 1
      for long in range(number_long):
        for tall in range(number_tall):
          #SingleBackground.current_images.append(SingleBackground.image)
          SingleBackground.GPU_current_images.append(SingleBackground.GPU_image)
          SingleBackground.current_x_poses.append(SingleBackground.x_pos + (SingleBackground.GPU_images[0][0][0]*(long+long_start)))
          SingleBackground.current_y_poses.append(SingleBackground.y_pos + (SingleBackground.GPU_images[0][0][1]*(tall+tall_start)))
      return
  #
    if PLAYER.x_dif != 0 and PLAYER.y_dif == 0:
      SingleBackground.current_images = []
      SingleBackground.GPU_current_images = []
      SingleBackground.current_y_poses = []
      if SingleBackground.number_of_milliseconds_since_updating_image >= SingleBackground.iteration_speed:
        SingleBackground.number_of_milliseconds_since_updating_image %= SingleBackground.iteration_speed
        SingleBackground.current_image_number += 1
        if SingleBackground.current_image_number == len(SingleBackground.GPU_images):
          SingleBackground.current_image_number = 0
      #SingleBackground.image = SingleBackground.images[SingleBackground.current_image_number]
      SingleBackground.GPU_image = SingleBackground.GPU_images[SingleBackground.current_image_number]
      number_long = (screen_width // SingleBackground.GPU_images[0][0][0]) + 1
      number_tall = (screen_height // SingleBackground.GPU_images[0][0][1]) + 1
      SingleBackground.y_pos -= (SingleBackground.scroll_speed_y * ((PLAYER.prev_y_pos[-1] - PLAYER.prev_y_pos[-2]) / (1 / fps))) * My_cached_info.target_fps_over_fps
      SingleBackground.y_pos = SingleBackground.y_pos - ((SingleBackground.y_pos // SingleBackground.GPU_images[0][0][1]) * SingleBackground.GPU_images[0][0][1])
      if not SingleBackground.scroll_leftright:
        SingleBackground.x_pos = - PLAYER.x_pos + ((1/2)*screen_width) + PLAYER.blit_change_x
        if SingleBackground.x_pos >= 0:
          number_long += 1
      if not SingleBackground.scroll_updown:
        SingleBackground.y_pos = - PLAYER.y_pos + ((1/2)*screen_height) + PLAYER.blit_change_y
        if SingleBackground.y_pos >= 0:
          number_tall += 1
      if SingleBackground.scroll_leftright:
        if SingleBackground.x_pos <= screen_width:
          number_long += 1
      if SingleBackground.scroll_updown:
        if SingleBackground.y_pos <= screen_height:
          number_tall += 1
      long_start, tall_start = 0, 0
      if SingleBackground.scroll_leftright:
        long_start -= 1
      if SingleBackground.scroll_updown:
        tall_start -= 1
      if SingleBackground.permanent_add_x != 0:
        number_long = 1
      if SingleBackground.permanent_add_y != 0:
        number_tall = 1
      for long in range(number_long):
        for tall in range(number_tall):
          #SingleBackground.current_images.append(SingleBackground.image)
          SingleBackground.GPU_current_images.append(SingleBackground.GPU_image)
          SingleBackground.current_y_poses.append(SingleBackground.y_pos + (SingleBackground.GPU_images[0][0][1]*(tall+tall_start)))
      if len(SingleBackground.current_y_poses) > len(SingleBackground.current_x_poses):
        SingleBackground.current_x_poses += SingleBackground.current_x_poses
        if (SingleBackground.current_x_poses[0:len(SingleBackground.current_x_poses)//2] == SingleBackground.current_x_poses[len(SingleBackground.current_x_poses)//2:]) and (SingleBackground.current_y_poses[0:len(SingleBackground.current_y_poses)//2] == SingleBackground.current_y_poses[len(SingleBackground.current_y_poses)//2:]):
          xlist1 = SingleBackground.current_x_poses[0:len(SingleBackground.current_x_poses)//2]
          xlist2 = SingleBackground.current_x_poses[len(SingleBackground.current_x_poses)//2:]
          xlist2.reverse()
          SingleBackground.current_x_poses = xlist1 + xlist2
      if len(SingleBackground.current_y_poses) < len(SingleBackground.current_x_poses):
        if SingleBackground.current_x_poses[:len(SingleBackground.current_x_poses)//2] == SingleBackground.current_x_poses[len(SingleBackground.current_x_poses)//2:]:
          SingleBackground.current_x_poses = SingleBackground.current_x_poses[:len(SingleBackground.current_x_poses)//2]
        else:
          SingleBackground.current_x_poses = [SingleBackground.current_x_poses[0]] + [SingleBackground.current_x_poses[len(SingleBackground.current_x_poses)//2]]
      return
  #
    if PLAYER.x_dif == 0 and PLAYER.y_dif != 0:
      SingleBackground.current_images = []
      SingleBackground.GPU_current_images = []
      SingleBackground.current_x_poses = []
      if SingleBackground.number_of_milliseconds_since_updating_image >= SingleBackground.iteration_speed:
        SingleBackground.number_of_milliseconds_since_updating_image %= SingleBackground.iteration_speed
        SingleBackground.current_image_number += 1
        if SingleBackground.current_image_number == len(SingleBackground.GPU_images):
          SingleBackground.current_image_number = 0
      #SingleBackground.image = SingleBackground.images[SingleBackground.current_image_number]
      SingleBackground.GPU_image = SingleBackground.GPU_images[SingleBackground.current_image_number]
      number_long = (screen_width // SingleBackground.GPU_images[0][0][0]) + 1
      number_tall = (screen_height // SingleBackground.GPU_images[0][0][1]) + 1
      SingleBackground.x_pos -= (SingleBackground.scroll_speed_x * ((PLAYER.prev_x_pos[-1] - PLAYER.prev_x_pos[-2]) / (1 / fps))) * My_cached_info.target_fps_over_fps
      SingleBackground.x_pos = SingleBackground.x_pos - ((SingleBackground.x_pos // SingleBackground.GPU_images[0][0][0]) * SingleBackground.GPU_images[0][0][0])
      if not SingleBackground.scroll_leftright:
        SingleBackground.x_pos = - PLAYER.x_pos + ((1/2)*screen_width) + PLAYER.blit_change_x
        if SingleBackground.x_pos >= 0:
          number_long += 1
      if not SingleBackground.scroll_updown:
        SingleBackground.y_pos = - PLAYER.y_pos + ((1/2)*screen_height) + PLAYER.blit_change_y
        if SingleBackground.y_pos >= 0:
          number_tall += 1
      if SingleBackground.scroll_leftright:
        if SingleBackground.x_pos <= screen_width:
          number_long += 1
      if SingleBackground.scroll_updown:
        if SingleBackground.y_pos <= screen_height:
          number_tall += 1
      long_start, tall_start = 0, 0
      if SingleBackground.scroll_leftright:
        long_start -= 1
      if SingleBackground.scroll_updown:
        tall_start -= 1
      if SingleBackground.permanent_add_x != 0:
        number_long = 1
      if SingleBackground.permanent_add_y != 0:
        number_tall = 1
      for long in range(number_long):
        for tall in range(number_tall):
          #SingleBackground.current_images.append(SingleBackground.image)
          SingleBackground.GPU_current_images.append(SingleBackground.GPU_image)
          SingleBackground.current_x_poses.append(SingleBackground.x_pos + (SingleBackground.GPU_images[0][0][0]*(long+long_start)))
      if len(SingleBackground.current_y_poses) < len(SingleBackground.current_x_poses):
        SingleBackground.current_y_poses += SingleBackground.current_y_poses
        if (SingleBackground.current_x_poses[0:len(SingleBackground.current_x_poses)//2] == SingleBackground.current_x_poses[len(SingleBackground.current_x_poses)//2:]) and (SingleBackground.current_y_poses[0:len(SingleBackground.current_y_poses)//2] == SingleBackground.current_y_poses[len(SingleBackground.current_y_poses)//2:]):
          ylist1 = SingleBackground.current_y_poses[0:len(SingleBackground.current_y_poses)//2]
          ylist2 = SingleBackground.current_y_poses[len(SingleBackground.current_y_poses)//2:]
          ylist2.reverse()
          SingleBackground.current_y_poses = ylist1 + ylist2
      if len(SingleBackground.current_y_poses) > len(SingleBackground.current_x_poses):
        if SingleBackground.current_y_poses[:len(SingleBackground.current_y_poses)//2] == SingleBackground.current_y_poses[len(SingleBackground.current_y_poses)//2:]:
          SingleBackground.current_y_poses = SingleBackground.current_y_poses[:len(SingleBackground.current_y_poses)//2]
        else:
          SingleBackground.current_y_poses = [SingleBackground.current_y_poses[0]] + [SingleBackground.current_y_poses[len(SingleBackground.current_y_poses)//2]]
      return
  #
    if PLAYER.x_dif != 0 and PLAYER.y_dif != 0:
      SingleBackground.current_images = []
      SingleBackground.GPU_current_images = []
      if SingleBackground.number_of_milliseconds_since_updating_image >= SingleBackground.iteration_speed:
        SingleBackground.number_of_milliseconds_since_updating_image %= SingleBackground.iteration_speed
        SingleBackground.current_image_number += 1
        if SingleBackground.current_image_number == len(SingleBackground.GPU_images):
          SingleBackground.current_image_number = 0
      #SingleBackground.image = SingleBackground.images[SingleBackground.current_image_number]
      SingleBackground.GPU_image = SingleBackground.GPU_images[SingleBackground.current_image_number]
      for i in range(len(SingleBackground.current_x_poses)):
        #SingleBackground.current_images.append(SingleBackground.image)
        SingleBackground.GPU_current_images.append(SingleBackground.GPU_image)
      return
  #
  #
  if SingleBackground.special_directions == 2:
    if (((PLAYER.x_dif == 0) and (PLAYER.y_dif == 0)) or PLAYER.changed_region_last_frame):
      SingleBackground.current_images = []
      SingleBackground.GPU_current_images = []
      SingleBackground.current_x_poses = []
      SingleBackground.current_y_poses = []
      if SingleBackground.number_of_milliseconds_since_updating_image >= SingleBackground.iteration_speed:
        SingleBackground.number_of_milliseconds_since_updating_image %= SingleBackground.iteration_speed
        SingleBackground.current_image_number += 1
        if SingleBackground.current_image_number == len(SingleBackground.GPU_images):
          SingleBackground.current_image_number = 0
      #SingleBackground.image = SingleBackground.images[SingleBackground.current_image_number]
      SingleBackground.GPU_image = SingleBackground.GPU_images[SingleBackground.current_image_number]
      number_long = (screen_width // SingleBackground.GPU_images[0][0][0]) + 1
      number_tall = (screen_height // SingleBackground.GPU_images[0][0][1]) + 1
      SingleBackground.x_pos -= (SingleBackground.scroll_speed_x * ((PLAYER.prev_x_pos[-1] - PLAYER.prev_x_pos[-2]) / (1 / fps))) * My_cached_info.target_fps_over_fps
      SingleBackground.x_pos += 1 * My_cached_info.target_fps_over_fps
      SingleBackground.y_pos -= SingleBackground.scroll_speed_y * ((PLAYER.prev_y_pos[-1] - PLAYER.prev_y_pos[-2]) / (1 / fps))
      if (SingleBackground.x_pos + PLAYER.x_pos - ((1/2)*screen_width) - abs(PLAYER.blit_change_x) - abs(PLAYER.x_dif) - SingleBackground.GPU_images[0][0][0]) >= MAP.rect[2]:
        SingleBackground.x_pos = -PLAYER.x_pos - 500
      SingleBackground.y_pos = SingleBackground.y_pos - ((SingleBackground.y_pos // MAP.rect[3]) * MAP.rect[3])
      if not SingleBackground.scroll_leftright:
        SingleBackground.x_pos = - PLAYER.x_pos + ((1/2)*screen_width) + PLAYER.blit_change_x
        if SingleBackground.x_pos >= 0:
          number_long += 1
      if not SingleBackground.scroll_updown:
        SingleBackground.y_pos = - PLAYER.y_pos + ((1/2)*screen_height) + PLAYER.blit_change_y
        if SingleBackground.y_pos >= 0:
          number_tall += 1
      if SingleBackground.scroll_leftright:
        if SingleBackground.x_pos <= screen_width:
          number_long += 1
      if SingleBackground.scroll_updown:
        if SingleBackground.y_pos <= screen_height:
          number_tall += 1
      long_start, tall_start = 0, 0
      if SingleBackground.scroll_leftright:
        long_start -= 1
      if SingleBackground.scroll_updown:
        tall_start -= 1
      if SingleBackground.permanent_add_x != 0:
        number_long = 1
      if SingleBackground.permanent_add_y != 0:
        number_tall = 1
      number_long = 1
      number_tall = 1
      for long in range(number_long):
        for tall in range(number_tall):
          #SingleBackground.current_images.append(SingleBackground.image)
          SingleBackground.GPU_current_images.append(SingleBackground.GPU_image)
          SingleBackground.current_x_poses.append(SingleBackground.x_pos + (SingleBackground.GPU_images[0][0][0]*(long+long_start)))
          SingleBackground.current_y_poses.append(SingleBackground.y_pos + (SingleBackground.GPU_images[0][0][1]*(tall+tall_start)))
      return
  #
    if PLAYER.x_dif != 0 and PLAYER.y_dif == 0:
      SingleBackground.current_images = []
      SingleBackground.GPU_current_images = []
      SingleBackground.current_x_poses = []
      SingleBackground.current_y_poses = []
      if SingleBackground.number_of_milliseconds_since_updating_image >= SingleBackground.iteration_speed:
        SingleBackground.number_of_milliseconds_since_updating_image %= SingleBackground.iteration_speed
        SingleBackground.current_image_number += 1
        if SingleBackground.current_image_number == len(SingleBackground.GPU_images):
          SingleBackground.current_image_number = 0
      #SingleBackground.image = SingleBackground.images[SingleBackground.current_image_number]
      SingleBackground.GPU_image = SingleBackground.GPU_images[SingleBackground.current_image_number]
      number_long = (screen_width // SingleBackground.GPU_images[0][0][0]) + 1
      number_tall = (screen_height // SingleBackground.GPU_images[0][0][1]) + 1
      SingleBackground.x_pos += 1 * My_cached_info.target_fps_over_fps
      if (SingleBackground.x_pos + PLAYER.x_pos - ((1/2)*screen_width) - abs(PLAYER.blit_change_x) - abs(PLAYER.x_dif) - SingleBackground.GPU_images[0][0][0]) >= MAP.rect[2]:
        SingleBackground.x_pos = -PLAYER.x_pos - 500
      SingleBackground.y_pos -= SingleBackground.scroll_speed_y * ((PLAYER.prev_y_pos[-1] - PLAYER.prev_y_pos[-2]) / (1 / fps))
      SingleBackground.y_pos = SingleBackground.y_pos - ((SingleBackground.y_pos // MAP.rect[3]) * MAP.rect[3])
      if not SingleBackground.scroll_leftright:
        SingleBackground.x_pos = - PLAYER.x_pos + ((1/2)*screen_width) + PLAYER.blit_change_x
        if SingleBackground.x_pos >= 0:
          number_long += 1
      if not SingleBackground.scroll_updown:
        SingleBackground.y_pos = - PLAYER.y_pos + ((1/2)*screen_height) + PLAYER.blit_change_y
        if SingleBackground.y_pos >= 0:
          number_tall += 1
      if SingleBackground.scroll_leftright:
        if SingleBackground.x_pos <= screen_width:
          number_long += 1
      if SingleBackground.scroll_updown:
        if SingleBackground.y_pos <= screen_height:
          number_tall += 1
      long_start, tall_start = 0, 0
      if SingleBackground.scroll_leftright:
        long_start -= 1
      if SingleBackground.scroll_updown:
        tall_start -= 1
      if SingleBackground.scroll_updown:
        tall_start -= 1
      if SingleBackground.permanent_add_x != 0:
        number_long = 1
      if SingleBackground.permanent_add_y != 0:
        number_tall = 1
      number_long = 1
      number_tall = 1
      for long in range(number_long):
        for tall in range(number_tall):
          #SingleBackground.current_images.append(SingleBackground.image)
          SingleBackground.GPU_current_images.append(SingleBackground.GPU_image)
          SingleBackground.current_x_poses.append(SingleBackground.x_pos + (SingleBackground.GPU_images[0][0][0]*(long+long_start)))
          SingleBackground.current_y_poses.append(SingleBackground.y_pos + (SingleBackground.GPU_images[0][0][1]*(tall+tall_start)))
      if len(SingleBackground.current_y_poses) > len(SingleBackground.current_x_poses):
        SingleBackground.current_x_poses += SingleBackground.current_x_poses
        if (SingleBackground.current_x_poses[0:len(SingleBackground.current_x_poses)//2] == SingleBackground.current_x_poses[len(SingleBackground.current_x_poses)//2:]) and (SingleBackground.current_y_poses[0:len(SingleBackground.current_y_poses)//2] == SingleBackground.current_y_poses[len(SingleBackground.current_y_poses)//2:]):
          xlist1 = SingleBackground.current_x_poses[0:len(SingleBackground.current_x_poses)//2]
          xlist2 = SingleBackground.current_x_poses[len(SingleBackground.current_x_poses)//2:]
          xlist2.reverse()
          SingleBackground.current_x_poses = xlist1 + xlist2
      if len(SingleBackground.current_y_poses) < len(SingleBackground.current_x_poses):
        SingleBackground.current_x_poses = SingleBackground.current_x_poses[:len(SingleBackground.current_x_poses)//2]
      return
  #
  #
  if SingleBackground.special_directions == 3:
    bound_left = -(MAP.x_pos - PLAYER.x_pos + stop_scrolling_left + PLAYER.blit_change_x - PLAYER.x_dif)
    bound_top = -(MAP.y_pos - PLAYER.y_pos + stop_scrolling_top + PLAYER.blit_change_y - PLAYER.y_dif)
    bound_right = bound_left + screen_width
    bound_bottom = bound_top + screen_height
    #
    if SingleBackground.number_of_milliseconds_since_updating_image >= SingleBackground.iteration_speed:
      SingleBackground.number_of_milliseconds_since_updating_image %= SingleBackground.iteration_speed
      SingleBackground.current_image_number += 1
      if SingleBackground.current_image_number == len(SingleBackground.GPU_images):
        SingleBackground.current_image_number = 0
    #SingleBackground.image = SingleBackground.images[SingleBackground.current_image_number]
    SingleBackground.GPU_image = SingleBackground.GPU_images[SingleBackground.current_image_number]
    #
    SingleBackground.current_images = []
    SingleBackground.GPU_current_images = []
    SingleBackground.current_x_poses = []
    SingleBackground.current_y_poses = []
    leftest = bound_left // SingleBackground.GPU_image[0][0]
    rightest = bound_right // SingleBackground.GPU_image[0][0]
    topest = bound_top // SingleBackground.GPU_image[0][1]
    bottomest = bound_bottom // SingleBackground.GPU_image[0][1]
    if leftest == rightest:
      long = 1
    if leftest != rightest:
      long = 2
    if topest == bottomest:
      tall = 1
    if topest != bottomest:
      tall = 2
    #
    for l in range(long):
      for t in range(tall):
        #SingleBackground.current_images.append(SingleBackground.image)
        SingleBackground.GPU_current_images.append(SingleBackground.GPU_image)
        SingleBackground.current_x_poses.append((leftest * SingleBackground.GPU_image[0][0]) + (l * SingleBackground.GPU_image[0][0]) - bound_left)
        SingleBackground.current_y_poses.append((topest * SingleBackground.GPU_image[0][1]) + (t * SingleBackground.GPU_image[0][1]) - bound_top)
    return


def adjust_SingleSewerPumpWater_given_rot(SingleSewerPumpWater):
  cur_cos = math.cos(math.radians(SingleSewerPumpWater.current_rotation))
  cur_sin = math.sin(math.radians(SingleSewerPumpWater.current_rotation))
  if 0 <= SingleSewerPumpWater.current_rotation < 90:
    SingleSewerPumpWater.x_pos += abs(((SPINNY_OBJECTS[SingleSewerPumpWater.attached_to_which_spinny_object].rect[2]/2) + SPINNY_OBJECTS[SingleSewerPumpWater.attached_to_which_spinny_object].permanent_sewer_pump_position_changer)*cur_cos) - abs((SingleSewerPumpWater.rect[3]/2)*cur_sin)
    SingleSewerPumpWater.y_pos -= abs(((SPINNY_OBJECTS[SingleSewerPumpWater.attached_to_which_spinny_object].rect[3]/2) + SPINNY_OBJECTS[SingleSewerPumpWater.attached_to_which_spinny_object].permanent_sewer_pump_position_changer)*cur_sin) + abs((SingleSewerPumpWater.rect[3]/2)*cur_cos) + (SingleSewerPumpWater.length*cur_sin)
    return
  if 90 <= SingleSewerPumpWater.current_rotation < 180:
    SingleSewerPumpWater.x_pos -= abs(((SPINNY_OBJECTS[SingleSewerPumpWater.attached_to_which_spinny_object].rect[2]/2) + SPINNY_OBJECTS[SingleSewerPumpWater.attached_to_which_spinny_object].permanent_sewer_pump_position_changer)*cur_cos) + abs((SingleSewerPumpWater.rect[3]/2)*cur_sin) - (SingleSewerPumpWater.length*cur_cos)
    SingleSewerPumpWater.y_pos -= abs(((SPINNY_OBJECTS[SingleSewerPumpWater.attached_to_which_spinny_object].rect[3]/2) + SPINNY_OBJECTS[SingleSewerPumpWater.attached_to_which_spinny_object].permanent_sewer_pump_position_changer)*cur_sin) + abs((SingleSewerPumpWater.rect[3]/2)*cur_cos) + (SingleSewerPumpWater.length*cur_sin)
    return
  if 180 <= SingleSewerPumpWater.current_rotation < 270:
    SingleSewerPumpWater.x_pos -= abs(((SPINNY_OBJECTS[SingleSewerPumpWater.attached_to_which_spinny_object].rect[2]/2) + SPINNY_OBJECTS[SingleSewerPumpWater.attached_to_which_spinny_object].permanent_sewer_pump_position_changer)*cur_cos) + abs((SingleSewerPumpWater.rect[3]/2)*cur_sin) - (SingleSewerPumpWater.length*cur_cos)
    SingleSewerPumpWater.y_pos += abs(((SPINNY_OBJECTS[SingleSewerPumpWater.attached_to_which_spinny_object].rect[3]/2) + SPINNY_OBJECTS[SingleSewerPumpWater.attached_to_which_spinny_object].permanent_sewer_pump_position_changer)*cur_sin) - abs((SingleSewerPumpWater.rect[3]/2)*cur_cos)
    return
  if 270 <= SingleSewerPumpWater.current_rotation < 360:
    SingleSewerPumpWater.x_pos += abs(((SPINNY_OBJECTS[SingleSewerPumpWater.attached_to_which_spinny_object].rect[2]/2) + SPINNY_OBJECTS[SingleSewerPumpWater.attached_to_which_spinny_object].permanent_sewer_pump_position_changer)*cur_cos) - abs((SingleSewerPumpWater.rect[3]/2)*cur_sin)
    SingleSewerPumpWater.y_pos += abs(((SPINNY_OBJECTS[SingleSewerPumpWater.attached_to_which_spinny_object].rect[3]/2) + SPINNY_OBJECTS[SingleSewerPumpWater.attached_to_which_spinny_object].permanent_sewer_pump_position_changer)*cur_sin) - abs((SingleSewerPumpWater.rect[3]/2)*cur_cos)
    return


def adjust_SingleSewerPumpWater(SingleSewerPumpWater):
  my_current_rotation = my_sheath.rotation%360
  cur_cos = math.cos(math.radians(SingleSewerPumpWater.rotation))
  cur_sin = math.sin(math.radians(SingleSewerPumpWater.rotation))
  if 0 <= SingleSewerPumpWater.rotation < 90:
    SingleSewerPumpWater.x_pos += - abs(SingleSewerPumpWater.rect[3]*cur_sin)
    SingleSewerPumpWater.y_pos -= + abs(SingleSewerPumpWater.rect[3]*cur_cos) + (SingleSewerPumpWater.length*cur_sin)
    return
  if 90 <= SingleSewerPumpWater.rotation < 180:
    SingleSewerPumpWater.x_pos -= + abs(SingleSewerPumpWater.rect[3]*cur_sin) - (SingleSewerPumpWater.length*cur_cos)
    SingleSewerPumpWater.y_pos -= + abs(SingleSewerPumpWater.rect[3]*cur_cos) + (SingleSewerPumpWater.length*cur_sin)
    return
  if 180 <= SingleSewerPumpWater.rotation < 270:
    SingleSewerPumpWater.x_pos -= + abs(SingleSewerPumpWater.rect[3]*cur_sin) - (SingleSewerPumpWater.length*cur_cos)
    SingleSewerPumpWater.y_pos += - abs(SingleSewerPumpWater.rect[3]*cur_cos)
    return
  if 270 <= SingleSewerPumpWater.rotation < 360:
    SingleSewerPumpWater.x_pos += - abs(SingleSewerPumpWater.rect[3]*cur_sin)
    SingleSewerPumpWater.y_pos += - abs(SingleSewerPumpWater.rect[3]*cur_cos)
    return


def update_sewer_pump_water():
  for SingleSewerPumpWater in SEWER_PUMP_WATER:
    update_single_sewer_pump_water(SingleSewerPumpWater)


def update_single_sewer_pump_water(SingleSewerPumpWater):
  if SingleSewerPumpWater.sewer_pump_type == 1:
    SingleSewerPumpWater.x_pos = SingleSewerPumpWater.source_x
    SingleSewerPumpWater.y_pos = SingleSewerPumpWater.source_y
    if SingleSewerPumpWater.stage_in_spout == 0: # resting
      if SingleSewerPumpWater.sleeper_timer_start == 0:
        SingleSewerPumpWater.sleeper_timer_start = frame_counter
      if frame_counter == SingleSewerPumpWater.sleeper_timer + SingleSewerPumpWater.sleeper_timer_start:
        SingleSewerPumpWater.stage_in_spout = 1
        SingleSewerPumpWater.sleeper_timer_start = 0
      return
    #
    if SingleSewerPumpWater.stage_in_spout == 1: # spout moving up
      SingleSewerPumpWater.length += SingleSewerPumpWater.vel
      if SingleSewerPumpWater.length >= SingleSewerPumpWater.maximum_length:
        SingleSewerPumpWater.length = SingleSewerPumpWater.maximum_length
        SingleSewerPumpWater.stage_in_spout = 2
      SingleSewerPumpWater.cropped_region[0] = (SingleSewerPumpWater.rect[2] - ((frame_counter*(24))%(SingleSewerPumpWater.rect[2]//2)))%(SingleSewerPumpWater.rect[2]//2)
      SingleSewerPumpWater.cropped_region[2] = SingleSewerPumpWater.length
      SingleSewerPumpWater.current_image = SingleSewerPumpWater.image.subsurface((SingleSewerPumpWater.cropped_region[0], SingleSewerPumpWater.cropped_region[1], SingleSewerPumpWater.cropped_region[2], SingleSewerPumpWater.cropped_region[3]))
      SingleSewerPumpWater.current_rect = SingleSewerPumpWater.current_image.get_rect(center = (SingleSewerPumpWater.x_pos, SingleSewerPumpWater.y_pos))
      adjust_SingleSewerPumpWater(SingleSewerPumpWater)
      SingleSewerPumpWater.current_image, SingleSewerPumpWater.current_rect = rotate_rectangular_image(SingleSewerPumpWater.current_image, SingleSewerPumpWater.current_rect, SingleSewerPumpWater.rotation)
      return
    #
    if SingleSewerPumpWater.stage_in_spout == 2: # spout staying up
      if SingleSewerPumpWater.top_timer_start == 0:
        SingleSewerPumpWater.top_timer_start = frame_counter
      if frame_counter == SingleSewerPumpWater.top_timer + SingleSewerPumpWater.top_timer_start:
        SingleSewerPumpWater.stage_in_spout = 3
        SingleSewerPumpWater.top_timer_start = 0
      SingleSewerPumpWater.cropped_region[0] = (SingleSewerPumpWater.rect[2] - ((frame_counter*(24))%(SingleSewerPumpWater.rect[2]//2)))%(SingleSewerPumpWater.rect[2]//2)
      SingleSewerPumpWater.cropped_region[2] = SingleSewerPumpWater.length
      SingleSewerPumpWater.current_image = SingleSewerPumpWater.image.subsurface((SingleSewerPumpWater.cropped_region[0], SingleSewerPumpWater.cropped_region[1], SingleSewerPumpWater.cropped_region[2], SingleSewerPumpWater.cropped_region[3]))
      SingleSewerPumpWater.current_rect = SingleSewerPumpWater.current_image.get_rect(center = (SingleSewerPumpWater.x_pos, SingleSewerPumpWater.y_pos))
      adjust_SingleSewerPumpWater(SingleSewerPumpWater)
      SingleSewerPumpWater.current_image, SingleSewerPumpWater.current_rect = rotate_rectangular_image(SingleSewerPumpWater.current_image, SingleSewerPumpWater.current_rect, SingleSewerPumpWater.rotation)
      return
    #
    if SingleSewerPumpWater.stage_in_spout == 3: # down
      SingleSewerPumpWater.length -= SingleSewerPumpWater.vel
      if SingleSewerPumpWater.length <= 0:
        SingleSewerPumpWater.length = 0
        SingleSewerPumpWater.stage_in_spout = 0
      SingleSewerPumpWater.cropped_region[0] = (SingleSewerPumpWater.rect[2] - ((frame_counter*(24))%(SingleSewerPumpWater.rect[2]//2)))%(SingleSewerPumpWater.rect[2]//2)
      SingleSewerPumpWater.cropped_region[2] = SingleSewerPumpWater.length
      SingleSewerPumpWater.current_image = SingleSewerPumpWater.image.subsurface((SingleSewerPumpWater.cropped_region[0], SingleSewerPumpWater.cropped_region[1], SingleSewerPumpWater.cropped_region[2], SingleSewerPumpWater.cropped_region[3]))
      SingleSewerPumpWater.current_rect = SingleSewerPumpWater.current_image.get_rect(center = (SingleSewerPumpWater.x_pos, SingleSewerPumpWater.y_pos))
      adjust_SingleSewerPumpWater(SingleSewerPumpWater)
      SingleSewerPumpWater.current_image, SingleSewerPumpWater.current_rect = rotate_rectangular_image(SingleSewerPumpWater.current_image, SingleSewerPumpWater.current_rect, SingleSewerPumpWater.rotation)
      return
    #
    #
  if SingleSewerPumpWater.sewer_pump_type == 2:
    SingleSewerPumpWater.x_pos = SingleSewerPumpWater.source_x
    SingleSewerPumpWater.y_pos = SingleSewerPumpWater.source_y
    SingleSewerPumpWater.current_rotation = SingleSewerPumpWater.rotation + SPINNY_OBJECTS[SingleSewerPumpWater.attached_to_which_spinny_object].current_rotation
    SingleSewerPumpWater.current_rotation = SingleSewerPumpWater.current_rotation % 360
    if SingleSewerPumpWater.stage_in_spout == 0: # resting
      if SingleSewerPumpWater.sleeper_timer_start == 0:
        SingleSewerPumpWater.sleeper_timer_start = frame_counter
      if frame_counter == SingleSewerPumpWater.sleeper_timer + SingleSewerPumpWater.sleeper_timer_start:
        SingleSewerPumpWater.stage_in_spout = 1
        SingleSewerPumpWater.sleeper_timer_start = 0
      return
    #
    if SingleSewerPumpWater.stage_in_spout == 1: # spout moving up
      SingleSewerPumpWater.length += SingleSewerPumpWater.vel
      if SingleSewerPumpWater.length >= SingleSewerPumpWater.maximum_length:
        SingleSewerPumpWater.length = SingleSewerPumpWater.maximum_length
        SingleSewerPumpWater.stage_in_spout = 2
      SingleSewerPumpWater.cropped_region[0] = (SingleSewerPumpWater.rect[2] - ((frame_counter*(24))%(SingleSewerPumpWater.rect[2]//2)))%(SingleSewerPumpWater.rect[2]//2)
      SingleSewerPumpWater.cropped_region[2] = SingleSewerPumpWater.length
      SingleSewerPumpWater.current_image = SingleSewerPumpWater.image.subsurface((SingleSewerPumpWater.cropped_region[0], SingleSewerPumpWater.cropped_region[1], SingleSewerPumpWater.cropped_region[2], SingleSewerPumpWater.cropped_region[3]))
      SingleSewerPumpWater.current_rect = SingleSewerPumpWater.current_image.get_rect(center = (SingleSewerPumpWater.x_pos, SingleSewerPumpWater.y_pos))
      adjust_SingleSewerPumpWater_given_rot(SingleSewerPumpWater)
      SingleSewerPumpWater.current_image, SingleSewerPumpWater.current_rect = rotate_rectangular_image(SingleSewerPumpWater.current_image, SingleSewerPumpWater.current_rect, SingleSewerPumpWater.current_rotation)
      return
    #
    if SingleSewerPumpWater.stage_in_spout == 2: # spout staying up
      if SingleSewerPumpWater.top_timer_start == 0:
        SingleSewerPumpWater.top_timer_start = frame_counter
      if frame_counter == SingleSewerPumpWater.top_timer + SingleSewerPumpWater.top_timer_start:
        SingleSewerPumpWater.stage_in_spout = 3
        SingleSewerPumpWater.top_timer_start = 0
      SingleSewerPumpWater.cropped_region[0] = (SingleSewerPumpWater.rect[2] - ((frame_counter*(24))%(SingleSewerPumpWater.rect[2]//2)))%(SingleSewerPumpWater.rect[2]//2)
      SingleSewerPumpWater.cropped_region[2] = SingleSewerPumpWater.length
      SingleSewerPumpWater.current_image = SingleSewerPumpWater.image.subsurface((SingleSewerPumpWater.cropped_region[0], SingleSewerPumpWater.cropped_region[1], SingleSewerPumpWater.cropped_region[2], SingleSewerPumpWater.cropped_region[3]))
      SingleSewerPumpWater.current_rect = SingleSewerPumpWater.current_image.get_rect(center = (SingleSewerPumpWater.x_pos, SingleSewerPumpWater.y_pos))
      adjust_SingleSewerPumpWater_given_rot(SingleSewerPumpWater)
      SingleSewerPumpWater.current_image, SingleSewerPumpWater.current_rect = rotate_rectangular_image(SingleSewerPumpWater.current_image, SingleSewerPumpWater.current_rect, SingleSewerPumpWater.current_rotation)
      return
    #
    if SingleSewerPumpWater.stage_in_spout == 3: # down
      SingleSewerPumpWater.length -= SingleSewerPumpWater.vel
      if SingleSewerPumpWater.length <= 0:
        SingleSewerPumpWater.length = 0
        SingleSewerPumpWater.stage_in_spout = 0
      SingleSewerPumpWater.cropped_region[0] = (SingleSewerPumpWater.rect[2] - ((frame_counter*(24))%(SingleSewerPumpWater.rect[2]//2)))%(SingleSewerPumpWater.rect[2]//2)
      SingleSewerPumpWater.cropped_region[2] = SingleSewerPumpWater.length
      SingleSewerPumpWater.current_image = SingleSewerPumpWater.image.subsurface((SingleSewerPumpWater.cropped_region[0], SingleSewerPumpWater.cropped_region[1], SingleSewerPumpWater.cropped_region[2], SingleSewerPumpWater.cropped_region[3]))
      SingleSewerPumpWater.current_rect = SingleSewerPumpWater.current_image.get_rect(center = (SingleSewerPumpWater.x_pos, SingleSewerPumpWater.y_pos))
      adjust_SingleSewerPumpWater_given_rot(SingleSewerPumpWater)
      SingleSewerPumpWater.current_image, SingleSewerPumpWater.current_rect = rotate_rectangular_image(SingleSewerPumpWater.current_image, SingleSewerPumpWater.current_rect, SingleSewerPumpWater.current_rotation)
      return


def update_spinny_objects():
  for SingleSpinny in SPINNY_OBJECTS:
    update_spinny_object(SingleSpinny)


def update_spinny_object(SingleSpinny):
  for _ in range(My_cached_info.whole_number_of_frames_this_frame):
    SingleSpinny.current_rotation = SingleSpinny.rotation + SingleSpinny.list_of_rotation_values[SingleSpinny.current_rotation_val]
    SingleSpinny.current_rotation = SingleSpinny.current_rotation % 360
    SingleSpinny.current_image = rotate_square_image(SingleSpinny.image, SingleSpinny.current_rotation)
    SingleSpinny.current_rotation_val += 1
    if SingleSpinny.current_rotation_val == len(SingleSpinny.list_of_rotation_values) - 1:
      SingleSpinny.current_rotation_val = 0
  #if frame_counter % SingleSpinny.droplet_frequency == 0:
  #  if SingleSpinny.rotation_of_spouts != []:
  #    for i in range(len(SingleSpinny.rotation_of_spouts)):
  #      spout_rotation = SingleSpinny.rotation_of_spouts[i]
  #      actual_rotation = spout_rotation + SingleSpinny.rotation
  #      SewerPumpWaterDroplets.append(SewerJet(x_pos = SingleSpinny.x_pos + (SingleSpinny.rect[2]/2) + (SingleSpinny.radius + SingleSpinny.permanent_sewer_pump_position_changer) * math.cos(math.radians(actual_rotation)) - 100, y_pos = SingleSpinny.y_pos + (SingleSpinny.rect[3]/2) - (SingleSpinny.radius + SingleSpinny.permanent_sewer_pump_position_changer) * math.sin(math.radians(actual_rotation)) - 100, x_vel = SingleSpinny.droplet_speed * math.cos(math.radians(actual_rotation)), y_vel = - SingleSpinny.droplet_speed * math.sin(math.radians(actual_rotation)), x_accel = 0, y_accel = 400, droplet_disappear_y_pos = SingleSpinny.droplet_disappear_y_pos[i], png_name = 'SEWER_JET'))
  #return



#class SewerJet():
#  def __init__(self, x_pos, y_pos, x_vel, y_vel, x_accel, y_accel, droplet_disappear_y_pos, png_name):
#    super().__init__()
#    self.x_pos = x_pos
#    self.y_pos = y_pos
#    self.x_vel = x_vel
#    self.y_vel = y_vel
#    self.x_accel = x_accel
#    self.y_accel = y_accel
#    self.rotation = 0
#    self.droplet_disappear_y_pos = droplet_disappear_y_pos
#    self.images = PyGameTextures[png_name]
#    self.GPU_images = OpenGLTextures[png_name]
#    self.current_image = self.images[0]
#    self.rect = self.images[0].get_rect(center = (self.x_pos, self.y_pos))
#    self.mask  = pygame.mask.from_surface(self.images[0])
#    self.radius = find_hypotnuse(self.rect[2], self.rect[3])


def update_leaks():
  for SingleLeak in LEAKS:
    update_leak(SingleLeak)


def update_leak(SingleLeak):
  SingleLeak.current_time = curr_time - SingleLeak.start_time
  #
  if SingleLeak.spray_step == 0: # not spraying
    if curr_time > SingleLeak.whole_time + SingleLeak.start_time:
      SingleLeak.start_time = curr_time
      SingleLeak.current_image = SingleLeak.images[0]
      SingleLeak.GPU_image = SingleLeak.GPU_images[0]
      return
    if curr_time > SingleLeak.start_time + SingleLeak.step0_time:
      SingleLeak.spray_step = 1
      return
  #
  if SingleLeak.spray_step == 1: # spray is extending
    current_step_time = SingleLeak.current_time - SingleLeak.step0_time
    SingleLeak.current_image = SingleLeak.images[current_step_time // (SingleLeak.extending_receding_speed)]
    SingleLeak.GPU_image = SingleLeak.GPU_images[current_step_time // (SingleLeak.extending_receding_speed)]
    if current_step_time >= (9*SingleLeak.extending_receding_speed):
      SingleLeak.spray_step = 2
      return
    return
  #
  if SingleLeak.spray_step == 2: # spray is at max length
    current_step_time = SingleLeak.current_time - SingleLeak.step0_time - (9*SingleLeak.extending_receding_speed)
    SingleLeak.current_milliseconds_to_pick_new_random_image += delta_milliseconds
    if SingleLeak.current_milliseconds_to_pick_new_random_image >= SingleLeak.milliseconds_to_pick_new_random_image:
      SingleLeak.current_milliseconds_to_pick_new_random_image %= SingleLeak.milliseconds_to_pick_new_random_image
      random_image_index = random.randint(10, 20)
      if random_image_index == SingleLeak.current_random:
        if random_image_index != 20:
          random_image_index += 1
        else:
          random_image_index = 10
      SingleLeak.current_random = random_image_index
      SingleLeak.current_image = SingleLeak.images[random_image_index]
      SingleLeak.GPU_image = SingleLeak.GPU_images[random_image_index]
    if current_step_time >= SingleLeak.step2_time:
      SingleLeak.spray_step = 3
      return
  #
  if SingleLeak.spray_step == 3: # spray is receding
    current_step_time = SingleLeak.current_time - SingleLeak.step0_time - (9*SingleLeak.extending_receding_speed) - SingleLeak.step2_time
    SingleLeak.current_image = SingleLeak.images[9 - (current_step_time // (SingleLeak.extending_receding_speed))]
    SingleLeak.GPU_image = SingleLeak.GPU_images[9 - (current_step_time // (SingleLeak.extending_receding_speed))]
    if current_step_time >= (9*SingleLeak.extending_receding_speed):
      SingleLeak.spray_step = 0
      return
    return


def find_active_quads():
  low_x  = (-GRATES[0].offset_x + PLAYER.x_pos - screen_width) // 256
  high_x = (-GRATES[0].offset_x + PLAYER.x_pos + screen_width) // 256
  low_y  = (-GRATES[0].offset_y + PLAYER.y_pos - screen_height) // 256
  high_y = (-GRATES[0].offset_y + PLAYER.y_pos + screen_height) // 256
  if low_x < 0:
    low_x = 0
  if high_x > (len(GRATES[0].TheDoor10_map[0]) - 1):
    high_x = (len(GRATES[0].TheDoor10_map[0]) - 1)
  if low_y < 0:
    low_y = 0
  if high_y > (len(GRATES[0].TheDoor10_map) - 1):
    high_y = (len(GRATES[0].TheDoor10_map) - 1)
  return (round(low_x), round(high_x), round(low_y), round(high_y))


def update_grates():
  GRATES[0].active_quads = find_active_quads()
  GRATES[0].current_frame = (My_cached_info.fake_frame_counter % 48) // 6


def update_water_surfaces():
  for SingleWaterSurface in WATER_SURFACES:
    update_water_surface(SingleWaterSurface)


def update_water_surface(SingleWaterSurface):
  SingleWaterSurface.number_of_milliseconds_since_updating_image += delta_milliseconds
  if SingleWaterSurface.number_of_milliseconds_since_updating_image >= SingleWaterSurface.milliseconds_before_updating_image:
    SingleWaterSurface.number_of_milliseconds_since_updating_image %= SingleWaterSurface.milliseconds_before_updating_image
    SingleWaterSurface.current_image_index += 1
    if SingleWaterSurface.current_image_index >= len(SingleWaterSurface.images):
      SingleWaterSurface.current_image_index = 0
    SingleWaterSurface.GPU_current_image =  SingleWaterSurface.GPU_images[SingleWaterSurface.current_image_index]
    SingleWaterSurface.current_image =  SingleWaterSurface.images[SingleWaterSurface.current_image_index]
    SingleWaterSurface.GPU_current_image_cover =  SingleWaterSurface.GPU_image_covers[SingleWaterSurface.current_image_index]
  #
  if SingleWaterSurface.water_surface_type == 2:
    SingleWaterSurface.x_pos = BUCKETS[SingleWaterSurface.connected_to_which_bucket].x_pos + 24
    SingleWaterSurface.y_pos = BUCKETS[SingleWaterSurface.connected_to_which_bucket].y_pos + 117


def update_levers():
  for SingleLever in LEVERS:
    update_lever(SingleLever)


def update_lever(SingleLever):
  if SingleLever.last_bolt_index < SingleLever.current_bolt_index:
    MixerSounds['LEVER'].play()
  SingleLever.last_lever_index = SingleLever.current_lever_index
  SingleLever.last_bolt_index = SingleLever.current_bolt_index
  #
  if SingleLever.current_lever_index <= 3:
    SingleLever.allow_another_charge = True
  if my_piston2.connected_to_which_lever == SingleLever.lever_index:
    SingleLever.last_charge_time = curr_time
  if my_piston2.connected_to_which_lever != SingleLever.lever_index:
    if (curr_time - SingleLever.last_charge_time) >= SingleLever.time_added_from_charge:
      SingleLever.last_charge_time = curr_time
      if SingleLever.current_bolt_index != 0:
        SingleLever.current_bolt_index -= 1
      SingleLever.GPU_current_bolt_image = SingleLever.GPU_bolt_images[SingleLever.current_bolt_index]
    if SingleLever.current_lever_index > 0:
      SingleLever.current_milliseconds_before_moving_lever_up += delta_milliseconds
      if SingleLever.current_milliseconds_before_moving_lever_up >= SingleLever.milliseconds_before_moving_lever_up:
        SingleLever.current_milliseconds_before_moving_lever_up %= SingleLever.milliseconds_before_moving_lever_up
        SingleLever.current_lever_index -= 1
      SingleLever.GPU_current_lever_image = SingleLever.GPU_lever_images[SingleLever.current_lever_index]
      SingleLever.current_image = SingleLever.images[SingleLever.current_lever_index]
  if SingleLever.current_bolt_index != 0:
    for SingleTV in TV:
      SingleTV.active_dots[SingleLever.lever_index + 1] = True
  else:
    for SingleTV in TV:
      SingleTV.active_dots[SingleLever.lever_index + 1] = False


def update_propellers():
  for i in range(len(PROPELLERS)):
    update_propeller(PROPELLERS[i], i)


def update_propeller(SinglePropeller, i):
  if SinglePropeller.propeller_type == 1: # main sewer are with TVs
    if not TV[0].active_dots[i] or MAP.region == 'TheDoor12':
      SinglePropeller.is_on = True
      SinglePropeller.milliseconds_since_image_update += delta_milliseconds
      if SinglePropeller.milliseconds_since_image_update >= SinglePropeller.milliseconds_per_image_update:
        SinglePropeller.milliseconds_since_image_update %= SinglePropeller.milliseconds_per_image_update
        SinglePropeller.current_image_index += 1
        if SinglePropeller.current_image_index > 5:
          SinglePropeller.current_image_index = 0
        SinglePropeller.GPU_current_image = SinglePropeller.GPU_images[SinglePropeller.current_image_index]
      if SinglePropeller.y_pos - 5 < (PLAYER.y_pos + ((1/2)*screen_height)) < SinglePropeller.y_pos + 208 + 5:
        if not SinglePropeller.flipped:
          if SinglePropeller.x_pos + 48 < (PLAYER.x_pos + ((1/2)*screen_width)) < SinglePropeller.x_pos + 48 + SinglePropeller.collision_box_width - 69:
            PLAYER.water_Fx += 6000
        else:
          if SinglePropeller.x_pos > (PLAYER.x_pos + ((1/2)*screen_width)) > SinglePropeller.x_pos - SinglePropeller.collision_box_width:
            PLAYER.water_Fx -= 6000
      if SinglePropeller.flipped:
        SinglePropeller.current_bubbles_x += 8 * My_cached_info.target_fps_over_fps
      if not SinglePropeller.flipped:
        SinglePropeller.current_bubbles_x -= 8 * My_cached_info.target_fps_over_fps
      SinglePropeller.current_bubbles_x = SinglePropeller.current_bubbles_x % SinglePropeller.collision_box_width
    else:
      SinglePropeller.is_on = False
      SinglePropeller.current_image_index = 0
      SinglePropeller.GPU_current_image = SinglePropeller.GPU_images[SinglePropeller.current_image_index]
  #
  if SinglePropeller.propeller_type == 2: # starting line of sewer race
    if LEVERS[0].current_bolt_index == 0:
      SinglePropeller.is_on = True
      SinglePropeller.milliseconds_since_image_update += delta_milliseconds
      if SinglePropeller.milliseconds_since_image_update >= SinglePropeller.milliseconds_per_image_update:
        SinglePropeller.milliseconds_since_image_update %= SinglePropeller.milliseconds_per_image_update
        SinglePropeller.current_image_index += 1
        if SinglePropeller.current_image_index > 5:
          SinglePropeller.current_image_index = 0
        SinglePropeller.GPU_current_image = SinglePropeller.GPU_images[SinglePropeller.current_image_index]
      if SinglePropeller.x_pos - 5 < (PLAYER.x_pos + ((1/2)*screen_width)) < SinglePropeller.x_pos + 208 + 5:
        if SinglePropeller.y_pos + 0 < (PLAYER.y_pos + ((1/2)*screen_height)) < SinglePropeller.y_pos + 48 + SinglePropeller.collision_box_width:
          PLAYER.water_Fy += 6000
      SinglePropeller.current_bubbles_x -= 8 * My_cached_info.target_fps_over_fps
      SinglePropeller.current_bubbles_x = SinglePropeller.current_bubbles_x % SinglePropeller.collision_box_width
    else:
      SinglePropeller.is_on = False
      SinglePropeller.current_image_index = 0
      SinglePropeller.GPU_current_image = SinglePropeller.GPU_images[SinglePropeller.current_image_index]
  #
  if SinglePropeller.propeller_type == 3: # permanently off sewer race
    SinglePropeller.is_on = False
    SinglePropeller.current_image_index = 0
    SinglePropeller.GPU_current_image = SinglePropeller.GPU_images[SinglePropeller.current_image_index]
  #
  if SinglePropeller.propeller_type == 4: # guarding upgrade in sewer race
    if LEVERS[0].current_bolt_index == 0:
      SinglePropeller.is_on = True
      SinglePropeller.milliseconds_since_image_update += delta_milliseconds
      if SinglePropeller.milliseconds_since_image_update >= SinglePropeller.milliseconds_per_image_update:
        SinglePropeller.milliseconds_since_image_update %= SinglePropeller.milliseconds_per_image_update
        SinglePropeller.current_image_index += 1
        if SinglePropeller.current_image_index > 5:
          SinglePropeller.current_image_index = 0
        SinglePropeller.GPU_current_image = SinglePropeller.GPU_images[SinglePropeller.current_image_index]
      if SinglePropeller.y_pos - 5 < (PLAYER.y_pos + ((1/2)*screen_height)) < SinglePropeller.y_pos + 208 + 5:
        if SinglePropeller.x_pos + 48 < (PLAYER.x_pos + ((1/2)*screen_width)) < SinglePropeller.x_pos + 48 + SinglePropeller.collision_box_width - 69:
          PLAYER.water_Fx += 6000
      SinglePropeller.current_bubbles_x -= 8 * My_cached_info.target_fps_over_fps
      SinglePropeller.current_bubbles_x = SinglePropeller.current_bubbles_x % SinglePropeller.collision_box_width
    else:
      SinglePropeller.is_on = False
      SinglePropeller.current_image_index = 0
      SinglePropeller.GPU_current_image = SinglePropeller.GPU_images[SinglePropeller.current_image_index]
  #
  if SinglePropeller.propeller_type == 5: # push up near end of race
    SinglePropeller.is_on = True
    SinglePropeller.milliseconds_since_image_update += delta_milliseconds
    if SinglePropeller.milliseconds_since_image_update >= SinglePropeller.milliseconds_per_image_update:
      SinglePropeller.milliseconds_since_image_update %= SinglePropeller.milliseconds_per_image_update
      SinglePropeller.current_image_index += 1
      if SinglePropeller.current_image_index > 5:
        SinglePropeller.current_image_index = 0
      SinglePropeller.GPU_current_image = SinglePropeller.GPU_images[SinglePropeller.current_image_index]
      if SinglePropeller.x_pos - 5 < (PLAYER.x_pos + ((1/2)*screen_width)) < SinglePropeller.x_pos + 208 + 5:
        if SinglePropeller.y_pos - SinglePropeller.collision_box_width < (PLAYER.y_pos + ((1/2)*screen_height)) < SinglePropeller.y_pos:
          PLAYER.water_Fy -= 12000
    SinglePropeller.current_bubbles_x += 8 * My_cached_info.target_fps_over_fps
    SinglePropeller.current_bubbles_x = SinglePropeller.current_bubbles_x % SinglePropeller.collision_box_width
  #
  if SinglePropeller.propeller_type == 6:
    SinglePropeller.is_on = True
    SinglePropeller.milliseconds_since_image_update += delta_milliseconds
    if SinglePropeller.milliseconds_since_image_update >= SinglePropeller.milliseconds_per_image_update:
      SinglePropeller.milliseconds_since_image_update %= SinglePropeller.milliseconds_per_image_update
      SinglePropeller.current_image_index += 1
      if SinglePropeller.current_image_index > 5:
        SinglePropeller.current_image_index = 0
      SinglePropeller.GPU_current_image = SinglePropeller.GPU_images[SinglePropeller.current_image_index]
    if ((587 <= PLAYER.x_pos <= 3541) and (5100 <= PLAYER.y_pos <= 6744)) or LEVERS[0].current_bolt_index == 0:
      SinglePropeller.extend_the_whole_way = False
    if not SinglePropeller.extend_the_whole_way:
      SinglePropeller.collision_box_width = 941
      SinglePropeller.GPU_bubbles_png = OpenGLTextures['BUBBLES6']
      if SinglePropeller.x_pos - 5 < (PLAYER.x_pos + ((1/2)*screen_width)) < SinglePropeller.x_pos + 208 + 5:
        if SinglePropeller.y_pos - SinglePropeller.collision_box_width < (PLAYER.y_pos + ((1/2)*screen_height)) < SinglePropeller.y_pos:
          PLAYER.water_Fy -= 12000
    if SinglePropeller.extend_the_whole_way:
      SinglePropeller.collision_box_width = 1392
      SinglePropeller.GPU_bubbles_png = OpenGLTextures['BUBBLES7']
      if SinglePropeller.x_pos - 5 < (PLAYER.x_pos + ((1/2)*screen_width)) < SinglePropeller.x_pos + 208 + 5:
        if SinglePropeller.y_pos - SinglePropeller.collision_box_width < (PLAYER.y_pos + ((1/2)*screen_height)) < SinglePropeller.y_pos:
          PLAYER.water_Fy -= 12000
    SinglePropeller.current_bubbles_x += 8 * My_cached_info.target_fps_over_fps
    SinglePropeller.current_bubbles_x = SinglePropeller.current_bubbles_x % SinglePropeller.collision_box_width
  #
  if SinglePropeller.propeller_type == 7:
    if PROPELLERS[7].extend_the_whole_way or LEVERS[0].current_bolt_index == 0:
      SinglePropeller.is_on = False
      SinglePropeller.current_image_index = 0
      SinglePropeller.GPU_current_image = SinglePropeller.GPU_images[SinglePropeller.current_image_index]
    else:
      SinglePropeller.is_on = True
      SinglePropeller.milliseconds_since_image_update += delta_milliseconds
      if SinglePropeller.milliseconds_since_image_update >= SinglePropeller.milliseconds_per_image_update:
        SinglePropeller.milliseconds_since_image_update %= SinglePropeller.milliseconds_per_image_update
        SinglePropeller.current_image_index += 1
        if SinglePropeller.current_image_index > 5:
          SinglePropeller.current_image_index = 0
      SinglePropeller.GPU_current_image = SinglePropeller.GPU_images[SinglePropeller.current_image_index]
      if SinglePropeller.x_pos - 5 < (PLAYER.x_pos + ((1/2)*screen_width)) < SinglePropeller.x_pos + 208 + 5:
        if SinglePropeller.y_pos + 0 < (PLAYER.y_pos + ((1/2)*screen_height)) < SinglePropeller.y_pos + 48 + SinglePropeller.collision_box_width:
          PLAYER.water_Fy += 6000
      SinglePropeller.current_bubbles_x -= 8 * My_cached_info.target_fps_over_fps
      SinglePropeller.current_bubbles_x = SinglePropeller.current_bubbles_x % SinglePropeller.collision_box_width


def update_goldfish_position(SingleGoldfish):
  used_vel = SingleGoldfish.vel * My_cached_info.target_fps_over_fps
  if SingleGoldfish.rotation == 0:
    SingleGoldfish.x_pos += used_vel
    return
  if 0 < SingleGoldfish.rotation < 90:
    SingleGoldfish.x_pos += abs(used_vel*math.cos(math.radians(SingleGoldfish.rotation)))
    SingleGoldfish.y_pos -= abs(used_vel*math.sin(math.radians(SingleGoldfish.rotation)))
    return
  if SingleGoldfish.rotation == 90:
    SingleGoldfish.y_pos -= used_vel
    return
  if 90 < SingleGoldfish.rotation < 180:
    SingleGoldfish.x_pos -= abs(used_vel*math.cos(math.radians(SingleGoldfish.rotation)))
    SingleGoldfish.y_pos -= abs(used_vel*math.sin(math.radians(SingleGoldfish.rotation)))
    return
  if SingleGoldfish.rotation == 180:
    SingleGoldfish.x_pos -= used_vel
    return
  if 180 < SingleGoldfish.rotation < 270:
    SingleGoldfish.x_pos -= abs(used_vel*math.cos(math.radians(SingleGoldfish.rotation)))
    SingleGoldfish.y_pos += abs(used_vel*math.sin(math.radians(SingleGoldfish.rotation)))
    return
  if SingleGoldfish.rotation == 270:
    SingleGoldfish.y_pos += used_vel
    return
  if 270 < SingleGoldfish.rotation <= 360:
    SingleGoldfish.x_pos += abs(used_vel*math.cos(math.radians(SingleGoldfish.rotation)))
    SingleGoldfish.y_pos += abs(used_vel*math.sin(math.radians(SingleGoldfish.rotation)))
    return


def find_goldfish_image_rotation(SingleGoldfish):
  if (0 <= SingleGoldfish.rotation <= 90) or (270 <= SingleGoldfish.rotation <= 360):
    SingleGoldfish.flipped = False
    SingleGoldfish.image_rotation = SingleGoldfish.rotation
    return
  else:
    SingleGoldfish.flipped = True
    SingleGoldfish.image_rotation = SingleGoldfish.rotation + 180


def goldfish_force_on_player(current_normal_force_angle):
  total_force = 1000000
  if current_normal_force_angle == 0:
    PLAYER.FNx += total_force
    PLAYER.FNy += 0
    return
  if 0 < current_normal_force_angle < 90:
    PLAYER.FNx += abs(total_force*math.cos(math.radians(current_normal_force_angle)))
    PLAYER.FNy -= abs(total_force*math.cos(math.radians(current_normal_force_angle)))
    return
  if current_normal_force_angle == 90:
    PLAYER.FNx += 0
    PLAYER.FNy -= total_force
    return
  if 90 < current_normal_force_angle < 180:
    PLAYER.FNx -= abs(total_force*math.cos(math.radians(current_normal_force_angle)))
    PLAYER.FNy -= abs(total_force*math.cos(math.radians(current_normal_force_angle)))
    return
  if current_normal_force_angle == 180:
    PLAYER.FNx -= total_force
    PLAYER.FNy += 0
    return
  if 180 < current_normal_force_angle < 270:
    PLAYER.FNx -= abs(total_force*math.cos(math.radians(current_normal_force_angle)))
    PLAYER.FNy += abs(total_force*math.cos(math.radians(current_normal_force_angle)))
    return
  if current_normal_force_angle == 270:
    PLAYER.FNx += 0
    PLAYER.FNy += total_force
    return
  if 270 < current_normal_force_angle <= 360:
    PLAYER.FNx += abs(total_force*math.cos(math.radians(current_normal_force_angle)))
    PLAYER.FNy += abs(total_force*math.cos(math.radians(current_normal_force_angle)))
    return


def update_goldfishes():
  which_goldfish = 0
  for SingleGoldfish in GOLDFISH:
    update_goldfish(SingleGoldfish, which_goldfish)
    which_goldfish += 1


def update_goldfish(SingleGoldfish, which_goldfish):
  SingleGoldfish.current_number_of_milliseconds += delta_milliseconds
  for i in range(which_goldfish + 1, len(GOLDFISH)):
    minx1, maxx1 = SingleGoldfish.x_pos, SingleGoldfish.x_pos + SingleGoldfish.rect[2]
    miny1, maxy1 = SingleGoldfish.y_pos, SingleGoldfish.y_pos + SingleGoldfish.rect[3]
    minx2, maxx2 = GOLDFISH[i].x_pos, GOLDFISH[i].x_pos + GOLDFISH[i].rect[2]
    miny2, maxy2 = GOLDFISH[i].y_pos, GOLDFISH[i].y_pos + GOLDFISH[i].rect[3]
    if (minx1 > maxx2) or (maxx1 < minx2) or (miny1 > maxy2) or (maxy1 < miny2):
      continue
    else:
      if (SingleGoldfish.x_pos >= GOLDFISH[i].x_pos) and (SingleGoldfish.y_pos <= GOLDFISH[i].y_pos):
        SingleGoldfish.rotation = 45
        GOLDFISH[i].rotation = 45 + 180
      if (SingleGoldfish.x_pos <= GOLDFISH[i].x_pos) and (SingleGoldfish.y_pos <= GOLDFISH[i].y_pos):
        SingleGoldfish.rotation = 135
        GOLDFISH[i].rotation = 135 + 180
      if (SingleGoldfish.x_pos <= GOLDFISH[i].x_pos) and (SingleGoldfish.y_pos >= GOLDFISH[i].y_pos):
        SingleGoldfish.rotation = 225
        GOLDFISH[i].rotation = 225 + 180
      if (SingleGoldfish.x_pos >= GOLDFISH[i].x_pos) and (SingleGoldfish.y_pos >= GOLDFISH[i].y_pos):
        SingleGoldfish.rotation = 315
        GOLDFISH[i].rotation = 315 + 180
  #
  if SingleGoldfish.x_pos < SingleGoldfish.bounds[0]:
    SingleGoldfish.rotation = 0
  if SingleGoldfish.x_pos > SingleGoldfish.bounds[1]:
    SingleGoldfish.rotation = 180
  if SingleGoldfish.y_pos < SingleGoldfish.bounds[2]:
    SingleGoldfish.rotation = 270
  if SingleGoldfish.y_pos > SingleGoldfish.bounds[3]:
    SingleGoldfish.rotation = 90
  #
  if SingleGoldfish.current_fish_step == 0:
    if random.randint(0, 50) == 20:
      SingleGoldfish.rotation += random.randint(0, 120) - 60
    SingleGoldfish.rotation += random.randint(-1, 1)
    SingleGoldfish.rotation = SingleGoldfish.rotation % 360
    update_goldfish_position(SingleGoldfish)
    find_goldfish_image_rotation(SingleGoldfish)
    if SingleGoldfish.current_number_of_milliseconds >= SingleGoldfish.image_update_every_milliseconds:
      SingleGoldfish.current_number_of_milliseconds = 0
      SingleGoldfish.current_image_index += 1
      if SingleGoldfish.current_image_index > len(SingleGoldfish.GPU_images) - 1:
        SingleGoldfish.current_image_index = 0
      SingleGoldfish.GPU_current_image = SingleGoldfish.GPU_images[SingleGoldfish.current_image_index]
      if not SingleGoldfish.flipped:
        SingleGoldfish.current_image = rotate_square_image(SingleGoldfish.images[SingleGoldfish.current_image_index], SingleGoldfish.image_rotation)
      if SingleGoldfish.flipped:
        SingleGoldfish.current_image = rotate_square_image(SingleGoldfish.flipped_images[SingleGoldfish.current_image_index], SingleGoldfish.image_rotation)
    return


def update_bubbles():
  global BUBBLES
  for SingleBubble in BUBBLES:
    update_bubble(SingleBubble)
  BUBBLES = [x for x in BUBBLES if not x.will_destruct]


def update_bubble(SingleBubble):
  SingleBubble.current_milliseconds_before_update += delta_milliseconds
  if SingleBubble.current_milliseconds_before_update >= SingleBubble.milliseconds_per_update:
    SingleBubble.current_milliseconds_before_update %= SingleBubble.milliseconds_per_update
    #
    orig_y_pos = SingleBubble.y_pos
    SingleBubble.GPU_current_image = SingleBubble.images[random.randint(0,3)]
    SingleBubble.x_pos += random.randint(-1,1)*0.5
    SingleBubble.y_pos += random.randint(-1,1)*0.5
    SingleBubble.x_vel += random.randint(-1,1)*0.5
    SingleBubble.y_vel += random.randint(-1,1)*0.5
    SingleBubble.y_vel += SingleBubble.y_accel * (1 / fps)
    SingleBubble.y_pos += (SingleBubble.y_vel * (1 / fps) + ((1 / 2) * SingleBubble.y_accel * (1 / fps)**2))
    SingleBubble.x_pos += SingleBubble.x_vel * (1 / fps)
    #
    SingleBubble.current_submersion += SingleBubble.y_pos - orig_y_pos
    if SingleBubble.current_submersion <= 0:
      SingleBubble.will_destruct = True


def update_transport_pipes():
  pipe_index = 0
  for SingleTransportPipe in TRANSPORT_PIPES:
    update_transport_pipe(SingleTransportPipe, pipe_index)
    pipe_index += 1
  #
  if MAP.region == 'Sewer':
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    box_of_wind_boundaries = [1512, 3559, 625, 1648]
    wind_dist_x = 0
    wind_dist_y = 0
    if PLAYER.x_pos < box_of_wind_boundaries[0]:
      wind_dist_x = abs(PLAYER.x_pos - box_of_wind_boundaries[0])
    if box_of_wind_boundaries[0] <= PLAYER.x_pos <= box_of_wind_boundaries[1]:
      wind_dist_x = 0
    if box_of_wind_boundaries[1] < PLAYER.x_pos:
      wind_dist_x = abs(PLAYER.x_pos - box_of_wind_boundaries[1])
    if PLAYER.y_pos < box_of_wind_boundaries[2]:
      wind_dist_y = abs(PLAYER.y_pos - box_of_wind_boundaries[2])
    if box_of_wind_boundaries[2] <= PLAYER.y_pos <= box_of_wind_boundaries[3]:
      wind_dist_y = 0
    if box_of_wind_boundaries[3] < PLAYER.y_pos:
      wind_dist_y = abs(PLAYER.y_pos - box_of_wind_boundaries[3])
    distance_between_player_and_wind = find_hypotnuse(wind_dist_x, wind_dist_y)
    #
    wind_loudness = My_cached_info.current_sound_loudness * MixerSoundsLoudness['TRANSPORT_PIPE_SUCK'] * ((900 - distance_between_player_and_wind) / 900)
    if wind_loudness > (My_cached_info.current_sound_loudness * MixerSoundsLoudness['TRANSPORT_PIPE_SUCK']):
      wind_loudness = (My_cached_info.current_sound_loudness * MixerSoundsLoudness['TRANSPORT_PIPE_SUCK'])
    if wind_loudness < 0:
      wind_loudness = 0
    MixerSounds['TRANSPORT_PIPE_SUCK'].set_volume(wind_loudness)
    for _ in range(1):
      if distance_between_player_and_wind < 900:
        if not My_cached_info.playing_transport_pipe_suck:
          MixerSounds['TRANSPORT_PIPE_SUCK'].play(-1)
          My_cached_info.playing_transport_pipe_suck = True
      else:
        MixerSounds['TRANSPORT_PIPE_SUCK'].stop()
        My_cached_info.playing_transport_pipe_suck = False
    #
    #
    absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
    box_of_wind_boundaries = [5867, 6074, 3025, 4461]
    wind_dist_x = 0
    wind_dist_y = 0
    if PLAYER.x_pos < box_of_wind_boundaries[0]:
      wind_dist_x = abs(PLAYER.x_pos - box_of_wind_boundaries[0])
    if box_of_wind_boundaries[0] <= PLAYER.x_pos <= box_of_wind_boundaries[1]:
      wind_dist_x = 0
    if box_of_wind_boundaries[1] < PLAYER.x_pos:
      wind_dist_x = abs(PLAYER.x_pos - box_of_wind_boundaries[1])
    if PLAYER.y_pos < box_of_wind_boundaries[2]:
      wind_dist_y = abs(PLAYER.y_pos - box_of_wind_boundaries[2])
    if box_of_wind_boundaries[2] <= PLAYER.y_pos <= box_of_wind_boundaries[3]:
      wind_dist_y = 0
    if box_of_wind_boundaries[3] < PLAYER.y_pos:
      wind_dist_y = abs(PLAYER.y_pos - box_of_wind_boundaries[3])
    distance_between_player_and_wind = find_hypotnuse(wind_dist_x, wind_dist_y)
    #
    wind_loudness = My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER2'] * ((900 - distance_between_player_and_wind) / 900)
    if wind_loudness > (My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER2']):
      wind_loudness = (My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER2'])
    if wind_loudness < 0:
      wind_loudness = 0
    MixerSounds['IRREGULARLY_SHAPED_WATER2'].set_volume(wind_loudness)
    for _ in range(1):
      if distance_between_player_and_wind < 900:
        if not My_cached_info.playing_irregular_surfing_water:
          MixerSounds['IRREGULARLY_SHAPED_WATER2'].play(-1)
          My_cached_info.playing_irregular_surfing_water = True
        continue
      else:
        MixerSounds['IRREGULARLY_SHAPED_WATER2'].stop()
        My_cached_info.playing_irregular_surfing_water = False


def update_transport_pipe(SingleTransportPipe, pipe_index):
  global TIME_SINCE_EXITING_PIPE, CANT_REENTER_PIPE, GRAPPLED_TO_PLATFORM
  TIME_SINCE_EXITING_PIPE += delta_milliseconds
  if TIME_SINCE_EXITING_PIPE >= 1000:
    CANT_REENTER_PIPE = False
  #
  if SingleTransportPipe.is_blowing:
    SingleTransportPipe.current_milliseconds_before_next_wind_index += delta_milliseconds
    SingleTransportPipe.current_wind_index += round(SingleTransportPipe.current_milliseconds_before_next_wind_index // SingleTransportPipe.milliseconds_before_next_wind_index)
    SingleTransportPipe.current_milliseconds_before_next_wind_index %= SingleTransportPipe.milliseconds_before_next_wind_index
    SingleTransportPipe.current_wind_index %= len(SingleTransportPipe.GPU_wind_images)
    SingleTransportPipe.GPU_current_wind_image = SingleTransportPipe.GPU_wind_images[SingleTransportPipe.current_wind_index]
  if SingleTransportPipe.is_sucking:
    SingleTransportPipe.current_milliseconds_before_next_wind_index += delta_milliseconds
    SingleTransportPipe.current_wind_index -= round(SingleTransportPipe.current_milliseconds_before_next_wind_index // SingleTransportPipe.milliseconds_before_next_wind_index)
    SingleTransportPipe.current_milliseconds_before_next_wind_index %= SingleTransportPipe.milliseconds_before_next_wind_index
    SingleTransportPipe.current_wind_index %= len(SingleTransportPipe.GPU_wind_images)
    SingleTransportPipe.GPU_current_wind_image = SingleTransportPipe.GPU_wind_images[SingleTransportPipe.current_wind_index]
  #
  if SingleTransportPipe.is_blowing or SingleTransportPipe.is_sucking:
    if not PLAYER.in_a_pipe:
      if not SingleTransportPipe.up and not SingleTransportPipe.down:
        if not SingleTransportPipe.flipped:
          if (SingleTransportPipe.x_pos + SingleTransportPipe.rect[2] - 69) < (PLAYER.x_pos + ((1/2)*screen_width)) < SingleTransportPipe.x_pos + SingleTransportPipe.rect[2] + SingleTransportPipe.blow_width:
            if (SingleTransportPipe.y_pos - 69) < (PLAYER.y_pos + ((1/2)*screen_height)) < SingleTransportPipe.y_pos + SingleTransportPipe.rect[3]:
              PLAYER.Fx += SingleTransportPipe.Fx
              PLAYER.Fy += SingleTransportPipe.Fy
              if my_piston2.extension > my_piston2.maximum_extension - my_piston2.extension_float_added:
                my_piston2.grapple_claw_x_pos = 0
                my_piston2.grapple_claw_y_pos = 0
                GRAPPLED_TO_PLATFORM = False
                Marker.x_pos, Marker.y_pos, Marker.prev_x_pos, Marker.prev_y_pos, my_piston2.grapple_claw_x_pos, my_piston2.grapple_claw_y_pos = 0, 0, 0, 0, 0, 0
              PLAYER.in_pipe_wind = True
        if SingleTransportPipe.flipped:
          if (SingleTransportPipe.x_pos) > (PLAYER.x_pos + ((1/2)*screen_width)) > SingleTransportPipe.x_pos - SingleTransportPipe.blow_width:
            if (SingleTransportPipe.y_pos - 69) < (PLAYER.y_pos + ((1/2)*screen_height)) < SingleTransportPipe.y_pos + SingleTransportPipe.rect[3]:
              PLAYER.Fx += SingleTransportPipe.Fx
              PLAYER.Fy += SingleTransportPipe.Fy
              if my_piston2.extension > my_piston2.maximum_extension - my_piston2.extension_float_added:
                my_piston2.grapple_claw_x_pos = 0
                my_piston2.grapple_claw_y_pos = 0
                GRAPPLED_TO_PLATFORM = False
                Marker.x_pos, Marker.y_pos, Marker.prev_x_pos, Marker.prev_y_pos, my_piston2.grapple_claw_x_pos, my_piston2.grapple_claw_y_pos = 0, 0, 0, 0, 0, 0
              PLAYER.in_pipe_wind = True
      if SingleTransportPipe.up:
        if (SingleTransportPipe.x_pos - 69) < (PLAYER.x_pos + ((1/2)*screen_width)) < (SingleTransportPipe.x_pos + SingleTransportPipe.rect[2]):
          if (SingleTransportPipe.y_pos) > (PLAYER.y_pos + ((1/2)*screen_height)) > (SingleTransportPipe.y_pos - SingleTransportPipe.blow_width - 69):
            PLAYER.Fx += SingleTransportPipe.Fx
            PLAYER.Fy += SingleTransportPipe.Fy
            if my_piston2.extension > my_piston2.maximum_extension - my_piston2.extension_float_added:
              my_piston2.grapple_claw_x_pos = 0
              my_piston2.grapple_claw_y_pos = 0
              GRAPPLED_TO_PLATFORM = False
              Marker.x_pos, Marker.y_pos, Marker.prev_x_pos, Marker.prev_y_pos, my_piston2.grapple_claw_x_pos, my_piston2.grapple_claw_y_pos = 0, 0, 0, 0, 0, 0
            PLAYER.in_pipe_wind = True
      if SingleTransportPipe.down:
        if (SingleTransportPipe.x_pos - 69) < (PLAYER.x_pos + ((1/2)*screen_width)) < (SingleTransportPipe.x_pos + SingleTransportPipe.rect[2]):
          if (SingleTransportPipe.y_pos + SingleTransportPipe.rect[3]) < (PLAYER.y_pos + ((1/2)*screen_height)) < (SingleTransportPipe.y_pos + SingleTransportPipe.rect[3] + SingleTransportPipe.blow_width):
            PLAYER.Fx += SingleTransportPipe.Fx
            PLAYER.Fy += SingleTransportPipe.Fy
            if my_piston2.extension > my_piston2.maximum_extension - my_piston2.extension_float_added:
              my_piston2.grapple_claw_x_pos = 0
              my_piston2.grapple_claw_y_pos = 0
              GRAPPLED_TO_PLATFORM = False
              Marker.x_pos, Marker.y_pos, Marker.prev_x_pos, Marker.prev_y_pos, my_piston2.grapple_claw_x_pos, my_piston2.grapple_claw_y_pos = 0, 0, 0, 0, 0, 0
            PLAYER.in_pipe_wind = True
  #
  if PLAYER.in_a_pipe:
    if PLAYER.in_which_pipe == pipe_index:
      if not PLAYER.got_centered_in_pipe:
        distance_to_change_x = ((PLAYER.final_desired_pipe_position_x - PLAYER.initial_player_position_when_touching_pipe_x) / 12) * My_cached_info.target_fps_over_fps
        distance_to_change_y = ((PLAYER.final_desired_pipe_position_y - PLAYER.initial_player_position_when_touching_pipe_y) / 12) * My_cached_info.target_fps_over_fps
        PLAYER.x_pos += distance_to_change_x
        PLAYER.y_pos += distance_to_change_y
        if (PLAYER.final_desired_pipe_position_x >= PLAYER.initial_player_position_when_touching_pipe_x) and (PLAYER.final_desired_pipe_position_x <= PLAYER.x_pos):
          if (PLAYER.final_desired_pipe_position_y >= PLAYER.initial_player_position_when_touching_pipe_y) and (PLAYER.final_desired_pipe_position_y <= PLAYER.y_pos):
            PLAYER.x_pos = PLAYER.final_desired_pipe_position_x
            PLAYER.y_pos = PLAYER.final_desired_pipe_position_y
            PLAYER.got_centered_in_pipe = True
            PLAYER.step_in_pipe_path = 1
          if (PLAYER.final_desired_pipe_position_y <= PLAYER.initial_player_position_when_touching_pipe_y) and (PLAYER.final_desired_pipe_position_y >= PLAYER.y_pos):
            PLAYER.x_pos = PLAYER.final_desired_pipe_position_x
            PLAYER.y_pos = PLAYER.final_desired_pipe_position_y
            PLAYER.got_centered_in_pipe = True
            PLAYER.step_in_pipe_path = 1
        if (PLAYER.final_desired_pipe_position_x <= PLAYER.initial_player_position_when_touching_pipe_x) and (PLAYER.final_desired_pipe_position_x >= PLAYER.x_pos):
          if (PLAYER.final_desired_pipe_position_y >= PLAYER.initial_player_position_when_touching_pipe_y) and (PLAYER.final_desired_pipe_position_y <= PLAYER.y_pos):
            PLAYER.x_pos = PLAYER.final_desired_pipe_position_x
            PLAYER.y_pos = PLAYER.final_desired_pipe_position_y
            PLAYER.got_centered_in_pipe = True
            PLAYER.step_in_pipe_path = 1
          if (PLAYER.final_desired_pipe_position_y <= PLAYER.initial_player_position_when_touching_pipe_y) and (PLAYER.final_desired_pipe_position_y >= PLAYER.y_pos):
            PLAYER.x_pos = PLAYER.final_desired_pipe_position_x
            PLAYER.y_pos = PLAYER.final_desired_pipe_position_y
            PLAYER.got_centered_in_pipe = True
            PLAYER.step_in_pipe_path = 1
        return
      #
      else:
        current_direction_in_pipe = SingleTransportPipe.path_to_other_side[PLAYER.step_in_pipe_path]
        if PLAYER.last_step_in_pipe_path != PLAYER.step_in_pipe_path:
          PLAYER.last_step_in_pipe_path = PLAYER.step_in_pipe_path
          PLAYER.initial_player_position_when_touching_pipe_x = PLAYER.x_pos
          PLAYER.initial_player_position_when_touching_pipe_y = PLAYER.y_pos
          if current_direction_in_pipe == 'L':
            PLAYER.final_desired_pipe_position_x = PLAYER.x_pos - SingleTransportPipe.rect[2]
            PLAYER.final_desired_pipe_position_y = PLAYER.y_pos
          if current_direction_in_pipe == 'R':
            PLAYER.final_desired_pipe_position_x = PLAYER.x_pos + SingleTransportPipe.rect[2]
            PLAYER.final_desired_pipe_position_y = PLAYER.y_pos
          if current_direction_in_pipe == 'U':
            PLAYER.final_desired_pipe_position_x = PLAYER.x_pos
            PLAYER.final_desired_pipe_position_y = PLAYER.y_pos - SingleTransportPipe.rect[3]
          if current_direction_in_pipe == 'D':
            PLAYER.final_desired_pipe_position_x = PLAYER.x_pos
            PLAYER.final_desired_pipe_position_y = PLAYER.y_pos + SingleTransportPipe.rect[3]
          if current_direction_in_pipe == 'E':
            if SingleTransportPipe.ejection_direction == 'L':
              PLAYER.final_desired_pipe_position_x = PLAYER.x_pos - (SingleTransportPipe.rect[2]/2)
              PLAYER.final_desired_pipe_position_y = PLAYER.y_pos
            if SingleTransportPipe.ejection_direction == 'R':
              PLAYER.final_desired_pipe_position_x = PLAYER.x_pos + (SingleTransportPipe.rect[2]/2)
              PLAYER.final_desired_pipe_position_y = PLAYER.y_pos
            if SingleTransportPipe.ejection_direction == 'U':
              PLAYER.final_desired_pipe_position_x = PLAYER.x_pos
              PLAYER.final_desired_pipe_position_y = PLAYER.y_pos - (SingleTransportPipe.rect[3]/2)
            if SingleTransportPipe.ejection_direction == 'D':
              PLAYER.final_desired_pipe_position_x = PLAYER.x_pos
              PLAYER.final_desired_pipe_position_y = PLAYER.y_pos + (SingleTransportPipe.rect[3]/2)
        if current_direction_in_pipe != 'E':
          distance_to_change_x = ((PLAYER.final_desired_pipe_position_x - PLAYER.initial_player_position_when_touching_pipe_x) / 24) * My_cached_info.target_fps_over_fps
          distance_to_change_y = ((PLAYER.final_desired_pipe_position_y - PLAYER.initial_player_position_when_touching_pipe_y) / 24) * My_cached_info.target_fps_over_fps
        if current_direction_in_pipe == 'E':
          distance_to_change_x = ((PLAYER.final_desired_pipe_position_x - PLAYER.initial_player_position_when_touching_pipe_x) / 12) * My_cached_info.target_fps_over_fps
          distance_to_change_y = ((PLAYER.final_desired_pipe_position_y - PLAYER.initial_player_position_when_touching_pipe_y) / 12) * My_cached_info.target_fps_over_fps
        PLAYER.x_pos += distance_to_change_x
        PLAYER.y_pos += distance_to_change_y
        if (PLAYER.final_desired_pipe_position_x >= PLAYER.initial_player_position_when_touching_pipe_x) and (PLAYER.final_desired_pipe_position_x <= PLAYER.x_pos):
          if (PLAYER.final_desired_pipe_position_y >= PLAYER.initial_player_position_when_touching_pipe_y) and (PLAYER.final_desired_pipe_position_y <= PLAYER.y_pos):
            PLAYER.x_pos = PLAYER.final_desired_pipe_position_x
            PLAYER.y_pos = PLAYER.final_desired_pipe_position_y
            if current_direction_in_pipe == 'E':
              PLAYER.in_a_pipe = False
              My_cached_info.milliseconds_can_go_back_in_transport_pipe = 0
              CANT_REENTER_PIPE = True
              TIME_SINCE_EXITING_PIPE = 0
              if SingleTransportPipe.ejection_direction == 'L':
                PLAYER.x_vel = -300
                PLAYER.y_vel = random.randint(-100, 100)
              if SingleTransportPipe.ejection_direction == 'R':
                PLAYER.x_vel = 300
                PLAYER.y_vel = random.randint(-100, 100)
              if SingleTransportPipe.ejection_direction == 'U':
                PLAYER.x_vel = random.randint(-100, 100)
                PLAYER.y_vel = -300
              if SingleTransportPipe.ejection_direction == 'D':
                PLAYER.x_vel = random.randint(-100, 100)
                PLAYER.y_vel = 300
              return
            PLAYER.step_in_pipe_path += 1
            return
          if (PLAYER.final_desired_pipe_position_y <= PLAYER.initial_player_position_when_touching_pipe_y) and (PLAYER.final_desired_pipe_position_y >= PLAYER.y_pos):
            PLAYER.x_pos = PLAYER.final_desired_pipe_position_x
            PLAYER.y_pos = PLAYER.final_desired_pipe_position_y
            if current_direction_in_pipe == 'E':
              PLAYER.in_a_pipe = False
              My_cached_info.milliseconds_can_go_back_in_transport_pipe = 0
              CANT_REENTER_PIPE = True
              TIME_SINCE_EXITING_PIPE = 0
              if SingleTransportPipe.ejection_direction == 'L':
                PLAYER.x_vel = -300
                PLAYER.y_vel = random.randint(-100, 100)
              if SingleTransportPipe.ejection_direction == 'R':
                PLAYER.x_vel = 300
                PLAYER.y_vel = random.randint(-100, 100)
              if SingleTransportPipe.ejection_direction == 'U':
                PLAYER.x_vel = random.randint(-100, 100)
                PLAYER.y_vel = -300
              if SingleTransportPipe.ejection_direction == 'D':
                PLAYER.x_vel = random.randint(-100, 100)
                PLAYER.y_vel = 300
              return
            PLAYER.step_in_pipe_path += 1
            return
        if (PLAYER.final_desired_pipe_position_x <= PLAYER.initial_player_position_when_touching_pipe_x) and (PLAYER.final_desired_pipe_position_x >= PLAYER.x_pos):
          if (PLAYER.final_desired_pipe_position_y > PLAYER.initial_player_position_when_touching_pipe_y) and (PLAYER.final_desired_pipe_position_y <= PLAYER.y_pos):
            PLAYER.x_pos = PLAYER.final_desired_pipe_position_x
            PLAYER.y_pos = PLAYER.final_desired_pipe_position_y
            if current_direction_in_pipe == 'E':
              PLAYER.in_a_pipe = False
              My_cached_info.milliseconds_can_go_back_in_transport_pipe = 0
              CANT_REENTER_PIPE = True
              TIME_SINCE_EXITING_PIPE = 0
              if SingleTransportPipe.ejection_direction == 'L':
                PLAYER.x_vel = -300
                PLAYER.y_vel = random.randint(-100, 100)
              if SingleTransportPipe.ejection_direction == 'R':
                PLAYER.x_vel = 300
                PLAYER.y_vel = random.randint(-100, 100)
              if SingleTransportPipe.ejection_direction == 'U':
                PLAYER.x_vel = random.randint(-100, 100)
                PLAYER.y_vel = -300
              if SingleTransportPipe.ejection_direction == 'D':
                PLAYER.x_vel = random.randint(-100, 100)
                PLAYER.y_vel = 300
              return
            PLAYER.step_in_pipe_path += 1
            return
          if (PLAYER.final_desired_pipe_position_y <= PLAYER.initial_player_position_when_touching_pipe_y) and (PLAYER.final_desired_pipe_position_y >= PLAYER.y_pos):
            PLAYER.x_pos = PLAYER.final_desired_pipe_position_x
            PLAYER.y_pos = PLAYER.final_desired_pipe_position_y
            if current_direction_in_pipe == 'E':
              PLAYER.in_a_pipe = False
              My_cached_info.milliseconds_can_go_back_in_transport_pipe = 0
              CANT_REENTER_PIPE = True
              TIME_SINCE_EXITING_PIPE = 0
              if SingleTransportPipe.ejection_direction == 'L':
                PLAYER.x_vel = -300
                PLAYER.y_vel = random.randint(-100, 100)
              if SingleTransportPipe.ejection_direction == 'R':
                PLAYER.x_vel = 300
                PLAYER.y_vel = random.randint(-100, 100)
              if SingleTransportPipe.ejection_direction == 'U':
                PLAYER.x_vel = random.randint(-100, 100)
                PLAYER.y_vel = -300
              if SingleTransportPipe.ejection_direction == 'D':
                PLAYER.x_vel = random.randint(-100, 100)
                PLAYER.y_vel = 300
              return
            PLAYER.step_in_pipe_path += 1
            return


def update_surf_boards():
  current_board = 0
  for SingleSurfBoard in SURF_BOARDS:
    update_surf_board(SingleSurfBoard, current_board)
  current_board += 1


def update_surf_board(SingleSurfBoard, which_board):
  SingleSurfBoard.touching_water_last_frame = SingleSurfBoard.touching_water
  SingleSurfBoard.touching_water = False
  start_of_update_y_vel = SingleSurfBoard.y_vel
  which_water = 0
  PLAYER.riding_a_wave = False
  if PLAYER.surfing_check_points:
    if PLAYER.time_since_leaving_board != 0:
      if not collision_happened and (True not in my_piston1.is_touching_wall):
        PLAYER.time_since_leaving_board += delta_milliseconds
      else:
        PLAYER.time_since_leaving_board = 0
  if not PLAYER.on_a_surf_board or not PLAYER.on_which_surf_board == which_board: # PLAYER not on board
    if SingleSurfBoard.image_rotation != 0:
      if 0 < SingleSurfBoard.image_rotation <= 180:
        SingleSurfBoard.image_rotation -= 1 * My_cached_info.target_fps_over_fps
      if 180 < SingleSurfBoard.image_rotation < 360:
        SingleSurfBoard.image_rotation += 1 * My_cached_info.target_fps_over_fps
      if (358 <= SingleSurfBoard.image_rotation <= 360) or (0 <= SingleSurfBoard.image_rotation <= 2):
        SingleSurfBoard.image_rotation = 0
  is_touching_water = False
  surf_board_wants_to_go_left = False
  surf_board_wants_to_go_right = False
  surf_board_resist_movement = False
  if (0 < SingleSurfBoard.image_rotation < 180):
    surf_board_wants_to_go_left = True
  if (180 < SingleSurfBoard.image_rotation < 360):
    surf_board_wants_to_go_right = True
  if (350 <= SingleSurfBoard.image_rotation <= 360) or (0 <= SingleSurfBoard.image_rotation <= 10) or (165 <= SingleSurfBoard.image_rotation <= 195):
    surf_board_resist_movement = True
  #
  center_of_board_x, center_of_board_y = SingleSurfBoard.x_pos + (SingleSurfBoard.rect[2]/2), SingleSurfBoard.y_pos + (SingleSurfBoard.rect[3]/2)
  SingleSurfBoard.Fx, SingleSurfBoard.Fy = 0, 400
  water_surface_index = 0
  for SingleWaterSurface in WATER_SURFACES:
    if not (water_surface_index in SingleSurfBoard.water_surface_collision_indexes):
      water_surface_index += 1
      continue
    water_surface_index += 1
    center_of_water_x, center_of_water_y = SingleWaterSurface.x_pos + (SingleWaterSurface.rect[2]/2), SingleWaterSurface.y_pos + (SingleWaterSurface.rect[3]/2)
    distance_between_board_and_water = find_hypotnuse(center_of_board_x - center_of_water_x, center_of_board_y - center_of_water_y)
    if distance_between_board_and_water <= (SingleSurfBoard.radius + SingleWaterSurface.radius):
      if SingleSurfBoard.went_under_last_frame:
        SingleSurfBoard.Fy = 0
      left_collisions_with_board, left_collision_with_board_happened = find_surf_board_collisions(SingleWaterSurface, SingleSurfBoard, SingleSurfBoard.left_collision_image)
      right_collisions_with_board, right_collision_with_board_happened = find_surf_board_collisions(SingleWaterSurface, SingleSurfBoard, SingleSurfBoard.right_collision_image)
      if PLAYER.surfing_check_points:
        if left_collision_with_board_happened or right_collision_with_board_happened:
          PLAYER.surfing_spin_checkpoints = [False, False, False, False]
      #
      if left_collision_with_board_happened and right_collision_with_board_happened: # board is flat
        SingleSurfBoard.touching_water = True
        if SingleSurfBoard.went_over_last_frame:
          SingleSurfBoard.y_vel *= 0.1
          SingleSurfBoard.went_over_last_frame = False
        is_touching_water = True
        if surf_board_wants_to_go_left:
          SingleSurfBoard.Fx -= (len(left_collisions_with_board) + len(right_collisions_with_board)) * 6
        if surf_board_wants_to_go_right:
          SingleSurfBoard.Fx += (len(left_collisions_with_board) + len(right_collisions_with_board)) * 6
        SingleSurfBoard.Fy -= (len(left_collisions_with_board) + len(right_collisions_with_board)) * 3
      if left_collision_with_board_happened and not right_collision_with_board_happened:
        SingleSurfBoard.touching_water = True
        if SingleSurfBoard.went_over_last_frame:
          SingleSurfBoard.y_vel *= 0.1
          SingleSurfBoard.went_over_last_frame = False
        is_touching_water = True
        SingleSurfBoard.Fx -= 6 * len(left_collisions_with_board)
        SingleSurfBoard.Fy -= len(left_collisions_with_board) * 3
      if not left_collision_with_board_happened and right_collision_with_board_happened:
        SingleSurfBoard.touching_water = True
        if SingleSurfBoard.went_over_last_frame:
          SingleSurfBoard.y_vel *= 0.1
          SingleSurfBoard.went_over_last_frame = False
        is_touching_water = True
        SingleSurfBoard.Fx += 6 * len(right_collisions_with_board)
        SingleSurfBoard.Fy -= len(right_collisions_with_board) * 3
      if not left_collision_with_board_happened and not right_collision_with_board_happened:
        if SingleSurfBoard.Fx == 0:
          SingleSurfBoard.Fx = 0
    which_water += 1
    continue
  #
  ignore_the_rest_of_the_waves = False
  for SingleWave in WAVES:
    if not ignore_the_rest_of_the_waves:
      center_of_wave_x, center_of_wave_y = SingleWave.x_pos + (SingleWave.rect[2]/2), SingleWave.y_pos + (SingleWave.rect[3]/2)
      distance_between_board_and_wave = find_hypotnuse(center_of_wave_x - center_of_board_x, center_of_wave_y - center_of_board_y)
      if distance_between_board_and_wave <= (SingleSurfBoard.radius + SingleWave.radius):
        wave_collisions_with_board, wave_collision_with_board_happened = find_surf_board_collisions(SingleWave, SingleSurfBoard, SingleSurfBoard.current_image)
        if wave_collision_with_board_happened:
          SingleSurfBoard.touching_water = True
          if PLAYER.surfing_check_points:
            PLAYER.surfing_spin_checkpoints = [False, False, False, False]
          ignore_the_rest_of_the_waves = True
          SingleSurfBoard.Fy -= len(wave_collisions_with_board) * 6
          if not 10 < SingleSurfBoard.image_rotation < 75:
            SingleSurfBoard.Fx += SingleWave.x_vel * 60
          if len(wave_collisions_with_board) > 120:
            if (0 <= SingleSurfBoard.image_rotation <= 5) or (340 <= SingleSurfBoard.image_rotation <= 360):
              if SingleSurfBoard.x_vel > 0:
                SingleSurfBoard.Fx = -abs(SingleSurfBoard.Fx)
              if SingleSurfBoard.x_vel < 0:
                SingleSurfBoard.Fx = abs(SingleSurfBoard.Fx)
              if -5 < SingleSurfBoard.x_vel < 5:
                if (PLAYER.on_a_surf_board and PLAYER.on_which_surf_board == which_board):
                  PLAYER.riding_a_wave = True
                  PLAYER.surfing_riding_wave = True
                  PLAYER.wave_size_multiplier = SingleWave.wave_size_multiplier
                SingleSurfBoard.x_vel = 0
                SingleSurfBoard.Fx = 0
                SingleSurfBoard.x_pos += SingleWave.x_vel * My_cached_info.target_fps_over_fps
                if (SingleSurfBoard.y_pos + SingleSurfBoard.attach_y) > (SingleWave.y_pos + (SingleWave.rect[3] / 2)):
                  SingleSurfBoard.Fy = -abs(SingleSurfBoard.Fy)
                if (SingleSurfBoard.y_pos + SingleSurfBoard.attach_y) < (SingleWave.y_pos + (SingleWave.rect[3] / 2)):
                  SingleSurfBoard.Fy = abs(SingleSurfBoard.Fy)
  if True in PLAYER.riding_a_wave_last_few_frames:
    PLAYER.surfing_riding_wave = True
  if not PLAYER.riding_a_wave and (False not in PLAYER.riding_a_wave_last_few_frames):
    SingleSurfBoard.x_vel = 350
  for _ in range(My_cached_info.whole_number_of_frames_this_frame):
    PLAYER.riding_a_wave_last_few_frames.append(PLAYER.riding_a_wave)
    PLAYER.riding_a_wave_last_few_frames = PLAYER.riding_a_wave_last_few_frames[1:]
  #
  if not is_touching_water and not SingleSurfBoard.went_under_last_frame:
    SingleSurfBoard.went_over_last_frame = True
  #
  if surf_board_resist_movement and is_touching_water:
    if SingleSurfBoard.x_vel > 0:
      SingleSurfBoard.Fx = -abs(SingleSurfBoard.Fx)
    if SingleSurfBoard.x_vel < 0:
      SingleSurfBoard.Fx = abs(SingleSurfBoard.Fx)
    if -5 < SingleSurfBoard.x_vel < 5:
      SingleSurfBoard.x_vel = 0
      SingleSurfBoard.Fx = 0
  #
  SingleSurfBoard.went_under_last_frame = False
  SingleSurfBoard.x_accel = SingleSurfBoard.Fx
  SingleSurfBoard.y_accel = SingleSurfBoard.Fy
  SingleSurfBoard.x_vel = SingleSurfBoard.x_vel + (SingleSurfBoard.x_accel * (1 / fps))
  SingleSurfBoard.y_vel = SingleSurfBoard.y_vel + (SingleSurfBoard.y_accel * (1 / fps))
  if abs(SingleSurfBoard.x_vel) >= 500:
    if SingleSurfBoard.x_vel > 0:
      SingleSurfBoard.x_vel = 500
    else:
      SingleSurfBoard.x_vel = -500
  if SingleSurfBoard.x_vel > 25:
    SingleSurfBoard.currently_flipping_image = True
  if SingleSurfBoard.x_vel < -25:
    SingleSurfBoard.currently_flipping_image = False
  if PLAYER.riding_a_wave or (True in PLAYER.riding_a_wave_last_few_frames):
    SingleSurfBoard.currently_flipping_image = True
  SingleSurfBoard.x_pos = SingleSurfBoard.x_pos + (SingleSurfBoard.x_vel * (1 / fps)) + ((1/2) * (SingleSurfBoard.x_accel) * ((1 / fps)**2))
  SingleSurfBoard.y_pos = SingleSurfBoard.y_pos + (SingleSurfBoard.y_vel * (1 / fps)) + ((1/2) * (SingleSurfBoard.y_accel) * ((1 / fps)**2))
  surf_ltwh = pygame.mask.from_surface(SingleSurfBoard.current_image).get_bounding_rects()[0]
  if (SingleSurfBoard.x_pos+surf_ltwh[0] < SingleSurfBoard.boundaries[0]) or (SingleSurfBoard.x_pos+surf_ltwh[0]+surf_ltwh[2] > SingleSurfBoard.boundaries[1]):
    if PLAYER.on_a_surf_board and PLAYER.on_which_surf_board == which_board:
      PLAYER.surfing_wipeout = True
      PLAYER.on_a_surf_board = False
      my_piston2.grapple_claw_x_pos = 0
      my_piston2.grapple_claw_y_pos = 0
      PLAYER.x_vel = SingleSurfBoard.x_vel
      PLAYER.y_vel = SingleSurfBoard.y_vel
    if (SingleSurfBoard.x_pos+surf_ltwh[0] < SingleSurfBoard.boundaries[0]):
      SingleSurfBoard.touching_water = True
      SingleSurfBoard.x_pos += 3 * My_cached_info.target_fps_over_fps
    if (SingleSurfBoard.x_pos+surf_ltwh[0]+surf_ltwh[2] > SingleSurfBoard.boundaries[1]):
      SingleSurfBoard.x_pos -= 3 * My_cached_info.target_fps_over_fps
    SingleSurfBoard.x_vel *= -1
  if (SingleSurfBoard.y_pos+surf_ltwh[1] < SingleSurfBoard.boundaries[2]) or (SingleSurfBoard.y_pos+surf_ltwh[1]+surf_ltwh[3] > SingleSurfBoard.boundaries[3]):
    if (SingleSurfBoard.y_pos+surf_ltwh[1] < SingleSurfBoard.boundaries[2]):
      SingleSurfBoard.y_vel += 10 * My_cached_info.target_fps_over_fps
    if (SingleSurfBoard.y_pos+surf_ltwh[1]+surf_ltwh[3] > SingleSurfBoard.boundaries[3]):
      SingleSurfBoard.touching_water = True
      SingleSurfBoard.y_vel -= 10 * My_cached_info.target_fps_over_fps
      SingleSurfBoard.went_under_last_frame = True
  if PLAYER.on_a_surf_board and PLAYER.on_which_surf_board == which_board:
    if collision_happened:
      PLAYER.surfing_wipeout = True
      PLAYER.on_a_surf_board = False
      my_piston2.grapple_claw_x_pos = 0
      my_piston2.grapple_claw_y_pos = 0
      PLAYER.x_vel = SingleSurfBoard.x_vel
      PLAYER.y_vel = SingleSurfBoard.y_vel
  SingleSurfBoard.previous_x = SingleSurfBoard.current_x
  SingleSurfBoard.previous_y = SingleSurfBoard.current_y
  SingleSurfBoard.current_x = SingleSurfBoard.x_pos
  SingleSurfBoard.current_y = SingleSurfBoard.y_pos
  if PLAYER.surfing_check_points:
    if (PLAYER.on_a_surf_board and PLAYER.on_which_surf_board == which_board):
      if PLAYER.y_pos < PLAYER.height_needed_to_start_going_really_high:
        if SingleSurfBoard.current_y < SingleSurfBoard.previous_y:
          PLAYER.surfing_going_really_high = True
          PLAYER.surfing_high_points_to_add = SingleSurfBoard.previous_y - SingleSurfBoard.current_y
  if not SingleSurfBoard.touching_water_last_frame and SingleSurfBoard.touching_water:
    if SingleSurfBoard.y_vel > 0:
      surf_board_splash_vel_multiplier = start_of_update_y_vel / 600
      if surf_board_splash_vel_multiplier > 1:
        surf_board_splash_vel_multiplier = 1
      if surf_board_splash_vel_multiplier < 0:
        surf_board_splash_vel_multiplier = 0
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      distance_between_player_and_SurfBoard = find_hypotnuse(abs(absolute_center_of_player_x - (SingleSurfBoard.x_pos - ((1/2)*screen_width) + (SingleSurfBoard.rect[2]/2))), abs(absolute_center_of_player_y - (SingleSurfBoard.y_pos - ((1/2)*screen_height) + (SingleSurfBoard.rect[3]/2))))
      distance_between_player_and_surf_board_sound_multiplier = ((600 - distance_between_player_and_SurfBoard) / 600)
      if distance_between_player_and_surf_board_sound_multiplier > 1:
        distance_between_player_and_surf_board_sound_multiplier = 1
      if distance_between_player_and_surf_board_sound_multiplier < 0:
        distance_between_player_and_surf_board_sound_multiplier = 0
      surf_board_splash_loudness = My_cached_info.current_sound_loudness * MixerSoundsLoudness['SURF_BOARD_HITTING_WATER'] * surf_board_splash_vel_multiplier * distance_between_player_and_surf_board_sound_multiplier
      MixerSounds['SURF_BOARD_HITTING_WATER'].set_volume(surf_board_splash_loudness)
      MixerSounds['SURF_BOARD_HITTING_WATER'].play()


def update_waves():
  global WAVES
  My_cached_info.current_milliseconds_needed_to_make_new_wave += delta_milliseconds
  if My_cached_info.current_milliseconds_needed_to_make_new_wave >= My_cached_info.milliseconds_needed_to_make_new_wave:
    My_cached_info.current_milliseconds_needed_to_make_new_wave %= My_cached_info.milliseconds_needed_to_make_new_wave
    random_wave_size_number = random.randint(0, 40)
    if random_wave_size_number < 30:
      current_wave_name = 'SMALL_WAVE'
      WAVES.append(Wave(x_pos = 600 + ((1/2)*screen_width), y_pos = 2021 - 134 + ((1/2)*screen_height), x_vel = random.randint(4, 6), png_name = current_wave_name))
    if 30 <= random_wave_size_number <= 38:
      current_wave_name = 'MEDIUM_WAVE'
      WAVES.append(Wave(x_pos = 600 + ((1/2)*screen_width), y_pos = 2021 - 269 + ((1/2)*screen_height), x_vel = random.randint(4, 6), png_name = current_wave_name))
    if 38 < random_wave_size_number:
      current_wave_name = 'BIG_WAVE'
      WAVES.append(Wave(x_pos = 600 + ((1/2)*screen_width), y_pos = 2021 - 539 + ((1/2)*screen_height), x_vel = random.randint(4, 6), png_name = current_wave_name))
  for SingleWave in WAVES:
    update_wave(SingleWave)
  WAVES = [x for x in WAVES if not x.impending_deletion]
  #
  absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
  box_of_wind_boundaries = [600, 807, 584, 2020]
  wind_dist_x = 0
  wind_dist_y = 0
  if PLAYER.x_pos < box_of_wind_boundaries[0]:
    wind_dist_x = abs(PLAYER.x_pos - box_of_wind_boundaries[0])
  if box_of_wind_boundaries[0] <= PLAYER.x_pos <= box_of_wind_boundaries[1]:
    wind_dist_x = 0
  if box_of_wind_boundaries[1] < PLAYER.x_pos:
    wind_dist_x = abs(PLAYER.x_pos - box_of_wind_boundaries[1])
  if PLAYER.y_pos < box_of_wind_boundaries[2]:
    wind_dist_y = abs(PLAYER.y_pos - box_of_wind_boundaries[2])
  if box_of_wind_boundaries[2] <= PLAYER.y_pos <= box_of_wind_boundaries[3]:
    wind_dist_y = 0
  if box_of_wind_boundaries[3] < PLAYER.y_pos:
    wind_dist_y = abs(PLAYER.y_pos - box_of_wind_boundaries[3])
  distance_between_player_and_wind = find_hypotnuse(wind_dist_x, wind_dist_y)
  #
  wind_loudness = My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER2'] * ((900 - distance_between_player_and_wind) / 900)
  if wind_loudness > (My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER2']):
    wind_loudness = (My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER2'])
  if wind_loudness < 0:
    wind_loudness = 0
  MixerSounds['IRREGULARLY_SHAPED_WATER2'].set_volume(wind_loudness)
  for _ in range(1):
    if distance_between_player_and_wind < 900:
      if not My_cached_info.playing_irregular_surfing_water:
        MixerSounds['IRREGULARLY_SHAPED_WATER2'].play(-1)
        My_cached_info.playing_irregular_surfing_water = True
      continue
    else:
      MixerSounds['IRREGULARLY_SHAPED_WATER2'].stop()
      My_cached_info.playing_irregular_surfing_water = False


def update_wave(SingleWave):
  SingleWave.current_milliseconds_before_showing_next_image += delta_milliseconds
  if SingleWave.current_milliseconds_before_showing_next_image >= SingleWave.milliseconds_before_showing_next_image:
    SingleWave.current_milliseconds_before_showing_next_image %= SingleWave.milliseconds_before_showing_next_image
    SingleWave.current_image_index += 1
    if SingleWave.current_image_index > len(SingleWave.GPU_images) - 1:
      SingleWave.current_image_index = 0
  SingleWave.GPU_current_image = SingleWave.GPU_images[SingleWave.current_image_index]
  SingleWave.current_image = SingleWave.images[SingleWave.current_image_index]
  #
  SingleWave.x_pos += SingleWave.x_vel * My_cached_info.target_fps_over_fps
  if SingleWave.x_pos >= 4876 + ((1/2)*screen_width):
    SingleWave.impending_deletion = True


def rat_is_on_the_screen(SingleSurfingRat):
  adjusted_x_pos = SingleSurfingRat.x_pos - ((1/2)*screen_width)
  adjusted_y_pos = SingleSurfingRat.y_pos - ((1/2)*screen_height)
  if PLAYER.x_pos - screen_width <= adjusted_x_pos <= PLAYER.x_pos + screen_width:
    if PLAYER.y_pos - screen_height <= adjusted_y_pos <= PLAYER.y_pos + screen_height:
      SingleSurfingRat.is_on_screen = True
    else:
      SingleSurfingRat.is_on_screen = False
  else:
    SingleSurfingRat.is_on_screen = False


def update_eating_rat():
  global EATING_RAT
  try:
    SingleEatingRat = EATING_RAT[0]
  except:
    return
  SingleEatingRat.show_dialogue = False
  SingleEatingRat.current_milliseconds_needed_before_next_rat_image += delta_milliseconds
  if SingleEatingRat.current_milliseconds_needed_before_next_rat_image >= SingleEatingRat.milliseconds_needed_before_next_rat_image:
    SingleEatingRat.current_milliseconds_needed_before_next_rat_image %= SingleEatingRat.milliseconds_needed_before_next_rat_image
    SingleEatingRat.current_rat_image_index += 1
    if SingleEatingRat.current_rat_image_index > len(SingleEatingRat.GPU_standing_images) - 1:
      SingleEatingRat.current_rat_image_index = 0
  absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
  distance_between_player_and_rat = find_hypotnuse(abs(absolute_center_of_player_x - (SingleEatingRat.x_pos - ((1/2)*screen_width) + (278/2))), abs(absolute_center_of_player_y - (SingleEatingRat.y_pos - ((1/2)*screen_height) + (94/2))))
  if not PLAYER.talked_to_eating_rat_before:
    if distance_between_player_and_rat <= 400:
      PLAYER.talked_to_eating_rat_before = True
      everything_save_data(True, 93, '1')
  SingleEatingRat.GPU_current_rat_image = SingleEatingRat.GPU_standing_images[SingleEatingRat.current_rat_image_index]
  if EATING_RAT[0].eaten_how_much_food == 4 and not SingleEatingRat.currently_eating_food:
    if not (distance_between_player_and_rat <= 400):
      SingleEatingRat.can_say_hi = True
    if distance_between_player_and_rat <= 400:
      SingleEatingRat.show_dialogue = True
      SingleEatingRat.GPU_current_rat_image = SingleEatingRat.GPU_talking_images[SingleEatingRat.current_rat_image_index]
      SingleEatingRat.milliseconds_conclusion_talking += delta_milliseconds
      if 0 <= SingleEatingRat.milliseconds_conclusion_talking <= 200:
        SingleEatingRat.show_dialogue = False
        SingleEatingRat.GPU_current_dialogue = SingleEatingRat.IFeelSoSatisfiedNow
      if 200 <= SingleEatingRat.milliseconds_conclusion_talking <= 3000:
        SingleEatingRat.GPU_current_dialogue = SingleEatingRat.IFeelSoSatisfiedNow
      if 3000 <= SingleEatingRat.milliseconds_conclusion_talking <= 3200:
        SingleEatingRat.show_dialogue = False
        SingleEatingRat.GPU_current_dialogue = SingleEatingRat.IFeelSoSatisfiedNow
      if (3200 <= SingleEatingRat.milliseconds_conclusion_talking) and not PLAYER.collected_wrench:
        SingleEatingRat.can_say_hi = False
        SingleEatingRat.GPU_current_dialogue = OpenGLTextures['IWantYouToHaveThis2']
        if TOOLS == []:
          TOOLS.append(Tools(x_pos = 4592 + ((1/2)*screen_width), y_pos = 560 + ((1/2)*screen_height), png_name = 'WRENCH'))
      if PLAYER.collected_wrench:
        if SingleEatingRat.can_say_hi:
          SingleEatingRat.show_dialogue = True
          SingleEatingRat.GPU_current_dialogue = SingleEatingRat.HiyaHamsterFriend
  if (distance_between_player_and_rat <= 400) or SingleEatingRat.currently_eating_food:
    SingleEatingRat.milliseconds_speaking_with_hamster += delta_milliseconds
    if 0 <= SingleEatingRat.eaten_how_much_food <= 3:
      for SingleFood in FOOD:
        if SingleEatingRat.x_pos + 252-64 <= SingleFood.x_pos <= SingleEatingRat.x_pos + 277:
          if SingleEatingRat.y_pos + 48-64 <= SingleFood.y_pos <= SingleEatingRat.y_pos + 71:
            SingleEatingRat.milliseconds_speaking_with_hamster = 90000
            SingleEatingRat.show_dialogue = False
    if 0 <= SingleEatingRat.milliseconds_speaking_with_hamster <= 8800:
      if 0 <= SingleEatingRat.milliseconds_speaking_with_hamster < 2800:
        SingleEatingRat.GPU_current_dialogue = SingleEatingRat.OhHelloLittleHamster
        SingleEatingRat.show_dialogue = True
        SingleEatingRat.GPU_current_rat_image = SingleEatingRat.GPU_talking_images[SingleEatingRat.current_rat_image_index]
      if 2800 <= SingleEatingRat.milliseconds_speaking_with_hamster < 3000:
        SingleEatingRat.GPU_current_dialogue = SingleEatingRat.OhHelloLittleHamster
        SingleEatingRat.show_dialogue = False
        SingleEatingRat.GPU_current_rat_image = SingleEatingRat.GPU_talking_images[SingleEatingRat.current_rat_image_index]
      if 3000 <= SingleEatingRat.milliseconds_speaking_with_hamster < 5800:
        SingleEatingRat.GPU_current_dialogue = SingleEatingRat.DoYouHappenToHaveAnyFood
        SingleEatingRat.show_dialogue = True
        SingleEatingRat.GPU_current_rat_image = SingleEatingRat.GPU_talking_images[SingleEatingRat.current_rat_image_index]
      if 5800 <= SingleEatingRat.milliseconds_speaking_with_hamster < 6000:
        if SingleEatingRat.eaten_how_much_food > 0:
          SingleEatingRat.milliseconds_speaking_with_hamster = 9000
        SingleEatingRat.GPU_current_dialogue = SingleEatingRat.DoYouHappenToHaveAnyFood
        SingleEatingRat.show_dialogue = False
        SingleEatingRat.GPU_current_rat_image = SingleEatingRat.GPU_talking_images[SingleEatingRat.current_rat_image_index]
      if 6000 <= SingleEatingRat.milliseconds_speaking_with_hamster <= 8800:
        SingleEatingRat.GPU_current_dialogue = SingleEatingRat.ItsBeenToughToFindFoodRecently
        SingleEatingRat.show_dialogue = True
        SingleEatingRat.GPU_current_rat_image = SingleEatingRat.GPU_talking_images[SingleEatingRat.current_rat_image_index]
    else:
      which_food = 0
      if not SingleEatingRat.currently_eating_food:
        for SingleFood in FOOD:
          if SingleEatingRat.x_pos + 252-64 <= SingleFood.x_pos <= SingleEatingRat.x_pos + 277:
            if SingleEatingRat.y_pos + 48-64 <= SingleFood.y_pos <= SingleEatingRat.y_pos + 71:
              SingleEatingRat.currently_eating_food = True
              SingleEatingRat.GPU_current_rat_image = SingleEatingRat.GPU_talking_images[SingleEatingRat.current_rat_image_index]
              SingleFood.being_eaten = True
              SingleEatingRat.eating_which_food = SingleFood.food_index
              SingleEatingRat.eaten_how_much_food += 1
              SingleEatingRat.how_much_food_is_there_left = len(FOOD)
              SingleEatingRat.milliseconds_speaking_with_hamster = 10000
              if SingleFood.food_index == 0:
                everything_save_data(True, 21, '1')
                My_cached_info.food_that_exists[0] = False
              if SingleFood.food_index == 1:
                everything_save_data(True, 22, '1')
                My_cached_info.food_that_exists[1] = False
              if SingleFood.food_index == 2:
                everything_save_data(True, 23, '1')
                My_cached_info.food_that_exists[2] = False
              if SingleFood.food_index == 3:
                everything_save_data(True, 24, '1')
                My_cached_info.food_that_exists[3] = False
              if PLAYER.carrying_food:
                if PLAYER.carrying_which_food == which_food:
                  PLAYER.carrying_food = False
                  PLAYER.carrying_which_food = 666
                  my_piston2.grapple_claw_x_pos = 0
                  my_piston2.grapple_claw_y_pos = 0
                  Marker.x_pos, Marker.y_pos = 0, 0
          which_food += 1
      else:
        SingleEatingRat.show_dialogue = True
        SingleEatingRat.GPU_current_rat_image = SingleEatingRat.GPU_talking_images[SingleEatingRat.current_rat_image_index]
        SingleEatingRat.GPU_current_dialogue = SingleEatingRat.compliments[SingleEatingRat.eating_which_food]
        eating_loudness_distance_multiplier = ((500 - distance_between_player_and_rat) / 500)
        if eating_loudness_distance_multiplier > 1:
          eating_loudness_distance_multiplier = 1
        if eating_loudness_distance_multiplier < 0:
          eating_loudness_distance_multiplier = 0
        MixerSounds['EATING_RAT'].set_volume(My_cached_info.current_sound_loudness * MixerSoundsLoudness['EATING_RAT'] * eating_loudness_distance_multiplier)
        if not SingleEatingRat.playing_eating_sound:
          SingleEatingRat.playing_eating_sound = True
          MixerSounds['EATING_RAT'].play(-1)
        if SingleEatingRat.how_much_food_is_there_left != len(FOOD):
          SingleEatingRat.currently_eating_food = False
          SingleEatingRat.playing_eating_sound = False
          MixerSounds['EATING_RAT'].fadeout(100)


def update_surfing_rat():
  global SURFING_RAT, UPGRADES, SURFING_CLOCK, SURFING_PROGRESS_BAR
  try:
    SingleSurfingRat = SURFING_RAT[0]
  except:
    return
  rat_is_on_the_screen(SingleSurfingRat)
  SingleSurfingRat.show_dialogue = False
  SingleSurfingRat.current_milliseconds_needed_before_next_rat_image += delta_milliseconds
  if SingleSurfingRat.current_milliseconds_needed_before_next_rat_image >= SingleSurfingRat.milliseconds_needed_before_next_rat_image:
    SingleSurfingRat.current_milliseconds_needed_before_next_rat_image %= SingleSurfingRat.milliseconds_needed_before_next_rat_image
    SingleSurfingRat.current_rat_image_index += 1
    if SingleSurfingRat.current_rat_image_index > len(SingleSurfingRat.GPU_standing_images) - 1:
      SingleSurfingRat.current_rat_image_index = 0
  absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
  distance_between_player_and_rat = find_hypotnuse(abs(absolute_center_of_player_x - (SingleSurfingRat.x_pos - ((1/2)*screen_width) + (278/2))), abs(absolute_center_of_player_y - (SingleSurfingRat.y_pos - ((1/2)*screen_height) + (94/2))))
  #
  if SingleSurfingRat.stage_in_rat_activities == 0: # outside subarea, main sewer area
    if distance_between_player_and_rat <= 400:
      SingleSurfingRat.show_dialogue = True
      SingleSurfingRat.GPU_current_dialogue = SingleSurfingRat.WassupHamsterDudette
      SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_talking_images[SingleSurfingRat.current_rat_image_index]
    else:
      SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_standing_images[SingleSurfingRat.current_rat_image_index]
    return
  #
  if SingleSurfingRat.stage_in_rat_activities == 1: # enter surfing sub area
    if (distance_between_player_and_rat <= 400) and (PLAYER.x_pos <= SingleSurfingRat.x_pos - ((1/2)*screen_width) - 50):
      SingleSurfingRat.current_milliseconds_since_starting_rat_stage += delta_milliseconds
      if 0 <= SingleSurfingRat.current_milliseconds_since_starting_rat_stage <= 2500:
        SingleSurfingRat.show_dialogue = True
        SingleSurfingRat.GPU_current_dialogue = SingleSurfingRat.DoYouSurfBro
        SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_talking_images[SingleSurfingRat.current_rat_image_index]
      if 2500 < SingleSurfingRat.current_milliseconds_since_starting_rat_stage <= 2700:
        SingleSurfingRat.show_dialogue = False
        SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_talking_images[SingleSurfingRat.current_rat_image_index]
      if 2700 < SingleSurfingRat.current_milliseconds_since_starting_rat_stage <= 4700:
        SingleSurfingRat.show_dialogue = True
        SingleSurfingRat.GPU_current_dialogue = SingleSurfingRat.IfSoIdLoveToWatch
        SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_talking_images[SingleSurfingRat.current_rat_image_index]
      if 4700 < SingleSurfingRat.current_milliseconds_since_starting_rat_stage:
        SingleSurfingRat.show_dialogue = False
        SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_talking_images[SingleSurfingRat.current_rat_image_index]
    if PLAYER.on_a_surf_board:
      SingleSurfingRat.stage_in_rat_activities = 2
      My_cached_info.current_surfing_points = 0
      SingleSurfingRat.current_milliseconds_since_starting_rat_stage = 0
      SURFING_CLOCK = SurfingClock()
      SURFING_PROGRESS_BAR = SurfingProgressBar()
      SURFING_CLOCK.is_showing = True
      SURFING_PROGRESS_BAR.is_showing = True
      PLAYER.surfing_check_points = True
    else:
      SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_standing_images[SingleSurfingRat.current_rat_image_index]
    return
  #
  if SingleSurfingRat.stage_in_rat_activities == 2: # challenge is currently happening
    My_cached_info.current_milliseconds_in_surfing_challenge += delta_milliseconds
    SURFING_CLOCK.surfing_clock_hand_rotation = 360 - (360 * (My_cached_info.current_milliseconds_in_surfing_challenge / My_cached_info.milliseconds_needed_to_complete_surfing_challenge))
    SURFING_PROGRESS_BAR.how_filled = SURFING_PROGRESS_BAR.GPU_SURFING_PROGRESS_BAR_INSIDE[0][0] * (My_cached_info.current_surfing_points / My_cached_info.points_needed_to_win_surfing_challenge)
    SURFING_PROGRESS_BAR.fraction_string = str(round(My_cached_info.current_surfing_points)) + '/' + str(My_cached_info.points_needed_to_win_surfing_challenge)
    SURFING_PROGRESS_BAR.number_image_length = 0
    SURFING_PROGRESS_BAR.current_GPU_numbers = []
    for SingleString in SURFING_PROGRESS_BAR.fraction_string:
      SURFING_PROGRESS_BAR.number_image_length += SURFING_PROGRESS_BAR.number_spacing_dict[SingleString]
      SURFING_PROGRESS_BAR.current_GPU_numbers.append(SURFING_PROGRESS_BAR.number_OpenGL_dict[SingleString])
    SURFING_PROGRESS_BAR.progress_bar_spacing_on_each_side = (SURFING_PROGRESS_BAR.GPU_SURFING_PROGRESS_BAR_INSIDE[0][0] - SURFING_PROGRESS_BAR.number_image_length) / 2
    if SURFING_PROGRESS_BAR.how_filled >= SURFING_PROGRESS_BAR.GPU_SURFING_PROGRESS_BAR_INSIDE[0][0]:
      SURFING_PROGRESS_BAR.how_filled = SURFING_PROGRESS_BAR.GPU_SURFING_PROGRESS_BAR_INSIDE[0][0]
    SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_standing_images[SingleSurfingRat.current_rat_image_index]
    if My_cached_info.current_milliseconds_in_surfing_challenge > My_cached_info.milliseconds_needed_to_complete_surfing_challenge:
       My_cached_info.current_milliseconds_in_surfing_challenge = 0
       if My_cached_info.current_surfing_points >= My_cached_info.points_needed_to_win_surfing_challenge:
         SURFING_CLOCK.is_showing = False
         SingleSurfingRat.stage_in_rat_activities = 4
         My_cached_info.current_milliseconds_in_surfing_challenge = 0
         PLAYER.surfing_check_points = False
         return
       if My_cached_info.current_surfing_points < My_cached_info.points_needed_to_win_surfing_challenge:
         SURFING_CLOCK.is_showing = False
         SingleSurfingRat.stage_in_rat_activities = 3
         My_cached_info.current_milliseconds_in_surfing_challenge = 0
         PLAYER.surfing_check_points = False
    return
  #
  if SingleSurfingRat.stage_in_rat_activities == 3: # failed surfing challenge
    SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_standing_images[SingleSurfingRat.current_rat_image_index]
    if (distance_between_player_and_rat <= 400) and (PLAYER.x_pos <= SingleSurfingRat.x_pos - ((1/2)*screen_width) - 50):
      SingleSurfingRat.current_milliseconds_since_starting_rat_stage += delta_milliseconds
      if 0 <= SingleSurfingRat.current_milliseconds_since_starting_rat_stage <= 3000:
        SingleSurfingRat.show_dialogue = True
        SingleSurfingRat.GPU_current_dialogue = SingleSurfingRat.YouWerePrettyCoolOutThere
        SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_talking_images[SingleSurfingRat.current_rat_image_index]
      if 3000 <= SingleSurfingRat.current_milliseconds_since_starting_rat_stage <= 3200:
        SingleSurfingRat.show_dialogue = False
        SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_talking_images[SingleSurfingRat.current_rat_image_index]
      if 3200 <= SingleSurfingRat.current_milliseconds_since_starting_rat_stage <= 6200:
        SingleSurfingRat.show_dialogue = True
        SingleSurfingRat.GPU_current_dialogue = SingleSurfingRat.ButIThinkYouCouldBeBetter
        SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_talking_images[SingleSurfingRat.current_rat_image_index]
      if 6200 <= SingleSurfingRat.current_milliseconds_since_starting_rat_stage <= 6400:
        SingleSurfingRat.show_dialogue = False
        SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_talking_images[SingleSurfingRat.current_rat_image_index]
      if 6400 <= SingleSurfingRat.current_milliseconds_since_starting_rat_stage <= 9400:
        SingleSurfingRat.show_dialogue = True
        SingleSurfingRat.GPU_current_dialogue = SingleSurfingRat.YouShouldComeSurfAgain
        SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_talking_images[SingleSurfingRat.current_rat_image_index]
    if (2000 <= SingleSurfingRat.current_milliseconds_since_starting_rat_stage) and PLAYER.on_a_surf_board:
      SingleSurfingRat.stage_in_rat_activities = 1
      SingleSurfingRat.current_milliseconds_since_starting_rat_stage = 100000
      My_cached_info.current_milliseconds_in_surfing_challenge = 0
    return
  #
  if SingleSurfingRat.stage_in_rat_activities == 4: # won surfing challenge
    SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_standing_images[SingleSurfingRat.current_rat_image_index]
    if (distance_between_player_and_rat <= 400) and (PLAYER.x_pos <= SingleSurfingRat.x_pos - ((1/2)*screen_width) - 50):
      SingleSurfingRat.current_milliseconds_since_starting_rat_stage += delta_milliseconds
      if (UPGRADES != []) or not PLAYER.CollectedUpgrades[10]:
        if 0 <= SingleSurfingRat.current_milliseconds_since_starting_rat_stage <= 3000:
          SingleSurfingRat.show_dialogue = True
          SingleSurfingRat.GPU_current_dialogue = SingleSurfingRat.ThatWasRadicalBro
          SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_talking_images[SingleSurfingRat.current_rat_image_index]
        if 3000 <= SingleSurfingRat.current_milliseconds_since_starting_rat_stage <= 3200:
          SingleSurfingRat.show_dialogue = False
          SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_talking_images[SingleSurfingRat.current_rat_image_index]
        if 3200 <= SingleSurfingRat.current_milliseconds_since_starting_rat_stage <= 6200:
          if SURFING_RAT[0].allow_upgrade_to_spawn == '1':
            UPGRADES = []
          if SURFING_RAT[0].allow_upgrade_to_spawn == '0' and UPGRADES == []:
            my_upgrade11 = Upgrade(x_pos = 5856+((1/2) * screen_width), y_pos = 1808+((1/2) * screen_height), collected = False)
            UPGRADES = [my_upgrade11]
          SingleSurfingRat.show_dialogue = True
          SingleSurfingRat.GPU_current_dialogue = SingleSurfingRat.IWantYouToHaveThis
          SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_talking_images[SingleSurfingRat.current_rat_image_index]
        if 6200 <= SingleSurfingRat.current_milliseconds_since_starting_rat_stage:
          SingleSurfingRat.stage_in_rat_activities = 1
          SingleSurfingRat.current_milliseconds_since_starting_rat_stage = 100000
          My_cached_info.current_milliseconds_in_surfing_challenge = 0
      else:
        if 0 <= SingleSurfingRat.current_milliseconds_since_starting_rat_stage <= 3000:
          SingleSurfingRat.show_dialogue = True
          SingleSurfingRat.GPU_current_dialogue = SingleSurfingRat.ItsAPleasureSeeinYouSurf
          SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_talking_images[SingleSurfingRat.current_rat_image_index]
        if 3000 <= SingleSurfingRat.current_milliseconds_since_starting_rat_stage <= 3200:
          SingleSurfingRat.show_dialogue = False
          SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_talking_images[SingleSurfingRat.current_rat_image_index]
        if 3200 <= SingleSurfingRat.current_milliseconds_since_starting_rat_stage <= 6200:
          SingleSurfingRat.show_dialogue = True
          SingleSurfingRat.GPU_current_dialogue = SingleSurfingRat.ComeBackAgainSometimeDudette
          SingleSurfingRat.GPU_current_rat_image = SingleSurfingRat.GPU_talking_images[SingleSurfingRat.current_rat_image_index]
        if 6200 <= SingleSurfingRat.current_milliseconds_since_starting_rat_stage:
          SingleSurfingRat.stage_in_rat_activities = 1
          SingleSurfingRat.current_milliseconds_since_starting_rat_stage = 100000
          My_cached_info.current_milliseconds_in_surfing_challenge = 0
    return


def update_buckets():
  for SingleBucket in BUCKETS:
    update_bucket(SingleBucket)


def update_bucket(SingleBucket):
  if MAP.region == 'TheDoor12':
    return
  if SingleBucket.stage_in_bucket_movement == 1: # bottom
    MY_VINES[0].y_pos = -10+((1/2) * screen_height)
    MY_VINES[0].y_poss[0] = MY_VINES[0].y_pos
    SingleBucket.x_pos = SingleBucket.bottom_x
    SingleBucket.y_pos = SingleBucket.bottom_y
    SingleBucket.time_since_last_in_bucket += delta_milliseconds
    if (not ON_A_BUCKET and collision_happened) or (SingleBucket.time_since_last_in_bucket > 4000):
      SingleBucket.is_allowed_to_move_again = True
      SingleBucket.time_since_last_in_bucket = 0
    if ON_A_BUCKET and IN_A_BUCKET and SingleBucket.is_allowed_to_move_again:
      SingleBucket.stage_in_bucket_movement = 2
    return
  #
  if SingleBucket.stage_in_bucket_movement == 2: # moving up
    if True:
      if ON_A_BUCKET or (PLAYER.y_pos < (SingleBucket.y_pos - ((1/2)*screen_height)) + SingleBucket.rect[3]):
        SingleBucket.y_pos -= SingleBucket.vel * My_cached_info.target_fps_over_fps
        MY_VINES[0].y_poss[0] -= SingleBucket.vel * My_cached_info.target_fps_over_fps
        if ON_A_BUCKET:
          PLAYER.y_pos -= SingleBucket.vel * My_cached_info.target_fps_over_fps
      else:
        SingleBucket.stage_in_bucket_movement = 4
    if SingleBucket.y_pos <= SingleBucket.top_y:
      SingleBucket.stage_in_bucket_movement = 3
      SingleBucket.is_allowed_to_move_again = False
    if SingleBucket.y_pos >= SingleBucket.bottom_y:
      SingleBucket.stage_in_bucket_movement = 1
      SingleBucket.time_since_last_in_bucket = 0
      SingleBucket.is_allowed_to_move_again = False
    return
  #
  if SingleBucket.stage_in_bucket_movement == 3: # top
    MY_VINES[0].y_pos = -10+((1/2) * screen_height)
    MY_VINES[0].y_poss[0] = MY_VINES[0].y_pos - abs(SingleBucket.bottom_y - SingleBucket.top_y)
    SingleBucket.x_pos = SingleBucket.top_x
    SingleBucket.y_pos = SingleBucket.top_y
    if not ON_A_BUCKET and collision_happened:
      SingleBucket.is_allowed_to_move_again = True
    if (ON_A_BUCKET and IN_A_BUCKET and SingleBucket.is_allowed_to_move_again) or (SingleBucket.y_pos - ((1 / 2) * screen_height) <= PLAYER.y_pos - 500):
      SingleBucket.stage_in_bucket_movement = 4
    return
  #
  if SingleBucket.stage_in_bucket_movement == 4: # moving down
    if 5197 <= PLAYER.x_pos <= 5509 + 68:
      if SingleBucket.y_pos - ((1 / 2) * screen_height) <= PLAYER.y_pos - 400 <= SingleBucket.y_pos - ((1 / 2) * screen_height) + 240:
        if not ON_A_BUCKET:
          return
    SingleBucket.y_pos += SingleBucket.vel * My_cached_info.target_fps_over_fps
    MY_VINES[0].y_poss[0] += SingleBucket.vel * My_cached_info.target_fps_over_fps
    if ON_A_BUCKET:
      PLAYER.y_pos += SingleBucket.vel * My_cached_info.target_fps_over_fps
    if SingleBucket.y_pos >= SingleBucket.bottom_y:
      SingleBucket.stage_in_bucket_movement = 1
      SingleBucket.time_since_last_in_bucket = 0
      SingleBucket.is_allowed_to_move_again = False
    return


def update_foods():
  global FOOD
  for SingleFood in FOOD:
    update_food(SingleFood)
  temp_food = []
  lost_a_food = False
  lost_which_food = 666
  for i in range(len(FOOD)):
    if not FOOD[i].completely_eaten:
      temp_food.append(FOOD[i])
    else:
      lost_a_food = True
      lost_which_food = i
  if lost_which_food != 666:
    if PLAYER.carrying_which_food > lost_which_food:
      PLAYER.carrying_which_food -= 1
  FOOD = temp_food


def update_food(SingleFood):
  global FOOD
  y_accel = 0
  SingleFood.Fy = 0
  if SingleFood.being_eaten:
    SingleFood.x_pos = EATING_RAT[0].x_pos + 260 - (SingleFood.rect[2]/2)
    SingleFood.y_pos = EATING_RAT[0].y_pos + 60 - (SingleFood.rect[3]/2)
    SingleFood.current_milliseconds_since_starting_being_eaten += delta_milliseconds
    if SingleFood.current_milliseconds_since_starting_being_eaten >= SingleFood.milliseconds_to_be_completely_eaten:
      SingleFood.completely_eaten = True
  if not SingleFood.being_carried:
    SingleFood.current_milliseconds_before_being_allowed_to_hold_food_again -= delta_milliseconds
    if WATER_REGIONS != []:
      for i in range(len(WATER_REGIONS)):
        find_water_force_on_food(WATER_REGIONS[i][0], WATER_REGIONS[i][1], WATER_REGIONS[i][2], WATER_REGIONS[i][3], WATER_REGIONS[i][4], WATER_REGIONS[i][5], SingleFood)
    if BUCKETS != []:
      for i in range(len(BUCKETS)):
        find_water_force_on_food(BUCKETS[i].water_region[0] - 15, BUCKETS[i].water_region[1] + 15, BUCKETS[i].water_region[2], BUCKETS[i].water_region[3], 0, 0, SingleFood)
    y_accel += SingleFood.Fy
    SingleFood.current_image = rotate_square_image(SingleFood.image, SingleFood.image_rotation)
    SingleFood.mask = pygame.mask.from_surface(SingleFood.current_image)
    SingleFood_collision_points, SingleFood_collision_happened = find_food_collisions_with_offsets(MAP, SingleFood, -((1/2) * screen_width), -((1/2) * screen_height))
    if SingleFood_collision_happened:
      SingleFood.y_vel = 0
      current_bounding_rect = SingleFood.mask.get_bounding_rects()[0]
      ylist = [y for (x, y) in SingleFood_collision_points]
      #if (current_bounding_rect[1] != min(ylist)) and current_bounding_rect[1] != min(ylist) + 1:
      #if not (min(ylist) <= current_bounding_rect[1] <= min(ylist) + 10):
      if not (current_bounding_rect[1] <= min(ylist) <= current_bounding_rect[1] + 10):
        SingleFood.y_pos -= abs(max(ylist) - min(ylist))
    if not SingleFood_collision_happened:
      y_accel += 400
      SingleFood.y_vel = SingleFood.y_vel + (y_accel * (1 / fps))
      if SingleFood.y_vel > 400:
        SingleFood.y_vel = 400
      if SingleFood.y_vel < -400:
        SingleFood.y_vel = -400
      SingleFood.x_pos = SingleFood.x_pos + (SingleFood.x_vel * (1 / fps))
      SingleFood.y_pos = SingleFood.y_pos + (SingleFood.y_vel * (1 / fps) + ((1 / 2) * y_accel * (1 / fps)**2))


def update_garbage_cans():
  global GARBAGE_CAN
  for SingleGarbageCan in GARBAGE_CAN:
    update_garbage_can(SingleGarbageCan)


def update_garbage_can(SingleGarbageCan):
  absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
  #
  if not SingleGarbageCan.player_is_inside and not SingleGarbageCan.player_is_tentatively_inside:
    if SingleGarbageCan.x_pos + SingleGarbageCan.player_is_tentatively_inside_boundaries[0] <= absolute_center_of_player_x + ((1/2)*screen_width) <= SingleGarbageCan.x_pos + SingleGarbageCan.player_is_tentatively_inside_boundaries[1]:
      if SingleGarbageCan.y_pos + SingleGarbageCan.player_is_tentatively_inside_boundaries[2] <= absolute_center_of_player_y + ((1/2)*screen_height) <= SingleGarbageCan.y_pos + SingleGarbageCan.player_is_tentatively_inside_boundaries[3]:
        SingleGarbageCan_collision_points, SingleGarbageCan_collision_happened = find_collisions_with_offsets(SingleGarbageCan, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
        if not SingleGarbageCan_collision_happened:
          SingleGarbageCan.player_is_tentatively_inside = True
          SingleGarbageCan.player_is_inside = False
          return
    SingleGarbageCan.player_is_tentatively_inside = False
    return
  #
  if SingleGarbageCan.player_is_tentatively_inside and not SingleGarbageCan.player_is_inside:
    if SingleGarbageCan.x_pos + SingleGarbageCan.player_is_inside_boundaries[0] <= absolute_center_of_player_x + ((1/2)*screen_width) <= SingleGarbageCan.x_pos + SingleGarbageCan.player_is_inside_boundaries[1]:
      if SingleGarbageCan.y_pos + SingleGarbageCan.player_is_inside_boundaries[2] <= absolute_center_of_player_y + ((1/2)*screen_height) <= SingleGarbageCan.y_pos + SingleGarbageCan.player_is_inside_boundaries[3]:
        SingleGarbageCan.player_is_tentatively_inside = False
        SingleGarbageCan.player_is_inside = True
        return
    if SingleGarbageCan.x_pos + SingleGarbageCan.player_is_tentatively_inside_boundaries[0] <= absolute_center_of_player_x + ((1/2)*screen_width) <= SingleGarbageCan.x_pos + SingleGarbageCan.player_is_tentatively_inside_boundaries[1]:
      if SingleGarbageCan.y_pos + SingleGarbageCan.player_is_tentatively_inside_boundaries[2] <= absolute_center_of_player_y + ((1/2)*screen_height) <= SingleGarbageCan.y_pos + SingleGarbageCan.player_is_tentatively_inside_boundaries[3]:
        return
    SingleGarbageCan.player_is_tentatively_inside = False
    return
  #
  if not SingleGarbageCan.player_is_tentatively_inside and SingleGarbageCan.player_is_inside:
    if SingleGarbageCan.x_pos + SingleGarbageCan.player_is_tentatively_inside_boundaries[0] <= absolute_center_of_player_x + ((1/2)*screen_width) <= SingleGarbageCan.x_pos + SingleGarbageCan.player_is_tentatively_inside_boundaries[1]:
      if SingleGarbageCan.y_pos + SingleGarbageCan.player_is_tentatively_inside_boundaries[2] <= absolute_center_of_player_y + ((1/2)*screen_height) <= SingleGarbageCan.y_pos + SingleGarbageCan.player_is_tentatively_inside_boundaries[3]:
        SingleGarbageCan.player_is_tentatively_inside = True
        SingleGarbageCan.player_is_inside = False
    return


def update_themachine():
  if THE_MACHINE != []:
    for _ in range(1):
      if ((THE_MACHINE[0].x_pos + 28) <= PLAYER.x_pos + ((1 / 2) * screen_width) <= (THE_MACHINE[0].x_pos + 171 - 68)) and ((THE_MACHINE[0].y_pos + 113) <= PLAYER.y_pos + ((1 / 2) * screen_height) <= (THE_MACHINE[0].y_pos + 260)):
        THE_MACHINE[0].player_in_left_side = True
      else:
        THE_MACHINE[0].player_in_left_side = False
    for _ in range(1):
      if ((THE_MACHINE[0].x_pos + 310) <= PLAYER.x_pos + ((1 / 2) * screen_width) <= (THE_MACHINE[0].x_pos + 453 - 68)) and ((THE_MACHINE[0].y_pos + 113) <= PLAYER.y_pos + ((1 / 2) * screen_height) <= (THE_MACHINE[0].y_pos + 260)):
        THE_MACHINE[0].player_in_right_side = True
      else:
        THE_MACHINE[0].player_in_right_side = False
    #
    if not Currently_pressed_controls.pressed_controls['INTERACT']:
      THE_MACHINE[0].allow_the_player_to_place_another_tool = True
    if Currently_pressed_controls.pressed_controls['INTERACT']:
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      if 2224 <= absolute_center_of_player_x <= 2770:
        if 667 <= absolute_center_of_player_y <= 1018:
          if THE_MACHINE[0].allow_the_player_to_place_another_tool:
            for _ in range(1):
              if PLAYER.collected_screw_driver:
                if not THE_MACHINE[0].repair_screw_driver:
                  THE_MACHINE[0].repair_screw_driver = True
                  THE_MACHINE[0].allow_the_player_to_place_another_tool = False
                  everything_save_data(True, 41, '1')
                  continue
              if PLAYER.collected_wire_cutter:
                if not THE_MACHINE[0].repair_wire_cutter:
                  THE_MACHINE[0].repair_wire_cutter = True
                  THE_MACHINE[0].allow_the_player_to_place_another_tool = False
                  everything_save_data(True, 42, '1')
                  continue
              if PLAYER.collected_wrench:
                if not THE_MACHINE[0].repair_wrench:
                  THE_MACHINE[0].repair_wrench = True
                  THE_MACHINE[0].allow_the_player_to_place_another_tool = False
                  everything_save_data(True, 43, '1')
                  continue
    #
    if THE_MACHINE[0].repair_screw_driver:
      if THE_MACHINE[0].screw_driver_reached_themachine:
        THE_MACHINE[0].milliseconds_since_screw_driver_repair += delta_milliseconds
        if 0 <= THE_MACHINE[0].milliseconds_since_screw_driver_repair <= THE_MACHINE[0].milliseconds_for_smoke_to_appear:
          THE_MACHINE[0].screw_stage = 1
        if THE_MACHINE[0].milliseconds_for_smoke_to_appear < THE_MACHINE[0].milliseconds_since_screw_driver_repair <= THE_MACHINE[0].milliseconds_for_smoke_to_appear + THE_MACHINE[0].milliseconds_for_smoke_to_hangout:
          THE_MACHINE[0].screw_stage = 2
        if THE_MACHINE[0].milliseconds_for_smoke_to_appear + THE_MACHINE[0].milliseconds_for_smoke_to_hangout < THE_MACHINE[0].milliseconds_since_screw_driver_repair <= THE_MACHINE[0].milliseconds_for_smoke_to_appear + THE_MACHINE[0].milliseconds_for_smoke_to_hangout + THE_MACHINE[0].milliseconds_for_smoke_to_disappear:
          THE_MACHINE[0].screw_stage = 3
        if THE_MACHINE[0].milliseconds_for_smoke_to_appear + THE_MACHINE[0].milliseconds_for_smoke_to_hangout + THE_MACHINE[0].milliseconds_for_smoke_to_disappear < THE_MACHINE[0].milliseconds_since_screw_driver_repair:
          THE_MACHINE[0].screw_stage = 4
      else:
        if THE_MACHINE[0].screw_driver_xy == []:
          THE_MACHINE[0].screw_driver_xy = [PLAYER.x_pos + ((1/2)*screen_width), PLAYER.y_pos + ((1/2)*screen_height)]
        current_angle_to_move = math.degrees(math.atan2(THE_MACHINE[0].screw_destination_xy[1] - THE_MACHINE[0].screw_driver_xy[1], THE_MACHINE[0].screw_destination_xy[0] - THE_MACHINE[0].screw_driver_xy[0]))
        THE_MACHINE[0].screw_driver_xy[0] += (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps) * math.cos(math.radians(current_angle_to_move))
        THE_MACHINE[0].screw_driver_xy[1] += (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps) * math.sin(math.radians(current_angle_to_move))
        if (THE_MACHINE[0].screw_destination_xy[0] - (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps)) <= THE_MACHINE[0].screw_driver_xy[0] <= (THE_MACHINE[0].screw_destination_xy[0] + (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps)):
          if (THE_MACHINE[0].screw_destination_xy[1] - (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps)) <= THE_MACHINE[0].screw_driver_xy[1] <= (THE_MACHINE[0].screw_destination_xy[1] + (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps)):
            THE_MACHINE[0].screw_driver_reached_themachine = True
#
    if THE_MACHINE[0].repair_wire_cutter:
      if THE_MACHINE[0].wire_cutter_reached_themachine:
        THE_MACHINE[0].milliseconds_since_wire_cutter_repair += delta_milliseconds
        if 0 <= THE_MACHINE[0].milliseconds_since_wire_cutter_repair <= THE_MACHINE[0].milliseconds_for_smoke_to_appear:
          THE_MACHINE[0].wire_cutter_stage = 1
        if THE_MACHINE[0].milliseconds_for_smoke_to_appear < THE_MACHINE[0].milliseconds_since_wire_cutter_repair <= THE_MACHINE[0].milliseconds_for_smoke_to_appear + THE_MACHINE[0].milliseconds_for_smoke_to_hangout:
          THE_MACHINE[0].wire_cutter_stage = 2
        if THE_MACHINE[0].milliseconds_for_smoke_to_appear + THE_MACHINE[0].milliseconds_for_smoke_to_hangout < THE_MACHINE[0].milliseconds_since_wire_cutter_repair <= THE_MACHINE[0].milliseconds_for_smoke_to_appear + THE_MACHINE[0].milliseconds_for_smoke_to_hangout + THE_MACHINE[0].milliseconds_for_smoke_to_disappear:
          THE_MACHINE[0].wire_cutter_stage = 3
        if THE_MACHINE[0].milliseconds_for_smoke_to_appear + THE_MACHINE[0].milliseconds_for_smoke_to_hangout + THE_MACHINE[0].milliseconds_for_smoke_to_disappear < THE_MACHINE[0].milliseconds_since_wire_cutter_repair:
          THE_MACHINE[0].wire_cutter_stage = 4
      else:
        if THE_MACHINE[0].wire_cutter_xy == []:
          THE_MACHINE[0].wire_cutter_xy = [PLAYER.x_pos + ((1/2)*screen_width), PLAYER.y_pos + ((1/2)*screen_height)]
        current_angle_to_move = math.degrees(math.atan2(THE_MACHINE[0].wire_cutter_destination_xy[1] - THE_MACHINE[0].wire_cutter_xy[1], THE_MACHINE[0].wire_cutter_destination_xy[0] - THE_MACHINE[0].wire_cutter_xy[0]))
        THE_MACHINE[0].wire_cutter_xy[0] += (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps) * math.cos(math.radians(current_angle_to_move))
        THE_MACHINE[0].wire_cutter_xy[1] += (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps) * math.sin(math.radians(current_angle_to_move))
        if (THE_MACHINE[0].wire_cutter_destination_xy[0] - (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps)) <= THE_MACHINE[0].wire_cutter_xy[0] <= (THE_MACHINE[0].wire_cutter_destination_xy[0] + (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps)):
          if (THE_MACHINE[0].wire_cutter_destination_xy[1] - (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps)) <= THE_MACHINE[0].wire_cutter_xy[1] <= (THE_MACHINE[0].wire_cutter_destination_xy[1] + (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps)):
            THE_MACHINE[0].wire_cutter_reached_themachine = True
#
    if THE_MACHINE[0].repair_wrench:
      if THE_MACHINE[0].wrench_reached_themachine:
        THE_MACHINE[0].milliseconds_since_wrench_repair += delta_milliseconds
        if 0 <= THE_MACHINE[0].milliseconds_since_wrench_repair <= THE_MACHINE[0].milliseconds_for_smoke_to_appear:
          THE_MACHINE[0].wrench_stage = 1
        if THE_MACHINE[0].milliseconds_for_smoke_to_appear < THE_MACHINE[0].milliseconds_since_wrench_repair <= THE_MACHINE[0].milliseconds_for_smoke_to_appear + THE_MACHINE[0].milliseconds_for_smoke_to_hangout:
          THE_MACHINE[0].wrench_stage = 2
        if THE_MACHINE[0].milliseconds_for_smoke_to_appear + THE_MACHINE[0].milliseconds_for_smoke_to_hangout < THE_MACHINE[0].milliseconds_since_wrench_repair <= THE_MACHINE[0].milliseconds_for_smoke_to_appear + THE_MACHINE[0].milliseconds_for_smoke_to_hangout + THE_MACHINE[0].milliseconds_for_smoke_to_disappear:
          THE_MACHINE[0].wrench_stage = 3
        if THE_MACHINE[0].milliseconds_for_smoke_to_appear + THE_MACHINE[0].milliseconds_for_smoke_to_hangout + THE_MACHINE[0].milliseconds_for_smoke_to_disappear < THE_MACHINE[0].milliseconds_since_wrench_repair:
          THE_MACHINE[0].wrench_stage = 4
      else:
        if THE_MACHINE[0].wrench_xy == []:
          THE_MACHINE[0].wrench_xy = [PLAYER.x_pos + ((1/2)*screen_width), PLAYER.y_pos + ((1/2)*screen_height)]
        current_angle_to_move = math.degrees(math.atan2(THE_MACHINE[0].wrench_destination_xy[1] - THE_MACHINE[0].wrench_xy[1], THE_MACHINE[0].wrench_destination_xy[0] - THE_MACHINE[0].wrench_xy[0]))
        THE_MACHINE[0].wrench_xy[0] += (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps) * math.cos(math.radians(current_angle_to_move))
        THE_MACHINE[0].wrench_xy[1] += (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps) * math.sin(math.radians(current_angle_to_move))
        if (THE_MACHINE[0].wrench_destination_xy[0] - (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps)) <= THE_MACHINE[0].wrench_xy[0] <= (THE_MACHINE[0].wrench_destination_xy[0] + (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps)):
          if (THE_MACHINE[0].wrench_destination_xy[1] - (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps)) <= THE_MACHINE[0].wrench_xy[1] <= (THE_MACHINE[0].wrench_destination_xy[1] + (THE_MACHINE[0].tool_speed * My_cached_info.target_fps_over_fps)):
            THE_MACHINE[0].wrench_reached_themachine = True
    #
    #
    if not (THE_MACHINE[0].screw_stage > 2) and not (THE_MACHINE[0].wire_cutter_stage > 2) and not (THE_MACHINE[0].wrench_stage > 2):
      THE_MACHINE[0].GPU_current_machine_image = THE_MACHINE[0].GPU_images[0]
    if not (THE_MACHINE[0].screw_stage > 2) and not (THE_MACHINE[0].wire_cutter_stage > 2) and (THE_MACHINE[0].wrench_stage > 2):
      THE_MACHINE[0].GPU_current_machine_image = THE_MACHINE[0].GPU_images[1]
    if not (THE_MACHINE[0].screw_stage > 2) and (THE_MACHINE[0].wire_cutter_stage > 2) and not (THE_MACHINE[0].wrench_stage > 2):
      THE_MACHINE[0].GPU_current_machine_image = THE_MACHINE[0].GPU_images[2]
    if not (THE_MACHINE[0].screw_stage > 2) and (THE_MACHINE[0].wire_cutter_stage > 2) and (THE_MACHINE[0].wrench_stage > 2):
      THE_MACHINE[0].GPU_current_machine_image = THE_MACHINE[0].GPU_images[3]
    if (THE_MACHINE[0].screw_stage > 2) and not (THE_MACHINE[0].wire_cutter_stage > 2) and not (THE_MACHINE[0].wrench_stage > 2):
      THE_MACHINE[0].GPU_current_machine_image = THE_MACHINE[0].GPU_images[4]
    if (THE_MACHINE[0].screw_stage > 2) and not (THE_MACHINE[0].wire_cutter_stage > 2) and (THE_MACHINE[0].wrench_stage > 2):
      THE_MACHINE[0].GPU_current_machine_image = THE_MACHINE[0].GPU_images[5]
    if (THE_MACHINE[0].screw_stage > 2) and (THE_MACHINE[0].wire_cutter_stage > 2) and not (THE_MACHINE[0].wrench_stage > 2):
      THE_MACHINE[0].GPU_current_machine_image = THE_MACHINE[0].GPU_images[6]
    if (THE_MACHINE[0].screw_stage > 2) and (THE_MACHINE[0].wire_cutter_stage > 2) and (THE_MACHINE[0].wrench_stage > 2):
      THE_MACHINE[0].GPU_current_machine_image = THE_MACHINE[0].GPU_images[7]


def HamsterOs_touching_edge(current_bounding_rect):
  which_edge = [False, False, False, False]
  if (HAMSTER_BOX[0].x_pos <= HAMSTER_BOX[0].boundaries[0] + current_bounding_rect[0]):
    which_edge[0] = True
  if (HAMSTER_BOX[0].x_pos >= HAMSTER_BOX[0].boundaries[1] - current_bounding_rect[0] - current_bounding_rect[2]):
    which_edge[1] = True
  if (HAMSTER_BOX[0].y_pos <= HAMSTER_BOX[0].boundaries[2] + current_bounding_rect[1]):
    which_edge[2] = True
  if (HAMSTER_BOX[0].y_pos >= HAMSTER_BOX[0].boundaries[3] - current_bounding_rect[1] - current_bounding_rect[3]):
    which_edge[3] = True
  return which_edge


def update_HamsterOs():
  global BOX_GRABBED_BY_PLAYER
  HAMSTER_BOX[0].rotation %= 360
  HAMSTER_BOX[0].current_milliseconds_before_picking_up_again -= delta_milliseconds
  HAMSTER_BOX[0].current_image = rotate_square_image(HAMSTER_BOX[0].image, HAMSTER_BOX[0].rotation)
  HAMSTER_BOX[0].mask = pygame.mask.from_surface(HAMSTER_BOX[0].current_image)
  current_bounding_rect = HAMSTER_BOX[0].mask.get_bounding_rects()[0]
  touching_which_edge = HamsterOs_touching_edge(current_bounding_rect)
  HAMSTER_BOX[0].touching_which_edges = touching_which_edge
  for _ in range(1):
    if not BOX_GRABBED_BY_PLAYER:
      if ((HAMSTER_BOX[0].x_pos + 80) <= HAMSTER_BOX[0].boundaries_to_be_placed_in_machine[0]) or ((HAMSTER_BOX[0].x_pos) >= HAMSTER_BOX[0].boundaries_to_be_placed_in_machine[1]):
        HAMSTER_BOX[0].in_themachine = False
      else:
        HAMSTER_BOX[0].in_themachine = True
    else:
      HAMSTER_BOX[0].in_themachine = False
  if HAMSTER_BOX[0].in_themachine:
    HAMSTER_BOX[0].x_pos = HAMSTER_BOX[0].machine_x_pos
    HAMSTER_BOX[0].y_pos = HAMSTER_BOX[0].machine_y_pos
    HAMSTER_BOX[0].rotation = 0
    return
  if touching_which_edge[0]:
    HAMSTER_BOX[0].x_pos += 2 * My_cached_info.target_fps_over_fps
    if BOX_GRABBED_BY_PLAYER:
      HAMSTER_BOX[0].current_milliseconds_before_picking_up_again = HAMSTER_BOX[0].milliseconds_before_picking_up_again
      my_piston2.grapple_claw_x_pos = 0
      my_piston2.grapple_claw_y_pos = 0
    BOX_GRABBED_BY_PLAYER = False
    HUMAN[0].moving_toward_HamsterOs = True
    HUMAN[0].following_hamster = False
    HAMSTER_BOX[0].held_by_player = False
    HAMSTER_BOX[0].held_by_human = False
  if touching_which_edge[1]:
    HAMSTER_BOX[0].x_pos -= 2 * My_cached_info.target_fps_over_fps
    if BOX_GRABBED_BY_PLAYER:
      HAMSTER_BOX[0].current_milliseconds_before_picking_up_again = HAMSTER_BOX[0].milliseconds_before_picking_up_again
      my_piston2.grapple_claw_x_pos = 0
      my_piston2.grapple_claw_y_pos = 0
    BOX_GRABBED_BY_PLAYER = False
    HUMAN[0].moving_toward_HamsterOs = True
    HUMAN[0].following_hamster = False
    HAMSTER_BOX[0].held_by_player = False
    HAMSTER_BOX[0].held_by_human = False
  if touching_which_edge[2]:
    HAMSTER_BOX[0].y_pos += 2 * My_cached_info.target_fps_over_fps
    if BOX_GRABBED_BY_PLAYER:
      HAMSTER_BOX[0].current_milliseconds_before_picking_up_again = HAMSTER_BOX[0].milliseconds_before_picking_up_again
      my_piston2.grapple_claw_x_pos = 0
      my_piston2.grapple_claw_y_pos = 0
    BOX_GRABBED_BY_PLAYER = False
    HUMAN[0].moving_toward_HamsterOs = True
    HUMAN[0].following_hamster = False
    HAMSTER_BOX[0].held_by_player = False
    HAMSTER_BOX[0].held_by_human = False
  if (PLAYER.y_pos + ((1 / 2) * screen_height) >= HAMSTER_BOX[0].boundaries[3]):
    if BOX_GRABBED_BY_PLAYER:
      HAMSTER_BOX[0].current_milliseconds_before_picking_up_again = HAMSTER_BOX[0].milliseconds_before_picking_up_again
      my_piston2.grapple_claw_x_pos = 0
      my_piston2.grapple_claw_y_pos = 0
    BOX_GRABBED_BY_PLAYER = False
  HAMSTER_BOX[0].held_by_player = BOX_GRABBED_BY_PLAYER
  #
  if not HAMSTER_BOX[0].held_by_player and not HAMSTER_BOX[0].held_by_human:
    y_accel = 0
    orig_x_pos = HAMSTER_BOX[0].x_pos
    orig_y_pos = HAMSTER_BOX[0].y_pos
    y_accel += 400
    HAMSTER_BOX[0].y_vel = HAMSTER_BOX[0].y_vel + (y_accel * (1 / fps))
    if HAMSTER_BOX[0].y_vel > 400:
      HAMSTER_BOX[0].y_vel = 400
    if HAMSTER_BOX[0].y_vel < -400:
      HAMSTER_BOX[0].y_vel = -400
    HAMSTER_BOX[0].x_pos = HAMSTER_BOX[0].x_pos + (HAMSTER_BOX[0].x_vel * (1 / fps))
    HAMSTER_BOX[0].y_pos = HAMSTER_BOX[0].y_pos + (HAMSTER_BOX[0].y_vel * (1 / fps) + ((1 / 2) * y_accel * (1 / fps)**2))
    if touching_which_edge[3]:
      HAMSTER_BOX[0].y_pos = HAMSTER_BOX[0].boundaries[3] - current_bounding_rect[1] - current_bounding_rect[3]
      if (HAMSTER_BOX[0].rotation != HAMSTER_BOX[0].allowable_angles[0]) and (HAMSTER_BOX[0].rotation != HAMSTER_BOX[0].allowable_angles[1]) and (HAMSTER_BOX[0].rotation != HAMSTER_BOX[0].allowable_angles[2]) and (HAMSTER_BOX[0].rotation != HAMSTER_BOX[0].allowable_angles[3]):
        for _ in range(1):
          if HAMSTER_BOX[0].angles[0] <= HAMSTER_BOX[0].rotation <= HAMSTER_BOX[0].angles[1]:
            if HAMSTER_BOX[0].rotation < 90:
              HAMSTER_BOX[0].rotation += 5 * My_cached_info.target_fps_over_fps
            if HAMSTER_BOX[0].rotation > 90:
              HAMSTER_BOX[0].rotation -= 5 * My_cached_info.target_fps_over_fps
            if 85 <= HAMSTER_BOX[0].rotation <= 95:
              HAMSTER_BOX[0].rotation = 90
            continue
          if HAMSTER_BOX[0].angles[1] <= HAMSTER_BOX[0].rotation <= HAMSTER_BOX[0].angles[2]:
            if HAMSTER_BOX[0].rotation < 180:
              HAMSTER_BOX[0].rotation += 5 * My_cached_info.target_fps_over_fps
            if HAMSTER_BOX[0].rotation > 180:
              HAMSTER_BOX[0].rotation -= 5 * My_cached_info.target_fps_over_fps
            if 175 <= HAMSTER_BOX[0].rotation <= 185:
              HAMSTER_BOX[0].rotation = 180
            continue
          if HAMSTER_BOX[0].angles[2] <= HAMSTER_BOX[0].rotation <= HAMSTER_BOX[0].angles[3]:
            if HAMSTER_BOX[0].rotation < 270:
              HAMSTER_BOX[0].rotation += 5 * My_cached_info.target_fps_over_fps
            if HAMSTER_BOX[0].rotation > 270:
              HAMSTER_BOX[0].rotation -= 5 * My_cached_info.target_fps_over_fps
            if 265 <= HAMSTER_BOX[0].rotation <= 275:
              HAMSTER_BOX[0].rotation = 270
            continue
          if (HAMSTER_BOX[0].angles[3] <= HAMSTER_BOX[0].rotation <= 360) or (0 <= HAMSTER_BOX[0].rotation <= HAMSTER_BOX[0].angles[0]):
            if (HAMSTER_BOX[0].angles[3] <= HAMSTER_BOX[0].rotation <= 360):
              HAMSTER_BOX[0].rotation += 5 * My_cached_info.target_fps_over_fps
            if (0 <= HAMSTER_BOX[0].rotation <= HAMSTER_BOX[0].angles[0]):
              HAMSTER_BOX[0].rotation -= 5 * My_cached_info.target_fps_over_fps
            HAMSTER_BOX[0].rotation %= 360
            if (355 <= HAMSTER_BOX[0].rotation <= 360) or (0 <= HAMSTER_BOX[0].rotation <= 5):
              HAMSTER_BOX[0].rotation = 0
            continue


def update_Human():
  #
  absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
  distance_between_player_and_human = find_hypotnuse(abs(absolute_center_of_player_x - (HUMAN[0].x_pos - ((1/2)*screen_width) + (HUMAN[0].rect[2]/2))), abs(absolute_center_of_player_y - (HUMAN[0].y_pos - ((1/2)*screen_height) + (HUMAN[0].rect[3]/2))))
  human_stepping_distance_multiplier = ((900 - distance_between_player_and_human) / 900)
  if human_stepping_distance_multiplier > 1:
    human_stepping_distance_multiplier = 1
  if human_stepping_distance_multiplier < 0:
    human_stepping_distance_multiplier = 0
  walking_loudness = My_cached_info.current_sound_loudness * MixerSoundsLoudness['HUMAN_STEP'] * human_stepping_distance_multiplier
  MixerSounds['HUMAN_STEP'].set_volume(walking_loudness)
  if HUMAN[0].moving_toward_HamsterOs:
    HUMAN[0].y_pos = HUMAN[0].orig_y_pos
    HUMAN[0].current_milliseconds_walking += delta_milliseconds
    if HUMAN[0].current_milliseconds_walking >= HUMAN[0].milliseconds_next_walking:
      HUMAN[0].current_milliseconds_walking %= HUMAN[0].milliseconds_next_walking
      HUMAN[0].walking_index += 1
      if HUMAN[0].walking_index >= len(HUMAN[0].GPU_WALKING):
        HUMAN[0].walking_index = 0
      if HUMAN[0].walking_index == 1 or HUMAN[0].walking_index == 4:
        MixerSounds['HUMAN_STEP'].play()
    if HUMAN[0].x_pos < HAMSTER_BOX[0].x_pos:
      HUMAN[0].x_pos += 1.2 * My_cached_info.target_fps_over_fps
      HUMAN[0].flipped = False
    if HUMAN[0].x_pos > HAMSTER_BOX[0].x_pos:
      HUMAN[0].x_pos -= 1.2 * My_cached_info.target_fps_over_fps
      HUMAN[0].flipped = True
    if (HAMSTER_BOX[0].x_pos - 4 <= HUMAN[0].x_pos <= HAMSTER_BOX[0].x_pos + 4):
      HUMAN[0].eating_HamsterOs = True
      HUMAN[0].moving_toward_HamsterOs = False
      HAMSTER_BOX[0].held_by_human = True
      if HAMSTER_BOX[0].in_themachine:
        HUMAN[0].eating_HamsterOs = False
        HUMAN[0].in_themachine = True
    HUMAN[0].GPU_current_image = HUMAN[0].GPU_WALKING[HUMAN[0].walking_index]
    return
  #
  if HUMAN[0].eating_HamsterOs:
    orig_human_eating_index = HUMAN[0].eating_index
    HUMAN[0].y_pos = HUMAN[0].orig_y_pos
    HUMAN[0].current_milliseconds_eating += delta_milliseconds
    if HUMAN[0].current_milliseconds_eating >= HUMAN[0].milliseconds_next_eating:
      HUMAN[0].current_milliseconds_eating %= HUMAN[0].milliseconds_next_eating
      HUMAN[0].eating_index += 1
      if HUMAN[0].eating_index >= len(HUMAN[0].GPU_EATING):
        HUMAN[0].eating_index = 0
    if HUMAN[0].eating_index == 2 and orig_human_eating_index == 1:
      if distance_between_player_and_human < 500:
        for _ in range(1):
          volume_multiplier = ((500 - distance_between_player_and_human) / 500)
          if volume_multiplier < 0:
            volume_multiplier = 0
            continue
          if volume_multiplier > 1:
            volume_multiplier = 1
        MixerSounds['HAMSTEROS_CRUNCH'].set_volume(My_cached_info.current_sound_loudness * MixerSoundsLoudness['HAMSTEROS_CRUNCH'] * volume_multiplier)
        MixerSounds['HAMSTEROS_CRUNCH'].play()
    HUMAN[0].GPU_current_image = HUMAN[0].GPU_EATING[HUMAN[0].eating_index]
    return
  #
  if HUMAN[0].following_hamster:
    changed_index_this_frame = False
    HUMAN[0].y_pos = HUMAN[0].orig_y_pos
    show_walk_animation = False
    HUMAN[0].current_milliseconds_walking += delta_milliseconds
    if HUMAN[0].current_milliseconds_walking >= HUMAN[0].milliseconds_next_walking:
      HUMAN[0].current_milliseconds_walking %= HUMAN[0].milliseconds_next_walking
      HUMAN[0].walking_index += 1
      if HUMAN[0].walking_index >= len(HUMAN[0].GPU_WALKING):
        HUMAN[0].walking_index = 0
      changed_index_this_frame = True
    HUMAN[0].current_milliseconds_standing += delta_milliseconds
    if HUMAN[0].current_milliseconds_standing >= HUMAN[0].milliseconds_next_standing:
      HUMAN[0].current_milliseconds_standing %= HUMAN[0].milliseconds_next_standing
      HUMAN[0].standing_index += 1
      if HUMAN[0].standing_index >= len(HUMAN[0].GPU_STANDING):
        HUMAN[0].standing_index = 0
    if ((HUMAN[0].x_pos + 115) < HAMSTER_BOX[0].x_pos):
      HUMAN[0].x_pos += 1.2 * My_cached_info.target_fps_over_fps
      HUMAN[0].flipped = False
      show_walk_animation = True
    if (HUMAN[0].x_pos > (HAMSTER_BOX[0].x_pos + 80)):
      HUMAN[0].x_pos -= 1.2 * My_cached_info.target_fps_over_fps
      HUMAN[0].flipped = True
      show_walk_animation = True
    if show_walk_animation:
      HUMAN[0].GPU_current_image = HUMAN[0].GPU_WALKING[HUMAN[0].walking_index]
      if HUMAN[0].walking_index == 1 or HUMAN[0].walking_index == 4:
        if changed_index_this_frame:
          MixerSounds['HUMAN_STEP'].play()
    if not show_walk_animation:
      HUMAN[0].GPU_current_image = HUMAN[0].GPU_STANDING[HUMAN[0].standing_index]
    return
  #
  if HUMAN[0].in_themachine:
    orig_human_eating_index = HUMAN[0].eating_index
    HUMAN[0].x_pos = HUMAN[0].machine_x_pos
    HUMAN[0].y_pos = HUMAN[0].machine_y_pos
    HUMAN[0].flipped = True
    HUMAN[0].current_milliseconds_eating += delta_milliseconds
    if HUMAN[0].current_milliseconds_eating >= HUMAN[0].milliseconds_next_eating:
      HUMAN[0].current_milliseconds_eating %= HUMAN[0].milliseconds_next_eating
      HUMAN[0].eating_index += 1
      if HUMAN[0].eating_index >= len(HUMAN[0].GPU_EATING):
        HUMAN[0].eating_index = 0
    if HUMAN[0].eating_index == 2 and orig_human_eating_index == 1:
      if distance_between_player_and_human < 500:
        for _ in range(1):
          volume_multiplier = ((500 - distance_between_player_and_human) / 500)
          if volume_multiplier < 0:
            volume_multiplier = 0
            continue
          if volume_multiplier > 1:
            volume_multiplier = 1
        MixerSounds['HAMSTEROS_CRUNCH'].set_volume(My_cached_info.current_sound_loudness * MixerSoundsLoudness['HAMSTEROS_CRUNCH'] * volume_multiplier)
        MixerSounds['HAMSTEROS_CRUNCH'].play()
    HUMAN[0].GPU_current_image = HUMAN[0].GPU_EATING[HUMAN[0].eating_index]
    return


def update_sublevel_difficulties():
  current_index = 0
  for SingleSublLevelDifficulty in SUB_LEVEL_DIFFICULTIES:
    update_single_sublevel_difficulty(SingleSublLevelDifficulty, current_index)
    current_index += 1


def update_single_sublevel_difficulty(SingleSublLevelDifficulty, current_index):
  distance_between_player_and_sublevel_difficulty = find_hypotnuse(PLAYER.x_pos + 34 - SingleSublLevelDifficulty.center_of_door_x + ((1/2)*screen_width), PLAYER.y_pos + 34 - SingleSublLevelDifficulty.center_of_door_y + ((1/2)*screen_height))
  if distance_between_player_and_sublevel_difficulty < 65:
    #
    if not SingleSublLevelDifficulty.player_has_been_close_before:
      SingleSublLevelDifficulty.player_has_been_close_before = True
      if MAP.region == 'Forest':
        if current_index == 0:
          everything_save_data(True, 69, '1')
        if current_index == 1:
          everything_save_data(True, 70, '1')
        if current_index == 2:
          everything_save_data(True, 71, '1')
        if current_index == 3:
          everything_save_data(True, 72, '1')
        if current_index == 4:
          everything_save_data(True, 73, '1')
      if MAP.region == 'AntHill':
        if current_index == 0:
          everything_save_data(True, 74, '1')
        if current_index == 1:
          everything_save_data(True, 75, '1')
        if current_index == 2:
          everything_save_data(True, 76, '1')
      if MAP.region == 'Sewer':
        if current_index == 0:
          everything_save_data(True, 77, '1')
        if current_index == 1:
          everything_save_data(True, 78, '1')
        if current_index == 2:
          everything_save_data(True, 79, '1')
      if MAP.region == 'Town':
        if current_index == 0:
          everything_save_data(True, 80, '1')
    #
    if MAP.region == 'Town':
      if not (GARBAGE_CAN[0].player_is_tentatively_inside or GARBAGE_CAN[0].player_is_inside):
        return
    if not SingleSublLevelDifficulty.player_is_close:
      SingleSublLevelDifficulty.milliseconds_player_started_being_close = curr_time
      SingleSublLevelDifficulty.player_is_close = True
      if 0 <= SingleSublLevelDifficulty.millisecond_counter <= SingleSublLevelDifficulty.milliseconds_to_completion:
        SingleSublLevelDifficulty.millisecond_counter = SingleSublLevelDifficulty.milliseconds_to_completion - SingleSublLevelDifficulty.millisecond_counter
      else:
        SingleSublLevelDifficulty.millisecond_counter = 0
    if SingleSublLevelDifficulty.millisecond_counter == 0:
      if MAP.region == 'Forest':
        if current_index == 0:
          multiple_everything_save_data(True, ['TheDoor1', str(PLAYER.x_vel), str(PLAYER.y_vel), 'Forest', '0', '0', str(PLAYER.x_pos), str(PLAYER.y_pos)], [59, 60, 61, 62, 63, 64, 65, 66])
        if current_index == 1:
          multiple_everything_save_data(True, ['TheDoor2', str(PLAYER.x_vel), str(PLAYER.y_vel), 'Forest', '0', '0', str(PLAYER.x_pos), str(PLAYER.y_pos)], [59, 60, 61, 62, 63, 64, 65, 66])
        if current_index == 2:
          multiple_everything_save_data(True, ['TheDoor3', str(PLAYER.x_vel), str(PLAYER.y_vel), 'Forest', '0', '0', str(PLAYER.x_pos), str(PLAYER.y_pos)], [59, 60, 61, 62, 63, 64, 65, 66])
        if current_index == 3:
          multiple_everything_save_data(True, ['TheDoor4', str(PLAYER.x_vel), str(PLAYER.y_vel), 'Forest', '0', '0', str(PLAYER.x_pos), str(PLAYER.y_pos)], [59, 60, 61, 62, 63, 64, 65, 66])
        if current_index == 4:
          multiple_everything_save_data(True, ['TheDoor5', str(PLAYER.x_vel), str(PLAYER.y_vel), 'Forest', '0', '0', str(PLAYER.x_pos), str(PLAYER.y_pos)], [59, 60, 61, 62, 63, 64, 65, 66])
      if MAP.region == 'AntHill':
        if current_index == 0:
          multiple_everything_save_data(True, ['TheDoor7', str(PLAYER.x_vel), str(PLAYER.y_vel), 'AntHill', '0', '0', str(PLAYER.x_pos), str(PLAYER.y_pos)], [59, 60, 61, 62, 63, 64, 65, 66])
        if current_index == 1:
          multiple_everything_save_data(True, ['TheDoor8', str(PLAYER.x_vel), str(PLAYER.y_vel), 'AntHill', '0', '0', str(PLAYER.x_pos), str(PLAYER.y_pos)], [59, 60, 61, 62, 63, 64, 65, 66])
        if current_index == 2:
          multiple_everything_save_data(True, ['TheDoor9', str(PLAYER.x_vel), str(PLAYER.y_vel), 'AntHill', '0', '0', str(PLAYER.x_pos), str(PLAYER.y_pos)], [59, 60, 61, 62, 63, 64, 65, 66])
      if MAP.region == 'Sewer':
        if current_index == 0:
          multiple_everything_save_data(True, ['TheDoor10', str(PLAYER.x_vel), str(PLAYER.y_vel), 'Sewer', '0', '0', str(PLAYER.x_pos), str(PLAYER.y_pos)], [59, 60, 61, 62, 63, 64, 65, 66])
        if current_index == 1:
          multiple_everything_save_data(True, ['TheDoor11', str(PLAYER.x_vel), str(PLAYER.y_vel), 'Sewer', '0', '0', str(PLAYER.x_pos), str(PLAYER.y_pos)], [59, 60, 61, 62, 63, 64, 65, 66])
        if current_index == 2:
          multiple_everything_save_data(True, ['TheDoor12', str(PLAYER.x_vel), str(PLAYER.y_vel), 'Sewer', '0', '0', str(PLAYER.x_pos), str(PLAYER.y_pos)], [59, 60, 61, 62, 63, 64, 65, 66])
      if MAP.region == 'Town':
        if current_index == 0:
          multiple_everything_save_data(True, ['TheDoor13', str(PLAYER.x_vel), str(PLAYER.y_vel), 'Town', '0', '0', str(PLAYER.x_pos), str(PLAYER.y_pos)], [59, 60, 61, 62, 63, 64, 65, 66])
    SingleSublLevelDifficulty.millisecond_counter += delta_milliseconds
  #
  else:
    if SingleSublLevelDifficulty.player_is_close:
      SingleSublLevelDifficulty.milliseconds_player_stopped_being_close = curr_time
      SingleSublLevelDifficulty.player_is_close = False
      if 0 <= SingleSublLevelDifficulty.millisecond_counter <= SingleSublLevelDifficulty.milliseconds_to_completion:
        SingleSublLevelDifficulty.millisecond_counter = SingleSublLevelDifficulty.milliseconds_to_completion - SingleSublLevelDifficulty.millisecond_counter
      else:
        SingleSublLevelDifficulty.millisecond_counter = 0
    SingleSublLevelDifficulty.millisecond_counter += delta_milliseconds


def update_trash():
  for SingleTrash in TRASH:
    update_single_trash(SingleTrash)


def update_single_trash(SingleTrash):
  if not PLAYER.has_piston1:
    if PLAYER.x_pos > 4222:
      PLAYER.FNx -= 4500
  if not SingleTrash.trash_has_been_collected:
    distance_between_player_and_trash = find_hypotnuse(PLAYER.x_pos + 34 - SingleTrash.x_pos + ((1/2)*screen_width) - ((1 / 2) * SingleTrash.GPU_trash_image[0][0]), PLAYER.y_pos + 34 - SingleTrash.y_pos + ((1/2)*screen_height) - ((1 / 2) * SingleTrash.GPU_trash_image[0][1]))
    if distance_between_player_and_trash <= 90:
      SingleTrash.player_is_close_enough_to_collect = True
      if Currently_pressed_controls.pressed_controls['INTERACT']:
        SingleTrash.trash_has_been_collected = True
        if SingleTrash.which_index == 0:
          SUB_LEVEL_DIFFICULTIES[1].allowed_to_display = False
          PLAYER.has_piston1 = True
          everything_save_data(True, 50, '1')
          PLAYER.dialogue_millisecond_counter = 0
          PLAYER.which_dialogue = 4
          PLAYER.intro_data[3] = 1
          total_collected_upgrades = 0
          for SingleUpgradeCollected in PLAYER.CollectedUpgrades:
            if SingleUpgradeCollected:
              total_collected_upgrades += 1
          my_piston1.maximum_extension = maximum_piston_length_dict[str(total_collected_upgrades)]
          my_piston2.maximum_extension = maximum_piston_length_dict[str(total_collected_upgrades)]
        if SingleTrash.which_index == 1:
          SUB_LEVEL_DIFFICULTIES[2].allowed_to_display = False
          PLAYER.has_piston2 = True
          everything_save_data(True, 51, '1')
          PLAYER.dialogue_millisecond_counter = 0
          PLAYER.which_dialogue = 5
          PLAYER.intro_data[4] = 1
          total_collected_upgrades = 0
          for SingleUpgradeCollected in PLAYER.CollectedUpgrades:
            if SingleUpgradeCollected:
              total_collected_upgrades += 1
          my_piston1.maximum_extension = maximum_piston_length_dict[str(total_collected_upgrades)]
          my_piston2.maximum_extension = maximum_piston_length_dict[str(total_collected_upgrades)]
    #
    else:
      SingleTrash.player_is_close_enough_to_collect = False


 ############
### EVENTS ###
 ############


def check_events():
  update_vines()
  if PLAYER.region == 'Forest':
    for _ in range(My_cached_info.whole_number_of_frames_this_frame):
      update_Hawk()
  if PLAYER.region != 'TheDoor4':
    update_ants()
  if PLAYER.region == 'TheDoor4':
    update_football_ants()
  if PLAYER.region == 'AntHill':
    update_QueenAnt()
  if BEETLE_FRIEND != []:
    for _ in range(My_cached_info.whole_number_of_frames_this_frame):
      update_Beetle()
  if MAP.region != 'TheDoor7':
    if ELEVATORS != []:
      for _ in range(My_cached_info.whole_number_of_frames_this_frame):
        update_elevators()
  if MAP.region == 'TheDoor7':
    for _ in range(My_cached_info.whole_number_of_frames_this_frame):
      update_big_elevator(ELEVATORS[0])
  if MAP.region == 'TheDoor10' or MAP.region == 'Sewer':
    update_grates()
  update_keys()
  for _ in range(My_cached_info.whole_number_of_frames_this_frame):
    update_MovingBouncies()
    update_leaves()
    open_doors()
  update_PlayerMoverAnts()
  update_squirrels()
  update_upgrades()
  update_tools()
  update_roots()
  update_dripdrops()
  update_spinny_objects()
  update_sewer_pump_water()
  update_leaks()
  update_water_surfaces()
  update_levers()
  update_propellers()
  update_goldfishes()
  update_transport_pipes()
  update_surf_boards()
  update_surfing_rat()
  update_eating_rat()
  if MAP.region == 'TheDoor12':
    update_waves()
  update_buckets()
  update_foods()
  update_garbage_cans()
  update_themachine()
  if HAMSTER_BOX != []:
    update_Human()
    update_HamsterOs()
  update_sublevel_difficulties()
  update_trash()


def update_surfing_points():
  points_before_update = My_cached_info.current_surfing_points
  PLAYER.milliseconds_since_last_adding_points += delta_milliseconds
  point_multiplier = 1.6
  if PLAYER.surfing_wipeout:
    PLAYER.surfing_wipeout = False
    My_cached_info.current_surfing_points -= 100
  if PLAYER.surfing_catch_the_board and PLAYER.on_a_surf_board:
    PLAYER.surfing_catch_the_board = False
    if PLAYER.allow_catch_the_board_points:
      if PLAYER.time_since_leaving_board > 800:
        My_cached_info.current_surfing_points += (PLAYER.time_since_leaving_board / 20) * point_multiplier
    PLAYER.time_since_leaving_board = 0
  if PLAYER.surfing_spin_checkpoints[0] and PLAYER.surfing_spin_checkpoints[1] and PLAYER.surfing_spin_checkpoints[2] and PLAYER.surfing_spin_checkpoints[3] and PLAYER.on_a_surf_board:
    PLAYER.surfing_spin_checkpoints = [False, False, False, False]
    My_cached_info.current_surfing_points += 15 * point_multiplier
  if PLAYER.surfing_riding_wave and PLAYER.on_a_surf_board:
    PLAYER.surfing_riding_wave = False
    My_cached_info.current_surfing_points += (0.1 * PLAYER.wave_size_multiplier * My_cached_info.target_fps_over_fps) * point_multiplier
  if PLAYER.surfing_going_really_high and PLAYER.on_a_surf_board:
    PLAYER.surfing_going_really_high = False
    My_cached_info.current_surfing_points += PLAYER.surfing_high_points_to_add * 0.15 * point_multiplier
    PLAYER.surfing_high_points_to_add = 0
  #
  if My_cached_info.current_surfing_points < 0:
    My_cached_info.current_surfing_points = 0
  #
  points_after_update = My_cached_info.current_surfing_points
  if points_after_update != points_before_update:
    if PLAYER.milliseconds_since_last_adding_points >= PLAYER.milliseconds_allowed_before_making_a_new_number:
      point_change_str = str(round(points_after_update - points_before_update, 1))
      NUMBERS_ABOVE_HAMSTER.append(NumbersAboveHamster(point_change_str))
    else:
      point_change_str = str(points_after_update - points_before_update)
      if NUMBERS_ABOVE_HAMSTER == []:
        NUMBERS_ABOVE_HAMSTER.append(NumbersAboveHamster(point_change_str))
        return
      NUMBERS_ABOVE_HAMSTER[-1].running_tot_float = NUMBERS_ABOVE_HAMSTER[-1].running_tot_float + float(point_change_str)
      NUMBERS_ABOVE_HAMSTER[-1].number_string = str(round(NUMBERS_ABOVE_HAMSTER[-1].running_tot_float, 1))
      NUMBERS_ABOVE_HAMSTER[-1].current_GPU_numbers = []
      NUMBERS_ABOVE_HAMSTER[-1].length_of_all_symbols = 0
      NUMBERS_ABOVE_HAMSTER[-1].current_milliseconds_before_expiry = 0
      for SingleSymbol in NUMBERS_ABOVE_HAMSTER[-1].number_string:
        NUMBERS_ABOVE_HAMSTER[-1].current_GPU_numbers.append(NUMBERS_ABOVE_HAMSTER[-1].number_OpenGL_dict[SingleSymbol])
        NUMBERS_ABOVE_HAMSTER[-1].length_of_all_symbols += NUMBERS_ABOVE_HAMSTER[-1].number_spacing_dict[SingleSymbol]
    PLAYER.milliseconds_since_last_adding_points = 0


def update_scrolling_at_edges(cur_map):
  stop_scrolling_left   = (screen_width / 2)
  stop_scrolling_right  = (cur_map.rect[2] - (screen_width / 2))
  stop_scrolling_top    = (screen_height / 2)
  stop_scrolling_bottom = (cur_map.rect[3] - (screen_height / 2))
  return stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom


all_maps_dict = {'MAP12': (0, 0, [[0, 1000, 5500, 6000]], [['Forest']], [1], 'MAP12', False, [], [], 'MAP12'),
                 'Forest': (0, 0, [[9110-20, 9110+85-69+20, 4860-20, 4860+85-69+20], [11608-20, 11608+85-69+20, 927-20, 927+85-69+20],[5952-20, 5952+85-69+20, 4843-20, 4843+85-69+20], [2592-20, 2592+85-69+20, 212-20, 212+85-69+20], [7110-20, 7110+85-69+20, 3355-20, 3355+85-69+20]], [['TheDoor1'], ['TheDoor2'], ['TheDoor4'], ['TheDoor5'], ['TheDoor3']], [1, 1, 1, 1, 1], 'Forest', True, [[2027, 2296, 5921, 6000], [6229, 6442, 5921, 6000], [11900, 12000, 0, 4244]], [['AntHill', 666], ['AntHill', 666], ['Town', 666]], 'FOREST'),
                 'TheDoor1': (0, 0, [[80-20, 80+85-69+20, 4315-20, 4315+85-69+20]], [['Forest']], [3], 'TheDoor1', False, [], [], 'THE_DOOR1'),
                 'TheDoor2': (0, 0, [[251-20, 251+85-69+20, 1887-20, 1887+85-69+20]], [['Forest']], [2], 'TheDoor2', False, [], [], 'THE_DOOR2'),
                 'TheDoor3': (0, 0, [[880-20, 880+85-69+20, 4240+3500-20, 4240+3500+85-69+20]], [['Forest']], [6], 'TheDoor3', False, [], [], 'THE_DOOR3'),
                 'TheDoor4': (0, 0, [[1328-20, 1328+85-69+20, 4841-20, 4841+85-69+20]], [['Forest']], [4], 'TheDoor4', False, [], [], 'THE_DOOR4'),
                 'TheDoor5': (0, 0, [[2592-20, 2592+85-69+20, 6078-20, 6078+85-69+20]], [['Forest']], [5], 'TheDoor5', True, [[0, 5021+69, 6161, 6240]], [['TheDoor5', 666]], 'THE_DOOR5'),
                 'AntHill': (0, 0, [[4881-20, 4881+85-69+20, 1409-20, 1409+85-69+20], [963-20, 963+85-69+20, 849-20, 849+85-69+20], [3530-20, 3530+85-69+20, 2285-20, 2285+85-69+20]], [['TheDoor7'], ['TheDoor8'], ['TheDoor9']], [1, 1, 1], 'AntHill', True, [[922.6, 922.7, 5717.4, 5717.5], [6229, 6421, 0, 125], [11952-40, 12000, 2657, 3024], [2080, 2467, 0, 28]], [['TheDoor6'], ['Forest'], ['Sewer'], ['Forest']], 'ANTHILL'),
                 'TheDoor6': (0, 0, [], [], [], 'TheDoor6', True, [[0, 10069, 3458, 4069], [0,0,0,0], [0,0,0,0], [0, 48, 0, 4000]], [['TheDoor6', 666], [''], [''], ['AntHill', 666]], 'THE_DOOR6'),
                 'TheDoor7': (0, 0, [[638-20, 638+85-69+20, 959-20, 959+85-69+20]], [['AntHill']], [3], 'TheDoor7', True, [], [], 'THE_DOOR7'),
                 'TheDoor8': (0, 0, [[2356-20, 2356+85-69+20, 2325+1-20, 2325+1+85-69+20]], [['AntHill']], [4], 'TheDoor8', True, [], [], 'THE_DOOR8'),
                 'TheDoor9': (0, 0, [[1750-44-20, 1750-44+85-69+20, 8634-87-20, 8634-87+85-69+20]], [['AntHill']], [5], 'TheDoor9', False, [], [], 'THE_DOOR9'),
                 'Sewer': (0, 0, [[11240-20, 11240+85-69+20, 636-20, 636+85-69+20], [784-20, 784+85-69+20, 5051-20, 5051+85-69+20], [11147-20, 11147+85-69+20, 4320-20, 4320+85-69+20]], [['TheDoor10'], ['TheDoor11'], ['TheDoor12']], [1, 1, 1], 'Sewer', True, [[5226, 5480, 0, 100], [0, 0, 0, 0], [0, 48, 2657, 3024]], [['Town'], [''], ['AntHill']], 'SEWER'),
                 'TheDoor10': (0, 0, [[3157-20, 3157+85-69+20, 5673-20, 5673+85-69+20]], [['Sewer']], [1], 'TheDoor10', False, [], [], 'THE_DOOR10'),
                 'TheDoor11': (0, 0, [[2768-20, 2768+85-69+20, 3084-20, 3084+85-69+20]], [['Sewer']], [2], 'TheDoor11', False, [], [], 'THE_DOOR11'),
                 'TheDoor12': (0, 0, [[5880-20, 5880+85-69+20, 1879-20, 1879+85-69+20]], [['Sewer']], [3], 'TheDoor12', True, [], [], 'THE_DOOR12'),
                 'Town': (0, 0, [[743-20, 743+85-69+20, 2640-20, 2640+85-69+20]], [['TheDoor13']], [1], 'Town', True, [[0, 40, 0, 2793], [2234, 2488, 2565, 2782]], [['Forest', 666], ['Sewer', 666]], 'TOWN'),
                 'TheDoor13': (0, 0, [[496-20, 496+85-69+20, 3523-20, 3523+85-69+20]], [['Town']], [1], 'TheDoor13', False, [], [], 'THE_DOOR13')}


class MyFakeMap():
  def __init__(self, x_pos, y_pos, change_region_points, new_regions, spawn_location, region, forced_exit, forced_exit_points, forced_exit_next_map, png_name):
    super().__init__()
    self.png_name = png_name
    self.x_pos = x_pos
    self.y_pos = y_pos
    #
    self.change_region_points = change_region_points # [low_x, high_x, low_y, high_y]
    self.new_regions = new_regions
    self.spawn_location = spawn_location # a number
    self.region = region
    self.forced_exit = forced_exit
    self.forced_exit_points = forced_exit_points
    self.forced_exit_next_map = forced_exit_next_map

last_map_str = 'TheDoor12'
MAP = MyFakeMap(all_maps_dict[last_map_str][0], all_maps_dict[last_map_str][1], all_maps_dict[last_map_str][2], all_maps_dict[last_map_str][3], all_maps_dict[last_map_str][4], all_maps_dict[last_map_str][5], all_maps_dict[last_map_str][6], all_maps_dict[last_map_str][7], all_maps_dict[last_map_str][8], all_maps_dict[last_map_str][9])



def change_region(all_arguments):
  try:
    everything_save_data(True, 83, str(My_cached_info.play_time))
  except:
    pass
  global PRETTY_MAP, MAP, BACKGROUND, PLAYER, BUBBLES, MY_VINES, CLOUDS, TEETERTOTTERS, ALLKEYS, DOORS, DOORS_WITH_KNOB, ANTS, PLAYER_MOVER_ANTS, SQUIRRELS, BOUNCIES, MOVING_BOUNCIES, ELEVATORS, LEAVES, ROOTS, DRIPDROPS, UPGRADES, TV, PROPELLERS, LEVERS, Hawk, QueenAnt, BEETLE_FRIEND, WATER_REGIONS, WATER_SURFACES, WATER_COVERS, IRREGULARLY_SHAPED_WATER, SEWER_PUMP_WATER, LEAKS, GRATES, GOLDFISH, TRANSPORT_PIPES, SURF_BOARDS, SURFING_RAT, EATING_RAT, SURFING_CLOCK, SURFING_PROGRESS_BAR, NUMBERS_ABOVE_HAMSTER, WAVES, BUCKETS, FOOD, GARBAGE_CAN, THE_MACHINE, TOOLS, HAMSTER_BOX, HUMAN, HAMSTER_PELLET, SUB_LEVEL_DIFFICULTIES, TRASH, SPINNY_OBJECTS, MY_SPRITES_FRONT, MY_SPRITES_BACK, MOVING_SPRITE_FRONT, MOVING_SPRITE_BACK
  global STANDING_ON_TEETERTOTTER, ON_AN_ELEVATOR, STANDING_ON_CLOUD, STANDING_ON_WHICH_CLOUD, ON_A_GARBAGE_CAN, ON_THE_MACHINE, KEY_GRABBED_BY_PLAYER, BOX_GRABBED_BY_PLAYER, reduce_KEy, GRAPPLED_TO_PLATFORM, SUPER_BOUNCY, RELEASED_GRAPPLE_LAST_FRAME, ON_A_BUCKET, IN_A_BUCKET, CANT_REENTER_PIPE, TIME_SINCE_EXITING_PIPE, TOUCHED_ROOT, PLAY_UPGRADE_CUTSCENE, PLAY_UPGRADE_CUTSCENE_start_frame, PLAY_UPGRADE_CUTSCENE_end_frame, PREVIOUS_PUSH_PISTON
  for k, v in MixerSounds.items():
    v.stop()
  pygame.mixer.stop()
  all_current_save_data = everything_save_data(False, 0, '')
  My_cached_info.upgrade_finished_flying_around_player = False
  My_cached_info.milliseconds_into_upgrade_flying_around_player = 0
  if MAP != '':
    old_map_region = MAP.region
  MAP, PLAYER, new_region, old_map_spawn_index, forced_out = all_arguments[0], all_arguments[1], all_arguments[2], all_arguments[3], all_arguments[4]
  #
  if My_cached_info.load_from_previous_location:
    My_cached_info.load_from_previous_location = False
    last_map_str = all_current_save_data[59][0:-1]
    MAP = MyFakeMap(all_maps_dict[last_map_str][0], all_maps_dict[last_map_str][1], all_maps_dict[last_map_str][2], all_maps_dict[last_map_str][3], all_maps_dict[last_map_str][4], all_maps_dict[last_map_str][5], all_maps_dict[last_map_str][6], all_maps_dict[last_map_str][7], all_maps_dict[last_map_str][8], all_maps_dict[last_map_str][9])
    try:
      PLAYER.x_vel, PLAYER.y_vel = float(all_current_save_data[60][0:-1]), float(all_current_save_data[61][0:-1])
    except:
      PLAYER = PlayerClass(mass = 1, x_pos = 300, y_pos = 5500, x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, Fx = 0, Fy = 0, Fgx = 0, Fgy = 0, movement_Fx = 0, movement_Fy = 0, piston_Fx = 0, piston_Fy = 0, water_Fx = 0, water_Fy = 0, FNx = 0, FNy = 0, piston1_type = 'PushPiston', piston2_type = 'GrapplePiston', prev_slope_angle = 0, blit_change_x = 0, blit_change_y = 0, x_dif = 0, y_dif = 0, erroring = 0, region = 'MAP12')
      PLAYER.x_vel, PLAYER.y_vel = float(all_current_save_data[60][0:-1]), float(all_current_save_data[61][0:-1])
    new_region = str(all_current_save_data[62][0:-1])
    old_map_spawn_index = int(all_current_save_data[63][0:-1])
    forced_out_num = all_current_save_data[64][0]
    if forced_out_num == '0':
      forced_out = False
    if forced_out_num == '1':
      forced_out = True
    PLAYER.x_pos, PLAYER.y_pos = float(all_current_save_data[65][0:-1]), float(all_current_save_data[66][0:-1])
  #
  if MAP != '':
    if My_cached_info.last_map_region != new_region:
      everything_save_data(True, 59, str(My_cached_info.last_map_region))
    if My_cached_info.teleported:
      My_cached_info.teleported = False
      everything_save_data(True, 59, str(My_cached_info.desired_last_map_region))
    try:
      everything_save_data(True, 60, str(PLAYER.x_vel))
      everything_save_data(True, 61, str(PLAYER.y_vel))
    except:
      everything_save_data(True, 60, str(0))
      everything_save_data(True, 61, str(0))
    everything_save_data(True, 62, str(new_region))
    everything_save_data(True, 63, str(old_map_spawn_index))
    if forced_out:
      everything_save_data(True, 64, '1')
    if not forced_out:
      everything_save_data(True, 64, '0')
    everything_save_data(True, 65, str(PLAYER.x_pos))
    everything_save_data(True, 66, str(PLAYER.y_pos))
    all_current_save_data = everything_save_data(False, 0, '')
  #
  My_cached_info.loaded_in_last_frame = True
  My_cached_info.on_a_loading_screen = True
  My_cached_info.number_of_textures_to_delete = 0
  My_cached_info.texture_IDs_to_delete = []
  if all_current_save_data[46][0] == '0':
    My_cached_info.play_intro_sequence = True
    new_region = 'Town'
  try:
    PLAYER.changed_region_last_frame = True
  except:
    PLAYER = PlayerClass(mass = 1, x_pos = 300, y_pos = 5500, x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, Fx = 0, Fy = 0, Fgx = 0, Fgy = 0, movement_Fx = 0, movement_Fy = 0, piston_Fx = 0, piston_Fy = 0, water_Fx = 0, water_Fy = 0, FNx = 0, FNy = 0, piston1_type = 'PushPiston', piston2_type = 'GrapplePiston', prev_slope_angle = 0, blit_change_x = 0, blit_change_y = 0, x_dif = 0, y_dif = 0, erroring = 0, region = 'MAP12')
    PLAYER.changed_region_last_frame = True
  ignore_the_rest = False
  if PLAYER != '':
    PLAYER.region = new_region
  global MOVING_SPRITE_FRONT, GRASSES, MOVING_SPRITE_BACK, MY_SPRITES_FRONT, MY_SPRITES_BACK, my_bottom_ball, my_bottom_ball_inner, my_top_ball, my_top_ball_inner, my_left_ball, my_left_ball_inner, my_right_ball, my_right_ball_inner, my_middle_ball, my_AllBall, my_sheath, my_piston1, my_piston2, Marker, stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom
  if new_region == 'MAP12':
    if not My_cached_info.PlayingForestTheme:
      pygame.mixer.music.load(My_cached_info.ForestThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = True
      My_cached_info.PlayingSewerTheme = False
    my_vine1 = Vine(x_pos = 11800, y_pos = 5600, vine_length = 30, vine_segment_length = 9, rotation = 270, angular_accel = 0, angular_vel = 130, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 100, png_name = 'VINE9', vine_type = 1)
    my_vine2 = Vine(x_pos = 11100, y_pos = 5600, vine_length = 30, vine_segment_length = 9, rotation = 270, angular_accel = 0, angular_vel = -130, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 100, png_name = 'VINE9', vine_type = 1)
    my_vine3 = Vine(x_pos = 10400, y_pos = 5600, vine_length = 30, vine_segment_length = 9, rotation = 270, angular_accel = 0, angular_vel = 130, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 100, png_name = 'VINE9', vine_type = 1)
    MY_VINES = [my_vine1, my_vine2, my_vine3]
    my_cloud1 = Cloud(x_pos = 3000+((1/2) * screen_width), y_pos = 4700+((1/2) * screen_height), x_vel = 50, y_vel = 50, x_accel = 20, y_accel = 20, is_the_player_swinging = False, standing_on_cloud = False, png_name = 'CLOUD1_1', png_name2 = 'CLOUD1_2')
    CLOUDS = [my_cloud1]
    TeeterTotter1 = TeeterTotter(x_pos = 4462+((1/2) * screen_width), y_pos = 5690+((1/2) * screen_height), collision_circle_x = 4462+500, collision_circle_y = 5690+20, collision_circle_radius = 255, pivot_x = 415, rotation = 20, angular_vel = 0, angular_accel = 0, is_the_player_on = False, is_the_push_piston_pushing = False, png_name = 'TEETERTOTTER1')
    TeeterTotter2 = TeeterTotter(x_pos = 5062+((1/2) * screen_width), y_pos = 5690+((1/2) * screen_height), collision_circle_x = 5062+500, collision_circle_y = 5690+20, collision_circle_radius = 255, pivot_x = 415, rotation = 20, angular_vel = 0, angular_accel = 0, is_the_player_on = False, is_the_push_piston_pushing = False, png_name = 'TEETERTOTTER1')
    TEETERTOTTERS = [TeeterTotter1, TeeterTotter2]
    my_key1 = AKey(x_pos = 580+((1/2) * screen_width), y_pos = 5700+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [2600+((1/2) * screen_width), 2800+((1/2) * screen_width), 5800+((1/2) * screen_height), 6000+((1/2) * screen_height)], is_inserted_xy = [3300+((1/2) * screen_width),5800+((1/2) * screen_height)], key_type = 1, vel = 150, png_name1 = 'PINK_KEY', png_name2 = '')
    my_key2 = AKey(x_pos = 580+((1/2) * screen_width), y_pos = 5700+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [2600+((1/2) * screen_width), 2800+((1/2) * screen_width), 5800+((1/2) * screen_height), 6000+((1/2) * screen_height)], is_inserted_xy = [3300+((1/2) * screen_width),5800+((1/2) * screen_height)], key_type = 1, vel = 150, png_name1 = 'PINK_KEY', png_name2 = '')
    ALLKEYS = [my_key1, my_key2]
    my_door1 = Door(x_pos = 2200+((1/2) * screen_width), y_pos = 5500+((1/2) * screen_height), is_open = False, is_open_x = 2200+((1/2) * screen_width), is_open_y = 5200+((1/2) * screen_height), door_type = 1, png_name = 'BROWN_DOOR')
    DOORS = [my_door1]
    DOORS_WITH_KNOB = []
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[0, 1000, 5500, 6000]], new_regions = [['Forest']], spawn_location = [1], region = 'MAP12', forced_exit = False, forced_exit_points = [], forced_exit_next_map = [], png_name = 'MAP12')
    Ant1 = Ant(x_pos = 200+((1/2) * screen_width), y_pos = 5350+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = 180, frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    Ant2 = Ant(x_pos = 200+((1/2) * screen_width), y_pos = 5350+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = 180, frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    Ant3 = Ant(x_pos = 200+((1/2) * screen_width), y_pos = 5350+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = 180, frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    Ant4 = Ant(x_pos = 200+((1/2) * screen_width), y_pos = 5350+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = 180, frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    Ant5 = Ant(x_pos = 200+((1/2) * screen_width), y_pos = 5350+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = 180, frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    Ant6 = Ant(x_pos = 200+((1/2) * screen_width), y_pos = 5350+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = 180, frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    Ant7 = Ant(x_pos = 200+((1/2) * screen_width), y_pos = 5350+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = 180, frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    Ant8 = Ant(x_pos = 200+((1/2) * screen_width), y_pos = 5350+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = 180, frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    ANTS = [Ant1, Ant2, Ant3, Ant4, Ant5, Ant6, Ant7, Ant8]
    PLAYER_MOVER_ANTS = []
    SQUIRRELS = []
    BOUNCIES = []
    MOVING_BOUNCIES = []
    ELEVATORS = []
    my_leaf1 = Leaf(x_pos = 8100+((1/2) * screen_width), y_pos = 5200+((1/2) * screen_height), accumulated_y_pos = 0, respawn_x = 8100+((1/2) * screen_height), respawn_y = 5200+((1/2) * screen_height), expiry_y_pos = 5952+((1/2) * screen_height), falling_speed = 0.3, rotation = 0, x_path = [300*math.cos(math.radians(x)) for x in range(360)], y_path = [-50*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'SMALL_LEAF')
    LEAVES = [my_leaf1]
    my_root1 = Root(x_pos = 992+((1/2)*screen_width), y_pos = 5664+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 600, time_to_finish_regrowth = 690, allowable_damage = 300, png_name = 'Root1/')
    my_root2 = Root(x_pos = 992+300+((1/2)*screen_width), y_pos = 5664+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 600, time_to_finish_regrowth = 690, allowable_damage = 300, png_name = 'Root1/')
    ROOTS = [my_root1, my_root2]
    my_dripdrop = DripDrop(x_pos = 1967+((1/2)*screen_width), y_pos = 5520+((1/2)*screen_height), start_vel = 150, max_vel = 600, end_y_pos = 6000-72-51+((1/2)*screen_height), accel = 400)
    DRIPDROPS = [my_dripdrop]
    my_upgrade1 = Upgrade(x_pos = 500+((1/2) * screen_width), y_pos = 5300+((1/2) * screen_width), collected = False)
    UPGRADES = [my_upgrade1]
    WATER_REGIONS = [(3000, 4000, 5000 - 69, 6000, 50, 0)] # (x1 x2, y1 y2, x_force, y_force)
    WATER_COVERS = []
    WATER_SURFACES = []
    IRREGULARLY_SHAPED_WATER = []
    SPINNY_OBJECTS = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    GRATES = []
    GOLDFISH = []
    TRANSPORT_PIPES = []
    SURF_BOARDS = []
    SURFING_RAT = []
    EATING_RAT = []
    WAVES = []
    BUCKETS = []
    FOOD = []
    GARBAGE_CAN = []
    THE_MACHINE = []
    TOOLS = []
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    SUB_LEVEL_DIFFICULTIES = []
    TRASH = []
    PLAYER = PlayerClass(mass = 1, x_pos = 300, y_pos = 5500, x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, Fx = 0, Fy = 0, Fgx = 0, Fgy = 0, movement_Fx = 0, movement_Fy = 0, piston_Fx = 0, piston_Fy = 0, water_Fx = 0, water_Fy = 0, FNx = 0, FNy = 0, piston1_type = 'PushPiston', piston2_type = 'GrapplePiston', prev_slope_angle = 0, blit_change_x = 0, blit_change_y = 0, x_dif = 0, y_dif = 0, erroring = 0, region = 'MAP12')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP12')
    BACKGROUND1 = Background(scroll_leftright = True, scroll_updown = True, iteration_speed = 11, scroll_speed_x = 0.04/10, scroll_speed_y = 0.04/10, scale = True, scale_size = (2000, 2000), permanent_add_x = 0, permanent_add_y = 0, use_convert_alpha = False, special_directions = 3, png_name = 'AntHill_BG')
    BACKGROUND = [BACKGROUND1]
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    Water1 = SimplySprite(x_pos = 3000 + stop_scrolling_left, y_pos = 5000 + stop_scrolling_top, png_name = 'WATER1')
    MY_SPRITES_FRONT = [Water1]
    MY_SPRITES_BACK = []
    MOVING_SPRITE_FRONT = []
    MOVING_SPRITE_BACK = []
    TV = []
    PROPELLERS = []
    LEVERS = []
    Hawk = []
    QueenAnt = []
    BEETLE_FRIEND = []
  #
  if new_region == 'Forest':
    everything_save_data(True, 96, '1')
    if not My_cached_info.PlayingForestTheme:
      pygame.mixer.music.load(My_cached_info.ForestThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = True
      My_cached_info.PlayingSewerTheme = False
    if forced_out:
      if old_map_spawn_index == 0:
        PLAYER.x_pos, PLAYER.y_pos = 11900, (PLAYER.y_pos * (4171 / 2693)) - 15
        PLAYER.x_vel = -abs(PLAYER.x_vel)
        if PLAYER.x_vel > -50:
          PLAYER.x_vel = -50
        ignore_the_rest = True
      if old_map_spawn_index == 1:
        PLAYER.x_pos, PLAYER.y_pos = 6466, 5908
        PLAYER.x_vel, PLAYER.y_vel = 150, 0
        ignore_the_rest = True
      if old_map_spawn_index == 3:
        PLAYER.x_pos, PLAYER.y_pos = 2000, 5903
        PLAYER.x_vel, PLAYER.y_vel = -200, -80
        ignore_the_rest = True
    if not ignore_the_rest:
      if MAP.spawn_location[old_map_spawn_index] == 1: # Forest entrance
        PLAYER.x_pos, PLAYER.y_pos = 11700, 3900
        PLAYER.x_vel, PLAYER.y_vel = 0, 0
      if MAP.spawn_location[old_map_spawn_index] == 2: # TheDoor2 entrance
        PLAYER.x_pos, PLAYER.y_pos = 11608, 907
        PLAYER.x_vel, PLAYER.y_vel = 0, 0
      if MAP.spawn_location[old_map_spawn_index] == 3: # TheDoor1 entrance
        PLAYER.x_pos, PLAYER.y_pos = 9120, 4870
        PLAYER.x_vel, PLAYER.y_vel = 0, 0
      if MAP.spawn_location[old_map_spawn_index] == 4: # TheDoor4 entrance
        PLAYER.x_pos, PLAYER.y_pos = 5952, 4843
        PLAYER.x_vel, PLAYER.y_vel = 0, 0
      if MAP.spawn_location[old_map_spawn_index] == 5: # TheDoor5 entrance
        PLAYER.x_pos, PLAYER.y_pos = 2592, 212
        PLAYER.x_vel, PLAYER.y_vel = 0, 0
        My_cached_info.leaving_the_door5 = True
      if MAP.spawn_location[old_map_spawn_index] == 6: # TheDoor3 entrance
        PLAYER.x_pos, PLAYER.y_pos = 7110, 3355
        PLAYER.x_vel, PLAYER.y_vel = 0, 0
    PLAYER.region = 'Forest'
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[9110-20, 9110+85-69+20, 4860-20, 4860+85-69+20], [11608-20, 11608+85-69+20, 927-20, 927+85-69+20],[5952-20, 5952+85-69+20, 4843-20, 4843+85-69+20], [2592-20, 2592+85-69+20, 212-20, 212+85-69+20], [7110-20, 7110+85-69+20, 3355-20, 3355+85-69+20]], new_regions = [['TheDoor1'], ['TheDoor2'], ['TheDoor4'], ['TheDoor5'], ['TheDoor3']], spawn_location = [1, 1, 1, 1, 1], region = 'Forest', forced_exit = True, forced_exit_points = [[2027, 2296, 5921, 6000], [6229, 6442, 5921, 6000], [11900, 12000, 0, 4244]], forced_exit_next_map = [['AntHill', 666], ['AntHill', 666], ['Town', 666]], png_name = 'FOREST')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_FOREST')
    BACKGROUND1 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.015/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 0, use_convert_alpha = False, special_directions = 1, png_name = 'Forest_BG1')
    #BACKGROUND2 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.06/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 2917-18, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG2')
    BACKGROUND3 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.025/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 4133-18, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG3')
    BACKGROUND4 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.04/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 4046-18, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG4')
    BACKGROUND5 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.06/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 3865-18, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG5')
    BACKGROUND6 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.067/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 3598-18, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG6')
    BACKGROUND7 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.075/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 3262-18, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG7')
    #BACKGROUND8 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.09/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 2927-18, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG8')
    #BACKGROUND9 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.04/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 2859-18, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG9') # 2.2
    #BACKGROUND10 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.07/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 3263-18, use_convert_alpha = True, special_directions = 1,  png_name = 'Forest_BG10') # 1.3, 1.5
    #BACKGROUND11 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.1/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 3733-18, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG11') # 0.45, 0.8
    BACKGROUND12 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.1/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 2728-18, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG12') # 2.3, 2728
    #BACKGROUND13 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.08/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 3263-18, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG13') # 1.5, 3263
    #BACKGROUND14 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.06/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 3598-18, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG14') # 1.0, 3598
    DEER = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 11, scroll_speed_x = 0.1/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 4081-18, use_convert_alpha = True, special_directions = 2, png_name = 'Forest_BGDEER') # Deer
    BACKGROUND = [BACKGROUND1, BACKGROUND3, BACKGROUND4, BACKGROUND5, BACKGROUND6, DEER, BACKGROUND7, BACKGROUND12]
    #BACKGROUND = [BACKGROUND1, BACKGROUND11, BACKGROUND10, BACKGROUND9]
    #BACKGROUND = [BACKGROUND1, BACKGROUND6, DEER, BACKGROUND7, BACKGROUND12]
    #BACKGROUND = [BACKGROUND1, BACKGROUND6, DEER, BACKGROUND7, BACKGROUND12]
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    my_vine1 = Vine(x_pos = 6060+((1/2) * screen_width), y_pos = 3140+((1/2) * screen_height), vine_length = 31, vine_segment_length = 25, rotation = 270, angular_accel = 0, angular_vel = 85, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 50, png_name = 'VINE18', vine_type = 1)
    my_vine2 = Vine(x_pos = 4790+((1/2) * screen_width), y_pos = 2745+((1/2) * screen_height), vine_length = 30, vine_segment_length = 20, rotation = 270, angular_accel = 0, angular_vel = 85, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 50, png_name = 'VINE18', vine_type = 1)
    MY_VINES = [my_vine1, my_vine2]
    my_cloud2 = Cloud(x_pos = 10612+((1/2) * screen_width), y_pos = 1236+((1/2) * screen_height), x_vel = 110, y_vel = -40, x_accel = 20, y_accel = 20, is_the_player_swinging = False, standing_on_cloud = False, png_name = 'CLOUD2_1', png_name2 = 'CLOUD2_2', fall_off_left = 22, fall_off_right = 45)
    CLOUDS = [my_cloud2]
    TEETERTOTTERS = []
    my_key1 = AKey(x_pos = 6969+((1/2) * screen_width), y_pos = 5152+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [7610+((1/2) * screen_width), 7760+((1/2) * screen_width), 4841+((1/2) * screen_height), 5030+((1/2) * screen_height)], is_inserted_xy = [3300+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 1, vel = 150, png_name1 = 'PINK_KEY', png_name2 = '')
    my_door1 = Door(x_pos = 7745+((1/2) * screen_width), y_pos = 4834+((1/2) * screen_height), is_open = False, is_open_x = 7745+((1/2) * screen_width), is_open_y = 4725+((1/2) * screen_height), door_type = 1, png_name = 'PINK_DOOR')
    if all_current_save_data[102][0] == '1':
      my_key1.is_inserted = True
      my_key1.x_pos = my_key1.is_inserted_xy[0]
      my_key1.y_pos = my_key1.is_inserted_xy[1]
    ALLKEYS = [my_key1]
    DOORS = [my_door1]
    DOORS_WITH_KNOB = []
    ANTS = []
    PLAYER_MOVER_ANTS = []
    my_squirrel1 = Squirrel(x_pos = 7555-10+((1/2) * screen_width), y_pos = 4075+((1/2) * screen_height), vel = 4.218, x1 = 7555-10+((1/2) * screen_width), y1 = 4075+((1/2) * screen_height), x2 = 7555-11-10+((1/2) * screen_width), y2 = 3050+((1/2) * screen_height), flip_squirrel = True, rotate_squirrel = 341, png_name = '')
    my_squirrel3 = Squirrel(x_pos = 1822-73+((1/2) * screen_width), y_pos = 2782+((1/2) * screen_height), vel = 6.1, x1 = 1822-73+((1/2) * screen_width), y1 = 2782+((1/2) * screen_height), x2 = 1822-73+((1/2) * screen_width), y2 = 1612+((1/2) * screen_height), flip_squirrel = False, rotate_squirrel = 15, png_name = '')
    my_squirrel4 = Squirrel(x_pos = 929+((1/2) * screen_width), y_pos = 1346+15+((1/2) * screen_height), vel = 4.205, x1 = 929+((1/2) * screen_width), y1 = 1346+15+((1/2) * screen_height), x2 = 1719+((1/2) * screen_width), y2 = 1501+15+((1/2) * screen_height), flip_squirrel = False, rotate_squirrel = 90, png_name = '')
    SQUIRRELS = [my_squirrel1, my_squirrel3, my_squirrel4]
    BOUNCIES = []
    MOVING_BOUNCIES = []
    ELEVATORS = []
    my_leaf1 = Leaf(x_pos = 7875+((1/2) * screen_width), y_pos = 3229+((1/2) * screen_height), accumulated_y_pos = 0, respawn_x = 7875+((1/2) * screen_width), respawn_y = 3229+((1/2) * screen_height), expiry_y_pos = 967, falling_speed = 0.29, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(0+36,360+36)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0+36,180+36)], rot_path = [15*math.cos(math.radians(x)) for x in range(0+36,360+36)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf2 = Leaf(x_pos = 6558+((1/2) * screen_width), y_pos = 3229+((1/2) * screen_height), accumulated_y_pos = 300, respawn_x = 6558+((1/2) * screen_width), respawn_y = 3229+((1/2) * screen_height), expiry_y_pos = 1000, falling_speed = 0.29, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(0+36,360+36)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0+36,180+36)], rot_path = [15*math.cos(math.radians(x)) for x in range(0+36,360+36)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    LEAVES = [my_leaf1, my_leaf2]
    ROOTS = []
    DRIPDROPS = []
    UPGRADES = []
    WATER_REGIONS = [[3926, 3926+1474, 4088-69, 4079+200-69, 0, 0], [9369, 9369+297, 1359-69, 1359+65-69, 0, 0]]
    water_cover1 = WaterCover(x_pos = 3925+((1/2) * screen_width), y_pos = 4094+((1/2) * screen_height), png_name = 'FOREST_WATER_COVER1')
    WATER_COVERS = [water_cover1]
    water_surface1 = WaterSurface(x_pos = 3953+((1/2) * screen_width), y_pos = 4079+((1/2) * screen_height), width = 1445, png_name = 'WATER_SURFACE_FOREST1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface2 = WaterSurface(x_pos = 9369-1+((1/2) * screen_width), y_pos = 1358+((1/2) * screen_height), width = 299, png_name = 'WATER_SURFACE_FOREST2', water_surface_type = 1, connected_to_which_bucket = 666)
    WATER_SURFACES = [water_surface1, water_surface2]
    IRREGULARLY_SHAPED_WATER = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    GRATES = []
    GOLDFISH = []
    TRANSPORT_PIPES = []
    SURF_BOARDS = []
    SURFING_RAT = []
    EATING_RAT = []
    WAVES = []
    BUCKETS = []
    FOOD = []
    GARBAGE_CAN = []
    THE_MACHINE = []
    Screw_driver = Tools(x_pos = 2111 + ((1/2)*screen_width), y_pos = 1294 + ((1/2)*screen_height), png_name = 'SCREW_DRIVER')
    TOOLS = []
    if all_current_save_data[16][0] == '0':
      TOOLS = [Screw_driver]
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    TheDoor1_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 9110+((1/2) * screen_width) + 42.5, center_of_door_y = 4860+((1/2) * screen_height) + 42.5, difficulty = 0)
    TheDoor2_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 11608+((1/2) * screen_width) + 42.5, center_of_door_y = 927+((1/2) * screen_height) + 42.5, difficulty = 0)
    TheDoor3_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 7110+((1/2) * screen_width) + 42.5, center_of_door_y = 3355+((1/2) * screen_height) + 42.5, difficulty = 1)
    TheDoor4_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 5952+((1/2) * screen_width) + 42.5, center_of_door_y = 4843+((1/2) * screen_height) + 42.5, difficulty = 1)
    TheDoor5_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 2592+((1/2) * screen_width) + 42.5, center_of_door_y = 212+((1/2) * screen_height) + 42.5, difficulty = 0)
    SUB_LEVEL_DIFFICULTIES = [TheDoor1_sublevel_difficulty, TheDoor2_sublevel_difficulty, TheDoor3_sublevel_difficulty, TheDoor4_sublevel_difficulty, TheDoor5_sublevel_difficulty]
    TRASH = []
    SPINNY_OBJECTS = []
    #Fence_right = SimplySprite(x_pos = 10600+((1/2) * screen_width), y_pos = 4095+((1/2) * screen_height), png_name = 'FENCE_RIGHT')
    TopOfTree = SimplySprite(x_pos = 2475-1+((1/2) * screen_width), y_pos = 1476-1+((1/2) * screen_height), png_name = 'TOP_OF_TREE')
    #Mouse1 = SimplySprite(x_pos = 7100+((1/2) * screen_width), y_pos = 4178+((1/2) * screen_height), png_name = 'MOUSE1')
    #Water1 = SimplySprite(x_pos = 3926+((1/2) * screen_width), y_pos = 4079+((1/2) * screen_height), png_name = 'WATER2')
    Water2 = SimplySprite(x_pos = 9369+((1/2) * screen_width), y_pos = 1359+((1/2) * screen_height), png_name = 'WATER3')
    CloudSprite2 = SimplySprite(x_pos = 8643+((1/2) * screen_width), y_pos = 1458+((1/2) * screen_height), png_name = 'CLOUD_SPRITE1')
    TheDoor1 = SimplySprite(x_pos = 9110+((1/2) * screen_width), y_pos = 4860+((1/2) * screen_height), png_name = 'THE_DOOR')
    TheDoor2 = SimplySprite(x_pos = 11608+((1/2) * screen_width), y_pos = 927+((1/2) * screen_height), png_name = 'THE_DOOR')
    TheDoor3 = SimplySprite(x_pos = 7110+((1/2) * screen_width), y_pos = 3355+((1/2) * screen_height), png_name = 'THE_DOOR')
    TheDoor4 = SimplySprite(x_pos = 5952+((1/2) * screen_width), y_pos = 4843+((1/2) * screen_height), png_name = 'THE_DOOR')
    TheDoor5 = SimplySprite(x_pos = 2592+((1/2) * screen_width), y_pos = 212+((1/2) * screen_height), png_name = 'THE_DOOR')
    Forest_door_hider = SimplySprite(x_pos = 7744+((1/2) * screen_width), y_pos = 4718+((1/2) * screen_height), png_name = 'FOREST_DOOR_HIDER')
    MY_SPRITES_FRONT = [TopOfTree, CloudSprite2]
    MY_SPRITES_BACK = [TheDoor1, TheDoor2, TheDoor3, TheDoor4, TheDoor5, Forest_door_hider]
    Flower1 = MovingSprite(x_pos = 11728+((1/2) * screen_width), y_pos = 4095+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 20, png_name = 'FLOWER1')
    Flower2 = MovingSprite(x_pos = 10966+((1/2) * screen_width), y_pos = 3983+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 20, png_name = 'FLOWER2')
    Flower3 = MovingSprite(x_pos = 10121+((1/2) * screen_width), y_pos = 4038+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 20, png_name = 'FLOWER3')
    Flower4 = MovingSprite(x_pos = 8730+((1/2) * screen_width), y_pos = 4018+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 20, png_name = 'FLOWER2')
    Flower5 = MovingSprite(x_pos = 6503+((1/2) * screen_width), y_pos = 4049+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 20, png_name = 'FLOWER1')
    Flower6 = MovingSprite(x_pos = 6224+((1/2) * screen_width), y_pos = 4090+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 20, png_name = 'FLOWER1')
    Flower7 = MovingSprite(x_pos = 1637+((1/2) * screen_width), y_pos = 4041+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 20, png_name = 'FLOWER3')
    Flower8 = MovingSprite(x_pos = 49+((1/2) * screen_width), y_pos = 3987+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 20, png_name = 'FLOWER2')
    MOVING_SPRITE_FRONT = []
    MOVING_SPRITE_BACK = [Flower1, Flower2, Flower3, Flower4, Flower5, Flower6, Flower7, Flower8]
    Grass1 = Grass(x_pos = 11908+((1/2) * screen_width), y_pos = 4151+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass2 = Grass(x_pos = 11840+((1/2) * screen_width), y_pos = 4153+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'FOREST_GRASS_R0')
    Grass3 = Grass(x_pos = 11759+((1/2) * screen_width), y_pos = 4146+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass4 = Grass(x_pos = 11686+((1/2) * screen_width), y_pos = 4147+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'FOREST_GRASS_R10')
    Grass5 = Grass(x_pos = 11625+((1/2) * screen_width), y_pos = 4129+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R20')
    Grass6 = Grass(x_pos = 11562+((1/2) * screen_width), y_pos = 4108+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'FOREST_GRASS_R20')
    Grass7 = Grass(x_pos = 11493+((1/2) * screen_width), y_pos = 4091+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass8 = Grass(x_pos = 11417+((1/2) * screen_width), y_pos = 4102+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'FOREST_GRASS_R20')
    Grass9 = Grass(x_pos = 11352+((1/2) * screen_width), y_pos = 4112+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R10')
    Grass10 = Grass(x_pos = 11289+((1/2) * screen_width), y_pos = 4126+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'FOREST_GRASS_R20')
    Grass11 = Grass(x_pos = 11229+((1/2) * screen_width), y_pos = 4141+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R20')
    Grass12 = Grass(x_pos = 11169+((1/2) * screen_width), y_pos = 4145+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'FOREST_GRASS_R0')
    Grass13 = Grass(x_pos = 11119+((1/2) * screen_width), y_pos = 4135+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R30')
    Grass14 = Grass(x_pos = 11056+((1/2) * screen_width), y_pos = 4105+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'FOREST_GRASS_R20')
    Grass15 = Grass(x_pos = 10995+((1/2) * screen_width), y_pos = 4073+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R30')
    Grass16 = Grass(x_pos = 10926+((1/2) * screen_width), y_pos = 4042+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'FOREST_GRASS_R20')
    Grass17 = Grass(x_pos = 10863+((1/2) * screen_width), y_pos = 4002+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R30')
    Grass18 = Grass(x_pos = 10792+((1/2) * screen_width), y_pos = 3973+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'FOREST_GRASS_R10')
    Grass19 = Grass(x_pos = 10710+((1/2) * screen_width), y_pos = 3964+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass20 = Grass(x_pos = 10631+((1/2) * screen_width), y_pos = 3981+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'FOREST_GRASS_R20')
    Grass21 = Grass(x_pos = 10559+((1/2) * screen_width), y_pos = 4004+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R20')
    Grass22 = Grass(x_pos = 10499+((1/2) * screen_width), y_pos = 4047+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'FOREST_GRASS_R30')
    Grass23 = Grass(x_pos = 10433+((1/2) * screen_width), y_pos = 4088+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R30')
    Grass24 = Grass(x_pos = 10365+((1/2) * screen_width), y_pos = 4118+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'FOREST_GRASS_R20')
    Grass25 = Grass(x_pos = 10289+((1/2) * screen_width), y_pos = 4129+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R10')
    Grass26 = Grass(x_pos = 10211+((1/2) * screen_width), y_pos = 4139+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'FOREST_GRASS_R0')
    Grass27 = Grass(x_pos = 10129+((1/2) * screen_width), y_pos = 4144+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass28 = Grass(x_pos = 10048+((1/2) * screen_width), y_pos = 4146+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'FOREST_GRASS_R0')
    Grass29 = Grass(x_pos = 8806+((1/2) * screen_width), y_pos = 4116+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass30 = Grass(x_pos = 8875+((1/2) * screen_width), y_pos = 4131+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R20')
    Grass31 = Grass(x_pos = 8730+((1/2) * screen_width), y_pos = 4132+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R20')
    Grass32 = Grass(x_pos = 6792+((1/2) * screen_width), y_pos = 4140+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R20')
    Grass33 = Grass(x_pos = 6581+((1/2) * screen_width), y_pos = 4084+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass34 = Grass(x_pos = 6319+((1/2) * screen_width), y_pos = 4145+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R20')
    Grass35 = Grass(x_pos = 5746+((1/2) * screen_width), y_pos = 4079+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R30')
    Grass36 = Grass(x_pos = 3691+((1/2) * screen_width), y_pos = 4141+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass37 = Grass(x_pos = 3634+((1/2) * screen_width), y_pos = 4141+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass38 = Grass(x_pos = 1721+((1/2) * screen_width), y_pos = 4141+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass39 = Grass(x_pos = 1655+((1/2) * screen_width), y_pos = 4141+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass40 = Grass(x_pos = 1389+((1/2) * screen_width), y_pos = 4142+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R20')
    Grass41 = Grass(x_pos = 214+((1/2) * screen_width), y_pos = 4128+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R20')
    Grass42 = Grass(x_pos = 140+((1/2) * screen_width), y_pos = 4105+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R20')
    Grass43 = Grass(x_pos = 59+((1/2) * screen_width), y_pos = 4088+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R10')
    Grass44 = Grass(x_pos = -24+((1/2) * screen_width), y_pos = 4079+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass45 = Grass(x_pos = 7716+((1/2) * screen_width), y_pos = 4141+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass46 = Grass(x_pos = 7645+((1/2) * screen_width), y_pos = 4141+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    GRASSES = [Grass1, Grass2, Grass3, Grass4, Grass5, Grass6, Grass7, Grass8, Grass9, Grass10, Grass11, Grass12, Grass13, Grass14, Grass15, Grass16, Grass17, Grass18, Grass19, Grass20, Grass21, Grass22, Grass23, Grass24, Grass25, Grass26, Grass27, Grass28, Grass29, Grass30, Grass31, Grass32, Grass33, Grass34, Grass35, Grass36, Grass37, Grass38, Grass39, Grass40, Grass41, Grass42, Grass43, Grass44, Grass45, Grass46]
    TV = []
    PROPELLERS = []
    LEVERS = []
    Hawk = BossHawk(x_pos = 2600-600+((1/2) * screen_width), y_pos = 2200-300+((1/2) * screen_height), next_location_x = 0, next_location_y = 0, current_frame = 0, frame_of_arrival = 0, my_step = 1, total_distance_to_cover = 0, delta_x = 0, delta_y = 0, nesting = True, png_name = 'Forest/BossHawk/NEW_BossHawk.png')
    QueenAnt = []
    BEETLE_FRIEND = []
  #
  if new_region == 'TheDoor1': # Forest area metal bar door
    if not My_cached_info.PlayingForestTheme:
      pygame.mixer.music.load(My_cached_info.ForestThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = True
      My_cached_info.PlayingSewerTheme = False
    if MAP.spawn_location[old_map_spawn_index] == 1: # enter from Forest
      PLAYER.x_pos, PLAYER.y_pos = 115, 4330
      PLAYER.x_vel, PLAYER.y_vel = 0, 0
    PLAYER.region = 'TheDoor1'
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[80-20, 80+85-69+20, 4315-20, 4315+85-69+20]], new_regions = [['Forest']], spawn_location = [3], region = 'TheDoor1', forced_exit = False, forced_exit_points = [], forced_exit_next_map = [], png_name = 'THE_DOOR1')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_THE_DOOR1')
    BACKGROUND = []
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    my_vine1 = Vine(x_pos = 674+8+((1/2) * screen_width), y_pos = 3120+16+((1/2) * screen_height), vine_length = 1, vine_segment_length = 1360, rotation = 270, angular_accel = 0, angular_vel = 0, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 0, png_name = 'LONGLEAD2', vine_type = 1)
    my_vine2 = Vine(x_pos = 674+8-1+620+((1/2) * screen_width), y_pos = 3036+12+((1/2) * screen_height), vine_length = 1, vine_segment_length = 1264, rotation = 270, angular_accel = 0, angular_vel = 0, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 0, png_name = 'LONGLEAD1', vine_type = 1)
    MY_VINES = [my_vine1, my_vine2]
    CLOUDS = []
    TeeterTotter1 = TeeterTotter(x_pos = 221-30+((1/2) * screen_width), y_pos = 4380+((1/2) * screen_height), collision_circle_x = 221-30+500, collision_circle_y = 4380+20, collision_circle_radius = 255, pivot_x = 415, rotation = -20, angular_vel = 0, angular_accel = 0, is_the_player_on = False, is_the_push_piston_pushing = False, png_name = 'TEETERTOTTER1')
    TeeterTotter2 = TeeterTotter(x_pos = 781+30+((1/2) * screen_width), y_pos = 4380+((1/2) * screen_height), collision_circle_x = 781+30+500, collision_circle_y = 4380+20, collision_circle_radius = 255, pivot_x = 415, rotation = 20, angular_vel = 0, angular_accel = 0, is_the_player_on = False, is_the_push_piston_pushing = False, png_name = 'TEETERTOTTER1')
    TEETERTOTTERS = [TeeterTotter1, TeeterTotter2]
    ALLKEYS = []
    DOORS = []
    DOORS_WITH_KNOB = []
    ANTS = []
    PLAYER_MOVER_ANTS = []
    SQUIRRELS = []
    BOUNCIES = []
    MOVING_BOUNCIES = []
    ELEVATORS = []
    LEAVES = []
    ROOTS = []
    DRIPDROPS = []
    UPGRADES = []
    if all_current_save_data[27][0] == '0':
      my_upgrade1 = Upgrade(x_pos = 144+((1/2) * screen_width), y_pos = 816+((1/2) * screen_height), collected = False)
      UPGRADES = [my_upgrade1]
    WATER_REGIONS = []
    WATER_COVERS = []
    WATER_SURFACES = []
    IRREGULARLY_SHAPED_WATER = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    GRATES = []
    GOLDFISH = []
    TRANSPORT_PIPES = []
    SURF_BOARDS = []
    SURFING_RAT = []
    EATING_RAT = []
    WAVES = []
    BUCKETS = []
    FOOD = []
    GARBAGE_CAN = []
    THE_MACHINE = []
    TOOLS = []
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    TheDoor1_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 90+((1/2) * screen_width) + 42.5, center_of_door_y = 4315+((1/2) * screen_height) + 42.5, difficulty = 4)
    SUB_LEVEL_DIFFICULTIES = [TheDoor1_sublevel_difficulty]
    TRASH = []
    SPINNY_OBJECTS = []
    MY_SPRITES_FRONT = []
    TheDoor1 = SimplySprite(x_pos = 90+((1/2) * screen_width), y_pos = 4315+((1/2) * screen_height), png_name = 'THE_DOOR')
    MY_SPRITES_BACK = [TheDoor1]
    MOVING_SPRITE_FRONT = []
    MOVING_SPRITE_BACK = []
    Grass1 = Grass(x_pos = 258+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass2 = Grass(x_pos = 331+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'ANTHILL_GRASS_R0')
    Grass3 = Grass(x_pos = 406+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass4 = Grass(x_pos = 486+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'ANTHILL_GRASS_R0')
    Grass5 = Grass(x_pos = 561+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass6 = Grass(x_pos = 644+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'ANTHILL_GRASS_R0')
    Grass7 = Grass(x_pos = 727+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass8 = Grass(x_pos = 798+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'ANTHILL_GRASS_R0')
    Grass9 = Grass(x_pos = 881+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass10 = Grass(x_pos = 960+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'ANTHILL_GRASS_R0')
    Grass11 = Grass(x_pos = 1037+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass12 = Grass(x_pos = 1123+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'ANTHILL_GRASS_R0')
    Grass13 = Grass(x_pos = 1201+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass14 = Grass(x_pos = 1285+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'ANTHILL_GRASS_R0')
    Grass15 = Grass(x_pos = 1372+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass16 = Grass(x_pos = 1452+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'ANTHILL_GRASS_R0')
    Grass17 = Grass(x_pos = 1535+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass18 = Grass(x_pos = 1618+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'ANTHILL_GRASS_R0')
    Grass19 = Grass(x_pos = 1699+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass20 = Grass(x_pos = 1781+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'ANTHILL_GRASS_R0')
    Grass21 = Grass(x_pos = 1867+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass22 = Grass(x_pos = 1948+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'ANTHILL_GRASS_R0')
    Grass23 = Grass(x_pos = 2034+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass24 = Grass(x_pos = 2117+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = True, png_name = 'ANTHILL_GRASS_R0')
    Grass25 = Grass(x_pos = 2194+((1/2) * screen_width), y_pos = 4787+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass26 = Grass(x_pos = 1909+((1/2) * screen_width), y_pos = 3608+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass27 = Grass(x_pos = 1991+((1/2) * screen_width), y_pos = 3608+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass28 = Grass(x_pos = 3347+((1/2) * screen_width), y_pos = 2105+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass29 = Grass(x_pos = 3268+((1/2) * screen_width), y_pos = 2105+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass30 = Grass(x_pos = 3185+((1/2) * screen_width), y_pos = 2105+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass31 = Grass(x_pos = 734+((1/2) * screen_width), y_pos = 2825+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass32 = Grass(x_pos = 222+((1/2) * screen_width), y_pos = 2808+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R10')
    GRASSES = [Grass1, Grass2, Grass3, Grass4, Grass5, Grass6, Grass7, Grass8, Grass9, Grass10, Grass11, Grass12, Grass13, Grass14, Grass15, Grass16, Grass17, Grass18, Grass19, Grass20, Grass21, Grass22, Grass23, Grass24, Grass25, Grass26, Grass27, Grass28, Grass29, Grass30, Grass31, Grass32]
    TV = []
    PROPELLERS = []
    LEVERS = []
    Hawk = []
    QueenAnt = []
    BEETLE_FRIEND = []
  #
  if new_region == 'TheDoor2': # Forest area cloud door
    if not My_cached_info.PlayingForestTheme:
      pygame.mixer.music.load(My_cached_info.ForestThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = True
      My_cached_info.PlayingSewerTheme = False
    if MAP.spawn_location[old_map_spawn_index] == 1:
      PLAYER.x_pos, PLAYER.y_pos = 248, 1892
      PLAYER.x_vel, PLAYER.y_vel = 0, 0
    PLAYER.region = 'TheDoor2'
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[251-20, 251+85-69+20, 1887-20, 1887+85-69+20]], new_regions = [['Forest']], spawn_location = [2], region = 'TheDoor2', forced_exit = False, forced_exit_points = [], forced_exit_next_map = [], png_name = 'THE_DOOR2')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_THE_DOOR2')
    BACKGROUND = []
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    MY_VINES = []
    my_cloud1 = Cloud(x_pos = 1966+((1/2) * screen_width), y_pos = 1680+((1/2) * screen_height), x_vel = 130, y_vel = -50, x_accel = 20, y_accel = 20, is_the_player_swinging = False, standing_on_cloud = False, png_name = 'CLOUD2_1', png_name2 = 'CLOUD2_2', fall_off_left = 22, fall_off_right = 45)
    my_cloud2 = Cloud(x_pos = 2489+((1/2) * screen_width), y_pos = 478+((1/2) * screen_height), x_vel = 150, y_vel = 0, x_accel = 20, y_accel = 20, is_the_player_swinging = False, standing_on_cloud = False, png_name = 'CLOUD1_1', png_name2 = 'CLOUD1_2', fall_off_left = 0, fall_off_right = -10)
    CLOUDS = [my_cloud1, my_cloud2]
    TEETERTOTTERS = []
    ALLKEYS = []
    DOORS = []
    DOORS_WITH_KNOB = []
    ANTS = []
    PLAYER_MOVER_ANTS = []
    SQUIRRELS = []
    BOUNCIES = []
    MOVING_BOUNCIES = []
    ELEVATORS = []
    LEAVES = []
    ROOTS = []
    DRIPDROPS = []
    UPGRADES = []
    if all_current_save_data[28][0] == '0':
      my_upgrade2 = Upgrade(x_pos = 1328+((1/2) * screen_width), y_pos = 336+((1/2) * screen_height), collected = False)
      UPGRADES = [my_upgrade2]
    WATER_REGIONS = [[754, 3823, 2224-69, 2353, 0, 0]]
    cloud_water_cover = WaterCover(x_pos = 773+((1/2) * screen_width), y_pos = 2230+((1/2) * screen_height), png_name = 'CLOUD_COVER')
    WATER_COVERS = [cloud_water_cover]
    water_surface1 = WaterSurface(x_pos = 753+((1/2) * screen_width), y_pos = 2214+((1/2) * screen_height), width = 63, png_name = 'WATER_SURFACE_CLOUD_LEFT', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface2 = WaterSurface(x_pos = 753+63+((1/2) * screen_width), y_pos = 2214+((1/2) * screen_height), width = 2945, png_name = 'WATER_SURFACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface3 = WaterSurface(x_pos = 3761+((1/2) * screen_width), y_pos = 2214+((1/2) * screen_height), width = 44, png_name = 'WATER_SURFACE_CLOUD_RIGHT', water_surface_type = 1, connected_to_which_bucket = 666)
    WATER_SURFACES = [water_surface1, water_surface2, water_surface3]
    IRREGULARLY_SHAPED_WATER = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    GRATES = []
    GOLDFISH = []
    TRANSPORT_PIPES = []
    SURF_BOARDS = []
    SURFING_RAT = []
    EATING_RAT = []
    WAVES = []
    BUCKETS = []
    FOOD = []
    GARBAGE_CAN = []
    THE_MACHINE = []
    TOOLS = []
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    TheDoor2_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 251+((1/2) * screen_width) + 42.5, center_of_door_y = 1887+((1/2) * screen_height) + 42.5, difficulty = 4)
    SUB_LEVEL_DIFFICULTIES = [TheDoor2_sublevel_difficulty]
    TRASH = []
    SPINNY_OBJECTS = []
    #Water1 = SimplySprite(x_pos = 754+((1/2) * screen_width), y_pos = 2214+((1/2) * screen_height), png_name = 'WATER4')
    CloudSprite1 = SimplySprite(x_pos = 170+((1/2) * screen_width), y_pos = 1973+((1/2) * screen_height), png_name = 'CLOUD_SPRITE2')
    CloudSprite2 = SimplySprite(x_pos = 934+((1/2) * screen_width), y_pos = 1871+((1/2) * screen_height), png_name = 'CLOUD_SPRITE3')
    CloudSprite3 = SimplySprite(x_pos = 2860+((1/2) * screen_width), y_pos = 1354+((1/2) * screen_height), png_name = 'CLOUD_SPRITE4')
    CloudSprite4 = SimplySprite(x_pos = 1168+((1/2) * screen_width), y_pos = 440+((1/2) * screen_height), png_name = 'CLOUD_SPRITE5')
    TheDoor2 = SimplySprite(x_pos = 251+((1/2) * screen_width), y_pos = 1887+((1/2) * screen_height), png_name = 'THE_DOOR')
    MY_SPRITES_FRONT = [CloudSprite1, CloudSprite2, CloudSprite3, CloudSprite4]
    MY_SPRITES_BACK = [TheDoor2]
    MOVING_SPRITE_FRONT = []
    MOVING_SPRITE_BACK = []
    GRASSES = []
    TV = []
    PROPELLERS = []
    LEVERS = []
    Hawk = []
    QueenAnt = []
    BEETLE_FRIEND = []
  #
  if new_region == 'TheDoor3': # Forest area tree trunk door
    if not My_cached_info.PlayingForestTheme:
      pygame.mixer.music.load(My_cached_info.ForestThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = True
      My_cached_info.PlayingSewerTheme = False
    if MAP.spawn_location[old_map_spawn_index] == 1:
      PLAYER.x_pos, PLAYER.y_pos = 880, 7738
      PLAYER.x_vel, PLAYER.y_vel = 0, 0
    PLAYER.region = 'TheDoor3'
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[880-20, 880+85-69+20, 4240+3500-20, 4240+3500+85-69+20]], new_regions = [['Forest']], spawn_location = [6], region = 'TheDoor3', forced_exit = False, forced_exit_points = [], forced_exit_next_map = [], png_name = 'THE_DOOR3')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_THE_DOOR3')
    BACKGROUND = []
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    MY_VINES = []
    CLOUDS = []
    TEETERTOTTERS = []
    ALLKEYS = []
    DOORS = []
    DOORS_WITH_KNOB = []
    ANTS = []
    PLAYER_MOVER_ANTS = []
    SQUIRRELS = []
    bouncy1 = BouncyObject(x_pos = 1838+25+((1/2) * screen_width), y_pos = 4538+3500+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 1000, collision_circle_x = 1838+25+163, collision_circle_y = 4538+3500+163, collision_circle_radius = 163, png_name = 'BOUNCY_MUSHROOM1')
    bouncy2 = BouncyObject(x_pos = 1838-500+((1/2) * screen_width), y_pos = 4538+3500+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 1000, collision_circle_x = 1838-500+163, collision_circle_y = 4538+3500+163, collision_circle_radius = 163, png_name = 'BOUNCY_MUSHROOM1')
    bouncy3 = BouncyObject(x_pos = 1838-250+((1/2) * screen_width), y_pos = 4538+3500+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 1000, collision_circle_x = 1838-250+163, collision_circle_y = 4538+3500+163, collision_circle_radius = 163, png_name = 'BOUNCY_MUSHROOM1')
    bouncy4 = BouncyObject(x_pos = 1838-1050+((1/2) * screen_width), y_pos = 4538+3500+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 1000, collision_circle_x = 1838-1050+163, collision_circle_y = 4538+3500+163, collision_circle_radius = 163, png_name = 'BOUNCY_MUSHROOM1')
    bouncy5 = BouncyObject(x_pos = 1838-790+((1/2) * screen_width), y_pos = 4538+3500+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 1000, collision_circle_x = 1838-790+163, collision_circle_y = 4538+3500+163, collision_circle_radius = 163, png_name = 'BOUNCY_MUSHROOM1')
    bouncy6 = BouncyObject(x_pos = 2175-70+20+((1/2) * screen_width), y_pos = 3563+3500-63+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 1000, collision_circle_x = 2175+20, collision_circle_y = 3563+3500, collision_circle_radius = 100, png_name = 'BOUNCY_MUSHROOM2')
    bouncy7 = BouncyObject(x_pos = 823-70+((1/2) * screen_width), y_pos = 3144+3500-63+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 1000, collision_circle_x = 823, collision_circle_y = 3144+3500, collision_circle_radius = 100, png_name = 'BOUNCY_MUSHROOM2')
    bouncy8 = BouncyObject(x_pos = 1321+((1/2) * screen_width), y_pos = 2193+3500-80+3+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 1000, collision_circle_x = 1321+37, collision_circle_y = 2193+3500-80+40+3, collision_circle_radius = 60, png_name = 'SMALL_MUSHY')
    bouncy9 = BouncyObject(x_pos = 1603+((1/2) * screen_width), y_pos = 2193+3500-80+3+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 1000, collision_circle_x = 1603+37, collision_circle_y = 2193+3500-80+40+3, collision_circle_radius = 60, png_name = 'SMALL_MUSHY')
    bouncy13 = BouncyObject(x_pos = 1438-41+((1/2) * screen_width), y_pos = 1725+3500-35+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 1000, collision_circle_x = 1438-41+34, collision_circle_y = 1725+3500-35+63, collision_circle_radius = 75, png_name = 'BOUNCY_MUSHROOM_LEFT')
    bouncy14 = BouncyObject(x_pos = 1533+((1/2) * screen_width), y_pos = 1725+3500-35+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 1000, collision_circle_x = 1533+34, collision_circle_y = 1725+3500-35+63, collision_circle_radius = 75, png_name = 'BOUNCY_MUSHROOM_RIGHT')
    bouncy15 = BouncyObject(x_pos = 1932+((1/2) * screen_width), y_pos = 4401+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 1000, collision_circle_x = 1932+121, collision_circle_y = 4401+121, collision_circle_radius = 175, png_name = 'MEDIUM_MUSHY')
    bouncy16 = BouncyObject(x_pos = 1218-122+((1/2) * screen_width), y_pos = 2940-243+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 1000, collision_circle_x = 1218-122+122, collision_circle_y = 2940-243+122, collision_circle_radius = 175, png_name = 'MEDIUM_MUSHY')
    BOUNCIES = [bouncy1, bouncy2, bouncy3, bouncy4, bouncy5, bouncy6, bouncy7, bouncy8, bouncy9, bouncy13, bouncy14, bouncy15, bouncy16]
    MOVING_BOUNCIES = []
    ELEVATORS = []
    LEAVES = []
    ROOTS = []
    DRIPDROPS = []
    UPGRADES = []
    if all_current_save_data[29][0] == '0':
      my_upgrade3 = Upgrade(x_pos = 2048+((1/2) * screen_width), y_pos = 864+((1/2) * screen_height), collected = False)
      UPGRADES = [my_upgrade3]
    WATER_REGIONS = []
    WATER_COVERS = []
    WATER_SURFACES = []
    IRREGULARLY_SHAPED_WATER = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    GRATES = []
    GOLDFISH = []
    TRANSPORT_PIPES = []
    SURF_BOARDS = []
    SURFING_RAT = []
    EATING_RAT = []
    WAVES = []
    BUCKETS = []
    FOOD = []
    GARBAGE_CAN = []
    THE_MACHINE = []
    TOOLS = []
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    TheDoor3_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 880+((1/2) * screen_width) + 42.5, center_of_door_y = 7738+((1/2) * screen_height) + 42.5, difficulty = 4)
    SUB_LEVEL_DIFFICULTIES = [TheDoor3_sublevel_difficulty]
    TRASH = []
    SPINNY_OBJECTS = []
    TheDoor3 = SimplySprite(x_pos = 880+((1/2) * screen_width), y_pos = 7738+((1/2) * screen_height), png_name = 'THE_DOOR')
    MY_SPRITES_FRONT = []
    MY_SPRITES_BACK = [TheDoor3]
    MOVING_SPRITE_FRONT = []
    MOVING_SPRITE_BACK = []
    GRASSES = []
    TV = []
    PROPELLERS = []
    LEVERS = []
    Hawk = []
    QueenAnt = []
    BEETLE_FRIEND = []
  #
  if new_region == 'TheDoor4': # Forest area Football door
    if not My_cached_info.PlayingForestTheme:
      pygame.mixer.music.load(My_cached_info.ForestThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = True
      My_cached_info.PlayingSewerTheme = False
    if MAP.spawn_location[old_map_spawn_index] == 1:
      PLAYER.x_pos, PLAYER.y_pos = 1328, 4841
      PLAYER.x_vel, PLAYER.y_vel = 0, 0
    PLAYER.region = 'TheDoor4'
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[1328-20, 1328+85-69+20, 4841-20, 4841+85-69+20]], new_regions = [['Forest']], spawn_location = [4], region = 'TheDoor4', forced_exit = False, forced_exit_points = [], forced_exit_next_map = [], png_name = 'THE_DOOR4')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_THE_DOOR4')
    BACKGROUND = []
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    MY_VINES = []
    CLOUDS = []
    TEETERTOTTERS = []
    ALLKEYS = []
    DOORS = []
    DOORS_WITH_KNOB = []
    Ant1 = Ant(x_pos = random.randint(170,2569-64)+((1/2) * screen_width), y_pos = random.randint(647,4042)+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 10000, check_y_range = 10000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT2', png_name2 = 'ANT2')
    Ant2 = Ant(x_pos = random.randint(170,2569-64)+((1/2) * screen_width), y_pos = random.randint(647,4042)+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 10000, check_y_range = 10000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT2', png_name2 = 'ANT2')
    Ant3 = Ant(x_pos = random.randint(170,2569-64)+((1/2) * screen_width), y_pos = random.randint(647,4042)+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 10000, check_y_range = 10000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT2', png_name2 = 'ANT2')
    Ant4 = Ant(x_pos = random.randint(170,2569-64)+((1/2) * screen_width), y_pos = random.randint(647,4042)+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 10000, check_y_range = 10000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT2', png_name2 = 'ANT2')
    Ant5 = Ant(x_pos = random.randint(170,2569-64)+((1/2) * screen_width), y_pos = random.randint(647,4042)+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 10000, check_y_range = 10000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT2', png_name2 = 'ANT2')
    Ant6 = Ant(x_pos = random.randint(170,2569-64)+((1/2) * screen_width), y_pos = random.randint(647,4042)+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 10000, check_y_range = 10000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT2', png_name2 = 'ANT2')
    Ant7 = Ant(x_pos = random.randint(170,2569-64)+((1/2) * screen_width), y_pos = random.randint(647,4042)+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 10000, check_y_range = 10000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT2', png_name2 = 'ANT2')
    Ant8 = Ant(x_pos = random.randint(170,2569-64)+((1/2) * screen_width), y_pos = random.randint(647,4042)+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 10000, check_y_range = 10000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT2', png_name2 = 'ANT2')
    Ant9 = Ant(x_pos = random.randint(170,2569-64)+((1/2) * screen_width), y_pos = random.randint(647,4042)+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 10000, check_y_range = 10000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT2', png_name2 = 'ANT2')
    Ant10 = Ant(x_pos = random.randint(170,2569-64)+((1/2) * screen_width), y_pos = random.randint(647,4042)+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 10000, check_y_range = 10000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT2', png_name2 = 'ANT2')
    Ant11 = Ant(x_pos = random.randint(170,2569-64)+((1/2) * screen_width), y_pos = random.randint(647,4042)+((1/2) * screen_width), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 10000, check_y_range = 10000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT2', png_name2 = 'ANT2')
    ANTS = [Ant1, Ant2, Ant3, Ant4, Ant5, Ant6, Ant7, Ant8, Ant9, Ant10, Ant11]
    PLAYER_MOVER_ANTS = []
    SQUIRRELS = []
    BOUNCIES = []
    MOVING_BOUNCIES = []
    ELEVATORS = []
    LEAVES = []
    ROOTS = []
    DRIPDROPS = []
    UPGRADES = []
    if all_current_save_data[30][0] == '0':
      my_upgrade4 = Upgrade(x_pos = 1336+((1/2) * screen_width), y_pos = 512+((1/2) * screen_height), collected = False)
      UPGRADES = [my_upgrade4]
    WATER_REGIONS = []
    WATER_COVERS = []
    WATER_SURFACES = []
    IRREGULARLY_SHAPED_WATER = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    GRATES = []
    GOLDFISH = []
    TRANSPORT_PIPES = []
    SURF_BOARDS = []
    SURFING_RAT = []
    EATING_RAT = []
    WAVES = []
    BUCKETS = []
    FOOD = []
    GARBAGE_CAN = []
    THE_MACHINE = []
    TOOLS = []
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    TheDoor4_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 1328+((1/2) * screen_width) + 42.5, center_of_door_y = 4841+((1/2) * screen_height) + 42.5, difficulty = 4)
    SUB_LEVEL_DIFFICULTIES = [TheDoor4_sublevel_difficulty]
    TRASH = []
    SPINNY_OBJECTS = []
    TheDoor4 = SimplySprite(x_pos = 1328+((1/2) * screen_width), y_pos = 4841+((1/2) * screen_height), png_name = 'THE_DOOR')
    MY_SPRITES_FRONT = []
    MY_SPRITES_BACK = [TheDoor4]
    MOVING_SPRITE_FRONT = []
    MOVING_SPRITE_BACK = []
    GRASSES = []
    TV = []
    PROPELLERS = []
    LEVERS = []
    Hawk = []
    QueenAnt = []
    BEETLE_FRIEND = []
  #
  if new_region == 'TheDoor5': # Forest area top of boss tree
    if not My_cached_info.PlayingForestTheme:
      pygame.mixer.music.load(My_cached_info.ForestThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = True
      My_cached_info.PlayingSewerTheme = False
    if forced_out:
      PLAYER.x_pos, PLAYER.y_pos = 2592, 6078
      PLAYER.x_vel, PLAYER.y_vel = 0, 0
      ignore_the_rest = True
    if MAP.spawn_location[old_map_spawn_index] == 1 and not ignore_the_rest:
      PLAYER.x_pos, PLAYER.y_pos = 2592, 6078
      PLAYER.x_vel, PLAYER.y_vel = 0, 0
    PLAYER.region = 'TheDoor5'
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[2592-20, 2592+85-69+20, 6078-20, 6078+85-69+20]], new_regions = [['Forest']], spawn_location = [5], region = 'TheDoor5', forced_exit = True, forced_exit_points = [[0, 5021+69, 6161, 6240]], forced_exit_next_map = [['TheDoor5', 666]], png_name = 'THE_DOOR5')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_THE_DOOR5')
    BACKGROUND = []
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    my_vine1 = Vine(x_pos = 2575+((1/2) * screen_width), y_pos = 3830+((1/2) * screen_height), vine_length = 22, vine_segment_length = 25, rotation = 270, angular_accel = 0, angular_vel = 54, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 40, png_name = 'VINE18_SHADE', vine_type = 1)
    MY_VINES = [my_vine1]
    CLOUDS = []
    TEETERTOTTERS = []
    ALLKEYS = []
    DOORS = []
    DOORS_WITH_KNOB = []
    ANTS = []
    PLAYER_MOVER_ANTS = []
    my_squirrel1 = Squirrel(x_pos = 1909+((1/2) * screen_width), y_pos = 5375+((1/2) * screen_height), vel = 3.5, x1 = 1909+((1/2) * screen_width), y1 = 5375+((1/2) * screen_height), x2 = 2025+((1/2) * screen_width), y2 = 4597+((1/2) * screen_height), flip_squirrel = False, rotate_squirrel = 0, png_name = '')
    my_squirrel2 = Squirrel(x_pos = 1912+((1/2) * screen_width), y_pos = 5950+((1/2) * screen_height), vel = 3.5, x1 = 1912+((1/2) * screen_width), y1 = 5950+((1/2) * screen_height), x2 = 1928+((1/2) * screen_width), y2 = 5731+((1/2) * screen_height), flip_squirrel = True, rotate_squirrel = 330, png_name = '')
    my_squirrel3 = Squirrel(x_pos = 712+((1/2) * screen_width), y_pos = 4211+((1/2) * screen_height), vel = 5.6, x1 = 712+((1/2) * screen_width), y1 = 4211+((1/2) * screen_height), x2 = 1949+((1/2) * screen_width), y2 = 4430+((1/2) * screen_height), flip_squirrel = False, rotate_squirrel = 84, png_name = '')
    my_squirrel4 = Squirrel(x_pos = 3080+((1/2) * screen_width), y_pos = 4238+((1/2) * screen_height), vel = 5.6, x1 = 3080+((1/2) * screen_width), y1 = 4238+((1/2) * screen_height), x2 = 3021+((1/2) * screen_width), y2 = 3830+((1/2) * screen_height), flip_squirrel = True, rotate_squirrel = 10, png_name = '')
    my_squirrel5 = Squirrel(x_pos = 3321+((1/2) * screen_width), y_pos = 5975+((1/2) * screen_height), vel = 3.5, x1 = 3321+((1/2) * screen_width), y1 = 5975+((1/2) * screen_height), x2 = 3247+((1/2) * screen_width), y2 = 5431+((1/2) * screen_height), flip_squirrel = True, rotate_squirrel = 2, png_name = '')
    my_squirrel6 = Squirrel(x_pos = 4243+((1/2) * screen_width), y_pos = 5235-15+((1/2) * screen_height), vel = 5.89, x1 = 4243+((1/2) * screen_width), y1 = 5235-15+((1/2) * screen_height), x2 = 3330+((1/2) * screen_width), y2 = 5370-15+((1/2) * screen_height), flip_squirrel = True, rotate_squirrel = 275, png_name = '')
    my_squirrel7 = Squirrel(x_pos = 2231-7+((1/2) * screen_width), y_pos = 3649+((1/2) * screen_height), vel = 5.5, x1 = 2231-7+((1/2) * screen_width), y1 = 3649+((1/2) * screen_height), x2 = 2450-7+((1/2) * screen_width), y2 = 2112+((1/2) * screen_height), flip_squirrel = True, rotate_squirrel = 345, png_name = '')
    my_squirrel8 = Squirrel(x_pos = 2890-67+((1/2) * screen_width), y_pos = 2973+((1/2) * screen_height), vel = 5.5, x1 = 2890-67+((1/2) * screen_width), y1 = 2973+((1/2) * screen_height), x2 = 2697-67+((1/2) * screen_width), y2 = 1594+((1/2) * screen_height), flip_squirrel = False, rotate_squirrel = 25, png_name = '')
    SQUIRRELS = [my_squirrel1, my_squirrel2, my_squirrel3, my_squirrel4, my_squirrel5, my_squirrel6, my_squirrel7, my_squirrel8]
    BOUNCIES = []
    MOVING_BOUNCIES = []
    ELEVATORS = []
    LEAVES = []
    ROOTS = []
    DRIPDROPS = []
    UPGRADES = []
    if all_current_save_data[31][0] == '0':
      my_upgrade5 = Upgrade(x_pos = 2611-34+((1/2) * screen_width), y_pos = 1149-34+((1/2) * screen_height), collected = False)
      UPGRADES = [my_upgrade5]
    WATER_REGIONS = []
    WATER_COVERS = []
    WATER_SURFACES = []
    IRREGULARLY_SHAPED_WATER = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    GRATES = []
    GOLDFISH = []
    TRANSPORT_PIPES = []
    SURF_BOARDS = []
    SURFING_RAT = []
    EATING_RAT = []
    WAVES = []
    BUCKETS = []
    FOOD = []
    GARBAGE_CAN = []
    THE_MACHINE = []
    TOOLS = []
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    TheDoor5_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 2592+((1/2) * screen_width) + 42.5, center_of_door_y = 6078+((1/2) * screen_height) + 42.5, difficulty = 4)
    SUB_LEVEL_DIFFICULTIES = [TheDoor5_sublevel_difficulty]
    TRASH = []
    SPINNY_OBJECTS = []
    TheDoor5 = SimplySprite(x_pos = 2592+((1/2) * screen_width), y_pos = 6078+((1/2) * screen_height), png_name = 'THE_DOOR')
    MY_SPRITES_FRONT = []
    MY_SPRITES_BACK = [TheDoor5]
    MOVING_SPRITE_FRONT = []
    MOVING_SPRITE_BACK = []
    GRASSES = []
    TV = []
    PROPELLERS = []
    LEVERS = []
    Hawk = []
    QueenAnt = []
    BEETLE_FRIEND = []
  #
  if new_region == 'AntHill':
    everything_save_data(True, 98, '1')
    if not My_cached_info.PlayingSewerTheme:
      pygame.mixer.music.load(My_cached_info.SewerThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = False
      My_cached_info.PlayingSewerTheme = True
    if forced_out:
      if old_map_spawn_index == 0:
        PLAYER.x_pos, PLAYER.y_pos = 2308, 30
        PLAYER.x_vel = abs(PLAYER.x_vel)
        if PLAYER.x_vel < 50:
          PLAYER.x_vel = 50
        ignore_the_rest = True
      if old_map_spawn_index == 1:
        PLAYER.x_pos, PLAYER.y_pos = 6225, 15
        PLAYER.x_vel = -abs(PLAYER.x_vel)
        if abs(PLAYER.x_vel) < 50:
          PLAYER.x_vel = -50
        ignore_the_rest = True
      if old_map_spawn_index == 2:
        PLAYER.x_pos, PLAYER.y_pos = 11888, 2928
        ignore_the_rest = True
      if old_map_spawn_index == 3: # TheDoor6 exit
        PLAYER.x_pos, PLAYER.y_pos = 430, 5750
        PLAYER.x_vel, PLAYER.y_vel = 0, 0
        ignore_the_rest = True
    if not forced_out:
      if MAP.spawn_location[old_map_spawn_index] == 3 and not ignore_the_rest: # TheDoor7 exit
        PLAYER.x_pos, PLAYER.y_pos = 4881, 1409
        PLAYER.x_vel, PLAYER.y_vel = 0, 0
      if MAP.spawn_location[old_map_spawn_index] == 4 and not ignore_the_rest: # TheDoor8 exit
        PLAYER.x_pos, PLAYER.y_pos = 963, 849
        PLAYER.x_vel, PLAYER.y_vel = 0, 0
      if MAP.spawn_location[old_map_spawn_index] == 5 and not ignore_the_rest: # TheDoor9 exit
        PLAYER.x_pos, PLAYER.y_pos = 3530, 2285
        PLAYER.x_vel, PLAYER.y_vel = 0, 0
    PLAYER.region = 'AntHill'
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[4881-20, 4881+85-69+20, 1409-20, 1409+85-69+20], [963-20, 963+85-69+20, 849-20, 849+85-69+20], [3530-20, 3530+85-69+20, 2285-20, 2285+85-69+20]], new_regions = [['TheDoor7'], ['TheDoor8'], ['TheDoor9']], spawn_location = [1, 1, 1], region = 'AntHill', forced_exit = True, forced_exit_points = [[922.6, 922.7, 5717.4, 5717.5], [6229, 6421, 0, 125], [11952-40, 12000, 2657, 3024], [2080, 2467, 0, 28]], forced_exit_next_map = [['TheDoor6'], ['Forest'], ['Sewer'], ['Forest']], png_name = 'ANTHILL')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_ANTHILL')
    BACKGROUND1 = Background(scroll_leftright = True, scroll_updown = True, iteration_speed = 11, scroll_speed_x = 0.04/10, scroll_speed_y = 0.04/10, scale = True, scale_size = (2000, 2000), permanent_add_x = 0, permanent_add_y = 0, use_convert_alpha = False, special_directions = 3, png_name = 'AntHill_BG')
    BACKGROUND = [BACKGROUND1]
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    MY_VINES = []
    CLOUDS = []
    TEETERTOTTERS = []
    my_key1 = AKey(x_pos = 1280+((1/2) * screen_width), y_pos = 832+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [1504+((1/2) * screen_width), 1659+((1/2) * screen_width), 777+((1/2) * screen_height), 935+((1/2) * screen_height)], is_inserted_xy = [3300+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 1, vel = 150, png_name1 = 'PINK_KEY', png_name2 = '')
    my_key2 = AKey(x_pos = 896+((1/2) * screen_width), y_pos = 4650+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [1087+((1/2) * screen_width), 1270+((1/2) * screen_width), 1256+((1/2) * screen_height), 4740+((1/2) * screen_height)], is_inserted_xy = [3300+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 1, vel = 150, png_name1 = 'BLUE_KEY', png_name2 = '')
    my_key3 = AKey(x_pos = 8944+((1/2) * screen_width), y_pos = 272+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [8097+((1/2) * screen_width), 8340+((1/2) * screen_width), 96+((1/2) * screen_height), 390+((1/2) * screen_height)], is_inserted_xy = [3300+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 1, vel = 150, png_name1 = 'ORANGE_KEY', png_name2 = '')
    my_key4 = AKey(x_pos = 2096+((1/2) * screen_width), y_pos = 3008+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [6200-150+((1/2) * screen_width), 6423+((1/2) * screen_width), 4067+((1/2) * screen_height), 4202+50+((1/2) * screen_height)], is_inserted_xy = [3300+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 1, vel = 150, png_name1 = 'RED_KEY', png_name2 = '')
    my_key5 = AKey(x_pos = 2976+((1/2) * screen_width), y_pos = 3408+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [2553+((1/2) * screen_width), 2868+((1/2) * screen_width), 2522+((1/2) * screen_height), 2735+((1/2) * screen_height)], is_inserted_xy = [3300+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 1, vel = 150, png_name1 = 'GREEN_KEY', png_name2 = '')
    my_key6 = AKey(x_pos = 15000+((1/2) * screen_width), y_pos = 15000+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [2553+((1/2) * screen_width), 2868+((1/2) * screen_width), 2522+((1/2) * screen_height), 2735+((1/2) * screen_height)], is_inserted_xy = [3300+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 1, vel = 150, png_name1 = 'YELLOW_KEY', png_name2 = '')
    my_key7 = AKey(x_pos = 8352+((1/2) * screen_width), y_pos = 4384+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [8538+((1/2) * screen_width), 8672+((1/2) * screen_width), 4020+((1/2) * screen_height), 4130+((1/2) * screen_height)], is_inserted_xy = [3300+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 1, vel = 150, png_name1 = 'BROWN_KEY', png_name2 = '')
    my_key8 = AKey(x_pos = 1632+((1/2) * screen_width), y_pos = 4768+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [1485+((1/2) * screen_width), 1656+((1/2) * screen_width), 4686+((1/2) * screen_height), 4834+((1/2) * screen_height)], is_inserted_xy = [3300+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 1, vel = 150, png_name1 = 'TEAL_KEY', png_name2 = '')
    my_key9 = AKey(x_pos = 8944+((1/2) * screen_width), y_pos = 848+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [8818+((1/2) * screen_width), 9022+((1/2) * screen_width), 832+((1/2) * screen_height), 974+((1/2) * screen_height)], is_inserted_xy = [3300+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 1, vel = 150, png_name1 = 'PURPLE_KEY', png_name2 = '')
    my_key10 = AKey(x_pos = 3136+((1/2) * screen_width), y_pos = 928+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [5123+((1/2) * screen_width), 5315+((1/2) * screen_width), 1556-200+((1/2) * screen_height), 1604+((1/2) * screen_height)], is_inserted_xy = [3300+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 3, vel = 150, png_name1 = 'GREY_KEY', png_name2 = '')
    ALLKEYS = [my_key1, my_key2, my_key3, my_key4, my_key5, my_key6, my_key7, my_key8, my_key9, my_key10]
    current_position_in_save_data = 1
    for SingleKey in ALLKEYS:
      if all_current_save_data[current_position_in_save_data][0] == '1' and current_position_in_save_data != 6:
        SingleKey.is_inserted = True
        SingleKey.x_pos = SingleKey.is_inserted_xy[0]
        SingleKey.y_pos = SingleKey.is_inserted_xy[1]
      current_position_in_save_data += 1
    my_door1 = Door(x_pos = 1664+((1/2) * screen_width), y_pos = 780+((1/2) * screen_height), is_open = False, is_open_x = 1664+((1/2) * screen_width), is_open_y = 780-180+((1/2) * screen_height), door_type = 1, png_name = 'PINK_DOOR')
    my_door2 = Door(x_pos = 1272+((1/2) * screen_width), y_pos = 4620+((1/2) * screen_height), is_open = False, is_open_x = 1272+((1/2) * screen_width), is_open_y = 4620-140+((1/2) * screen_height), door_type = 1, png_name = 'BLUE_DOOR')
    my_door3 = Door(x_pos = 8085+((1/2) * screen_width), y_pos = 191+((1/2) * screen_height), is_open = False, is_open_x = 8085+((1/2) * screen_width), is_open_y = 191-200+((1/2) * screen_height), door_type = 1, png_name = 'ORANGE_DOOR')
    my_door4 = Door(x_pos = 6424+((1/2) * screen_width), y_pos = 4057-5+((1/2) * screen_height), is_open = False, is_open_x = 6424+((1/2) * screen_width), is_open_y = 4057-150-5+((1/2) * screen_height), door_type = 1, png_name = 'RED_DOOR')
    my_door5 = Door(x_pos = 2705-5+((1/2) * screen_width), y_pos = 2472-11+((1/2) * screen_height), is_open = False, is_open_x = 2705-5-94.05+((1/2) * screen_width), is_open_y = 2472-11-124.45+((1/2) * screen_height), door_type = 1, png_name = 'GREEN_DOOR')
    my_door6 = Door(x_pos = 9549+((1/2) * screen_width), y_pos = 3342+((1/2) * screen_height), is_open = False, is_open_x = 9549+((1/2) * screen_width), is_open_y = 3342-120+((1/2) * screen_height), door_type = 3, png_name = 'YELLOW_DOOR')
    my_door7 = Door(x_pos = 8538+((1/2) * screen_width), y_pos = 4017+((1/2) * screen_height), is_open = False, is_open_x = 8538-145+((1/2) * screen_width), is_open_y = 4017+((1/2) * screen_height), door_type = 2, png_name = '')
    my_door8 = Door(x_pos = 1401+((1/2) * screen_width), y_pos = 4663+((1/2) * screen_height), is_open = False, is_open_x = 1401-60+((1/2) * screen_width), is_open_y = 4663+95+((1/2) * screen_height), door_type = 1, png_name = 'TEAL_DOOR')
    my_door9 = Door(x_pos = 8780+((1/2) * screen_width), y_pos = 832+((1/2) * screen_height), is_open = False, is_open_x = 8780+((1/2) * screen_width), is_open_y = 832-100+((1/2) * screen_height), door_type = 1, png_name = 'PURPLE_DOOR')
    my_door10 = Door(x_pos = 5133+((1/2) * screen_width), y_pos = 1431+((1/2) * screen_height), is_open = False, is_open_x = 5133+201+((1/2) * screen_width), is_open_y = 1431-146+((1/2) * screen_height), door_type = 1, png_name = 'GREY_DOOR')
    DOORS = [my_door1, my_door2, my_door3, my_door4, my_door5, my_door6, my_door7, my_door8, my_door9, my_door10]
    if all_current_save_data[6][0] == '2':
      DOORS[5].is_open = True
      DOORS[5].is_really_open = True
    DOORS_WITH_KNOB = []
    Ant1 = Ant(x_pos = 936+((1/2)*screen_width),   y_pos = 664+((1/2)*screen_height),  vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [410+((1/2)*screen_width), 1690+((1/2)*screen_width), 520+((1/2)*screen_height), 940+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    Ant2 = Ant(x_pos = 592+((1/2)*screen_width),    y_pos = 4164+((1/2)*screen_height), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [50+((1/2)*screen_width), 1312+((1/2)*screen_width), 3352+((1/2)*screen_height), 4768+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    Ant3 = Ant(x_pos = 2244+((1/2)*screen_width),   y_pos = 2808+((1/2)*screen_height), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [1776+((1/2)*screen_width), 2980+((1/2)*screen_width), 2544+((1/2)*screen_height), 3144+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    Ant4 = Ant(x_pos = 3000+((1/2)*screen_width),   y_pos = 2000+((1/2)*screen_height), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [2415+((1/2)*screen_width), 4020+((1/2)*screen_width), 1656+((1/2)*screen_height), 2376+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    Ant5 = Ant(x_pos = 4464+((1/2)*screen_width),   y_pos = 3804+((1/2)*screen_height), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [2530+((1/2)*screen_width), 6276+((1/2)*screen_width), 3108+((1/2)*screen_height), 4570+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    Ant6 = Ant(x_pos = 5715+((1/2)*screen_width),   y_pos = 2144+((1/2)*screen_height), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [4350+((1/2)*screen_width), 7616+((1/2)*screen_width), 1472+((1/2)*screen_height), 2550+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    Ant7 = Ant(x_pos = 8244+((1/2)*screen_width),   y_pos = 3660+((1/2)*screen_height),  vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [7192+((1/2)*screen_width), 9512+((1/2)*screen_width), 3248+((1/2)*screen_height), 4024+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    Ant8 = Ant(x_pos = 9168+((1/2)*screen_width),   y_pos = 1728+((1/2)*screen_height), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [8890+((1/2)*screen_width), 9430+((1/2)*screen_width), 816+((1/2)*screen_height), 2652+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    Ant9 = Ant(x_pos = 8511+((1/2)*screen_width),   y_pos = 348+((1/2)*screen_height), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [8286+((1/2)*screen_width), 9060+((1/2)*screen_width), 40+((1/2)*screen_height), 750+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    Ant10 = Ant(x_pos = 10768+((1/2)*screen_width),  y_pos = 3840+((1/2)*screen_height), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [10400+((1/2)*screen_width), 11332+((1/2)*screen_width), 2480+((1/2)*screen_height), 4584+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    Ant14 = Ant(x_pos = 2220+((1/2)*screen_width),  y_pos = 5600+((1/2)*screen_height), vel = random.randint(25,35) / 10, vel_multiplier = 1, check_x_range = 1000, check_y_range = 1000, frequency_of_key_check = 40, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 2, boundaries = [80+((1/2)*screen_width), 3120+((1/2)*screen_width), 5260+((1/2)*screen_height), 5980+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    ANTS = [Ant1, Ant2, Ant3, Ant4, Ant5, Ant6, Ant7, Ant8, Ant9, Ant10, Ant14]
    #GoldenAnt = PlayerMoverAnt(x_pos = 2440+((1/2) * screen_width), y_pos = 5660+((1/2) * screen_width), x_dest = 1110, y_dest = 5682, vision_range_x = 20000, vision_range_y = 20000, ignore_pickup_range = [[0, 1540, 5320, 6000], [5899, 11782, 0, 1930]], vel = random.randint(10,15) / 10, vel_multiplier = 8, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, png_name1 = 'AntHill/GoldenAnt/AllAnt2.png', png_name2 = 'AntHill/GoldenAnt/AllAnt3.png')
    PLAYER_MOVER_ANTS = []
    SQUIRRELS = []
    BOUNCIES = []
    MOVING_BOUNCIES = []
    ELEVATORS = []
    LEAVES = []
    my_root1 = Root(x_pos = 8250+((1/2)*screen_width), y_pos = 485+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root2 = Root(x_pos = 8583+((1/2)*screen_width), y_pos = 643+50+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root3 = Root(x_pos = 9300+((1/2)*screen_width), y_pos = 3461+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root4 = Root(x_pos = 8780+((1/2)*screen_width), y_pos = 3461+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root5 = Root(x_pos = 8528+((1/2)*screen_width), y_pos = 3461+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root6 = Root(x_pos = 7729+((1/2)*screen_width), y_pos = 3623+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root7 = Root(x_pos = 8057+((1/2)*screen_width), y_pos = 3620+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root8 = Root(x_pos = 3198+((1/2)*screen_width), y_pos = 3320+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root9 = Root(x_pos = 3727+((1/2)*screen_width), y_pos = 3434+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root10 = Root(x_pos = 4037+((1/2)*screen_width), y_pos = 3302+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root11 = Root(x_pos = 4302+((1/2)*screen_width), y_pos = 3709+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root12 = Root(x_pos = 4662+((1/2)*screen_width), y_pos = 3940+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root13 = Root(x_pos = 5358+((1/2)*screen_width), y_pos = 4096+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root14 = Root(x_pos = 2927+((1/2)*screen_width), y_pos = 3489+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    #
    my_root15 = Root(x_pos = 8944+((1/2)*screen_width), y_pos = 954+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root16 = Root(x_pos = 9207+((1/2)*screen_width), y_pos = 1181+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root17 = Root(x_pos = 8920+((1/2)*screen_width), y_pos = 1392+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root18 = Root(x_pos = 9138+((1/2)*screen_width), y_pos = 1627+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root19 = Root(x_pos = 9105+((1/2)*screen_width), y_pos = 1795+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root20 = Root(x_pos = 8976+((1/2)*screen_width), y_pos = 2013+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root21 = Root(x_pos = 9207+((1/2)*screen_width), y_pos = 2271+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root22 = Root(x_pos = 8976+((1/2)*screen_width), y_pos = 2475+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    #
    my_root23 = Root(x_pos = 5141+((1/2)*screen_width), y_pos = 1689+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root24 = Root(x_pos = 4899+((1/2)*screen_width), y_pos = 1939+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root25 = Root(x_pos = 5154+((1/2)*screen_width), y_pos = 2192+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root26 = Root(x_pos = 4881+((1/2)*screen_width), y_pos = 2380+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root27 = Root(x_pos = 6055+((1/2)*screen_width), y_pos = 1656+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root28 = Root(x_pos = 5647+((1/2)*screen_width), y_pos = 1858+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root29 = Root(x_pos = 5717+((1/2)*screen_width), y_pos = 2029+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root30 = Root(x_pos = 6072+((1/2)*screen_width), y_pos = 2219+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root31 = Root(x_pos = 5707+((1/2)*screen_width), y_pos = 2379+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root32 = Root(x_pos = 6016+((1/2)*screen_width), y_pos = 2513+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root33 = Root(x_pos = 6850+((1/2)*screen_width), y_pos = 1601+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root34 = Root(x_pos = 6555+((1/2)*screen_width), y_pos = 1891+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root35 = Root(x_pos = 6899+((1/2)*screen_width), y_pos = 2129+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root36 = Root(x_pos = 6587+((1/2)*screen_width), y_pos = 2370+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root37 = Root(x_pos = 6874+((1/2)*screen_width), y_pos = 2562+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root38 = Root(x_pos = 10611+((1/2)*screen_width), y_pos = 2704+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root39 = Root(x_pos = 10955+((1/2)*screen_width), y_pos = 2782+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root40 = Root(x_pos = 241+((1/2)*screen_width), y_pos = 3745+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root41 = Root(x_pos = 337+((1/2)*screen_width), y_pos = 4116+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root42 = Root(x_pos = 879+((1/2)*screen_width), y_pos = 4425+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root43 = Root(x_pos = 22+((1/2)*screen_width), y_pos = 3018+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root44 = Root(x_pos = 574+((1/2)*screen_width), y_pos = 2821+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root45 = Root(x_pos = 793+((1/2)*screen_width), y_pos = 1878+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root46 = Root(x_pos = 781+((1/2)*screen_width), y_pos = 1291+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    my_root47 = Root(x_pos = 279+((1/2)*screen_width), y_pos = 3419+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 120, png_name = 'Root1/')
    my_root48 = Root(x_pos = 105+((1/2)*screen_width), y_pos = 3419+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 120, png_name = 'Root1/')
    my_root49 = Root(x_pos = 620+((1/2)*screen_width), y_pos = 929+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 120, png_name = 'Root1/')
    my_root50 = Root(x_pos = 410+((1/2)*screen_width), y_pos = 929+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 120, png_name = 'Root1/')
    #
    my_root51 = Root(x_pos = 3942+((1/2)*screen_width), y_pos = 3072+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 120, png_name = 'Root1/')
    ROOTS = [my_root1, my_root2, my_root3, my_root4, my_root5, my_root6, my_root7, my_root8, my_root9, my_root10, my_root11, my_root12, my_root13, my_root14, my_root15, my_root16, my_root17, my_root18, my_root19, my_root20, my_root21, my_root22, my_root23, my_root24, my_root25, my_root26, my_root27, my_root28, my_root29, my_root30, my_root31, my_root32, my_root33, my_root34, my_root35, my_root36, my_root37, my_root38, my_root39, my_root40, my_root41, my_root42, my_root43, my_root44, my_root45, my_root46, my_root47, my_root48, my_root49, my_root50, my_root51]
    DRIPDROPS = []
    UPGRADES = []
    WATER_REGIONS = []
    WATER_COVERS = []
    WATER_SURFACES = []
    TopOfWaterFall = IrregularlyShapedWater(x_pos = 11384+((1/2)*screen_width), y_pos = 2945+((1/2) * screen_height), water_Fx = -200, water_Fy = 0, png_name = 'TOP_OF_WATER_FALL')
    WaterBeginningToFall = IrregularlyShapedWater(x_pos = 11249+((1/2)*screen_width), y_pos = 2945+((1/2) * screen_height), water_Fx = -150, water_Fy = 400, png_name = 'WATER_BEGINNING_TO_FALL')
    TopOfFallingWater = IrregularlyShapedWater(x_pos = 11158+((1/2)*screen_width), y_pos = 3025+1+((1/2) * screen_height), water_Fx = -50, water_Fy = 1000, png_name = 'TOP_OF_FALLING_WATER')
    MiddleOfFallingWater = IrregularlyShapedWater(x_pos = 11158+((1/2)*screen_width), y_pos = 3025+1+500+((1/2) * screen_height), water_Fx = -50, water_Fy = 1000, png_name = 'MIDDLE_OF_FALLING_WATER')
    BottomOfFallingWater = IrregularlyShapedWater(x_pos = 11158+((1/2)*screen_width), y_pos = 3025+1+1000+((1/2) * screen_height), water_Fx = -50, water_Fy = 1000, png_name = 'BOTTOM_OF_FALLING_WATER')
    BottomLake = IrregularlyShapedWater(x_pos = 10646+((1/2)*screen_width), y_pos = 4446+1+((1/2) * screen_height), water_Fx = -50, water_Fy = 0, png_name = 'BOTTOM_LAKE')
    FirstJourneyDownTunnel = IrregularlyShapedWater(x_pos = 10316+((1/2)*screen_width), y_pos = 4476+1+((1/2) * screen_height), water_Fx = -150, water_Fy = 500, png_name = 'FIRST_JOURNEY_DOWN_TUNNEL')
    SecondJourneyDownTunnel = IrregularlyShapedWater(x_pos = 9964+((1/2)*screen_width), y_pos = 4626+1+((1/2) * screen_height), water_Fx = -150, water_Fy = 500, png_name = 'SECOND_JOURNEY_DOWN_TUNNEL')
    ThirdJourneyDownTunnel = IrregularlyShapedWater(x_pos = 9629+((1/2)*screen_width), y_pos = 4831+1+((1/2) * screen_height), water_Fx = -150, water_Fy = 500, png_name = 'THIRD_JOURNEY_DOWN_TUNNEL')
    FourthJourneyDownTunnel = IrregularlyShapedWater(x_pos = 9344+((1/2)*screen_width), y_pos = 4950+1+((1/2) * screen_height), water_Fx = -150, water_Fy = 500, png_name = 'FOURTH_JOURNEY_DOWN_TUNNEL')
    FifthJourneyDownTunnel = IrregularlyShapedWater(x_pos = 9147+((1/2)*screen_width), y_pos = 5195+1+((1/2) * screen_height), water_Fx = -150, water_Fy = 500, png_name = 'FIFTH_JOURNEY_DOWN_TUNNEL')
    SixthJourneyDownTunnel = IrregularlyShapedWater(x_pos = 8937+((1/2)*screen_width), y_pos = 5420+1+((1/2) * screen_height), water_Fx = -150, water_Fy = 500, png_name = 'SIXTH_JOURNEY_DOWN_TUNNEL')
    SeventhJourneyDownTunnel = IrregularlyShapedWater(x_pos = 8780+((1/2)*screen_width), y_pos = 5662+1+((1/2) * screen_height), water_Fx = -150, water_Fy = 500, png_name = 'SEVENTH_JOURNEY_DOWN_TUNNEL')
    BottomOfWaterFall = IrregularlyShapedWater(x_pos = 8081+((1/2)*screen_width), y_pos = 5820+1+((1/2) * screen_height), water_Fx = 0, water_Fy = 0, png_name = 'BOTTOM_OF_WATER_FALL')
    IRREGULARLY_SHAPED_WATER = [TopOfWaterFall, WaterBeginningToFall, TopOfFallingWater, MiddleOfFallingWater, BottomOfFallingWater, BottomLake, FirstJourneyDownTunnel, SecondJourneyDownTunnel, ThirdJourneyDownTunnel, FourthJourneyDownTunnel, FifthJourneyDownTunnel, SixthJourneyDownTunnel, SeventhJourneyDownTunnel, BottomOfWaterFall]
    SEWER_PUMP_WATER = []
    LEAKS = []
    GRATES = []
    GOLDFISH = []
    TRANSPORT_PIPES = []
    SURF_BOARDS = []
    SURFING_RAT = []
    EATING_RAT = []
    WAVES = []
    BUCKETS = []
    FOOD = []
    GARBAGE_CAN = []
    THE_MACHINE = []
    TOOLS = []
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    TheDoor7_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 4881+((1/2) * screen_width) + 42.5, center_of_door_y = 1409+((1/2) * screen_height) + 42.5, difficulty = 3)
    TheDoor8_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 963+((1/2) * screen_width) + 42.5, center_of_door_y = 849+((1/2) * screen_height) + 42.5, difficulty = 1)
    TheDoor9_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 3530+((1/2) * screen_width) + 42.5, center_of_door_y = 2285+((1/2) * screen_height) + 42.5, difficulty = 2)
    SUB_LEVEL_DIFFICULTIES = [TheDoor7_sublevel_difficulty, TheDoor8_sublevel_difficulty, TheDoor9_sublevel_difficulty]
    TRASH = []
    SPINNY_OBJECTS = []
    TheDoor7 = SimplySprite(x_pos = 4881+((1/2) * screen_width), y_pos = 1409+((1/2) * screen_height), png_name = 'THE_DOOR')
    TheDoor8 = SimplySprite(x_pos = 963+((1/2) * screen_width), y_pos = 849+((1/2) * screen_height), png_name = 'THE_DOOR')
    TheDoor9 = SimplySprite(x_pos = 3530+((1/2) * screen_width), y_pos = 2285+((1/2) * screen_height), png_name = 'THE_DOOR')
    SewerWater1 = SimplySprite(x_pos = 8080+((1/2) * screen_width), y_pos = 2945+((1/2) * screen_height), png_name = 'SEWER_WATER1')
    BigRoot = SimplySprite(x_pos = 0+((1/2) * screen_width), y_pos = 0+((1/2) * screen_height), png_name = 'BIG_ROOT')
    MY_SPRITES_FRONT = []
    MY_SPRITES_BACK = [BigRoot, TheDoor7, TheDoor8, TheDoor9, SewerWater1]
    SewerWater2 = MovingSprite(x_pos = 8080+((1/2) * screen_width), y_pos = 2945+((1/2) * screen_height), number_of_frames = 3, current_frame = 0, frame_duration = 8, png_name = 'SEWER_WATER2')
    MOVING_SPRITE_FRONT = [SewerWater2]
    MOVING_SPRITE_BACK = []
    Grass1 = Grass(x_pos = 801+((1/2) * screen_width), y_pos = 837+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass2 = Grass(x_pos = 878+((1/2) * screen_width), y_pos = 837+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass3 = Grass(x_pos = 163+((1/2) * screen_width), y_pos = 4642+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass4 = Grass(x_pos = 849+((1/2) * screen_width), y_pos = 4642+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass5 = Grass(x_pos = 914+((1/2) * screen_width), y_pos = 4642+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass6 = Grass(x_pos = 1915+((1/2) * screen_width), y_pos = 4313+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass7 = Grass(x_pos = 2429+((1/2) * screen_width), y_pos = 4157+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass8 = Grass(x_pos = 2939+((1/2) * screen_width), y_pos = 4183+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R30')
    Grass9 = Grass(x_pos = 3474+((1/2) * screen_width), y_pos = 4344+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass10 = Grass(x_pos = 4305+((1/2) * screen_width), y_pos = 4402+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass11 = Grass(x_pos = 4376+((1/2) * screen_width), y_pos = 4415+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R10')
    Grass12 = Grass(x_pos = 5211+((1/2) * screen_width), y_pos = 4423+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R10')
    Grass13 = Grass(x_pos = 5292+((1/2) * screen_width), y_pos = 4415+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass14 = Grass(x_pos = 6682+((1/2) * screen_width), y_pos = 4042+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass15 = Grass(x_pos = 6752+((1/2) * screen_width), y_pos = 4019+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass16 = Grass(x_pos = 7679+((1/2) * screen_width), y_pos = 3870+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass17 = Grass(x_pos = 9506+((1/2) * screen_width), y_pos = 3841+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass18 = Grass(x_pos = 9585+((1/2) * screen_width), y_pos = 3791+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R30')
    Grass19 = Grass(x_pos = 10070+((1/2) * screen_width), y_pos = 3341+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass20 = Grass(x_pos = 2468+((1/2) * screen_width), y_pos = 3024+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass21 = Grass(x_pos = 1850+((1/2) * screen_width), y_pos = 2939+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R30')
    Grass22 = Grass(x_pos = 2662+((1/2) * screen_width), y_pos = 2206+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass23 = Grass(x_pos = 3231+((1/2) * screen_width), y_pos = 2273+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass24 = Grass(x_pos = 4686+((1/2) * screen_width), y_pos = 2373+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass25 = Grass(x_pos = 5579+((1/2) * screen_width), y_pos = 2572+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R10')
    Grass26 = Grass(x_pos = 6308+((1/2) * screen_width), y_pos = 2590+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass27 = Grass(x_pos = 6596+((1/2) * screen_width), y_pos = 2590+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass28 = Grass(x_pos = 7496+((1/2) * screen_width), y_pos = 2921+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R30')
    Grass29 = Grass(x_pos = 9442+((1/2) * screen_width), y_pos = 2554+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass30 = Grass(x_pos = 7856+((1/2) * screen_width), y_pos = 1006+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass31 = Grass(x_pos = 8444+((1/2) * screen_width), y_pos = 854+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass32 = Grass(x_pos = 7699+((1/2) * screen_width), y_pos = 275+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass33 = Grass(x_pos = 6868+((1/2) * screen_width), y_pos = 361+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass34 = Grass(x_pos = 6038+((1/2) * screen_width), y_pos = 346+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R30')
    Grass35 = Grass(x_pos = 8493+((1/2) * screen_width), y_pos = 4363+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass36 = Grass(x_pos = 7675+((1/2) * screen_width), y_pos = 4923+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R10')
    Grass37 = Grass(x_pos = 6682+((1/2) * screen_width), y_pos = 5048+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R30')
    Grass38 = Grass(x_pos = 6043+((1/2) * screen_width), y_pos = 5291+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass39 = Grass(x_pos = 7554+((1/2) * screen_width), y_pos = 5469+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass40 = Grass(x_pos = 6557+((1/2) * screen_width), y_pos = 5708+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass41 = Grass(x_pos = 5740+((1/2) * screen_width), y_pos = 5611+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass42 = Grass(x_pos = 4928+((1/2) * screen_width), y_pos = 5547+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass43 = Grass(x_pos = 4154+((1/2) * screen_width), y_pos = 5157+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass44 = Grass(x_pos = 2673+((1/2) * screen_width), y_pos = 5037+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass45 = Grass(x_pos = 1807+((1/2) * screen_width), y_pos = 4841+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R30')
    Grass46 = Grass(x_pos = 3010+((1/2) * screen_width), y_pos = 5703+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass47 = Grass(x_pos = 1977+((1/2) * screen_width), y_pos = 5798+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass48 = Grass(x_pos = 214+((1/2) * screen_width), y_pos = 5841+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R10')
    Grass49 = Grass(x_pos = 112+((1/2) * screen_width), y_pos = 5850+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    GRASSES = [Grass1, Grass2, Grass3, Grass4, Grass5, Grass6, Grass7, Grass8, Grass9, Grass10, Grass11, Grass12, Grass13, Grass14, Grass15, Grass16, Grass17, Grass18, Grass19, Grass20, Grass21, Grass22, Grass23, Grass24, Grass25, Grass26, Grass27, Grass28, Grass29, Grass30, Grass31, Grass32, Grass33, Grass34, Grass35, Grass36, Grass37, Grass38, Grass39, Grass40, Grass41, Grass42, Grass43, Grass44, Grass45, Grass46, Grass47, Grass48, Grass49]
    TV = []
    PROPELLERS = []
    LEVERS = []
    Hawk = []
    QueenAnt = QueenAntClass(x_pos = 425 + ((1/2) * screen_width), y_pos = 5619+12 + ((1/2) * screen_height), png_name1 = 'AntHill/QueenAnt/QueenAnt1.png', png_name2 = 'AntHill/QueenAnt/QueenAnt2.png', mouth_png_name = 'AntHill/QueenAnt/QueenAntMouth.png', butt_png_name = 'AntHill/QueenAnt/QueenAntButt.png')
    BEETLE_FRIEND = Beetle(x_pos = 628+((1/2)*screen_width), y_pos = 4682+((1/2)*screen_height), rotation = 5)
    beetle_position_data = all_current_save_data[13][0]
    if beetle_position_data == '0':
      pass
    if beetle_position_data == '1':
      BEETLE_FRIEND.stage_in_movement = 2
      BEETLE_FRIEND.substep = 31
      BEETLE_FRIEND.time_since_last_substep = 269
      BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter - BEETLE_FRIEND.time_since_last_substep
      BEETLE_FRIEND.x_pos = 6774.564001966768 - (1536/2) + ((1/2) * screen_width)
      BEETLE_FRIEND.y_pos = 4579.0 - (864/2) + ((1/2) * screen_height)
      BEETLE_FRIEND.rotation = -5
    if beetle_position_data == '2':
      BEETLE_FRIEND.stage_in_movement = 3
      BEETLE_FRIEND.substep = 22
      BEETLE_FRIEND.time_since_last_substep = 278
      BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter - BEETLE_FRIEND.time_since_last_substep
      BEETLE_FRIEND.x_pos = 8052.437167228389 - (1536/2) + ((1/2) * screen_width)
      BEETLE_FRIEND.y_pos = 4111.071737314156 - (864/2) + ((1/2) * screen_height)
      BEETLE_FRIEND.rotation = -4.1
    if beetle_position_data == '3':
      BEETLE_FRIEND.stage_in_movement = 5
      BEETLE_FRIEND.substep = 22
      BEETLE_FRIEND.time_since_last_substep = 256
      BEETLE_FRIEND.frame_at_last_substep = My_cached_info.fake_frame_counter - BEETLE_FRIEND.time_since_last_substep
      BEETLE_FRIEND.x_pos = 1659.2744446199326 - (1536/2) + ((1/2) * screen_width)
      BEETLE_FRIEND.y_pos = 6091.833260309422 - (864/2) + ((1/2) * screen_height)
      BEETLE_FRIEND.rotation = 135
      BEETLE_FRIEND.eaten = 3
  #
  if new_region == 'TheDoor6': # inside queen ant
    if not My_cached_info.PlayingSewerTheme:
      pygame.mixer.music.load(My_cached_info.SewerThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = False
      My_cached_info.PlayingSewerTheme = True
    if forced_out: # restart the sublevel
      PLAYER.x_pos, PLAYER.y_pos = 9889, 6
      PLAYER.x_vel, PLAYER.y_vel = 0, 0
      ignore_the_rest = True
    if not ignore_the_rest:
      if MAP.spawn_location[old_map_spawn_index] == 1: # esophagus entrance
        PLAYER.x_pos, PLAYER.y_pos = 9889, 6
        PLAYER.x_vel, PLAYER.y_vel = 0, 0
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [], new_regions = [], spawn_location = [], region = 'TheDoor6', forced_exit = True, forced_exit_points = [[0, 10069, 3458, 4069], [0,0,0,0], [0,0,0,0], [0, 48, 0, 4000]], forced_exit_next_map = [['TheDoor6', 666], [''], [''], ['AntHill', 666]], png_name = 'THE_DOOR6')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_THE_DOOR6')
    BACKGROUND = []
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    my_vine1 = Vine(x_pos = 3000+((1/2) * screen_width), y_pos = 2740+((1/2) * screen_height), vine_length = 15, vine_segment_length = 18, rotation = 270, angular_accel = 0, angular_vel = 20, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 25, png_name = 'UVULAVINE', vine_type = 1)
    my_vine2 = Vine(x_pos = 1650+((1/2) * screen_width), y_pos = 2803+((1/2) * screen_height), vine_length = 15, vine_segment_length = 18, rotation = 270, angular_accel = 0, angular_vel = 20, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 25, png_name = 'UVULAVINE', vine_type = 1)
    my_vine3 = Vine(x_pos = 800+((1/2) * screen_width), y_pos = 2420+((1/2) * screen_height), vine_length = 15, vine_segment_length = 18, rotation = 285, angular_accel = 0, angular_vel = 30, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 40, png_name = 'UVULAVINE', vine_type = 1)
    my_vine4 = Vine(x_pos = 900+((1/2) * screen_width), y_pos = 2443+((1/2) * screen_height), vine_length = 15, vine_segment_length = 18, rotation = 278.6, angular_accel = 0, angular_vel = 30, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 40, png_name = 'UVULAVINE', vine_type = 1)
    my_vine5 = Vine(x_pos = 1050+((1/2) * screen_width), y_pos = 2423-9+((1/2) * screen_height), vine_length = 15, vine_segment_length = 18, rotation = 270, angular_accel = 0, angular_vel = 30, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 40, png_name = 'UVULAVINE', vine_type = 1)
    my_vine6 = Vine(x_pos = 1180+((1/2) * screen_width), y_pos = 2407-19+((1/2) * screen_height), vine_length = 15, vine_segment_length = 18, rotation = 271, angular_accel = 0, angular_vel = 30, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 40, png_name = 'UVULAVINE', vine_type = 1)
    my_vine7 = Vine(x_pos = 2200+((1/2) * screen_width), y_pos = 2226-10+((1/2) * screen_height), vine_length = 21, vine_segment_length = 18, rotation = 285, angular_accel = 0, angular_vel = 30, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 40, png_name = 'UVULAVINE', vine_type = 1)
    MY_VINES = [my_vine1, my_vine2, my_vine3, my_vine4, my_vine5, my_vine6, my_vine7]
    CLOUDS = []
    TEETERTOTTERS = []
    ALLKEYS = []
    DOORS = []
    DOORS_WITH_KNOB = []
    ANTS = []
    PLAYER_MOVER_ANTS = []
    SQUIRRELS = []
    BOUNCIES = []
    MovingBouncy1 = MovingBouncyObject(x_pos = 8560+((1/2) * screen_width), y_pos = 3385+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 400, path_x = [400*math.sin(math.radians(x/3)) for x in range(0-380, 1080-380)], path_y = [20*math.sin(math.radians(x*2)) for x in range(180)], path_rotation = [16*math.sin(math.radians(x*3)) for x in range(120)], collision_circle_x = 8960+70, collision_circle_y = 3430+70, collision_circle_radius = 110, png_name = 'SQUARE_BOUNCY_MUSHROOM')
    MovingBouncy2 = MovingBouncyObject(x_pos = 6774+((1/2) * screen_width), y_pos = 3389+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 400, path_x = [-400*math.sin(math.radians(x/3)) for x in range(0-580, 1080-580)], path_y = [20*math.sin(math.radians(x*2)) for x in range(180)], path_rotation = [16*math.sin(math.radians(x*3)) for x in range(120)], collision_circle_x = 8960+70, collision_circle_y = 3430+70, collision_circle_radius = 110, png_name = 'SQUARE_BOUNCY_MUSHROOM')
    MovingBouncy3 = MovingBouncyObject(x_pos = 5454+((1/2) * screen_width), y_pos = 3389+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 400, path_x = [480*math.sin(math.radians(x/3)) for x in range(0-580, 1080-580)], path_y = [20*math.sin(math.radians(x*2)) for x in range(180)], path_rotation = [16*math.sin(math.radians(x*3)) for x in range(120)], collision_circle_x = 8960+70, collision_circle_y = 3430+70, collision_circle_radius = 110, png_name = 'SQUARE_BOUNCY_MUSHROOM')
    MovingBouncy4 = MovingBouncyObject(x_pos = 3600+((1/2) * screen_width), y_pos = 3306+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 400, path_x = [-480*math.sin(math.radians(x/3)) for x in range(0-780, 1080-780)], path_y = [20*math.sin(math.radians(x*2)) for x in range(180)], path_rotation = [16*math.sin(math.radians(x*3)) for x in range(120)], collision_circle_x = 8960+70, collision_circle_y = 3430+70, collision_circle_radius = 110, png_name = 'SQUARE_BOUNCY_MUSHROOM')
    MovingBouncy5 = MovingBouncyObject(x_pos = 2200+((1/2) * screen_width), y_pos = 3306+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 400, path_x = [-300*math.sin(math.radians(x/3)) for x in range(0-300, 1080-300)], path_y = [20*math.sin(math.radians(x*2)) for x in range(180)], path_rotation = [16*math.sin(math.radians(x*3)) for x in range(120)], collision_circle_x = 8960+70, collision_circle_y = 3430+70, collision_circle_radius = 110, png_name = 'SQUARE_BOUNCY_MUSHROOM')
    MovingBouncy6 = MovingBouncyObject(x_pos = 1000+((1/2) * screen_width), y_pos = 3306+((1/2) * screen_height), elasticity_x = 1, elasticity_y = 1000, max_x_vel = 600, max_y_vel = 700, path_x = [170*math.sin(math.radians(x/3)) for x in range(0-480, 1080-480)], path_y = [20*math.sin(math.radians(x*2)) for x in range(180)], path_rotation = [16*math.sin(math.radians(x*3)) for x in range(120)], collision_circle_x = 8960+70, collision_circle_y = 3430+70, collision_circle_radius = 110, png_name = 'SQUARE_BOUNCY_MUSHROOM')
    MOVING_BOUNCIES = [MovingBouncy1, MovingBouncy2, MovingBouncy3, MovingBouncy4, MovingBouncy5, MovingBouncy6]
    ELEVATORS = []
    LEAVES = []
    ROOTS = []
    DRIPDROPS = []
    UPGRADES = []
    WATER_REGIONS = []
    WATER_COVERS = []
    WATER_SURFACES = []
    IRREGULARLY_SHAPED_WATER = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    GRATES = []
    GOLDFISH = []
    TRANSPORT_PIPES = []
    SURF_BOARDS = []
    SURFING_RAT = []
    EATING_RAT = []
    WAVES = []
    BUCKETS = []
    FOOD = []
    GARBAGE_CAN = []
    THE_MACHINE = []
    TOOLS = []
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    SUB_LEVEL_DIFFICULTIES = []
    TRASH = []
    SPINNY_OBJECTS = []
    WaterSprite1 = MovingSprite(x_pos = 7804+((1/2) * screen_width), y_pos = 3368+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 15, png_name = 'WATER_SPRITE1')
    WaterSprite2 = MovingSprite(x_pos = 4712+((1/2) * screen_width), y_pos = 3381+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 15, png_name = 'WATER_SPRITE2')
    WaterSprite3 = MovingSprite(x_pos = 534+((1/2) * screen_width), y_pos = 3333+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 15, png_name = 'WATER_SPRITE3')
    MY_SPRITES_FRONT = []
    MY_SPRITES_BACK = []
    MOVING_SPRITE_FRONT = [WaterSprite1, WaterSprite2, WaterSprite3]
    MOVING_SPRITE_BACK = []
    GRASSES = []
    TV = []
    PROPELLERS = []
    LEVERS = []
    Hawk = []
    QueenAnt = []
    should_beetle_spawn = all_current_save_data[17][0]
    if should_beetle_spawn == '0':
      BEETLE_FRIEND = Beetle(x_pos = 9446+((1/2)*screen_width), y_pos = 3345+((1/2)*screen_height), rotation = -9.5)
    if should_beetle_spawn == '1':
      BEETLE_FRIEND = []
  #
  if new_region == 'TheDoor7': # elevator level
    if not My_cached_info.PlayingSewerTheme:
      pygame.mixer.music.load(My_cached_info.SewerThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = False
      My_cached_info.PlayingSewerTheme = True
    if MAP.spawn_location[old_map_spawn_index] == 1:
      PLAYER.x_pos, PLAYER.y_pos = 638, 959
      PLAYER.x_vel, PLAYER.y_vel = 0, 0
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[638-20, 638+85-69+20, 959-20, 959+85-69+20]], new_regions = [['AntHill']], spawn_location = [3], region = 'TheDoor7', forced_exit = True, forced_exit_points = [], forced_exit_next_map = [], png_name = 'THE_DOOR7')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_THE_DOOR7')
    BACKGROUND = []
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    MY_VINES = []
    CLOUDS = []
    TEETERTOTTERS = []
    my_key1 = AKey(x_pos = 1120+((1/2) * screen_width), y_pos = 992+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [3008+((1/2) * screen_width), 4200+((1/2) * screen_width), 5184+((1/2) * screen_height), 6000+((1/2) * screen_height)], is_inserted_xy = [8800+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 1, vel = 150, png_name1 = 'PINK_KEY', png_name2 = '')
    ALLKEYS = [my_key1]
    my_door1 = Door(x_pos = 3459+((1/2) * screen_width), y_pos = 5228+((1/2) * screen_height), is_open = False, is_open_x = 3459+((1/2) * screen_width), is_open_y = 5226-150-150+((1/2) * screen_height), door_type = 1, png_name = 'PINK_DOOR')
    DOORS = [my_door1]
    DOORS_WITH_KNOB = []
    Ant1 = Ant(x_pos = 2064+((1/2) * screen_width),   y_pos = 1250+((1/2) * screen_height), check_x_range = 20000, check_y_range = 20000,  vel = 1.0, vel_multiplier = 8, frequency_of_key_check = 1, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, ant_type = 1, boundaries = [0+((1/2)*screen_width), MAP.rect[2]+((1/2)*screen_width), 0+((1/2)*screen_height), MAP.rect[3]+((1/2)*screen_height)], png_name1 = 'ANT1', png_name2 = 'ANT1')
    ANTS = [Ant1]
    GreyAnt = PlayerMoverAnt(x_pos = 2064+((1/2) * screen_width), y_pos = 1250+((1/2) * screen_height), x_dest = 1000, y_dest = 992, vision_range_x = 20000, vision_range_y = 20000, ignore_pickup_range = [[0, 1190, 0, 1066]], vel = 1.0, vel_multiplier = 8, rotation = random.randint(0,359), frames_per_image_update = random.randint(9,14), current_ant_frame = 1, is_searching = True, found_a_misplaced_object = False, is_returning_object = False, png_name1 = 'ANT2', png_name2 = 'ANT2')
    PLAYER_MOVER_ANTS = [GreyAnt]
    SQUIRRELS = []
    BOUNCIES = []
    MOVING_BOUNCIES = []
    MyElevator1 = BigElevator(x_pos = 1200+((1/2) * screen_width), y_pos = 572+((1/2) * screen_height), vel = 2, activated = 0, number_of_floors = 2, current_floor = 2, open_right = False, open_left = True, left_door_open_at_bottom = False, right_door_open_at_bottom = True, left_door_open_at_top = True, right_door_open_at_top = False, x1 = 1200+((1/2) * screen_width), y1 = 4859+((1/2) * screen_height), x2 = 1200+((1/2) * screen_width), y2 = 572+((1/2) * screen_height), number_of_frames = 81, wasted_left_space = 51, wasted_right_space = 51, wasted_top_space = 47, wasted_bottom_space = 47, png_name = 'Elevator/Elevator2/Elevator')
    ELEVATORS = [MyElevator1]
    LEAVES = []
    my_root1 = Root(x_pos = 18250+((1/2)*screen_width), y_pos = 485+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 180, png_name = 'Root1/')
    ROOTS = [my_root1]
    DRIPDROPS = []
    UPGRADES = []
    if all_current_save_data[32][0] == '0':
      my_upgrade7 = Upgrade(x_pos = 3776+((1/2) * screen_width), y_pos = 5296+((1/2) * screen_height), collected = False)
      UPGRADES = [my_upgrade7]
    WATER_REGIONS = []
    WATER_COVERS = []
    WATER_SURFACES = []
    IRREGULARLY_SHAPED_WATER = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    GRATES = []
    GOLDFISH = []
    TRANSPORT_PIPES = []
    SURF_BOARDS = []
    SURFING_RAT = []
    EATING_RAT = []
    WAVES = []
    BUCKETS = []
    FOOD = []
    GARBAGE_CAN = []
    THE_MACHINE = []
    TOOLS = []
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    TheDoor7_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 638+((1/2) * screen_width) + 42.5, center_of_door_y = 959+((1/2) * screen_height) + 42.5, difficulty = 4)
    SUB_LEVEL_DIFFICULTIES = [TheDoor7_sublevel_difficulty]
    TRASH = []
    SPINNY_OBJECTS = []
    TheDoor7 = SimplySprite(x_pos = 638+((1/2) * screen_width), y_pos = 959+((1/2) * screen_height), png_name = 'THE_DOOR')
    Door_hider = SimplySprite(x_pos = 3455+((1/2) * screen_width), y_pos = 4756+((1/2) * screen_height), png_name = 'ELEVATOR_DOOR_HIDER')
    MY_SPRITES_FRONT = [Door_hider]
    MY_SPRITES_BACK = [TheDoor7]
    MOVING_SPRITE_FRONT = []
    MOVING_SPRITE_BACK = []
    GRASSES = []
    TV = []
    PROPELLERS = []
    LEVERS = []
    Hawk = []
    QueenAnt = []
    BEETLE_FRIEND = []
  #
  if new_region == 'TheDoor8': # Racing keys
    if not My_cached_info.PlayingSewerTheme:
      pygame.mixer.music.load(My_cached_info.SewerThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = False
      My_cached_info.PlayingSewerTheme = True
    if MAP.spawn_location[old_map_spawn_index] == 1:
      PLAYER.x_pos, PLAYER.y_pos = 2356, 2325
      PLAYER.x_vel, PLAYER.y_vel = 0, 0
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[2356-20, 2356+85-69+20, 2325+1-20, 2325+1+85-69+20]], new_regions = [['AntHill']], spawn_location = [4], region = 'TheDoor8', forced_exit = True, forced_exit_points = [], forced_exit_next_map = [], png_name = 'THE_DOOR8')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_THE_DOOR8')
    BACKGROUND = []
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    MY_VINES = []
    CLOUDS = []
    TEETERTOTTERS = []
    my_key1 = AKey(x_pos = 2399-34+((1/2) * screen_width), y_pos = 2448+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [2231+((1/2) * screen_width), 2568+((1/2) * screen_width), 2432+((1/2) * screen_height), 2529+((1/2) * screen_height)], is_inserted_xy = [8800+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 1, vel = 150, png_name1 = 'ORANGE_KEY', png_name2 = '')
    my_key2 = AKey(x_pos = 2399-34+((1/2) * screen_width), y_pos = 2199-100-34+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [2231+((1/2) * screen_width), 2568+((1/2) * screen_width), 2584+((1/2) * screen_height), 2761+((1/2) * screen_height)], is_inserted_xy = [8800+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 2, vel = 150, png_name1 = 'PINK_KEY', png_name2 = '')
    my_key3 = AKey(x_pos = 2399-34+((1/2) * screen_width), y_pos = 1899-150-34+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [2231+((1/2) * screen_width), 2568+((1/2) * screen_width), 2895+((1/2) * screen_height), 3194+((1/2) * screen_height)], is_inserted_xy = [8800+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 2, vel = 225, png_name1 = 'BLUE_KEY', png_name2 = '')
    my_key4 = AKey(x_pos = 2399-34+((1/2) * screen_width), y_pos = 1449-200-34+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [2231+((1/2) * screen_width), 2568+((1/2) * screen_width), 3347+((1/2) * screen_height), 3746+((1/2) * screen_height)], is_inserted_xy = [8800+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 2, vel = 300, png_name1 = 'RED_KEY', png_name2 = '')
    ALLKEYS = [my_key1, my_key2, my_key3, my_key4]
    my_door1 = Door(x_pos = 2327+1+((1/2) * screen_width), y_pos = 2529+2+((1/2) * screen_height), is_open = False, is_open_x = 2327+((1/2) * screen_width), is_open_y = 2792+((1/2) * screen_height), door_type = 2, png_name = '')
    my_door2 = Door(x_pos = 2327+1+((1/2) * screen_width), y_pos = 2792+2+((1/2) * screen_height), is_open = False, is_open_x = 2327+((1/2) * screen_width), is_open_y = 2792+((1/2) * screen_height), door_type = 2, png_name = '')
    my_door3 = Door(x_pos = 2327+1+((1/2) * screen_width), y_pos = 3196+2+((1/2) * screen_height), is_open = False, is_open_x = 2327+((1/2) * screen_width), is_open_y = 2792+((1/2) * screen_height), door_type = 2, png_name = '')
    my_door4 = Door(x_pos = 2327+1+((1/2) * screen_width), y_pos = 3747+2+((1/2) * screen_height), is_open = False, is_open_x = 2327+((1/2) * screen_width), is_open_y = 2792+((1/2) * screen_height), door_type = 2, png_name = '')
    DOORS = [my_door1, my_door2, my_door3, my_door4]
    DOORS_WITH_KNOB = []
    ANTS = []
    PLAYER_MOVER_ANTS = []
    SQUIRRELS = []
    BOUNCIES = []
    MOVING_BOUNCIES = []
    ELEVATORS = []
    LEAVES = []
    ROOTS = []
    DRIPDROPS = []
    UPGRADES = []
    if all_current_save_data[33][0] == '0':
      my_upgrade8 = Upgrade(x_pos = 2399-34+((1/2) * screen_width), y_pos = 4035-34+((1/2) * screen_height), collected = False)
      UPGRADES = [my_upgrade8]
    WATER_REGIONS = []
    WATER_COVERS = []
    WATER_SURFACES = []
    IRREGULARLY_SHAPED_WATER = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    GRATES = []
    GOLDFISH = []
    TRANSPORT_PIPES = []
    SURF_BOARDS = []
    SURFING_RAT = []
    EATING_RAT = []
    WAVES = []
    BUCKETS = []
    FOOD = []
    GARBAGE_CAN = []
    THE_MACHINE = []
    TOOLS = []
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    TheDoor8_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 2356+((1/2) * screen_width) + 42.5, center_of_door_y = 2325+1+((1/2) * screen_height) + 42.5, difficulty = 4)
    SUB_LEVEL_DIFFICULTIES = [TheDoor8_sublevel_difficulty]
    TRASH = []
    SPINNY_OBJECTS = []
    TheDoor8 = SimplySprite(x_pos = 2356+((1/2) * screen_width), y_pos = 2325+1+((1/2) * screen_height), png_name = 'THE_DOOR')
    MY_SPRITES_FRONT = []
    MY_SPRITES_BACK = [TheDoor8]
    MOVING_SPRITE_FRONT = []
    MOVING_SPRITE_BACK = []
    GRASSES = []
    TV = []
    PROPELLERS = []
    LEVERS = []
    Hawk = []
    QueenAnt = []
    BEETLE_FRIEND = []
  #
  if new_region == 'TheDoor26': # leaf level
    if MAP.spawn_location[old_map_spawn_index] == 1:
      PLAYER.x_pos, PLAYER.y_pos = 3326, 9409-4120
      PLAYER.x_vel, PLAYER.y_vel = 0, 0
    PLAYER.x_pos, PLAYER.y_pos = 3326, 9409-4120
    PLAYER.x_vel, PLAYER.y_vel = 0, 0
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[3326-20, 3326+85-69+20, 9409-20, 9409+85-69+20]], new_regions = [['AntHill']], spawn_location = [3], region = 'TheDoor8', forced_exit = False, forced_exit_points = [], forced_exit_next_map = [], png_name = 'THE_DOOR26')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_THE_DOOR26')
    BACKGROUND = []
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    MY_VINES = []
    CLOUDS = []
    TEETERTOTTERS = []
    ALLKEYS = []
    DOORS = []
    DOORS_WITH_KNOB = []
    ANTS = []
    PLAYER_MOVER_ANTS = []
    SQUIRRELS = []
    BOUNCIES = []
    MOVING_BOUNCIES = []
    ELEVATORS = []
    my_leaf0 = Leaf(x_pos = 920+((1/2) * screen_width), y_pos = 7284-4120+((1/2) * screen_height), accumulated_y_pos = (241.65*8), respawn_x = 920+((1/2) * screen_width), respawn_y = 7284-4120+((1/2) * screen_height), expiry_y_pos = 2296, falling_speed = 0.29, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(0,360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf1 = Leaf(x_pos = 860+((1/2) * screen_width), y_pos = 7284-4120+((1/2) * screen_height), accumulated_y_pos = (241.65*7), respawn_x = 860+((1/2) * screen_width), respawn_y = 7284-4120+((1/2) * screen_height), expiry_y_pos = 2296, falling_speed = 0.29, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(0+36,360+36)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0+36,180+36)], rot_path = [15*math.cos(math.radians(x)) for x in range(0+36,360+36)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf2 = Leaf(x_pos = 920+((1/2) * screen_width), y_pos = 7284-4120+((1/2) * screen_height), accumulated_y_pos = (241.65*6), respawn_x = 920+((1/2) * screen_width), respawn_y = 7284-4120+((1/2) * screen_height), expiry_y_pos = 2296, falling_speed = 0.29, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(0+72,360+72)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0+72,180+72)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0+72,360+72)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf3 = Leaf(x_pos = 860+((1/2) * screen_width), y_pos = 7284-4120+((1/2) * screen_height), accumulated_y_pos = (241.65*5), respawn_x = 860+((1/2) * screen_width), respawn_y = 7284-4120+((1/2) * screen_height), expiry_y_pos = 2296, falling_speed = 0.29, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(0+108,360+108)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0+108,180+108)], rot_path = [15*math.cos(math.radians(x)) for x in range(0+108,360+108)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf4 = Leaf(x_pos = 920+((1/2) * screen_width), y_pos = 7284-4120+((1/2) * screen_height), accumulated_y_pos = (241.65*4), respawn_x = 920+((1/2) * screen_width), respawn_y = 7284-4120+((1/2) * screen_height), expiry_y_pos = 2296, falling_speed = 0.29, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(0+144,360+144)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0+144,180+144)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0+144,360+144)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf5 = Leaf(x_pos = 860+((1/2) * screen_width), y_pos = 7284-4120+((1/2) * screen_height), accumulated_y_pos = (241.65*3), respawn_x = 860+((1/2) * screen_width), respawn_y = 7284-4120+((1/2) * screen_height), expiry_y_pos = 2296, falling_speed = 0.29, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(0+180,360+180)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0+180,180+180)], rot_path = [15*math.cos(math.radians(x)) for x in range(0+180,360+180)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf6 = Leaf(x_pos = 920+((1/2) * screen_width), y_pos = 7284-4120+((1/2) * screen_height), accumulated_y_pos = (241.65*2), respawn_x = 920+((1/2) * screen_width), respawn_y = 7284-4120+((1/2) * screen_height), expiry_y_pos = 2296, falling_speed = 0.29, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(0+216,360+216)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0+216,180+216)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0+216,360+216)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf7 = Leaf(x_pos = 860+((1/2) * screen_width), y_pos = 7284-4120+((1/2) * screen_height), accumulated_y_pos = (241.65*1), respawn_x = 860+((1/2) * screen_width), respawn_y = 7284-4120+((1/2) * screen_height), expiry_y_pos = 2296, falling_speed = 0.29, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(0+252,360+252)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0+252,180+252)], rot_path = [15*math.cos(math.radians(x)) for x in range(0+252,360+252)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf8 = Leaf(x_pos = 920+((1/2) * screen_width), y_pos = 7284-4120+((1/2) * screen_height), accumulated_y_pos = (241.65*0), respawn_x = 920+((1/2) * screen_width), respawn_y = 7284-4120+((1/2) * screen_height), expiry_y_pos = 2296, falling_speed = 0.29, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(0+288,360+288)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0+288,180+288)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0+288,360+288)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf9 = Leaf(x_pos = 860+((1/2) * screen_width), y_pos = 7284-4120+((1/2) * screen_height), accumulated_y_pos = (241.65*-1), respawn_x = 860+((1/2) * screen_width), respawn_y = 7284-4120+((1/2) * screen_height), expiry_y_pos = 2296, falling_speed = 0.29, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(0+324,360+324)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0+324,180+324)], rot_path = [15*math.cos(math.radians(x)) for x in range(0+324,360+324)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf10 = Leaf(x_pos = 973+(266*1)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*2), respawn_x = 973+(266*1)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf11 = Leaf(x_pos = 973+(266*2)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*1), respawn_x = 973+(266*2)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf12 = Leaf(x_pos = 973+(266*3)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*0), respawn_x = 973+(266*3)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf13 = Leaf(x_pos = 973+(266*4)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*-1), respawn_x = 973+(266*4)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf14 = Leaf(x_pos = 973+(266*5)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*-2), respawn_x = 973+(266*5)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf15 = Leaf(x_pos = 973+(266*6)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*-3), respawn_x = 973+(266*6)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf16 = Leaf(x_pos = 973+(266*7)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*-4), respawn_x = 973+(266*7)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf17 = Leaf(x_pos = 973+(266*1)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*6), respawn_x = 973+(266*1)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf18 = Leaf(x_pos = 973+(266*2)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*5), respawn_x = 973+(266*2)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf19 = Leaf(x_pos = 973+(266*3)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*4), respawn_x = 973+(266*3)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf20 = Leaf(x_pos = 973+(266*4)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*3), respawn_x = 973+(266*4)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf21 = Leaf(x_pos = 973+(266*5)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*2), respawn_x = 973+(266*5)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf22 = Leaf(x_pos = 973+(266*6)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*1), respawn_x = 973+(266*6)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf23 = Leaf(x_pos = 973+(266*7)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*0), respawn_x = 973+(266*7)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf24 = Leaf(x_pos = 973+(266*1)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*10), respawn_x = 973+(266*1)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf25 = Leaf(x_pos = 973+(266*2)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*9), respawn_x = 973+(266*2)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf26 = Leaf(x_pos = 973+(266*3)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*8), respawn_x = 973+(266*3)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf27 = Leaf(x_pos = 973+(266*4)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*7), respawn_x = 973+(266*4)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf28 = Leaf(x_pos = 973+(266*5)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*6), respawn_x = 973+(266*5)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf29 = Leaf(x_pos = 973+(266*6)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*5), respawn_x = 973+(266*6)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf30 = Leaf(x_pos = 973+(266*7)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*4), respawn_x = 973+(266*7)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf31 = Leaf(x_pos = 973+(266*1)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*14), respawn_x = 973+(266*1)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf32 = Leaf(x_pos = 973+(266*2)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*13), respawn_x = 973+(266*2)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf33 = Leaf(x_pos = 973+(266*3)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*12), respawn_x = 973+(266*3)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf34 = Leaf(x_pos = 973+(266*4)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*11), respawn_x = 973+(266*4)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf35 = Leaf(x_pos = 973+(266*5)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*10), respawn_x = 973+(266*5)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf36 = Leaf(x_pos = 973+(266*6)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*9), respawn_x = 973+(266*6)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf37 = Leaf(x_pos = 973+(266*7)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*8), respawn_x = 973+(266*7)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf38 = Leaf(x_pos = 973+(266*1)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*18), respawn_x = 973+(266*1)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf39 = Leaf(x_pos = 973+(266*2)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*17), respawn_x = 973+(266*2)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf40 = Leaf(x_pos = 973+(266*3)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*16), respawn_x = 973+(266*3)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf41 = Leaf(x_pos = 973+(266*4)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*15), respawn_x = 973+(266*4)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf42 = Leaf(x_pos = 973+(266*5)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*14), respawn_x = 973+(266*5)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf43 = Leaf(x_pos = 973+(266*6)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*13), respawn_x = 973+(266*6)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    my_leaf44 = Leaf(x_pos = 973+(266*7)+((1/2) * screen_width), y_pos = 4320-4120+((1/2) * screen_height), accumulated_y_pos = (292*12), respawn_x = 973+(266*7)+((1/2) * screen_width), respawn_y = 4320-4120+((1/2) * screen_height), expiry_y_pos = 5410-540+((1/2) * screen_height), falling_speed = 0.6, rotation = 0, x_path = [-180*math.cos(math.radians(x)) for x in range(360)], y_path = [-38*math.cos(math.radians(x*2)) for x in range(0,180)], rot_path = [-15*math.cos(math.radians(x)) for x in range(0,360)], wait_frames_before_beginning_to_disappear = 400, frames_before_checking_for_collision = 7, grapplable = True, flip_image = False, png_name = 'BIG_LEAF')
    #starting 973 3103
    #2131, 1556
    LEAVES = [my_leaf0, my_leaf1, my_leaf2, my_leaf3, my_leaf4, my_leaf5, my_leaf6, my_leaf7, my_leaf8, my_leaf9, my_leaf10, my_leaf11, my_leaf12, my_leaf13, my_leaf14, my_leaf15, my_leaf16, my_leaf17, my_leaf18, my_leaf19, my_leaf20, my_leaf21, my_leaf22, my_leaf23, my_leaf24, my_leaf25, my_leaf26, my_leaf27, my_leaf28, my_leaf29, my_leaf30, my_leaf31, my_leaf32, my_leaf33, my_leaf34, my_leaf35, my_leaf36, my_leaf37, my_leaf38, my_leaf39, my_leaf40, my_leaf41, my_leaf42, my_leaf43, my_leaf44]
    ROOTS = []
    DRIPDROPS = []
    UPGRADES = []
    WATER_REGIONS = []
    WATER_COVERS = []
    WATER_SURFACES = []
    IRREGULARLY_SHAPED_WATER = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    GRATES = []
    GOLDFISH = []
    TRANSPORT_PIPES = []
    SURF_BOARDS = []
    SURFING_RAT = []
    EATING_RAT = []
    WAVES = []
    BUCKETS = []
    FOOD = []
    GARBAGE_CAN = []
    THE_MACHINE = []
    TOOLS = []
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    SUB_LEVEL_DIFFICULTIES = []
    TRASH = []
    SPINNY_OBJECTS = []
    TheDoor8 = SimplySprite(x_pos = 3326+((1/2) * screen_width), y_pos = 9409-4120+((1/2) * screen_height), png_name = 'THE_DOOR')
    MY_SPRITES_FRONT = []
    MY_SPRITES_BACK = [TheDoor8]
    MOVING_SPRITE_FRONT = []
    MOVING_SPRITE_BACK = []
    GRASSES = []
    TV = []
    PROPELLERS = []
    LEVERS = []
    Hawk = []
    QueenAnt = []
    BEETLE_FRIEND = []
  #
  if new_region == 'TheDoor9': # root level
    if not My_cached_info.PlayingSewerTheme:
      pygame.mixer.music.load(My_cached_info.SewerThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = False
      My_cached_info.PlayingSewerTheme = True
    if MAP.spawn_location[old_map_spawn_index] == 1:
      PLAYER.x_pos, PLAYER.y_pos = 1750-34, 8634-75
      PLAYER.x_vel, PLAYER.y_vel = 0, 0
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[1750-44-20, 1750-44+85-69+20, 8634-87-20, 8634-87+85-69+20]], new_regions = [['AntHill']], spawn_location = [5], region = 'TheDoor9', forced_exit = False, forced_exit_points = [], forced_exit_next_map = [], png_name = 'THE_DOOR9')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_THE_DOOR9')
    BACKGROUND1 = Background(scroll_leftright = True, scroll_updown = True, iteration_speed = 11, scroll_speed_x = 0.1/10, scroll_speed_y = 0.1/10, scale = True, scale_size = (2000, 2000), permanent_add_x = 0, permanent_add_y = 0, use_convert_alpha = False, special_directions = 3, png_name = 'ROOT_LEVEL_BG')
    BACKGROUND = [BACKGROUND1]
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    MY_VINES = []
    CLOUDS = []
    TEETERTOTTERS = []
    my_key1 = AKey(x_pos = 111280+((1/2) * screen_width), y_pos = 832+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [1504+((1/2) * screen_width), 1659+((1/2) * screen_width), 777+((1/2) * screen_height), 935+((1/2) * screen_height)], is_inserted_xy = [3300+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 1, vel = 150, png_name1 = 'PINK_KEY', png_name2 = '')
    my_door1 = Door(x_pos = 111664+((1/2) * screen_width), y_pos = 780+((1/2) * screen_height), is_open = False, is_open_x = 1664+((1/2) * screen_width), is_open_y = 780-180+((1/2) * screen_height), door_type = 1, png_name = 'PINK_DOOR')
    ALLKEYS = [my_key1]
    DOORS = [my_door1]
    DOORS_WITH_KNOB = []
    ANTS = []
    PLAYER_MOVER_ANTS = []
    SQUIRRELS = []
    BOUNCIES = []
    MOVING_BOUNCIES = []
    ELEVATORS = []
    LEAVES = []
    my_root1 = Root(x_pos = 1469+((1/2)*screen_width), y_pos = 3275+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root2 = Root(x_pos = 1812+((1/2)*screen_width), y_pos = 3275+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root3 = Root(x_pos = 969+((1/2)*screen_width), y_pos = 3579+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root4 = Root(x_pos = 2312+((1/2)*screen_width), y_pos = 3579+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
#
    my_root5 = Root(x_pos = 632+2+((1/2)*screen_width), y_pos = 3853+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root6 = Root(x_pos = 800+4+((1/2)*screen_width), y_pos = 3853+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root7 = Root(x_pos = 968+6+((1/2)*screen_width), y_pos = 3853+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root8 = Root(x_pos = 1136+8+((1/2)*screen_width), y_pos = 3853+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root9 = Root(x_pos = 1304+10+((1/2)*screen_width), y_pos = 3853+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root10 = Root(x_pos = 1472+12+((1/2)*screen_width), y_pos = 3853+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root11 = Root(x_pos = 1640-14+((1/2)*screen_width), y_pos = 3853+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root12 = Root(x_pos = 1808-12+((1/2)*screen_width), y_pos = 3853+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root13 = Root(x_pos = 1976-10+((1/2)*screen_width), y_pos = 3853+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root14 = Root(x_pos = 2144-8+((1/2)*screen_width), y_pos = 3853+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root15 = Root(x_pos = 2312-6+((1/2)*screen_width), y_pos = 3853+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root16 = Root(x_pos = 2480-4+((1/2)*screen_width), y_pos = 3853+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root17 = Root(x_pos = 2648-2+((1/2)*screen_width), y_pos = 3853+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
#
    my_root18 = Root(x_pos = 632+2+((1/2)*screen_width), y_pos = 4127+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root19 = Root(x_pos = 800+4+((1/2)*screen_width), y_pos = 4127+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root20 = Root(x_pos = 968+6+((1/2)*screen_width), y_pos = 4127+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root21 = Root(x_pos = 1136+8+((1/2)*screen_width), y_pos = 4127+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root22 = Root(x_pos = 1304+10+((1/2)*screen_width), y_pos = 4127+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root23 = Root(x_pos = 1472+12+((1/2)*screen_width), y_pos = 4127+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root24 = Root(x_pos = 1640-14+((1/2)*screen_width), y_pos = 4127+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root25 = Root(x_pos = 1808-12+((1/2)*screen_width), y_pos = 4127+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root26 = Root(x_pos = 1976-10+((1/2)*screen_width), y_pos = 4127+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root27 = Root(x_pos = 2144-8+((1/2)*screen_width), y_pos = 4127+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root28 = Root(x_pos = 2312-6+((1/2)*screen_width), y_pos = 4127+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root29 = Root(x_pos = 2480-4+((1/2)*screen_width), y_pos = 4127+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root30 = Root(x_pos = 2648-2+((1/2)*screen_width), y_pos = 4127+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
#
    my_root31 = Root(x_pos = 632+2+((1/2)*screen_width), y_pos = 4401+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root32 = Root(x_pos = 800+4+((1/2)*screen_width), y_pos = 4401+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root33 = Root(x_pos = 968+6+((1/2)*screen_width), y_pos = 4401+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root34 = Root(x_pos = 1136+8+((1/2)*screen_width), y_pos = 4401+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root35 = Root(x_pos = 1304+10+((1/2)*screen_width), y_pos = 4401+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root36 = Root(x_pos = 1472+12+((1/2)*screen_width), y_pos = 4401+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root37 = Root(x_pos = 1640-14+((1/2)*screen_width), y_pos = 4401+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root38 = Root(x_pos = 1808-12+((1/2)*screen_width), y_pos = 4401+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root39 = Root(x_pos = 1976-10+((1/2)*screen_width), y_pos = 4401+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root40 = Root(x_pos = 2144-8+((1/2)*screen_width), y_pos = 4401+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root41 = Root(x_pos = 2312-6+((1/2)*screen_width), y_pos = 4401+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root42 = Root(x_pos = 2480-4+((1/2)*screen_width), y_pos = 4401+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
    my_root43 = Root(x_pos = 2648-2+((1/2)*screen_width), y_pos = 4401+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 110, png_name = 'Root1/')
#
    my_root44 = Root(x_pos = 1473+((1/2)*screen_width), y_pos = 4615+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root45 = Root(x_pos = 1807+((1/2)*screen_width), y_pos = 4829+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root46 = Root(x_pos = 1473+((1/2)*screen_width), y_pos = 4615+429+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root47 = Root(x_pos = 1807+((1/2)*screen_width), y_pos = 4829+429+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root48 = Root(x_pos = 1473+((1/2)*screen_width), y_pos = 4615+858+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root49 = Root(x_pos = 1807+((1/2)*screen_width), y_pos = 4829+858+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
#
    my_root50 = Root(x_pos = 2108+((1/2)*screen_width), y_pos = 5769+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 120, png_name = 'Root1/')
    my_root51 = Root(x_pos = 1808+((1/2)*screen_width), y_pos = 5853+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 80, png_name = 'Root1/')
    my_root52 = Root(x_pos = 1508+((1/2)*screen_width), y_pos = 5937+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 80, png_name = 'Root1/')
    my_root53 = Root(x_pos = 1208+((1/2)*screen_width), y_pos = 6021+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 80, png_name = 'Root1/')
    my_root54 = Root(x_pos = 908+((1/2)*screen_width), y_pos = 6105+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 120, png_name = 'Root1/')
    my_root55 = Root(x_pos = 1208+((1/2)*screen_width), y_pos = 6189+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 80, png_name = 'Root1/')
    my_root56 = Root(x_pos = 1484+((1/2)*screen_width), y_pos = 6273+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 80, png_name = 'Root1/')
    my_root57 = Root(x_pos = 1760+((1/2)*screen_width), y_pos = 6357+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 80, png_name = 'Root1/')
    my_root58 = Root(x_pos = 2036+((1/2)*screen_width), y_pos = 6441+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 80, png_name = 'Root1/')
    my_root59 = Root(x_pos = 2312+((1/2)*screen_width), y_pos = 6525+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 200, time_to_finish_regrowth = 290, allowable_damage = 80, png_name = 'Root1/')
#
    my_root60 = Root(x_pos = 632+((1/2)*screen_width), y_pos = 6649+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 140, png_name = 'Root1/')
    my_root61 = Root(x_pos = 800+((1/2)*screen_width), y_pos = 6649+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 140, png_name = 'Root1/')
    my_root62 = Root(x_pos = 968+((1/2)*screen_width), y_pos = 6649+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 140, png_name = 'Root1/')
    my_root63 = Root(x_pos = 1136+((1/2)*screen_width), y_pos = 6649+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 140, png_name = 'Root1/')
    my_root64 = Root(x_pos = 1808+((1/2)*screen_width), y_pos = 6649+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 140, png_name = 'Root1/')
    my_root65 = Root(x_pos = 1976+((1/2)*screen_width), y_pos = 6649+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 140, png_name = 'Root1/')
    my_root66 = Root(x_pos = 2144+((1/2)*screen_width), y_pos = 6649+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 140, png_name = 'Root1/')
    my_root67 = Root(x_pos = 2312+((1/2)*screen_width), y_pos = 6649+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 140, png_name = 'Root1/')
    my_root68 = Root(x_pos = 2480+((1/2)*screen_width), y_pos = 6649+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 140, png_name = 'Root1/')
    my_root69 = Root(x_pos = 2648+((1/2)*screen_width), y_pos = 6649+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 140, png_name = 'Root1/')
#
    my_root70 = Root(x_pos = 1390+((1/2)*screen_width), y_pos = 6963+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root71 = Root(x_pos = 1524+((1/2)*screen_width), y_pos = 6963+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root72 = Root(x_pos = 984+((1/2)*screen_width), y_pos = 7277+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root73 = Root(x_pos = 2076+((1/2)*screen_width), y_pos = 7213+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root74 = Root(x_pos = 984+((1/2)*screen_width), y_pos = 7591+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root75 = Root(x_pos = 2466+((1/2)*screen_width), y_pos = 7544+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root76 = Root(x_pos = 984+((1/2)*screen_width), y_pos = 7905+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root77 = Root(x_pos = 2558+((1/2)*screen_width), y_pos = 8064+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root78 = Root(x_pos = 1197+((1/2)*screen_width), y_pos = 8314+((1/2)*screen_height), flipped = False, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root79 = Root(x_pos = 1618+((1/2)*screen_width), y_pos = 8046+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
    my_root80 = Root(x_pos = 2083+((1/2)*screen_width), y_pos = 8314+((1/2)*screen_height), flipped = True, time_before_falling = 0, time_to_start_regrowth = 300, time_to_finish_regrowth = 390, allowable_damage = 180, png_name = 'Root1/')
#
    ROOTS = [my_root1, my_root2, my_root3, my_root4, my_root5, my_root6, my_root7, my_root8, my_root9, my_root10, my_root11, my_root12, my_root13, my_root14, my_root15, my_root16, my_root17, my_root18, my_root19, my_root20, my_root21, my_root22, my_root23, my_root24, my_root25, my_root26, my_root27, my_root28, my_root29, my_root30, my_root31, my_root32, my_root33, my_root34, my_root35, my_root36, my_root37, my_root38, my_root39, my_root40, my_root41, my_root42, my_root43, my_root44, my_root45, my_root46, my_root47, my_root48, my_root49, my_root50, my_root51, my_root52, my_root53, my_root54, my_root55, my_root56, my_root57, my_root58, my_root59, my_root60, my_root61, my_root62, my_root63, my_root64, my_root65, my_root66, my_root67, my_root68, my_root69, my_root70, my_root71, my_root72, my_root73, my_root74, my_root75, my_root76, my_root77, my_root78, my_root79, my_root80]
    DRIPDROPS = []
    UPGRADES = []
    if all_current_save_data[34][0] == '0':
      my_upgrade9 = Upgrade(x_pos = 1750-34+((1/2) * screen_width), y_pos = 3100+((1/2) * screen_height), collected = False)
      UPGRADES = [my_upgrade9]
    WATER_REGIONS = []
    WATER_COVERS = []
    WATER_SURFACES = []
    IRREGULARLY_SHAPED_WATER = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    GRATES = []
    GOLDFISH = []
    TRANSPORT_PIPES = []
    SURF_BOARDS = []
    SURFING_RAT = []
    EATING_RAT = []
    WAVES = []
    BUCKETS = []
    FOOD = []
    GARBAGE_CAN = []
    THE_MACHINE = []
    TOOLS = []
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    TheDoor9_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 1750-44+((1/2) * screen_width) + 42.5, center_of_door_y = 8634-87+((1/2) * screen_height) + 42.5, difficulty = 4)
    SUB_LEVEL_DIFFICULTIES = [TheDoor9_sublevel_difficulty]
    TRASH = []
    SPINNY_OBJECTS = []
    TheDoor9 = SimplySprite(x_pos = 1750-44+((1/2) * screen_width), y_pos = 8634-87+((1/2) * screen_height), png_name = 'THE_DOOR')
    MY_SPRITES_FRONT = []
    MY_SPRITES_BACK = [TheDoor9]
    MOVING_SPRITE_FRONT = []
    MOVING_SPRITE_BACK = []
    GRASSES = []
    TV = []
    PROPELLERS = []
    LEVERS = []
    Hawk = []
    QueenAnt = []
    BEETLE_FRIEND = []
  #
  if new_region == 'Sewer':
    everything_save_data(True, 99, '1')
    if not My_cached_info.PlayingSewerTheme:
      pygame.mixer.music.load(My_cached_info.SewerThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = False
      My_cached_info.PlayingSewerTheme = True
    skip_the_rest = True
    if forced_out:
      if old_map_spawn_index == 1:
        skip_the_rest = False
        PLAYER.x_pos, PLAYER.y_pos = 5321, 140
        PLAYER.x_vel, PLAYER.y_vel = 0, 400
      if old_map_spawn_index == 2:
        skip_the_rest = False
        PLAYER.x_pos, PLAYER.y_pos = 112, 2832
        #PLAYER.x_vel, PLAYER.y_vel = 0, 0
    if skip_the_rest:
      if (MAP.spawn_location[old_map_spawn_index] == 1) and skip_the_rest:
        PLAYER.x_pos, PLAYER.y_pos = 11240, 636
        PLAYER.x_vel, PLAYER.y_vel = 0, 0
      if (MAP.spawn_location[old_map_spawn_index] == 2) and skip_the_rest:
        PLAYER.x_pos, PLAYER.y_pos = 784, 5051
        PLAYER.x_vel, PLAYER.y_vel = 0, 0
      if (MAP.spawn_location[old_map_spawn_index] == 3) and skip_the_rest:
        PLAYER.x_pos, PLAYER.y_pos = 11147, 4320
        PLAYER.x_vel, PLAYER.y_vel = 0, 0
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[11240-20, 11240+85-69+20, 636-20, 636+85-69+20], [784-20, 784+85-69+20, 5051-20, 5051+85-69+20], [11147-20, 11147+85-69+20, 4320-20, 4320+85-69+20]], new_regions = [['TheDoor10'], ['TheDoor11'], ['TheDoor12']], spawn_location = [1, 1, 1], region = 'Sewer', forced_exit = True, forced_exit_points = [[5226, 5480, 0, 100], [0, 0, 0, 0], [0, 48, 2657, 3024]], forced_exit_next_map = [['Town'], [''], ['AntHill']], png_name = 'SEWER')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_SEWER')
    BACKGROUND1 = Background(scroll_leftright = True, scroll_updown = True, iteration_speed = 11, scroll_speed_x = 0.1/10, scroll_speed_y = 0.04/10, scale = True, scale_size = (2000, 2000), permanent_add_x = 0, permanent_add_y = 0, use_convert_alpha = False, special_directions = 3, png_name = 'SEWER_GREEN_BG')
    BACKGROUND2 = Background(scroll_leftright = True, scroll_updown = True, iteration_speed = 11, scroll_speed_x = 0.1/10, scroll_speed_y = 0.04/10, scale = True, scale_size = (2000, 2000), permanent_add_x = 0, permanent_add_y = 0, use_convert_alpha = False, special_directions = 3, png_name = 'SEWER_BG')
    BACKGROUND = [BACKGROUND1, BACKGROUND2]
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    my_vine1 = Vine(x_pos = 5349+((1/2) * screen_width), y_pos = 0-10+((1/2) * screen_height), vine_length = 1, vine_segment_length = 2894, rotation = 270, angular_accel = 0, angular_vel = 0, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 50, png_name = 'BUCKET_VINE', vine_type = 2)
    #my_vine2 = Vine(x_pos = 1682-33+((1/2) * screen_width), y_pos = 147+((1/2) * screen_height), vine_length = 7, vine_segment_length = 48, rotation = 270, angular_accel = 0, angular_vel = 0, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 50, png_name = 'SEWERVINE1', vine_type = 1)
    MY_VINES = [my_vine1]
    CLOUDS = []
    TEETERTOTTERS = []
    ALLKEYS = []
    DOORS = []
    DOORS_WITH_KNOB = []
    ANTS = []
    PLAYER_MOVER_ANTS = []
    SQUIRRELS = []
    BOUNCIES = []
    MOVING_BOUNCIES = []
    ELEVATORS = []
    LEAVES = []
    ROOTS = []
    DRIPDROPS = []
    UPGRADES = []
    WATER_REGIONS = [(772-2, 819+2, 3792-69, 3999, 3000, 0, True), (1072-2, 1119+2, 5504-69, 5711, 3000, 0, True), (3973-69-2, 4020-69+2, 5520-69, 5727, -3000, 0, True), (5460-69-2, 5507-69+2, 4164-69, 4371, -3000, 0, True), (5867-32, 5867+208-32, 3023-69, 4462, 0, 3000), (4840-32, 5866-32, 2960-69, 3024, 0, 0), (1456-32, 4839-32, 3049-69, 5167, 0, 0, True), (805-32, 1455-32, 3680-69, 4000, 0, 0), (4840-32, 5459-32, 4052-69, 4371, 0, 0), (3429-32, 3764-32, 5168-69, 5727, 0, 0), (3765-32, 3972-32, 5504-69, 5727, 0, 0), (1120-32, 1951-32, 5152-69, 5711, 0, 0), (5867-32, 10398-32, 4462-69, 5635, 0, 0), (0-32, 9199-32, 2960-69, 3024, 0, 0), (1456-32, 4839-32, 2992-69, 3103, 0, 0, True), (5245-32, 5461-32, 2992-69, 3312, 0, -3000)] # (x1 x2, y1 y2, x_force, y_force)
    water_surface1 = WaterSurface(x_pos = 0+((1/2) * screen_width), y_pos = 2944+((1/2) * screen_height), width = 4899, png_name = 'WATER_SURFACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface2 = WaterSurface(x_pos = 4898+((1/2) * screen_width), y_pos = 2944+((1/2) * screen_height), width = 4302, png_name = 'WATER_SURFACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface3 = WaterSurface(x_pos = 820+((1/2) * screen_width), y_pos = 3680+((1/2) * screen_height), width = 208, png_name = 'WATER_SURFACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface4 = WaterSurface(x_pos = 5252+((1/2) * screen_width), y_pos = 4052+((1/2) * screen_height), width = 208, png_name = 'WATER_SURFACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface5 = WaterSurface(x_pos = 1120+((1/2) * screen_width), y_pos = 5152+((1/2) * screen_height), width = 208, png_name = 'WATER_SURFACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface6 = WaterSurface(x_pos = 3765+((1/2) * screen_width), y_pos = 5504+((1/2) * screen_height), width = 208, png_name = 'WATER_SURFACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface7 = WaterSurface(x_pos = 5867+((1/2) * screen_width), y_pos = 4446+((1/2) * screen_height), width = 4530, png_name = 'WATER_SURFACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface8 = WaterSurface(x_pos = 10397+((1/2) * screen_width), y_pos = 4446+((1/2) * screen_height), width = 95, png_name = 'WATER_SURFACE_SURFING', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface9 = WaterSurface(x_pos = 5867+((1/2) * screen_width), y_pos = 4452+((1/2) * screen_height), width = 202, png_name = 'WATER_SURFACE2', water_surface_type = 2, connected_to_which_bucket = 0)
    water_pool1 = WaterCover(x_pos = 772+((1/2) * screen_width), y_pos = 3025+((1/2) * screen_height), png_name = 'WATER_POOL1')
    water_pool2 = WaterCover(x_pos = 0+((1/2) * screen_width), y_pos = 2960+((1/2) * screen_height), png_name = 'WATER_POOL2')
    water_pool3 = WaterCover(x_pos = 5867+((1/2) * screen_width), y_pos = 4462+((1/2) * screen_height), png_name = 'WATER_POOL3')
    WATER_COVERS = [water_pool1, water_pool2, water_pool3]
    WATER_SURFACES = [water_surface9, water_surface1, water_surface2, water_surface3, water_surface4, water_surface5, water_surface6, water_surface7, water_surface8]
    IRREGULARLY_SHAPED_WATER = []
    SPINNY_OBJECTS = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    my_grate = GrateWater(offset_x = 7024, offset_y = 209, starting_times = (0, 0, 0), expanding_receding_time = 16, staying_time = 120, waiting_time = 240, which_map = 'Sewer')
    GRATES = [my_grate]
    my_goldfish1 = Goldfish(x_pos = random.randint(1456+((1/2)*screen_width), 4839+((1/2)*screen_width)), y_pos = random.randint(3088+((1/2)*screen_height), 5167+((1/2)*screen_height)), vel = 3.5, bounds = [1456+((1/2)*screen_width), 4839+((1/2)*screen_width), 3088+((1/2)*screen_height), 5167+((1/2)*screen_height)], png_name = 'GOLDFISH')
    my_goldfish2 = Goldfish(x_pos = random.randint(1456+((1/2)*screen_width), 4839+((1/2)*screen_width)), y_pos = random.randint(3088+((1/2)*screen_height), 5167+((1/2)*screen_height)), vel = 3.5, bounds = [1456+((1/2)*screen_width), 4839+((1/2)*screen_width), 3088+((1/2)*screen_height), 5167+((1/2)*screen_height)], png_name = 'GOLDFISH')
    my_goldfish3 = Goldfish(x_pos = random.randint(1456+((1/2)*screen_width), 4839+((1/2)*screen_width)), y_pos = random.randint(3088+((1/2)*screen_height), 5167+((1/2)*screen_height)), vel = 3.5, bounds = [1456+((1/2)*screen_width), 4839+((1/2)*screen_width), 3088+((1/2)*screen_height), 5167+((1/2)*screen_height)], png_name = 'GOLDFISH')
    my_goldfish4 = Goldfish(x_pos = random.randint(1456+((1/2)*screen_width), 4839+((1/2)*screen_width)), y_pos = random.randint(3088+((1/2)*screen_height), 5167+((1/2)*screen_height)), vel = 3.5, bounds = [1456+((1/2)*screen_width), 4839+((1/2)*screen_width), 3088+((1/2)*screen_height), 5167+((1/2)*screen_height)], png_name = 'GOLDFISH')
    my_goldfish5 = Goldfish(x_pos = random.randint(1456+((1/2)*screen_width), 4839+((1/2)*screen_width)), y_pos = random.randint(3088+((1/2)*screen_height), 5167+((1/2)*screen_height)), vel = 3.5, bounds = [1456+((1/2)*screen_width), 4839+((1/2)*screen_width), 3088+((1/2)*screen_height), 5167+((1/2)*screen_height)], png_name = 'GOLDFISH')
    my_goldfish6 = Goldfish(x_pos = random.randint(1456+((1/2)*screen_width), 4839+((1/2)*screen_width)), y_pos = random.randint(3088+((1/2)*screen_height), 5167+((1/2)*screen_height)), vel = 3.5, bounds = [1456+((1/2)*screen_width), 4839+((1/2)*screen_width), 3088+((1/2)*screen_height), 5167+((1/2)*screen_height)], png_name = 'GOLDFISH')
    GOLDFISH = [my_goldfish1, my_goldfish2, my_goldfish3, my_goldfish4, my_goldfish5, my_goldfish6]
    my_transport_pipe1 = TransportPipe(x_pos = 415 + ((1/2)*screen_width), y_pos = 2401 + ((1/2)*screen_height), blow_width = 0, Fx = -3000, Fy = 0, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'ELUUUUUURE', ejection_direction = 'R', png_name = 'ONER_RIGHT', wind_png_name = 'PIPE_WIND', up = False, down = False)
    my_transport_pipe2 = TransportPipe(x_pos = 415 + ((1/2)*screen_width), y_pos = 881 + ((1/2)*screen_height), blow_width = 0, Fx = -3000, Fy = 0, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'ELDDDDDDRE', ejection_direction = 'R', png_name = 'ONER_RIGHT', wind_png_name = 'PIPE_WIND', up = False, down = False)
    my_transport_pipe3 = TransportPipe(x_pos = 1512 + ((1/2)*screen_width), y_pos = 1649 + ((1/2)*screen_height), blow_width = 512, Fx = 0, Fy = 3000, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'EDLLUUUE', ejection_direction = 'U', png_name = 'ONER_RIGHT', wind_png_name = 'PIPE_WIND', up = True, down = False)
    my_transport_pipe4 = TransportPipe(x_pos = 1512+(1*(256)) + ((1/2)*screen_width), y_pos = 1649 + ((1/2)*screen_height), blow_width = 512, Fx = 0, Fy = 3000, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'EDLLLUUUE', ejection_direction = 'U', png_name = 'ONER_UP', wind_png_name = 'PIPE_WIND', up = True, down = False)
    my_transport_pipe5 = TransportPipe(x_pos = 1512+(2*(256)) + ((1/2)*screen_width), y_pos = 1649 + ((1/2)*screen_height), blow_width = 512, Fx = 0, Fy = 3000, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'EDLLLLUUUE', ejection_direction = 'U', png_name = 'ONER_UP', wind_png_name = 'PIPE_WIND', up = True, down = False)
    my_transport_pipe6 = TransportPipe(x_pos = 1512+(3*(256)) + ((1/2)*screen_width), y_pos = 1649 + ((1/2)*screen_height), blow_width = 512, Fx = 0, Fy = 3000, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'EDLLLLLUUUE', ejection_direction = 'U', png_name = 'ONER_UP', wind_png_name = 'PIPE_WIND', up = True, down = False)
    my_transport_pipe7 = TransportPipe(x_pos = 1512+(4*(256)) + ((1/2)*screen_width), y_pos = 1649 + ((1/2)*screen_height), blow_width = 512, Fx = 0, Fy = 3000, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'EDLLLLLLUUUE', ejection_direction = 'U', png_name = 'ONER_UP', wind_png_name = 'PIPE_WIND', up = True, down = False)
    my_transport_pipe8 = TransportPipe(x_pos = 1512+(5*(256)) + ((1/2)*screen_width), y_pos = 1649 + ((1/2)*screen_height), blow_width = 512, Fx = 0, Fy = 3000, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'EDLLLLLLLUUUE', ejection_direction = 'U', png_name = 'ONER_UP', wind_png_name = 'PIPE_WIND', up = True, down = False)
    my_transport_pipe9 = TransportPipe(x_pos = 1512+(6*(256)) + ((1/2)*screen_width), y_pos = 1649 + ((1/2)*screen_height), blow_width = 512, Fx = 0, Fy = 3000, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'EDLLLLLLLLUUUE', ejection_direction = 'U', png_name = 'ONER_UP', wind_png_name = 'PIPE_WIND', up = True, down = False)
    my_transport_pipe10 = TransportPipe(x_pos = 1512+(7*(256)) + ((1/2)*screen_width), y_pos = 1649 + ((1/2)*screen_height), blow_width = 512, Fx = 0, Fy = 3000, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'EDLLLLLLLLLUUUE', ejection_direction = 'U', png_name = 'ONER_UP', wind_png_name = 'PIPE_WIND', up = True, down = False)
    my_transport_pipe11 = TransportPipe(x_pos = 1512+(0*(256)) + ((1/2)*screen_width), y_pos = 369 + ((1/2)*screen_height), blow_width = 296, Fx = 0, Fy = -3000, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'EULLDDE', ejection_direction = 'D', png_name = 'ONER_DOWN', wind_png_name = 'PIPE_WIND', up = False, down = True)
    my_transport_pipe12 = TransportPipe(x_pos = 1512+(1*(256)) + ((1/2)*screen_width), y_pos = 369 + ((1/2)*screen_height), blow_width = 296, Fx = 0, Fy = -3000, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'EULLLDDE', ejection_direction = 'D', png_name = 'ONER_DOWN', wind_png_name = 'PIPE_WIND', up = False, down = True)
    my_transport_pipe13 = TransportPipe(x_pos = 1512+(2*(256)) + ((1/2)*screen_width), y_pos = 369 + ((1/2)*screen_height), blow_width = 296, Fx = 0, Fy = -3000, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'EULLLLDDE', ejection_direction = 'D', png_name = 'ONER_DOWN', wind_png_name = 'PIPE_WIND', up = False, down = True)
    my_transport_pipe14 = TransportPipe(x_pos = 1512+(3*(256)) + ((1/2)*screen_width), y_pos = 369 + ((1/2)*screen_height), blow_width = 296, Fx = 0, Fy = -3000, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'EULLLLLDDE', ejection_direction = 'D', png_name = 'ONER_DOWN', wind_png_name = 'PIPE_WIND', up = False, down = True)
    my_transport_pipe15 = TransportPipe(x_pos = 1512+(4*(256)) + ((1/2)*screen_width), y_pos = 369 + ((1/2)*screen_height), blow_width = 296, Fx = 0, Fy = -3000, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'EULLLLLLDDE', ejection_direction = 'D', png_name = 'ONER_DOWN', wind_png_name = 'PIPE_WIND', up = False, down = True)
    my_transport_pipe16 = TransportPipe(x_pos = 1512+(5*(256)) + ((1/2)*screen_width), y_pos = 369 + ((1/2)*screen_height), blow_width = 296, Fx = 0, Fy = -3000, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'EULLLLLLLDDE', ejection_direction = 'D', png_name = 'ONER_DOWN', wind_png_name = 'PIPE_WIND', up = False, down = True)
    my_transport_pipe17 = TransportPipe(x_pos = 1512+(6*(256)) + ((1/2)*screen_width), y_pos = 369 + ((1/2)*screen_height), blow_width = 296, Fx = 0, Fy = -3000, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'EULLLLLLLLDDE', ejection_direction = 'D', png_name = 'ONER_DOWN', wind_png_name = 'PIPE_WIND', up = False, down = True)
    my_transport_pipe18 = TransportPipe(x_pos = 1512+(7*(256)) + ((1/2)*screen_width), y_pos = 369 + ((1/2)*screen_height), blow_width = 296, Fx = 0, Fy = -3000, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'EULLLLLLLLLDDE', ejection_direction = 'D', png_name = 'ONER_DOWN', wind_png_name = 'PIPE_WIND', up = False, down = True)
    my_transport_pipe19 = TransportPipe(x_pos = 4584 + ((1/2)*screen_width), y_pos = 1377 + ((1/2)*screen_height), blow_width = 0, Fx = 0, Fy = 0, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'EDDDE', ejection_direction = 'D', png_name = 'ONER_UP', wind_png_name = 'PIPE_WIND', up = True, down = False)
    my_transport_pipe20 = TransportPipe(x_pos = 11496 + ((1/2)*screen_width), y_pos = 4144 + ((1/2)*screen_height), blow_width = 0, Fx = 0, Fy = 0, flipped = False, is_entrance = True, is_blowing = False, is_sucking = True, path_to_other_side = 'ERUUUUUUUULE', ejection_direction = 'L', png_name = 'ONER_LEFT', wind_png_name = 'PIPE_WIND', up = False, down = False)
    TRANSPORT_PIPES = [my_transport_pipe1, my_transport_pipe2, my_transport_pipe3, my_transport_pipe4, my_transport_pipe5, my_transport_pipe6, my_transport_pipe7, my_transport_pipe8, my_transport_pipe9, my_transport_pipe10, my_transport_pipe11, my_transport_pipe12, my_transport_pipe13, my_transport_pipe14, my_transport_pipe15, my_transport_pipe16, my_transport_pipe17, my_transport_pipe18, my_transport_pipe19, my_transport_pipe20]
    my_surf_board1 = SurfBoard(x_pos = 5990+1000 + ((1/2)*screen_width), y_pos = 4352 + ((1/2)*screen_height), boundaries = [6074+((1/2)*screen_width), 10392+((1/2)*screen_width), 3072+((1/2)*screen_height), 4462+10+((1/2)*screen_height)], water_surface_collision_indexes = [7], png_name = 'SURF_BOARD')
    SURF_BOARDS = [my_surf_board1]
    SURFING_RAT = [SurfingRat(MAP.region)]
    EATING_RAT = [EatingRat()]
    WAVES = []
    my_bucket1 = Bucket(x_pos = 5228 + ((1/2)*screen_width), y_pos = 2884 + ((1/2)*screen_height), bottom_x = 5228 + ((1/2)*screen_width), bottom_y = 2884 + ((1/2)*screen_height), top_x = 5228 + ((1/2)*screen_width), top_y = 469 + ((1/2)*screen_height), vel = 5)
    if old_map_spawn_index == 1 and not skip_the_rest:
      my_bucket1.stage_in_bucket_movement = 3
      MY_VINES[0].y_poss[0] -= abs(my_bucket1.bottom_y - my_bucket1.top_y)
    BUCKETS = [my_bucket1]
    almond = Food(x_pos = 6020 + ((1/2)*screen_width), y_pos = 1376 + ((1/2)*screen_height), image_rotation = 90, flipped = False, png_name = 'ALMOND', food_index = 0)
    banana = Food(x_pos = 4496 + ((1/2)*screen_width), y_pos = 1264 + ((1/2)*screen_height), image_rotation = 0, flipped = False, png_name = 'BANANA', food_index = 1)
    blackberry = Food(x_pos = 4432 + ((1/2)*screen_width), y_pos = 5376 + ((1/2)*screen_height), image_rotation = 0, flipped = False, png_name = 'BLACKBERRY', food_index = 2)
    coconut = Food(x_pos = 11336 + ((1/2)*screen_width), y_pos = 4304 + ((1/2)*screen_height), image_rotation = 90, flipped = False, png_name = 'COCONUT', food_index = 3)
    FOOD = []
    TOOLS = []
    how_much_food_has_been_eaten = 4
    if all_current_save_data[21][0] == '0':
      FOOD.append(almond)
      how_much_food_has_been_eaten -= 1
      My_cached_info.food_that_exists[0] = True
    if all_current_save_data[22][0] == '0':
      FOOD.append(banana)
      how_much_food_has_been_eaten -= 1
      My_cached_info.food_that_exists[1] = True
    if all_current_save_data[23][0] == '0':
      FOOD.append(blackberry)
      how_much_food_has_been_eaten -= 1
      My_cached_info.food_that_exists[2] = True
    if all_current_save_data[24][0] == '0':
      FOOD.append(coconut)
      how_much_food_has_been_eaten -= 1
      My_cached_info.food_that_exists[3] = True
    if (how_much_food_has_been_eaten > 0):
      EATING_RAT[0].milliseconds_speaking_with_hamster = 3000
    if how_much_food_has_been_eaten == 4:
      EATING_RAT[0].milliseconds_speaking_with_hamster = 10000
      EATING_RAT[0].milliseconds_conclusion_talking = 5000
      if all_current_save_data[18][0] == '0':
        TOOLS.append(Tools(x_pos = 4592 + ((1/2)*screen_width), y_pos = 560 + ((1/2)*screen_height), png_name = 'WRENCH'))
    EATING_RAT[0].eaten_how_much_food = how_much_food_has_been_eaten
    GARBAGE_CAN = []
    THE_MACHINE = []
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    TheDoor10_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 11240+((1/2) * screen_width) + 42.5, center_of_door_y = 636+((1/2) * screen_height) + 42.5, difficulty = 3)
    TheDoor11_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 784+((1/2) * screen_width) + 42.5, center_of_door_y = 5051+((1/2) * screen_height) + 42.5, difficulty = 1)
    TheDoor12_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 11147+((1/2) * screen_width) + 42.5, center_of_door_y = 4320+((1/2) * screen_height) + 42.5, difficulty = 2)
    SUB_LEVEL_DIFFICULTIES = [TheDoor10_sublevel_difficulty, TheDoor11_sublevel_difficulty, TheDoor12_sublevel_difficulty]
    TRASH = []
    TheDoor10 = SimplySprite(x_pos = 11240+((1/2) * screen_width), y_pos = 636+((1/2) * screen_height), png_name = 'THE_DOOR')
    TheDoor11 = SimplySprite(x_pos = 784+((1/2) * screen_width), y_pos = 5051+((1/2) * screen_height), png_name = 'THE_DOOR')
    TheDoor12 = SimplySprite(x_pos = 11147+((1/2) * screen_width), y_pos = 4320+((1/2) * screen_height), png_name = 'THE_DOOR')
    WATER_SURFACE_HIDER_SURFING = SimplySprite(x_pos = 10399+((1/2) * screen_width), y_pos = 4446+((1/2) * screen_height), png_name = 'WATER_SURFACE_HIDER_SURFING')
    MY_SPRITES_FRONT = []
    MY_SPRITES_BACK = [TheDoor10, TheDoor11, TheDoor12]
    SEWER_WATER_FALL = MovingSprite(x_pos = 5867+((1/2) * screen_width), y_pos = 3023+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 4, png_name = 'SEWER_WATER_FALL')
    SEWER_WATER_FALL_FADED = MovingSprite(x_pos = 5867+((1/2) * screen_width), y_pos = 3023+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 4, png_name = 'SEWER_WATER_FALL_FADED')
    MOVING_SPRITE_FRONT = [SEWER_WATER_FALL_FADED]
    MOVING_SPRITE_BACK = [SEWER_WATER_FALL]
    GRASSES = []
    my_TV1 = TV_class(x_pos = 673+((1/2) * screen_width), y_pos = 3269+((1/2) * screen_height))
    my_TV2 = TV_class(x_pos = 673+((1/2) * screen_width), y_pos = 4741+((1/2) * screen_height))
    my_TV3 = TV_class(x_pos = 5077+((1/2) * screen_width), y_pos = 3641+((1/2) * screen_height))
    TV = [my_TV1, my_TV2, my_TV3]
    my_propeller1 = Propeller(x_pos = 772+((1/2) * screen_width), y_pos = 3792+((1/2) * screen_height), flipped = False, collision_box_width = 0, bubbles_png = 'BUBBLES1', propeller_type = 1)
    my_propeller2 = Propeller(x_pos = 5460+((1/2) * screen_width), y_pos = 4164+((1/2) * screen_height), flipped = True, collision_box_width = 620, bubbles_png = 'BUBBLES1', propeller_type = 1)
    my_propeller3 = Propeller(x_pos = 1072+((1/2) * screen_width), y_pos = 5504+((1/2) * screen_height), flipped = False, collision_box_width = 832, bubbles_png = 'BUBBLES2', propeller_type = 1)
    my_propeller4 = Propeller(x_pos = 3973+((1/2) * screen_width), y_pos = 5520+((1/2) * screen_height), flipped = True, collision_box_width = 544, bubbles_png = 'BUBBLES3', propeller_type = 1)
    PROPELLERS = [my_propeller1, my_propeller2, my_propeller3, my_propeller4]
    for i in range(len(my_TV1.active_dots)):
      PROPELLERS[i].is_on = not my_TV1.active_dots[i]
    my_lever1 = Lever(x_pos = 1232+((1/2) * screen_width), y_pos = 3520+((1/2) * screen_height), flipped = False, time_added_from_charge = 220, lever_index = 0)
    my_lever2 = Lever(x_pos = 4952+((1/2) * screen_width), y_pos = 3892+((1/2) * screen_height), flipped = True, time_added_from_charge = 220, lever_index = 1)
    my_lever3 = Lever(x_pos = 5636+((1/2) * screen_width), y_pos = 3892+((1/2) * screen_height), flipped = False, time_added_from_charge = 220, lever_index = 2)
    LEVERS = [my_lever1, my_lever2, my_lever3]
    Hawk = []
    QueenAnt = []
    BEETLE_FRIEND = []
  #
  if new_region == 'TheDoor10': # Grate level
    if not My_cached_info.PlayingSewerTheme:
      pygame.mixer.music.load(My_cached_info.SewerThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = False
      My_cached_info.PlayingSewerTheme = True
    if MAP.spawn_location[old_map_spawn_index] == 1:
      PLAYER.x_pos, PLAYER.y_pos = 3157, 5673
      PLAYER.x_vel, PLAYER.y_vel = 0, 0
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[3157-20, 3157+85-69+20, 5673-20, 5673+85-69+20]], new_regions = [['Sewer']], spawn_location = [1], region = 'TheDoor10', forced_exit = False, forced_exit_points = [], forced_exit_next_map = [], png_name = 'THE_DOOR10')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_THE_DOOR10')
    BACKGROUND1 = Background(scroll_leftright = True, scroll_updown = True, iteration_speed = 11, scroll_speed_x = 0.04/10, scroll_speed_y = 0.04/10, scale = True, scale_size = (2000, 2000), permanent_add_x = 0, permanent_add_y = 0, use_convert_alpha = False, special_directions = 3, png_name = 'SEWER_GREEN_BG')
    BACKGROUND2 = Background(scroll_leftright = True, scroll_updown = True, iteration_speed = 11, scroll_speed_x = 0.04/10, scroll_speed_y = 0.04/10, scale = True, scale_size = (2000, 2000), permanent_add_x = 0, permanent_add_y = 0, use_convert_alpha = False, special_directions = 3, png_name = 'SEWER_BG')
    BACKGROUND = [BACKGROUND1, BACKGROUND2]
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    MY_VINES = []
    CLOUDS = []
    TEETERTOTTERS = []
    ALLKEYS = []
    DOORS = []
    DOORS_WITH_KNOB = []
    ANTS = []
    PLAYER_MOVER_ANTS = []
    SQUIRRELS = []
    BOUNCIES = []
    MOVING_BOUNCIES = []
    ELEVATORS = []
    LEAVES = []
    ROOTS = []
    DRIPDROPS = []
    UPGRADES = []
    if all_current_save_data[35][0] == '0':
      my_upgrade9 = Upgrade(x_pos = 3199-34+((1/2) * screen_width), y_pos = 752+((1/2) * screen_height), collected = False)
      UPGRADES = [my_upgrade9]
    WATER_REGIONS = [] # (x1 x2, y1 y2, x_force, y_force)
    WATER_COVERS = []
    WATER_SURFACES = []
    IRREGULARLY_SHAPED_WATER = []
    SPINNY_OBJECTS = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    my_grate = GrateWater(offset_x = 0, offset_y = 128, starting_times = (0, 0, 0), expanding_receding_time = 16, staying_time = 120, waiting_time = 240, which_map = 'TheDoor10')
    GRATES = [my_grate]
    GOLDFISH = []
    TRANSPORT_PIPES = []
    SURF_BOARDS = []
    SURFING_RAT = []
    EATING_RAT = []
    WAVES = []
    BUCKETS = []
    FOOD = []
    GARBAGE_CAN = []
    THE_MACHINE = []
    TOOLS = []
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    TheDoor10_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 3157+((1/2) * screen_width) + 42.5, center_of_door_y = 5673+((1/2) * screen_height) + 42.5, difficulty = 4)
    SUB_LEVEL_DIFFICULTIES = [TheDoor10_sublevel_difficulty]
    TRASH = []
    MY_SPRITES_FRONT = []
    TheDoor10 = SimplySprite(x_pos = 3157+((1/2) * screen_width), y_pos = 5673+((1/2) * screen_height), png_name = 'THE_DOOR')
    MY_SPRITES_BACK = [TheDoor10]
    MOVING_SPRITE_FRONT = []
    MOVING_SPRITE_BACK = []
    GRASSES = []
    TV = []
    PROPELLERS = []
    LEVERS = []
    Hawk = []
    QueenAnt = []
    BEETLE_FRIEND = []
  #
  if new_region == 'TheDoor11': # Sewer race
    if not My_cached_info.PlayingSewerTheme:
      pygame.mixer.music.load(My_cached_info.SewerThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = False
      My_cached_info.PlayingSewerTheme = True
    if MAP.spawn_location[old_map_spawn_index] == 1:
      PLAYER.x_pos, PLAYER.y_pos = 2720, 3104
      PLAYER.x_vel, PLAYER.y_vel = 0, 0
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[2768-20, 2768+85-69+20, 3084-20, 3084+85-69+20]], new_regions = [['Sewer']], spawn_location = [2], region = 'TheDoor11', forced_exit = False, forced_exit_points = [], forced_exit_next_map = [], png_name = 'THE_DOOR11')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_THE_DOOR11')
    BACKGROUND1 = Background(scroll_leftright = True, scroll_updown = True, iteration_speed = 11, scroll_speed_x = 0.04/10, scroll_speed_y = 0.04/10, scale = True, scale_size = (2000, 2000), permanent_add_x = 0, permanent_add_y = 0, use_convert_alpha = False, special_directions = 3, png_name = 'SEWER_GREEN_BG')
    BACKGROUND2 = Background(scroll_leftright = True, scroll_updown = True, iteration_speed = 11, scroll_speed_x = 0.04/10, scroll_speed_y = 0.04/10, scale = True, scale_size = (2000, 2000), permanent_add_x = 0, permanent_add_y = 0, use_convert_alpha = False, special_directions = 3, png_name = 'SEWER_BG')
    BACKGROUND = [BACKGROUND1, BACKGROUND2]
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    MY_VINES = []
    CLOUDS = []
    TEETERTOTTERS = []
    ALLKEYS = []
    DOORS = []
    DOORS_WITH_KNOB = []
    ANTS = []
    PLAYER_MOVER_ANTS = []
    SQUIRRELS = []
    BOUNCIES = []
    MOVING_BOUNCIES = []
    ELEVATORS = []
    LEAVES = []
    ROOTS = []
    my_dripdrop1 = DripDrop(x_pos = 7562+((1/2)*screen_width), y_pos = 4506+((1/2)*screen_height), start_vel = 150, max_vel = 600, end_y_pos = 5679-72-8+((1/2)*screen_height), accel = 400)
    my_dripdrop2 = DripDrop(x_pos = 6652+((1/2)*screen_width), y_pos = 4506+((1/2)*screen_height), start_vel = 150, max_vel = 600, end_y_pos = 5679-72-8+((1/2)*screen_height), accel = 400)
    my_dripdrop3 = DripDrop(x_pos = 5984+((1/2)*screen_width), y_pos = 4506+((1/2)*screen_height), start_vel = 150, max_vel = 600, end_y_pos = 5679-72-8+((1/2)*screen_height), accel = 400)
    my_dripdrop4 = DripDrop(x_pos = 5650+((1/2)*screen_width), y_pos = 4840+((1/2)*screen_height), start_vel = 150, max_vel = 600, end_y_pos = 5049-72+((1/2)*screen_height), accel = 400)
    my_dripdrop5 = DripDrop(x_pos = 4648+((1/2)*screen_width), y_pos = 4506+((1/2)*screen_height), start_vel = 150, max_vel = 600, end_y_pos = 5679-72-8+((1/2)*screen_height), accel = 400)
    my_dripdrop6 = DripDrop(x_pos = 3980+((1/2)*screen_width), y_pos = 4506+((1/2)*screen_height), start_vel = 150, max_vel = 600, end_y_pos = 5679-72-8+((1/2)*screen_height), accel = 400)
    my_dripdrop7 = DripDrop(x_pos = 3312+((1/2)*screen_width), y_pos = 4506+((1/2)*screen_height), start_vel = 150, max_vel = 600, end_y_pos = 5679-72-8+((1/2)*screen_height), accel = 400)
    DRIPDROPS = [my_dripdrop1, my_dripdrop2, my_dripdrop3, my_dripdrop4, my_dripdrop5, my_dripdrop6, my_dripdrop7]
    UPGRADES = []
    if all_current_save_data[36][0] == '0':
      my_upgrade10 = Upgrade(x_pos = 304+((1/2) * screen_width), y_pos = 2976+((1/2) * screen_height), collected = False)
      UPGRADES = [my_upgrade10]
    WATER_REGIONS = [(505-2, 552+2, 3232-69, 3439, 3000, 0, True), (2503-69-2, 2550-69+2, 3232-69, 3439, -3000, 0, True), (553-32, 895+2-32, 3184-69, 3439, 0, 0), (2160-2-32, 2502-32, 3184-69, 3439, 0, 0), (896-32, 2159-32, 3184-69, 3439, 0, 0, True), (896-32, 2182-32, 1749-69, 3183, 0, 0, True), (2183-2-32, 2513-32, 1280-69, 1988, 50, -500), (2977-32, 3307-32, 1280-69, 1988, 50, 500), (3308-2-32, 3695-32, 1749-69, 2015, 500, 50, True), (3696-2-32, 4072-32, 1807-69, 2167, 360, 360, True), (3831-32, 4078-32, 2168-2-69, 2451, 50, 500, True), (3836-32, 4231-32, 2452-2-69, 2830, 360, 360, True), (4232-2-32, 4483-32, 2589-69, 2830, 500, 0, True), (4483-2-32, 4882-32, 2452-2-69, 2830, 360, -360, True), (4640-32, 4947-32, 1296-69, 2451, 0, -500), (5375-32, 5845-32, 1296-69, 1815, 360, 360), (5846-2-32, 8383-32, 1485-69, 1938, 1500, 0, True), (8384-2-32, 9340-32, 1484-69, 1922, 500, 100, True), (8438-32, 10176-32, 5472-69, 6598, 0, 0), (5825-32, 7890-32, 5664-69, 6595, 0, 0), (3153-32, 5506-32, 5664-69, 6595, 0, 0), (2397-32, 2719-32, 6258-69, 6595, -360, 360), (1730-32, 2396+2-32, 6354-69, 6595, -500, 0, True), (1408-32, 1729+2-32, 6262-69, 6595, -360, -360, True), (976-32, 2079-32, 3440-2-69, 6261+2, 0, 0, True)]
    water_surface1 = WaterSurface(x_pos = 553+((1/2) * screen_width), y_pos = 3184+((1/2) * screen_height), width = 208, png_name = 'WATER_SURFACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface2 = WaterSurface(x_pos = 2295+((1/2) * screen_width), y_pos = 3184+((1/2) * screen_height), width = 208, png_name = 'WATER_SURFACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface3 = WaterSurface(x_pos = 2253+((1/2) * screen_width), y_pos = 1280+((1/2) * screen_height), width = 241, png_name = 'WATER_SURFACE_RACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface4 = WaterSurface(x_pos = 2997+((1/2) * screen_width), y_pos = 1280+((1/2) * screen_height), width = 241, png_name = 'WATER_SURFACE_RACE2', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface5 = WaterSurface(x_pos = 4681+((1/2) * screen_width), y_pos = 1296+((1/2) * screen_height), width = 268, png_name = 'WATER_SURFACE_RACE3', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface6 = WaterSurface(x_pos = 5374+((1/2) * screen_width), y_pos = 1296+((1/2) * screen_height), width = 268, png_name = 'WATER_SURFACE_RACE4', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface7 = WaterSurface(x_pos = 8455+63+((1/2) * screen_width), y_pos = 5472+((1/2) * screen_height), width = 1707-63-1, png_name = 'WATER_SURFACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface11 = WaterSurface(x_pos = 8455+((1/2) * screen_width), y_pos = 5472+((1/2) * screen_height), width = 63, png_name = 'WATER_SURFACE_RACE6', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface8 = WaterSurface(x_pos = 5840+1+((1/2) * screen_width), y_pos = 5664+((1/2) * screen_height), width = 2036-2, png_name = 'WATER_SURFACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface9 = WaterSurface(x_pos = 3168+1+((1/2) * screen_width), y_pos = 5664+((1/2) * screen_height), width = 2324-2, png_name = 'WATER_SURFACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface10 = WaterSurface(x_pos = 2494+((1/2) * screen_width), y_pos = 6258+((1/2) * screen_height), width = 211, png_name = 'WATER_SURFACE_RACE5', water_surface_type = 1, connected_to_which_bucket = 666)
    water_pool1 = WaterCover(x_pos = 505+((1/2) * screen_width), y_pos = 1296+((1/2) * screen_height), png_name = 'RACING_POOL1')
    water_pool2 = WaterCover(x_pos = 3011+((1/2) * screen_width), y_pos = 1296+((1/2) * screen_height), png_name = 'RACING_POOL2')
    water_pool3 = WaterCover(x_pos = 5396+((1/2) * screen_width), y_pos = 1312+((1/2) * screen_height), png_name = 'RACING_POOL3')
    water_pool4 = WaterCover(x_pos = 3169+((1/2) * screen_width), y_pos = 5680+((1/2) * screen_height), png_name = 'RACING_POOL4')
    water_pool5 = WaterCover(x_pos = 5841+((1/2) * screen_width), y_pos = 5680+((1/2) * screen_height), png_name = 'RACING_POOL5')
    water_pool6 = WaterCover(x_pos = 8462+((1/2) * screen_width), y_pos = 5488+((1/2) * screen_height), png_name = 'RACING_POOL6')
    WATER_COVERS = [water_pool1, water_pool2, water_pool3, water_pool4, water_pool5, water_pool6]
    WATER_SURFACES = [water_surface1, water_surface2, water_surface3, water_surface4, water_surface5, water_surface6, water_surface7, water_surface8, water_surface9, water_surface10, water_surface11]
    IRREGULARLY_SHAPED_WATER = []
    SPINNY_OBJECTS = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    GRATES = []
    my_goldfish1 = Goldfish(x_pos = random.randint(3204+((1/2)*screen_width), 5412+((1/2)*screen_width)), y_pos = random.randint(5688+((1/2)*screen_height), 5900+((1/2)*screen_height)), vel = 3.5, bounds = [3219+((1/2)*screen_width), 5444+((1/2)*screen_width), 5680+((1/2)*screen_height), 6529+((1/2)*screen_height)], png_name = 'GOLDFISH')
    my_goldfish2 = Goldfish(x_pos = random.randint(3204+((1/2)*screen_width), 5412+((1/2)*screen_width)), y_pos = random.randint(5688+((1/2)*screen_height), 5900+((1/2)*screen_height)), vel = 3.5, bounds = [3219+((1/2)*screen_width), 5444+((1/2)*screen_width), 5680+((1/2)*screen_height), 6529+((1/2)*screen_height)], png_name = 'GOLDFISH')
    my_goldfish3 = Goldfish(x_pos = random.randint(5892+((1/2)*screen_width), 6257+((1/2)*screen_width)), y_pos = random.randint(5680+((1/2)*screen_height), 5900+((1/2)*screen_height)), vel = 3.5, bounds = [5893+((1/2)*screen_width), 7829+((1/2)*screen_width), 5680+((1/2)*screen_height), 6529+((1/2)*screen_height)], png_name = 'GOLDFISH')
    my_goldfish4 = Goldfish(x_pos = random.randint(5892+((1/2)*screen_width), 6257+((1/2)*screen_width)), y_pos = random.randint(5680+((1/2)*screen_height), 5900+((1/2)*screen_height)), vel = 3.5, bounds = [5893+((1/2)*screen_width), 7829+((1/2)*screen_width), 5680+((1/2)*screen_height), 6529+((1/2)*screen_height)], png_name = 'GOLDFISH')
    my_goldfish5 = Goldfish(x_pos = random.randint(8521+((1/2)*screen_width), 9541+((1/2)*screen_width)), y_pos = random.randint(5488+((1/2)*screen_height), 5949+((1/2)*screen_height)), vel = 3.5, bounds = [8521+((1/2)*screen_width), 10078+((1/2)*screen_width), 5488+((1/2)*screen_height), 6530+((1/2)*screen_height)], png_name = 'GOLDFISH')
    my_goldfish6 = Goldfish(x_pos = random.randint(8521+((1/2)*screen_width), 9541+((1/2)*screen_width)), y_pos = random.randint(5488+((1/2)*screen_height), 5949+((1/2)*screen_height)), vel = 3.5, bounds = [8521+((1/2)*screen_width), 10078+((1/2)*screen_width), 5488+((1/2)*screen_height), 6530+((1/2)*screen_height)], png_name = 'GOLDFISH')
    GOLDFISH = [my_goldfish1, my_goldfish2, my_goldfish3, my_goldfish4, my_goldfish5, my_goldfish6]
    TRANSPORT_PIPES = []
    SURF_BOARDS = []
    SURFING_RAT = []
    EATING_RAT = []
    WAVES = []
    BUCKETS = []
    FOOD = []
    GARBAGE_CAN = []
    THE_MACHINE = []
    TOOLS = []
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    TheDoor11_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 2768+((1/2) * screen_width) + 42.5, center_of_door_y = 3084+((1/2) * screen_height) + 42.5, difficulty = 4)
    SUB_LEVEL_DIFFICULTIES = [TheDoor11_sublevel_difficulty]
    TRASH = []
    MY_SPRITES_FRONT = []
    TheDoor11 = SimplySprite(x_pos = 2768+((1/2) * screen_width), y_pos = 3084+((1/2) * screen_height), png_name = 'THE_DOOR')
    MY_SPRITES_BACK = [TheDoor11]
    Piccinco_water = MovingSprite(x_pos = 8317+((1/2) * screen_width), y_pos = 1923+((1/2) * screen_height), number_of_frames = 3, current_frame = 0, frame_duration = 8, png_name = 'RACING_WATER_FALL')
    MOVING_SPRITE_FRONT = [Piccinco_water]
    MOVING_SPRITE_BACK = []
    GRASSES = []
    TV = []
    my_propeller1 = Propeller(x_pos = 1216+((1/2) * screen_width), y_pos = 1757+((1/2) * screen_height), flipped = False, collision_box_width = 350, bubbles_png = 'BUBBLES4', propeller_type = 2)
    my_propeller2 = Propeller(x_pos = 1216+208+((1/2) * screen_width), y_pos = 1757+((1/2) * screen_height), flipped = False, collision_box_width = 350, bubbles_png = 'BUBBLES4', propeller_type = 2)
    my_propeller3 = Propeller(x_pos = 1216+208+208+((1/2) * screen_width), y_pos = 1757+((1/2) * screen_height), flipped = False, collision_box_width = 350, bubbles_png = 'BUBBLES4', propeller_type = 2)
    my_propeller4 = Propeller(x_pos = 2503+((1/2) * screen_width), y_pos = 3232+((1/2) * screen_height), flipped = True, collision_box_width = 0, bubbles_png = 'BUBBLES4', propeller_type = 3)
    my_propeller5 = Propeller(x_pos = 505+((1/2) * screen_width), y_pos = 3232+((1/2) * screen_height), flipped = False, collision_box_width = 551, bubbles_png = 'BUBBLES5', propeller_type = 4)
    my_propeller6 = Propeller(x_pos = 1216+((1/2) * screen_width), y_pos = 4112+((1/2) * screen_height), flipped = False, collision_box_width = 941, bubbles_png = 'BUBBLES6', propeller_type = 5)
    my_propeller7 = Propeller(x_pos = 1216+208+208+((1/2) * screen_width), y_pos = 4112+((1/2) * screen_height), flipped = False, collision_box_width = 941, bubbles_png = 'BUBBLES6', propeller_type = 5)
    my_propeller8 = Propeller(x_pos = 1216+208+((1/2) * screen_width), y_pos = 4112+((1/2) * screen_height), flipped = False, collision_box_width = 941, bubbles_png = 'BUBBLES6', propeller_type = 6)
    my_propeller9 = Propeller(x_pos = 1424+((1/2) * screen_width), y_pos = 2464+((1/2) * screen_height), flipped = False, collision_box_width = 451, bubbles_png = 'BUBBLES8', propeller_type = 7)
    PROPELLERS = [my_propeller1, my_propeller2, my_propeller3, my_propeller4, my_propeller5, my_propeller6, my_propeller7, my_propeller8, my_propeller9]
    my_lever1 = Lever(x_pos = 1552+((1/2) * screen_width), y_pos = 2304+((1/2) * screen_height), flipped = False, time_added_from_charge = 760, lever_index = 0)
    LEVERS = [my_lever1]
    Hawk = []
    QueenAnt = []
    BEETLE_FRIEND = []
  #
  if new_region == 'TheDoor12': # Surfing [5867-600, 11471+600, 3041-600, 5679+600] ---> [5267, 12071, 2441, 6279], width = 6804, height = 3838
    if not My_cached_info.PlayingSewerTheme:
      pygame.mixer.music.load(My_cached_info.SewerThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = False
      My_cached_info.PlayingSewerTheme = True
    if MAP.spawn_location[old_map_spawn_index] == 1:
      PLAYER.x_pos, PLAYER.y_pos = 5880, 1879
      PLAYER.x_vel, PLAYER.y_vel = 0, 0
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[5880-20, 5880+85-69+20, 1879-20, 1879+85-69+20]], new_regions = [['Sewer']], spawn_location = [3], region = 'TheDoor12', forced_exit = True, forced_exit_points = [], forced_exit_next_map = [], png_name = 'THE_DOOR12')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_THE_DOOR12')
    BACKGROUND1 = Background(scroll_leftright = True, scroll_updown = True, iteration_speed = 11, scroll_speed_x = 0.04/10, scroll_speed_y = 0.04/10, scale = True, scale_size = (2000, 2000), permanent_add_x = 0, permanent_add_y = 0, use_convert_alpha = False, special_directions = 3, png_name = 'SEWER_GREEN_BG')
    BACKGROUND2 = Background(scroll_leftright = True, scroll_updown = True, iteration_speed = 11, scroll_speed_x = 0.04/10, scroll_speed_y = 0.04/10, scale = True, scale_size = (2000, 2000), permanent_add_x = 0, permanent_add_y = 0, use_convert_alpha = False, special_directions = 3, png_name = 'SEWER_BG')
    BACKGROUND = [BACKGROUND1, BACKGROUND2]
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    MY_VINES = []
    CLOUDS = []
    TEETERTOTTERS = []
    my_key1 = AKey(x_pos = 111280+((1/2) * screen_width), y_pos = 811312+((1/2) * screen_height), x_vel = 0, y_vel = 0, x_accel = 0, y_accel = 0, is_grabbed_by_player = False, is_grabbed_by_ant = False, is_inserted = False, is_inserted_coordinate_range = [1504+((1/2) * screen_width), 1659+((1/2) * screen_width), 777+((1/2) * screen_height), 935+((1/2) * screen_height)], is_inserted_xy = [3300+((1/2) * screen_width),8800+((1/2) * screen_height)], key_type = 1, vel = 150, png_name1 = 'PINK_KEY', png_name2 = '')
    my_door1 = Door(x_pos = 111664+((1/2) * screen_width), y_pos = 111780+((1/2) * screen_height), is_open = False, is_open_x = 1664+((1/2) * screen_width), is_open_y = 780-180+((1/2) * screen_height), door_type = 1, png_name = 'PINK_DOOR')
    ALLKEYS = [my_key1]
    DOORS = [my_door1]
    DOORS_WITH_KNOB = []
    ANTS = []
    PLAYER_MOVER_ANTS = []
    SQUIRRELS = []
    BOUNCIES = []
    MOVING_BOUNCIES = []
    ELEVATORS = []
    LEAVES = []
    ROOTS = []
    DRIPDROPS = []
    UPGRADES = []
    WATER_REGIONS = [(5867-5267-32, 5867-5267+208-32, 3023-2441-69, 4462-2441, 0, 3000), (600-32, 5127-32, 2021-69, 3194, 0, 0)]
    water_pool3 = WaterCover(x_pos = 600+((1/2) * screen_width), y_pos = 2021+((1/2) * screen_height), png_name = 'WATER_POOL3')
    WATER_COVERS = [water_pool3]
    water_surface1 = WaterSurface(x_pos = 0+((1/2) * screen_width), y_pos = 1611+((1/2) * screen_height), width = 193, png_name = 'WATER_SURFACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface2 = WaterSurface(x_pos = 0+((1/2) * screen_width), y_pos = 503+((1/2) * screen_height), width = 3933, png_name = 'WATER_SURFACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface7 = WaterSurface(x_pos = 600+((1/2) * screen_width), y_pos = 2005+((1/2) * screen_height), width = 4530, png_name = 'WATER_SURFACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface8 = WaterSurface(x_pos = 600+4530+((1/2) * screen_width), y_pos = 2005+((1/2) * screen_height), width = 95, png_name = 'WATER_SURFACE_SURFING', water_surface_type = 1, connected_to_which_bucket = 666)
    WATER_SURFACES = [water_surface1, water_surface2, water_surface7, water_surface8]
    IRREGULARLY_SHAPED_WATER = []
    SPINNY_OBJECTS = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    my_grate = GrateWater(offset_x = 7024-5267, offset_y = 209-2441, starting_times = (0, 0, 0), expanding_receding_time = 16, staying_time = 120, waiting_time = 240, which_map = 'Sewer')
    GRATES = [my_grate]
    GOLDFISH = []
    TRANSPORT_PIPES = []
    my_surf_board1 = SurfBoard(x_pos = 4320 + ((1/2)*screen_width), y_pos = 1866 + ((1/2)*screen_height), boundaries = [599+200+((1/2)*screen_width), 5126+((1/2)*screen_width), 599+((1/2)*screen_height), 2021+10+((1/2)*screen_height)], water_surface_collision_indexes = [2], png_name = 'SURF_BOARD')
    SURF_BOARDS = [my_surf_board1]
    SURFING_RAT = [SurfingRat(MAP.region)]
    SURFING_RAT[0].allow_upgrade_to_spawn = all_current_save_data[37][0]
    EATING_RAT = []
    WAVES = []
    my_bucket1 = Bucket(x_pos = -39 + ((1/2)*screen_width), y_pos = 443 + ((1/2)*screen_height), bottom_x = 5228 + ((1/2)*screen_width), bottom_y = 2884 + ((1/2)*screen_height), top_x = 5228 + ((1/2)*screen_width), top_y = 469 + ((1/2)*screen_height), vel = 5)
    BUCKETS = [my_bucket1]
    FOOD = []
    GARBAGE_CAN = []
    THE_MACHINE = []
    TOOLS = []
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    TheDoor12_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 5880+((1/2) * screen_width) + 42.5, center_of_door_y = 1879+((1/2) * screen_height) + 42.5, difficulty = 4)
    SUB_LEVEL_DIFFICULTIES = [TheDoor12_sublevel_difficulty]
    TRASH = []
    MY_SPRITES_FRONT = []
    TheDoor12 = SimplySprite(x_pos = 5880+((1/2) * screen_width), y_pos = 1879+((1/2) * screen_height), png_name = 'THE_DOOR')
    MY_SPRITES_BACK = [TheDoor12]
    SEWER_WATER_FALL = MovingSprite(x_pos = 600+((1/2) * screen_width), y_pos = 584+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 4, png_name = 'SEWER_WATER_FALL')
    SEWER_WATER_FALL_FADED = MovingSprite(x_pos = 600+((1/2) * screen_width), y_pos = 584+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 4, png_name = 'SEWER_WATER_FALL_FADED')
    MOVING_SPRITE_FRONT = [SEWER_WATER_FALL_FADED]
    MOVING_SPRITE_BACK = [SEWER_WATER_FALL]
    GRASSES = []
    my_TV3 = TV_class(x_pos = 5077-5267+((1/2) * screen_width), y_pos = 3641-2441+((1/2) * screen_height))
    TV = [my_TV3]
    my_propeller2 = Propeller(x_pos = 193+((1/2) * screen_width), y_pos = 1723+((1/2) * screen_height), flipped = True, collision_box_width = 620, bubbles_png = 'BUBBLES1', propeller_type = 1)
    PROPELLERS = [my_propeller2]
    my_lever3 = Lever(x_pos = 5636-5267+((1/2) * screen_width), y_pos = 3892-2441+((1/2) * screen_height), flipped = False, time_added_from_charge = 220, lever_index = 0)
    LEVERS = [my_lever3]
    Hawk = []
    QueenAnt = []
    BEETLE_FRIEND = []
  #
  if new_region == 'Town':
    everything_save_data(True, 97, '1')
    if not My_cached_info.PlayingForestTheme:
      pygame.mixer.music.load(My_cached_info.ForestThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = True
      My_cached_info.PlayingSewerTheme = False
    ignore_the_rest = False
    if not My_cached_info.play_intro_sequence:
      if forced_out:
        if old_map_spawn_index == 0:
          PLAYER.x_pos, PLAYER.y_pos = 2272, 2534
          PLAYER.x_vel = -100
          PLAYER.y_vel = -200
          ignore_the_rest = True
        if old_map_spawn_index == 2:
          PLAYER.x_pos, PLAYER.y_pos = 75, PLAYER.y_pos * (2693 / 4171)
          PLAYER.x_vel = abs(PLAYER.x_vel)
          if PLAYER.x_vel < 50:
            PLAYER.x_vel = 50
          ignore_the_rest = True
      if (MAP.spawn_location[old_map_spawn_index] == 1) and not ignore_the_rest:
        PLAYER.x_pos, PLAYER.y_pos = 743, 2640
        PLAYER.x_vel, PLAYER.y_vel = 0, 0
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[743-20, 743+85-69+20, 2640-20, 2640+85-69+20]], new_regions = [['TheDoor13']], spawn_location = [1], region = 'Town', forced_exit = True, forced_exit_points = [[0, 40, 0, 2793], [2234, 2488, 2565, 2782]], forced_exit_next_map = [['Forest', 666], ['Sewer', 666]], png_name = 'TOWN')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_TOWN')
    BACKGROUND1 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.015/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 0-1462, use_convert_alpha = False, special_directions = 1, png_name = 'Forest_BG1')
    BACKGROUND3 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.025/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 4133-18-1462, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG3')
    BACKGROUND4 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.04/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 4046-18-1462, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG4')
    BACKGROUND5 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.06/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 3865-18-1462, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG5')
    BACKGROUND6 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.067/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 3598-18-1462, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG6')
    BACKGROUND7 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.075/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 3262-18-1462, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG7')
    BACKGROUND12 = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 100000, scroll_speed_x = 0.1/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 2728-18-1462, use_convert_alpha = True, special_directions = 1, png_name = 'Forest_BG12') # 2.3, 2728
    DEER = Background(scroll_leftright = True, scroll_updown = False, iteration_speed = 11, scroll_speed_x = 0.1/10, scroll_speed_y = 1/10,  scale = False, scale_size = (2000, 6000), permanent_add_x = 0, permanent_add_y = 4081-18, use_convert_alpha = True, special_directions = 2, png_name = 'Forest_BGDEER') # Deer
    BACKGROUND = [BACKGROUND1, BACKGROUND3, BACKGROUND4, BACKGROUND5, BACKGROUND6, BACKGROUND7, BACKGROUND12]
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    my_vine1 = Vine(x_pos = 2355+((1/2) * screen_width), y_pos = 2448+((1/2) * screen_height), vine_length = 1, vine_segment_length = 2894, rotation = 270, angular_accel = 0, angular_vel = 0, is_the_player_swinging = False, connected_segment_of_vine = -1, max_angular_accel = 50, png_name = 'WELL_ROPE', vine_type = 1)
    MY_VINES = [my_vine1]
    CLOUDS = []
    TEETERTOTTERS = []
    ALLKEYS = []
    DOORS = []
    my_door_with_knob1 = DoorWithKnob(x_pos = 1363 + ((1/2)*screen_width), y_pos = 1132 + ((1/2)*screen_height), grapple_xy_poses1 = [(), (), (), (), (69, 140), (52, 140), (38, 140), (22, 140), (15, 140)], grapple_xy_poses2 = [(163, 140), (156, 140), (140, 140), (126, 140), (109, 140), (), (), (), ()], door_png_name = 'DOOR_WITH_KNOB', knob_png_name = 'KNOB')
    my_door_with_knob2 = DoorWithKnob(x_pos = 2314 + ((1/2)*screen_width), y_pos = 1132 + ((1/2)*screen_height), grapple_xy_poses1 = [(), (), (), (), (69, 140), (52, 140), (38, 140), (22, 140), (15, 140)], grapple_xy_poses2 = [(163, 140), (156, 140), (140, 140), (126, 140), (109, 140), (), (), (), ()], door_png_name = 'DOOR_WITH_KNOB', knob_png_name = 'KNOB')
    DOORS_WITH_KNOB = [my_door_with_knob1, my_door_with_knob2]
    ANTS = []
    PLAYER_MOVER_ANTS = []
    SQUIRRELS = []
    BOUNCIES = []
    MOVING_BOUNCIES = []
    ELEVATORS = []
    LEAVES = []
    ROOTS = []
    DRIPDROPS = []
    UPGRADES = []
    WATER_REGIONS = []
    WATER_COVERS = []
    WATER_SURFACES = []
    IRREGULARLY_SHAPED_WATER = []
    SPINNY_OBJECTS = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    GRATES = []
    GOLDFISH = []
    TRANSPORT_PIPES = []
    SURF_BOARDS = []
    SURFING_RAT = []
    EATING_RAT = []
    WAVES = []
    BUCKETS = []
    FOOD = []
    my_garbage_can1 = GarbageCan(x_pos = 616 + ((1/2)*screen_width), y_pos = 2583 + ((1/2)*screen_height))
    if not forced_out:
      if (MAP.spawn_location[old_map_spawn_index] == 1) and not ignore_the_rest:
        my_garbage_can1.player_is_inside = True
    GARBAGE_CAN = [my_garbage_can1]
    THE_MACHINE = [TheMachine()]
    if all_current_save_data[41][0] == '1':
      THE_MACHINE[0].placed_screw_driver = True
      THE_MACHINE[0].repair_screw_driver = True
      THE_MACHINE[0].screw_driver_reached_themachine = True
      THE_MACHINE[0].milliseconds_since_screw_driver_repair = 999999
      THE_MACHINE[0].screw_cur_milliseconds = 999999
      THE_MACHINE[0].smoke1_cur_milliseconds = 999999
      THE_MACHINE[0].screw_stage = 4
    if all_current_save_data[42][0] == '1':
      THE_MACHINE[0].placed_wire_cutter = True
      THE_MACHINE[0].repair_wire_cutter = True
      THE_MACHINE[0].wire_cutter_reached_themachine = True
      THE_MACHINE[0].milliseconds_since_wire_cutter_repair = 999999
      THE_MACHINE[0].wire_cutter_cur_milliseconds = 999999
      THE_MACHINE[0].smoke2_cur_milliseconds = 999999
      THE_MACHINE[0].smoke3_cur_milliseconds = 999999
      THE_MACHINE[0].wire_cutter_stage = 4
    if all_current_save_data[43][0] == '1':
      THE_MACHINE[0].placed_wrench = True
      THE_MACHINE[0].repair_wrench = True
      THE_MACHINE[0].wrench_reached_themachine = True
      THE_MACHINE[0].milliseconds_since_wrench_repair = 999999
      THE_MACHINE[0].wrench_cur_milliseconds = 999999
      THE_MACHINE[0].smoke4_cur_milliseconds = 999999
      THE_MACHINE[0].wrench_stage = 4
    TOOLS = []
    HAMSTER_BOX = [HamsterOs()]
    HUMAN = [Human()]
    HAMSTER_PELLET = []
    TheDoor13_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 743 + ((1/2)*screen_width) + 42.5, center_of_door_y = 2640+((1/2) * screen_height) + 42.5, difficulty = 0)
    SUB_LEVEL_DIFFICULTIES = [TheDoor13_sublevel_difficulty]
    TRASH = []
    Well = SimplySprite(x_pos = 2191+((1/2) * screen_width), y_pos = 2275+((1/2) * screen_height), png_name = 'WELL')
    MY_SPRITES_FRONT = [Well]
    MY_SPRITES_BACK = []
    Flower1 = MovingSprite(x_pos = 1580+((1/2) * screen_width), y_pos = 2584+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 20, png_name = 'FLOWER2')
    Flower2 = MovingSprite(x_pos = 1747+((1/2) * screen_width), y_pos = 2584+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 20, png_name = 'FLOWER2')
    Flower3 = MovingSprite(x_pos = 170+((1/2) * screen_width), y_pos = 2634+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 20, png_name = 'FLOWER1')
    Flower4 = MovingSprite(x_pos = 425+((1/2) * screen_width), y_pos = 2634+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 20, png_name = 'FLOWER1')
    Flower5 = MovingSprite(x_pos = 939+((1/2) * screen_width), y_pos = 2634+((1/2) * screen_height), number_of_frames = 4, current_frame = 0, frame_duration = 20, png_name = 'FLOWER1')
    MOVING_SPRITE_FRONT = []
    MOVING_SPRITE_BACK = [Flower1, Flower2, Flower3, Flower4, Flower5]
    Grass1 = Grass(x_pos = -16+((1/2) * screen_width), y_pos = 2684+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass2 = Grass(x_pos = 55+((1/2) * screen_width), y_pos = 2684+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass3 = Grass(x_pos = 258+((1/2) * screen_width), y_pos = 2684+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass4 = Grass(x_pos = 576+((1/2) * screen_width), y_pos = 2686+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass5 = Grass(x_pos = 798+((1/2) * screen_width), y_pos = 2686+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass6 = Grass(x_pos = 1021+((1/2) * screen_width), y_pos = 2684+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass7 = Grass(x_pos = 1479+((1/2) * screen_width), y_pos = 2684+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass8 = Grass(x_pos = 1936+((1/2) * screen_width), y_pos = 2684+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass9 = Grass(x_pos = 2180+((1/2) * screen_width), y_pos = 2684+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass10 = Grass(x_pos = 2247+((1/2) * screen_width), y_pos = 2684+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass11 = Grass(x_pos = 2321+((1/2) * screen_width), y_pos = 2684+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass12 = Grass(x_pos = 2386+((1/2) * screen_width), y_pos = 2684+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass13 = Grass(x_pos = 2458+((1/2) * screen_width), y_pos = 2684+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    Grass14 = Grass(x_pos = 2634+((1/2) * screen_width), y_pos = 2684+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'FOREST_GRASS_R0')
    GRASSES = [Grass1, Grass2, Grass3, Grass4, Grass5, Grass6, Grass7, Grass8, Grass9, Grass10, Grass11, Grass12, Grass13, Grass14]
    TV = []
    PROPELLERS = []
    LEVERS = []
    Hawk = []
    QueenAnt = []
    BEETLE_FRIEND = []
    beetle_exists = all_current_save_data[17][0]
    if beetle_exists == '0':
      pass
    if beetle_exists == '1':
      BEETLE_FRIEND = Beetle(x_pos = 628+((1/2)*screen_width), y_pos = 4682+((1/2)*screen_height), rotation = 5)
      BEETLE_FRIEND.x_pos = 1759 + ((1/2) * screen_width)
      BEETLE_FRIEND.y_pos = 2721 + ((1/2) * screen_height)
      BEETLE_FRIEND.rotation = -7
      BEETLE_FRIEND.flipped = True
      BEETLE_FRIEND.image_flipped = True
  if PLAYER.allowed_door_privileges:
    everything_save_data(True, 55, '1')
    all_current_save_data = everything_save_data(False, 0, '')
  #
  if new_region == 'TheDoor13': # tutorial
    if not My_cached_info.PlayingForestTheme:
      pygame.mixer.music.load(My_cached_info.ForestThemePath)
      pygame.mixer.music.play(-1)
      My_cached_info.PlayingForestTheme = True
      My_cached_info.PlayingSewerTheme = False
    if MAP.spawn_location[old_map_spawn_index] == 1:
      PLAYER.x_pos, PLAYER.y_pos = 496, 3523
      PLAYER.x_vel, PLAYER.y_vel = 0, 0
    MAP = MyMap(x_pos = 0, y_pos = 0, change_region_points = [[496-20, 496+85-69+20, 3523-20, 3523+85-69+20]], new_regions = [['Town']], spawn_location = [1], region = 'TheDoor13', forced_exit = False, forced_exit_points = [], forced_exit_next_map = [], png_name = 'THE_DOOR13')
    PRETTY_MAP = MapSimplySprite(x_pos = 0, y_pos = 0, png_name = 'PRETTY_MAP_THE_DOOR13')
    BACKGROUND1 = Background(scroll_leftright = True, scroll_updown = True, iteration_speed = 11, scroll_speed_x = 0.04/10, scroll_speed_y = 0.04/10, scale = True, scale_size = (2000, 2000), permanent_add_x = 0, permanent_add_y = 0, use_convert_alpha = False, special_directions = 1, png_name = 'SEWER_GREEN_BG')
    BACKGROUND2 = Background(scroll_leftright = True, scroll_updown = True, iteration_speed = 11, scroll_speed_x = 0.04/10, scroll_speed_y = 0.04/10, scale = True, scale_size = (2000, 2000), permanent_add_x = 0, permanent_add_y = 0, use_convert_alpha = False, special_directions = 1, png_name = 'SEWER_BG')
    BACKGROUND = [BACKGROUND1, BACKGROUND2]
    stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
    MY_VINES = []
    CLOUDS = []
    TEETERTOTTERS = []
    ALLKEYS = []
    DOORS = []
    DOORS_WITH_KNOB = []
    ANTS = []
    PLAYER_MOVER_ANTS = []
    SQUIRRELS = []
    BOUNCIES = []
    MOVING_BOUNCIES = []
    ELEVATORS = []
    LEAVES = []
    ROOTS = []
    DRIPDROPS = []
    UPGRADES = []
    if all_current_save_data[38][0] == '0':
      my_upgrade10 = Upgrade(x_pos = 6704+((1/2) * screen_width), y_pos = 1904+((1/2) * screen_height), collected = False)
      UPGRADES = [my_upgrade10]
    WATER_REGIONS = [(3045-32, 3867-32, 3759-69, 4430, 0, -50)]
    water_surface1 = WaterSurface(x_pos = 3045+((1/2) * screen_width), y_pos = 3759-16+((1/2) * screen_height), width = 208, png_name = 'WATER_SURFACE1', water_surface_type = 1, connected_to_which_bucket = 666)
    water_surface2 = WaterSurface(x_pos = 3410+((1/2) * screen_width), y_pos = 3759-15+((1/2) * screen_height), width = 382, png_name = 'WATER_SURFACE_TUTORIAL', water_surface_type = 1, connected_to_which_bucket = 666)
    water_cover1 = WaterCover(x_pos = 3045+((1/2) * screen_width), y_pos = 3759+((1/2) * screen_height), png_name = 'TUTORIAL_WATER_COVER')
    WATER_COVERS = [water_cover1]
    WATER_SURFACES = [water_surface1, water_surface2]
    IRREGULARLY_SHAPED_WATER = []
    SPINNY_OBJECTS = []
    SEWER_PUMP_WATER = []
    LEAKS = []
    GRATES = []
    GOLDFISH = []
    TRANSPORT_PIPES = []
    SURF_BOARDS = []
    SURFING_RAT = []
    EATING_RAT = []
    WAVES = []
    BUCKETS = []
    FOOD = []
    GARBAGE_CAN = []
    THE_MACHINE = []
    TOOLS = []
    HAMSTER_BOX = []
    HUMAN = []
    HAMSTER_PELLET = []
    TheDoor13_sublevel_difficulty = SubLevelDifficulty(center_of_door_x = 496+((1/2) * screen_width) + 42.5, center_of_door_y = 3523+((1/2) * screen_height) + 42.5, difficulty = 4)
    trash1_interact = SubLevelDifficulty(center_of_door_x = 4114+56+((1/2) * screen_width), center_of_door_y = 3667+31+((1/2) * screen_height), difficulty = 5)
    trash2_interact = SubLevelDifficulty(center_of_door_x = 6068+56+((1/2) * screen_width), center_of_door_y = 3306+31+((1/2) * screen_height), difficulty = 5)
    SUB_LEVEL_DIFFICULTIES = [TheDoor13_sublevel_difficulty, trash1_interact, trash2_interact]
    trash1 = Trash(x_pos = 4114 + ((1 / 2) * screen_width), y_pos = 3667 + ((1 / 2) * screen_height), png_collectable = 'SHEATH_TRASH', which_index = 0)
    trash2 = Trash(x_pos = 6068 + ((1 / 2) * screen_width), y_pos = 3306 + ((1 / 2) * screen_height), png_collectable = 'GRAPPLE_TRASH', which_index = 1)
    if all_current_save_data[50][0] == '1':
      trash1.trash_has_been_collected = True
      SUB_LEVEL_DIFFICULTIES[1].allowed_to_display = False
    if all_current_save_data[51][0] == '1':
      trash2.trash_has_been_collected = True
      SUB_LEVEL_DIFFICULTIES[2].allowed_to_display = False
    TRASH = [trash1, trash2]
    TheDoor13 = SimplySprite(x_pos = 496+((1/2) * screen_width), y_pos = 3523+((1/2) * screen_height), png_name = 'THE_DOOR')
    WaterSurfaceHider1 = SimplySprite(x_pos = 3758+((1/2) * screen_width), y_pos = 3731+((1/2) * screen_height), png_name = 'WATER_SURFACE_HIDER_TUTORIAL')
    TrashHider1 = SimplySprite(x_pos = 4113+((1/2) * screen_width), y_pos = 3719+((1/2) * screen_height), png_name = 'TRASH_HIDER1')
    TrashHider2 = SimplySprite(x_pos = 6068+((1/2) * screen_width), y_pos = 3358+((1/2) * screen_height), png_name = 'TRASH_HIDER2')
    MY_SPRITES_FRONT = [TrashHider1, TrashHider2]
    MY_SPRITES_BACK = [TheDoor13, WaterSurfaceHider1]
    MOVING_SPRITE_FRONT = []
    MOVING_SPRITE_BACK = []
    Grass1 = Grass(x_pos = 863+((1/2) * screen_width), y_pos = 3427+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R20')
    Grass2 = Grass(x_pos = 973+((1/2) * screen_width), y_pos = 3418+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R10')
    Grass3 = Grass(x_pos = 1056+((1/2) * screen_width), y_pos = 3448+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R30')
    Grass4 = Grass(x_pos = 1703+((1/2) * screen_width), y_pos = 3526+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R10')
    Grass5 = Grass(x_pos = 1835+((1/2) * screen_width), y_pos = 3512+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass6 = Grass(x_pos = 2451+((1/2) * screen_width), y_pos = 3701+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass7 = Grass(x_pos = 2370+((1/2) * screen_width), y_pos = 3701+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass8 = Grass(x_pos = 2294+((1/2) * screen_width), y_pos = 3701+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass9 = Grass(x_pos = 2618+((1/2) * screen_width), y_pos = 3469+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass10 = Grass(x_pos = 3762+((1/2) * screen_width), y_pos = 3644+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R10')
    Grass11 = Grass(x_pos = 3849+((1/2) * screen_width), y_pos = 3632+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R10')
    Grass12 = Grass(x_pos = 4525+((1/2) * screen_width), y_pos = 3620+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass13 = Grass(x_pos = 4605+((1/2) * screen_width), y_pos = 3620+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass14 = Grass(x_pos = 5081+((1/2) * screen_width), y_pos = 3620+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass15 = Grass(x_pos = 5162+((1/2) * screen_width), y_pos = 3620+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass16 = Grass(x_pos = 5248+((1/2) * screen_width), y_pos = 3620+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass17 = Grass(x_pos = 5324+((1/2) * screen_width), y_pos = 3620+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass18 = Grass(x_pos = 5401+((1/2) * screen_width), y_pos = 3620+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass19 = Grass(x_pos = 5479+((1/2) * screen_width), y_pos = 3620+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass20 = Grass(x_pos = 5555+((1/2) * screen_width), y_pos = 3620+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass21 = Grass(x_pos = 6254+((1/2) * screen_width), y_pos = 2805+((1/2) * screen_height), flipped = False, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    Grass22 = Grass(x_pos = 6370+((1/2) * screen_width), y_pos = 2805+((1/2) * screen_height), flipped = True, milliseconds_to_next_image = 260, in_the_back = False, png_name = 'ANTHILL_GRASS_R0')
    GRASSES = [Grass1, Grass2, Grass3, Grass4, Grass5, Grass6, Grass7, Grass8, Grass9, Grass10, Grass11, Grass12, Grass13, Grass14, Grass15, Grass16, Grass17, Grass18, Grass19, Grass20, Grass21, Grass22]
    TV = []
    PROPELLERS = []
    LEVERS = []
    Hawk = []
    QueenAnt = []
    BEETLE_FRIEND = []
    global ON_A_GARBAGE_CAN
    ON_A_GARBAGE_CAN = False
  #
  #
  SURFING_CLOCK = []
  SURFING_PROGRESS_BAR = []
  NUMBERS_ABOVE_HAMSTER = []
  my_bottom_ball =       BallCollision(x_pos = PLAYER.x_pos, y_pos = PLAYER.y_pos, offset_x = 29, offset_y = 43, png_name = 'Bottom_ball.png')
  my_bottom_ball_inner = BallCollision(x_pos = PLAYER.x_pos, y_pos = PLAYER.y_pos, offset_x = 29, offset_y = 67, png_name = 'Bottom_ball_inner.png')
  my_top_ball =          BallCollision(x_pos = PLAYER.x_pos, y_pos = PLAYER.y_pos, offset_x = 29, offset_y = 0, png_name = 'Top_ball.png')
  my_top_ball_inner =    BallCollision(x_pos = PLAYER.x_pos, y_pos = PLAYER.y_pos, offset_x = 29, offset_y = 1, png_name = 'Top_ball_inner.png')
  my_left_ball =         BallCollision(x_pos = PLAYER.x_pos, y_pos = PLAYER.y_pos, offset_x = 0, offset_y = 29, png_name = 'Left_ball.png')
  my_left_ball_inner =   BallCollision(x_pos = PLAYER.x_pos, y_pos = PLAYER.y_pos, offset_x = 1, offset_y = 29, png_name = 'Left_ball_inner.png')
  my_right_ball =        BallCollision(x_pos = PLAYER.x_pos, y_pos = PLAYER.y_pos, offset_x = 44, offset_y = 29, png_name = 'Right_ball.png')
  my_right_ball_inner =  BallCollision(x_pos = PLAYER.x_pos, y_pos = PLAYER.y_pos, offset_x = 67, offset_y = 29, png_name = 'Right_ball_inner.png')
  my_middle_ball =       BallCollision(x_pos = PLAYER.x_pos, y_pos = PLAYER.y_pos, offset_x = 29, offset_y = 0, png_name = 'MiddleBall.png')
  my_AllBall =           BallCollision(x_pos = PLAYER.x_pos, y_pos = PLAYER.y_pos, offset_x = 0, offset_y = 0, png_name = 'AllBall.png')
  my_sheath = PistonSheath(rotation = 0, x_pos = PLAYER.x_pos, y_pos = PLAYER.y_pos)
  try:
    my_piston1 = PushPiston(extension = 0, prev_extension = 0, maximum_extension = my_piston1.maximum_extension, x_pos = PLAYER.x_pos - 241, y_pos = PLAYER.y_pos - 241)
    my_piston2 = GrapplePiston(extension = 0, maximum_extension = my_piston1.maximum_extension, x_pos = PLAYER.x_pos - 241, y_pos = PLAYER.y_pos - 241, is_closed = False, is_currently_grappling = False, grapple_claw_x_pos = 0, grapple_claw_y_pos = 0, connected_to_map = False, connected_to_vine = False, connected_to_cloud = False)
  except:
    my_piston1 = PushPiston(extension = 0, prev_extension = 0, maximum_extension = 100, x_pos = PLAYER.x_pos - 241, y_pos = PLAYER.y_pos - 241)
    my_piston2 = GrapplePiston(extension = 0, maximum_extension = 100, x_pos = PLAYER.x_pos - 241, y_pos = PLAYER.y_pos - 241, is_closed = False, is_currently_grappling = False, grapple_claw_x_pos = 0, grapple_claw_y_pos = 0, connected_to_map = False, connected_to_vine = False, connected_to_cloud = False)
  Marker = TheMarker(x_pos = 0, y_pos = 0, prev_x_pos = 0, prev_y_pos = 0, png_name = 'Marker.png')
  PLAYER.how_submerged = 0
  PLAYER.forces_for_next_frame_x = 0
  PLAYER.forces_for_next_frame_y = 0
  PLAYER.changed_region_last_frame = True
  BUBBLES = []
  PLAYER.carrying_food = False
  PLAYER.carrying_which_food = 666
  if all_current_save_data[16][0] == '1':
    PLAYER.collected_screw_driver = True
  if all_current_save_data[17][0] == '1':
    PLAYER.collected_wire_cutter = True
  if all_current_save_data[18][0] == '1':
    PLAYER.collected_wrench = True
  for i in range(27, 39):
    if all_current_save_data[i][0] == '1':
      PLAYER.CollectedUpgrades[i - 27] = True
  for i in range(47, 53):
    if all_current_save_data[i][0] == '1':
      PLAYER.intro_data[i - 47] = 1
      if i == 50:
        PLAYER.has_piston1 = True
      if i == 51:
        PLAYER.has_piston2 = True
        PLAYER.have_detached_before = True
  if all_current_save_data[55][0] == '1':
    PLAYER.post_tutorial_data[0] = 1
  if all_current_save_data[56][0] == '1':
    PLAYER.post_tutorial_data[1] = 1
  PLAYER.region = MAP.region
  My_cached_info.milliseconds_into_tool_flying_around_player = 0
  My_cached_info.play_tool_sequence = False
  My_cached_info.current_milliseconds_in_surfing_challenge = 0
  if PLAYER.intro_data == [1, 1, 1, 1, 1, 1]:
    PLAYER.allowed_door_privileges = True
  PLAYER.dialogue_millisecond_counter = 0
  PLAYER.hamster_thinks_her_goal = False
  PLAYER.able_to_insert_into_machine = False
  My_cached_info.number_of_ant_sounds_being_played = 0
  My_cached_info.playing_door_sound = False
  My_cached_info.on_a_loading_screen = False
  total_collected_upgrades = 0
  for SingleUpgradeCollected in PLAYER.CollectedUpgrades:
    if SingleUpgradeCollected:
      total_collected_upgrades += 1
  my_piston1.maximum_extension = maximum_piston_length_dict[str(total_collected_upgrades)]
  my_piston2.maximum_extension = maximum_piston_length_dict[str(total_collected_upgrades)]
  My_cached_info.milliseconds_dont_show_trash_sublevel_difficulty = 0
  PLAYER.on_a_cloud_prev_frames = [False, False, False, False, False, False, False, False]
  My_cached_info.doing_the_back = True
  if all_current_save_data[90][0] == '1':
    PLAYER.talked_fast_travel = True
  if all_current_save_data[93][0] == '1':
    PLAYER.talked_to_eating_rat_before = True
  My_cached_info.playing_irregularly_shaped_water_sound = False
  STANDING_ON_TEETERTOTTER = False
  ON_AN_ELEVATOR = False
  STANDING_ON_CLOUD = False
  STANDING_ON_WHICH_CLOUD = 666
  ON_A_GARBAGE_CAN = False
  ON_THE_MACHINE = False
  PLAYER.on_a_surf_board = False
  KEY_GRABBED_BY_PLAYER = False
  BOX_GRABBED_BY_PLAYER = False
  reduce_KEy = False
  GRAPPLED_TO_PLATFORM = False
  SUPER_BOUNCY = False
  RELEASED_GRAPPLE_LAST_FRAME = False
  ON_A_BUCKET = False
  IN_A_BUCKET = False
  CANT_REENTER_PIPE = False
  TIME_SINCE_EXITING_PIPE = 0
  TOUCHED_ROOT = False
  PLAY_UPGRADE_CUTSCENE = False
  PLAY_UPGRADE_CUTSCENE_start_frame = 0
  PLAY_UPGRADE_CUTSCENE_end_frame = 0
  PREVIOUS_PUSH_PISTON = ['Nothing' for x in range(20)]
  My_cached_info.playing_upgrade_sequence = False
  My_cached_info.upgrade_finished_flying_around_player = False
  My_cached_info.milliseconds_into_upgrade_sequence = 0
  My_cached_info.bubble_flying_number_of_pixels_to_move = 0
  PLAYER.in_a_pipe = False
  PLAYER.in_which_pipe = 666
  PLAYER.last_step_in_pipe_path = 0
  PLAYER.step_in_pipe_path = 0
  PLAYER.got_centered_in_pipe = False
  PLAYER.initial_pipe_adjustment_to_center_x = 0
  PLAYER.initial_pipe_adjustment_to_center_y = 0
  PLAYER.initial_player_position_when_touching_pipe_x = 0
  PLAYER.initial_player_position_when_touching_pipe_y = 0
  PLAYER.final_desired_pipe_position_x = 0
  PLAYER.final_desired_pipe_position_y = 0
  PLAYER.in_pipe_wind = False
  global ANT_GRABBED_PLAYER
  ANT_GRABBED_PLAYER = False
  My_cached_info.playing_irregular_surfing_water = False
  My_cached_info.playing_wave_sound = False
  for SingleRoot in ROOTS:
    SingleRoot.shaky_root_sound.set_volume(My_cached_info.current_sound_loudness * MixerSoundsLoudness['SHAKY_ROOT'])
  return


 ##################
###  START GAME  ###
 ##################


collisions_with_bottom_ball, collison_with_bottom_ball_happened = False, False
collisions_with_top_ball, collison_with_top_ball_happened = False, False
collisions_with_left_ball, collison_with_left_ball_happened = False, False
collisions_with_right_ball, collison_with_right_ball_happened = False, False
cur_col_grapple_happened = False


running = True
prev_time = time.time()
target_fps = 60
fps = target_fps
frame_counter = 0

normal_force_angle = 500
leaving_a_wall = False


def readjust_everything_after_resolution_change(old_screen_width, old_screen_height):
  global stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom
  stop_scrolling_left, stop_scrolling_right, stop_scrolling_top, stop_scrolling_bottom = update_scrolling_at_edges(MAP)
  #
  for SingleVine in MY_VINES:
    SingleVine.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleVine.y_pos += (screen_height / 2) - (old_screen_height / 2)
    for i in range(len(SingleVine.x_poss)):
      SingleVine.x_poss[i] += (screen_width / 2) - (old_screen_width / 2)
      SingleVine.y_poss[i] += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleCloud in CLOUDS:
    SingleCloud.center_x += (screen_width / 2) - (old_screen_width / 2)
    SingleCloud.center_y += (screen_height / 2) - (old_screen_height / 2)
    SingleCloud.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleCloud.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleCloud.prev_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleCloud.prev_y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleTotter in TEETERTOTTERS:
    SingleTotter.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleTotter.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleTotter.original_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleTotter.original_y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleKey in ALLKEYS:
    SingleKey.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleKey.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleKey.original_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleKey.original_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleKey.is_inserted_coordinate_range[0] += (screen_width / 2) - (old_screen_width / 2)
    SingleKey.is_inserted_coordinate_range[1] += (screen_width / 2) - (old_screen_width / 2)
    SingleKey.is_inserted_coordinate_range[2] += (screen_height / 2) - (old_screen_height / 2)
    SingleKey.is_inserted_coordinate_range[3] += (screen_height / 2) - (old_screen_height / 2)
    if SingleKey.key_type == 3:
      SingleKey.xy_poses = [(5264+((1/2)*screen_width), 1616+((1/2)*screen_height)), (6176+((1/2)*screen_width), 1584+((1/2)*screen_height)), (6960+((1/2)*screen_width), 1504+((1/2)*screen_height)), (4944+((1/2)*screen_width), 2288+((1/2)*screen_height)), (6160+((1/2)*screen_width), 2416+((1/2)*screen_height)), (7024+((1/2)*screen_width), 2480+((1/2)*screen_height))]
  #
  for SingleDoor in DOORS:
    SingleDoor.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleDoor.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleDoor.original_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleDoor.original_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleDoor.is_open_x += (screen_width / 2) - (old_screen_width / 2)
    SingleDoor.is_open_y += (screen_height / 2) - (old_screen_height / 2)
    if SingleDoor.door_type == 2:
      SingleDoor.LeftImage_x_pos += (screen_width / 2) - (old_screen_width / 2)
      SingleDoor.LeftImage_y_pos += (screen_height / 2) - (old_screen_height / 2)
      SingleDoor.RightImage_x_pos += (screen_width / 2) - (old_screen_width / 2)
      SingleDoor.RightImage_y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleDoorWithKnob in DOORS_WITH_KNOB:
    SingleDoorWithKnob.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleDoorWithKnob.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleAnt in ANTS:
    SingleAnt.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleAnt.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleAnt.boundaries[0] += (screen_width / 2) - (old_screen_width / 2)
    SingleAnt.boundaries[1] += (screen_width / 2) - (old_screen_width / 2)
    SingleAnt.boundaries[2] += (screen_height / 2) - (old_screen_height / 2)
    SingleAnt.boundaries[3] += (screen_height / 2) - (old_screen_height / 2)
  #
  for SinglePlayerMoverAnt in PLAYER_MOVER_ANTS:
    SinglePlayerMoverAnt.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SinglePlayerMoverAnt.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleSquirrel in SQUIRRELS:
    SingleSquirrel.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleSquirrel.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleSquirrel.prev_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleSquirrel.prev_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleSquirrel.start_pos = (SingleSquirrel.start_pos[0] + (screen_width / 2) - (old_screen_width / 2), SingleSquirrel.start_pos[1] + (screen_height / 2) - (old_screen_height / 2))
    SingleSquirrel.end_pos = (SingleSquirrel.end_pos[0] + (screen_width / 2) - (old_screen_width / 2), SingleSquirrel.end_pos[1] + (screen_height / 2) - (old_screen_height / 2))
  #
  for SingleBouncy in BOUNCIES:
    SingleBouncy.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleBouncy.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleMovingBouncy in MOVING_BOUNCIES:
    SingleMovingBouncy.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleMovingBouncy.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleMovingBouncy.orig_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleMovingBouncy.orig_y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleElevator in ELEVATORS:
    SingleElevator.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.x1 += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.y1 += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.x2 += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.y2 += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.PlatformLeftTop_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.PlatformLeftTop_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.PlatformMiddleTop_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.PlatformMiddleTop_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.PlatformRightTop_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.PlatformRightTop_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.PlatformLeftBottom_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.PlatformLeftBottom_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.PlatformMiddleBottom_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.PlatformMiddleBottom_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.PlatformRightBottom_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.PlatformRightBottom_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.LeftMiddlePlatform_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.LeftMiddlePlatform_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.RightMiddlePlatform_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.RightMiddlePlatform_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.DownPeg1_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.DownPeg1_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.DownPeg2_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.DownPeg2_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.DownPeg3_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.DownPeg3_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.UpPeg1_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.UpPeg1_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.UpPeg2_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.UpPeg2_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.UpPeg3_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.UpPeg3_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.UpPeg4_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.UpPeg4_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.UpPeg5_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.UpPeg5_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.LeftDoor_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.LeftDoor_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleElevator.RightDoor_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleElevator.RightDoor_y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleLeaf in LEAVES:
    SingleLeaf.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleLeaf.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleLeaf.orig_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleLeaf.orig_y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleRoot in ROOTS:
    SingleRoot.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleRoot.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleDripDrop in DRIPDROPS:
    SingleDripDrop.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleDripDrop.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleDripDrop.start_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleDripDrop.end_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleDripDrop.phantom_y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleUpgrade in UPGRADES:
    SingleUpgrade.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleUpgrade.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleUpgrade.orig_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleUpgrade.orig_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleUpgrade.piston_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleUpgrade.piston_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleUpgrade.grapple_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleUpgrade.grapple_y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleWaterSurface in WATER_SURFACES:
    SingleWaterSurface.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleWaterSurface.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleIrregularlyShapedWater in IRREGULARLY_SHAPED_WATER:
    SingleIrregularlyShapedWater.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleIrregularlyShapedWater.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleSpinny in SPINNY_OBJECTS:
    SingleSpinny.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleSpinny.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleLeak in LEAKS:
    SingleLeak.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleLeak.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleGoldfish in GOLDFISH:
    SingleGoldfish.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleGoldfish.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleGoldfish.bounds[0] += (screen_width / 2) - (old_screen_width / 2)
    SingleGoldfish.bounds[1] += (screen_width / 2) - (old_screen_width / 2)
    SingleGoldfish.bounds[2] += (screen_height / 2) - (old_screen_height / 2)
    SingleGoldfish.bounds[3] += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleTransportPipe in TRANSPORT_PIPES:
    SingleTransportPipe.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleTransportPipe.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleSurfBoard in SURF_BOARDS:
    SingleSurfBoard.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleSurfBoard.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleSurfBoard.previous_x += (screen_width / 2) - (old_screen_width / 2)
    SingleSurfBoard.previous_y += (screen_height / 2) - (old_screen_height / 2)
    SingleSurfBoard.current_x += (screen_width / 2) - (old_screen_width / 2)
    SingleSurfBoard.current_y += (screen_height / 2) - (old_screen_height / 2)
    SingleSurfBoard.boundaries[0] += (screen_width / 2) - (old_screen_width / 2)
    SingleSurfBoard.boundaries[1] += (screen_width / 2) - (old_screen_width / 2)
    SingleSurfBoard.boundaries[2] += (screen_height / 2) - (old_screen_height / 2)
    SingleSurfBoard.boundaries[3] += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleSurfingRat in SURFING_RAT:
    SingleSurfingRat.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleSurfingRat.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleEatingRat in EATING_RAT:
    SingleEatingRat.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleEatingRat.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleWave in WAVES:
    SingleWave.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleWave.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleBucket in BUCKETS:
    SingleBucket.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleBucket.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleBucket.bottom_x += (screen_width / 2) - (old_screen_width / 2)
    SingleBucket.bottom_y += (screen_height / 2) - (old_screen_height / 2)
    SingleBucket.top_x += (screen_width / 2) - (old_screen_width / 2)
    SingleBucket.top_y += (screen_height / 2) - (old_screen_height / 2)
    SingleBucket.water_region[0] += (screen_width / 2) - (old_screen_width / 2)
    SingleBucket.water_region[1] += (screen_width / 2) - (old_screen_width / 2)
    SingleBucket.water_region[2] += (screen_height / 2) - (old_screen_height / 2)
    SingleBucket.water_region[3] += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleFood in FOOD:
    SingleFood.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleFood.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleGarbageCan in GARBAGE_CAN:
    SingleGarbageCan.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleGarbageCan.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleTheMachine in THE_MACHINE:
    SingleTheMachine.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleTheMachine.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleTheMachine.screw_destination_xy[0] += (screen_width / 2) - (old_screen_width / 2)
    SingleTheMachine.screw_destination_xy[1] += (screen_height / 2) - (old_screen_height / 2)
    SingleTheMachine.wire_cutter_destination_xy[0] += (screen_width / 2) - (old_screen_width / 2)
    SingleTheMachine.wire_cutter_destination_xy[1] += (screen_height / 2) - (old_screen_height / 2)
    SingleTheMachine.wrench_destination_xy[0] += (screen_width / 2) - (old_screen_width / 2)
    SingleTheMachine.wrench_destination_xy[1] += (screen_height / 2) - (old_screen_height / 2)
    try:
      SingleTheMachine.screw_driver_xy[0] += (screen_width / 2) - (old_screen_width / 2)
      SingleTheMachine.screw_driver_xy[1] += (screen_height / 2) - (old_screen_height / 2)
    except:
      pass
    try:
      SingleTheMachine.wire_cutter_xy[0] += (screen_width / 2) - (old_screen_width / 2)
      SingleTheMachine.wire_cutter_xy[1] += (screen_height / 2) - (old_screen_height / 2)
    except:
      pass
    try:
      SingleTheMachine.wrench_xy[0] += (screen_width / 2) - (old_screen_width / 2)
      SingleTheMachine.wrench_xy[1] += (screen_height / 2) - (old_screen_height / 2)
    except:
      pass
  #
  for SingleTool in TOOLS:
    SingleTool.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleTool.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleTool.orig_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleTool.orig_y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleHamsterOs in HAMSTER_BOX:
    SingleHamsterOs.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleHamsterOs.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleHamsterOs.machine_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleHamsterOs.machine_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleHamsterOs.boundaries_to_be_placed_in_machine[0] += (screen_width / 2) - (old_screen_width / 2)
    SingleHamsterOs.boundaries_to_be_placed_in_machine[1] += (screen_width / 2) - (old_screen_width / 2)
    SingleHamsterOs.boundaries[0] += (screen_width / 2) - (old_screen_width / 2)
    SingleHamsterOs.boundaries[1] += (screen_width / 2) - (old_screen_width / 2)
    SingleHamsterOs.boundaries[2] += (screen_height / 2) - (old_screen_height / 2)
    SingleHamsterOs.boundaries[3] += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleHuman in HUMAN:
    SingleHuman.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleHuman.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleHuman.orig_y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleHuman.machine_x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleHuman.machine_y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleSpriteFront in MY_SPRITES_FRONT:
    SingleSpriteFront.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleSpriteFront.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleSpriteBack in MY_SPRITES_BACK:
    SingleSpriteBack.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleSpriteBack.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleMovingSpriteFront in MOVING_SPRITE_FRONT:
    SingleMovingSpriteFront.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleMovingSpriteFront.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleMovingSpriteBack in MOVING_SPRITE_BACK:
    SingleMovingSpriteBack.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleMovingSpriteBack.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleGrass in GRASSES:
    SingleGrass.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleGrass.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleTV in TV:
    SingleTV.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleTV.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SinglePropeller in PROPELLERS:
    SinglePropeller.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SinglePropeller.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleLever in LEVERS:
    SingleLever.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleLever.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  try:
    Hawk.x_pos += (screen_width / 2) - (old_screen_width / 2)
    Hawk.y_pos += (screen_height / 2) - (old_screen_height / 2)
    Hawk.next_location_x += (screen_width / 2) - (old_screen_width / 2)
    Hawk.next_location_y += (screen_height / 2) - (old_screen_height / 2)
  except:
    pass
  #
  try:
    QueenAnt.x_pos += (screen_width / 2) - (old_screen_width / 2)
    QueenAnt.y_pos += (screen_height / 2) - (old_screen_height / 2)
  except:
    pass
  #
  try:
    BEETLE_FRIEND.x_pos += (screen_width / 2) - (old_screen_width / 2)
    BEETLE_FRIEND.y_pos += (screen_height / 2) - (old_screen_height / 2)
  except:
    pass
  #
  for SingleSublevelDifficulty in SUB_LEVEL_DIFFICULTIES:
    SingleSublevelDifficulty.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleSublevelDifficulty.y_pos += (screen_height / 2) - (old_screen_height / 2)
    SingleSublevelDifficulty.center_of_door_x += (screen_width / 2) - (old_screen_width / 2)
    SingleSublevelDifficulty.center_of_door_y += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleTrash in TRASH:
    SingleTrash.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleTrash.y_pos += (screen_height / 2) - (old_screen_height / 2)
  #
  for SingleWaterCover in WATER_COVERS:
    SingleWaterCover.x_pos += (screen_width / 2) - (old_screen_width / 2)
    SingleWaterCover.y_pos += (screen_height / 2) - (old_screen_height / 2)


def pause_menu():
  print(PLAYER.x_pos, PLAYER.y_pos)
  global clock
  My_cached_info.load_from_previous_location = False
  My_cached_info.playing_irregularly_shaped_water_sound = False
  My_cached_info.playing_transport_pipe_suck = False
  My_cached_info.number_of_ant_sounds_being_played = 0
  My_cached_info.playing_door_sound = False
  changing_region_for_TheDoor6 = False
  global aspect, screen_width, screen_height, Screen, available_screen_resolutions, current_screen_resolution_index, current_hotkeys, keys
  global current_music_loudness, current_sound_loudness
  global left_click, weird_click, right_click
  pygame.mixer.stop()
  temporary_screen_resolution_index = current_screen_resolution_index
  current_resolution_image = OpenGLTextures['RESOLUTION_IMAGES'][temporary_screen_resolution_index]
  all_current_save_data = everything_save_data(False, 0, '')
  allow_screen_left_click = True
  touching_resolution = False
  shady_pixel = OpenGLTextures['SHADY_BLACK_PIXEL']
  shady_size_multiplier_x = screen_width
  shady_size_multiplier_y = screen_height
  shady_pixel = ((shady_pixel[0][0] * screen_width, shady_pixel[0][1] * screen_height), shady_pixel[1])
  map_width_adjustment = screen_width * (3 / 5)
  map_height_adjustment = screen_height * (2 / 3)
  map_rectangle = OpenGLTextures['PAUSE_MENU_RECTANGLE']
  map_rectangle = ((map_width_adjustment, map_height_adjustment), map_rectangle[1])
  map_Forest = (((map_width_adjustment / 2) - 2, (map_height_adjustment / 2) - 2), OpenGLTextures['FOREST_MINI'][1])
  map_Town = (((map_width_adjustment / 2) - 2, (map_height_adjustment / 2) - 2), OpenGLTextures['TOWN_MINI'][1])
  map_AntHill = (((map_width_adjustment / 2) - 2, (map_height_adjustment / 2) - 2), OpenGLTextures['ANTHILL_MINI'][1])
  map_Sewer = (((map_width_adjustment / 2) - 2, (map_height_adjustment / 2) - 2), OpenGLTextures['SEWER_MINI'][1])
  adjust_door_pos_x = map_width_adjustment / 24000
  adjust_door_pos_y = map_height_adjustment / 12000
  TheDoor1_pos = [(9110+42) * adjust_door_pos_x, (4860+42) * adjust_door_pos_y]
  TheDoor2_pos = [(11608+42) * adjust_door_pos_x, (927+42) * adjust_door_pos_y]
  TheDoor3_pos = [(7110+42) * adjust_door_pos_x, (3355+42) * adjust_door_pos_y]
  TheDoor4_pos = [(5952+42) * adjust_door_pos_x, (4843+42) * adjust_door_pos_y]
  TheDoor5_pos = [(2592+42) * adjust_door_pos_x, (212+42) * adjust_door_pos_y]
  TheDoor7_pos = [(4881+42) * adjust_door_pos_x, (1409+42+6000) * adjust_door_pos_y]
  TheDoor8_pos = [(963+42) * adjust_door_pos_x, (849+42+6000) * adjust_door_pos_y]
  TheDoor9_pos = [(3530+42) * adjust_door_pos_x, (2285+42+6000) * adjust_door_pos_y]
  TheDoor10_pos = [(11240+42+12000) * adjust_door_pos_x, (636+42+6000) * adjust_door_pos_y]
  TheDoor11_pos = [(784+42+12000) * adjust_door_pos_x, (5051+42+6000) * adjust_door_pos_y]
  TheDoor12_pos = [(11147+42+12000) * adjust_door_pos_x, (4320+42+6000) * adjust_door_pos_y]
  TheDoor13_pos = [(743+2991+42+12000) * adjust_door_pos_x, (2640+1461+42) * adjust_door_pos_y]
  mini_hamster = [(PLAYER.x_pos) * adjust_door_pos_x, (PLAYER.y_pos) * adjust_door_pos_y]
  if MAP.region == 'TheDoor1':
    mini_hamster = TheDoor1_pos
  if MAP.region == 'TheDoor2':
    mini_hamster = TheDoor2_pos
  if MAP.region == 'TheDoor3':
    mini_hamster = TheDoor3_pos
  if MAP.region == 'TheDoor4':
    mini_hamster = TheDoor4_pos
  if MAP.region == 'TheDoor5':
    mini_hamster = TheDoor5_pos
  if MAP.region == 'TheDoor6':
    mini_hamster = [512 * adjust_door_pos_x, (5776+6000) * adjust_door_pos_y]
  if MAP.region == 'TheDoor7':
    mini_hamster = TheDoor7_pos
  if MAP.region == 'TheDoor8':
    mini_hamster = TheDoor8_pos
  if MAP.region == 'TheDoor9':
    mini_hamster = TheDoor9_pos
  if MAP.region == 'TheDoor10':
    mini_hamster = TheDoor10_pos
  if MAP.region == 'TheDoor11':
    mini_hamster = TheDoor11_pos
  if MAP.region == 'TheDoor12':
    mini_hamster = TheDoor12_pos
  if MAP.region == 'TheDoor13':
    mini_hamster = TheDoor13_pos
  if MAP.region == 'Town':
    mini_hamster = [mini_hamster[0]+((12000+2991) * adjust_door_pos_x), mini_hamster[1]+(1461 * adjust_door_pos_y)]
  if MAP.region == 'AntHill':
    mini_hamster = [mini_hamster[0]+((0) * adjust_door_pos_x), mini_hamster[1]+(6000 * adjust_door_pos_y)]
  if MAP.region == 'Sewer':
    mini_hamster = [mini_hamster[0]+((12000) * adjust_door_pos_x), mini_hamster[1]+(6000 * adjust_door_pos_y)]
  mini_hamster = (mini_hamster[0], mini_hamster[1])
  touching_a_travel = False
  touching_which_travel = [False for x in range(12)]
  door_size_adjustment = screen_height / 20
  adjusted_the_door = ((door_size_adjustment, door_size_adjustment), OpenGLTextures['THE_DOOR'][1])
  adjusted_shaded_the_door = ((door_size_adjustment, door_size_adjustment), OpenGLTextures['SHADED_THE_DOOR'][1])
  adjusted_outline_the_door = ((door_size_adjustment * (95 / 85), door_size_adjustment * (95 / 85)), OpenGLTextures['OUTLINE_THE_DOOR'][1])
  available_width_for_upgrades = ((3 / 10) * screen_width)
  single_upgrade_width_and_height = available_width_for_upgrades / 7
  single_highlight_width_and_height = single_upgrade_width_and_height * (75 / 69)
  move_highlight_left_and_up = (single_highlight_width_and_height - single_upgrade_width_and_height) / 2
  bottom_total_available_gap_size = available_width_for_upgrades - (4 * single_upgrade_width_and_height)
  single_gap_size = bottom_total_available_gap_size / 5
  piston1_x = single_upgrade_width_and_height * ((69 - 34) / 2) / 69
  piston1_y = single_upgrade_width_and_height * (14 / 69)
  piston1_width = single_upgrade_width_and_height * (34 / 69)
  piston1_height = single_upgrade_width_and_height * (9 / 69)
  piston2_x = single_upgrade_width_and_height * ((69 - 24) / 2) / 69
  piston2_y = single_upgrade_width_and_height * (31 / 69)
  piston2_width = single_upgrade_width_and_height * (24 / 69)
  piston2_height = single_upgrade_width_and_height * (26 / 69)
  upgrade_distance_from_top = ((screen_height * (1 / 6)) - single_upgrade_width_and_height) / 2
  available_menu_width = (1 / 3) * screen_width
  available_menu_height = screen_height
  empty_menu_width = (1 / 54) * screen_width
  actual_menu_width = available_menu_width - (2 * empty_menu_width)
  actual_menu_height = available_menu_height
  original_option_menu_width = 600
  original_option_menu_height = 800
  menu_width_aspect = actual_menu_width / original_option_menu_width
  menu_height_aspect = actual_menu_height / original_option_menu_height
  menu_option_height = 176
  show_toggle_full_screen = False
  space_between_menu_options = ((original_option_menu_height - (3 * menu_option_height)) / 4) * menu_height_aspect
  menu_option_height = menu_option_height * menu_height_aspect
  adjusted_continue = ((OpenGLTextures['CONTINUE'][0][0] * menu_width_aspect, OpenGLTextures['CONTINUE'][0][1] * menu_height_aspect), OpenGLTextures['CONTINUE'][1])
  adjusted_options = ((OpenGLTextures['OPTIONS'][0][0] * menu_width_aspect, OpenGLTextures['OPTIONS'][0][1] * menu_height_aspect), OpenGLTextures['OPTIONS'][1])
  adjusted_main_menu = ((OpenGLTextures['MAIN_MENU'][0][0] * menu_width_aspect, OpenGLTextures['MAIN_MENU'][0][1] * menu_height_aspect), OpenGLTextures['MAIN_MENU'][1])
  menu_option_width = OpenGLTextures['CONTINUE'][0][0] * menu_width_aspect
  option_menu_height = 160 * menu_height_aspect
  space_between_option_menu_options = 32 * menu_height_aspect
  adjusted_back = ((OpenGLTextures['BACK'][0][0] * menu_width_aspect, option_menu_height), OpenGLTextures['BACK'][1])
  adjusted_screen = ((OpenGLTextures['SCREEN_OPTIONS'][0][0] * menu_width_aspect, option_menu_height), OpenGLTextures['SCREEN_OPTIONS'][1])
  adjusted_sound = ((OpenGLTextures['SOUND'][0][0] * menu_width_aspect, option_menu_height), OpenGLTextures['SOUND'][1])
  adjusted_hotkeys = ((OpenGLTextures['HOTKEYS'][0][0] * menu_width_aspect, option_menu_height), OpenGLTextures['HOTKEYS'][1])
  adjusted_options_shiny_outside = ((OpenGLTextures['SHINY_OUTSIDE'][0][0] * menu_width_aspect, 176 * menu_height_aspect), OpenGLTextures['SHINY_OUTSIDE'][1])
  adjusted_chain = ((OpenGLTextures['CHAIN'][0][0], (2.5 * menu_option_height) + (3 * space_between_menu_options)), OpenGLTextures['CHAIN'][1])
  adjusted_options_chain = ((OpenGLTextures['CHAIN'][0][0], (3.5 * option_menu_height) + (4 * space_between_option_menu_options)), OpenGLTextures['CHAIN'][1])
  adjusted_shiny_outside = ((OpenGLTextures['SHINY_OUTSIDE'][0][0] * menu_width_aspect, OpenGLTextures['SHINY_OUTSIDE'][0][1] * menu_height_aspect), OpenGLTextures['SHINY_OUTSIDE'][1])
  adjusted_screen_back = ((OpenGLTextures['BACK'][0][0] * menu_width_aspect, OpenGLTextures['BACK'][0][1] * menu_height_aspect), OpenGLTextures['BACK'][1])
  adjusted_resolution = ((OpenGLTextures['RESOLUTION'][0][0] * menu_width_aspect, OpenGLTextures['RESOLUTION'][0][1] * menu_height_aspect), OpenGLTextures['RESOLUTION'][1])
  adjusted_full_screen = ((OpenGLTextures['FULL_SCREEN'][0][0] * menu_width_aspect, OpenGLTextures['FULL_SCREEN'][0][1] * menu_height_aspect), OpenGLTextures['FULL_SCREEN'][1])
  adjusted_windowed = ((OpenGLTextures['WINDOWED'][0][0] * menu_width_aspect, OpenGLTextures['WINDOWED'][0][1] * menu_height_aspect), OpenGLTextures['WINDOWED'][1])
  adjusted_screen_back = ((OpenGLTextures['BACK'][0][0] * menu_width_aspect, OpenGLTextures['BACK'][0][1] * menu_height_aspect), OpenGLTextures['BACK'][1])
  change_screen_note_aspect = (screen_width / 1.45) / OpenGLTextures['CHANGE_RESOLUTION_NOTE'][0][0]
  adjusted_resolution_note = ((OpenGLTextures['CHANGE_RESOLUTION_NOTE'][0][0] * change_screen_note_aspect, OpenGLTextures['CHANGE_RESOLUTION_NOTE'][0][1] * change_screen_note_aspect), OpenGLTextures['CHANGE_RESOLUTION_NOTE'][1])
  sound_adjustment_bar_width = (48/100) * screen_width
  adjusted_sound_bar_being_moved = ((OpenGLTextures['SOUND_BAR_BEING_MOVED'][0][0], OpenGLTextures['SOUND_BAR_BEING_MOVED'][0][1]), OpenGLTextures['SOUND_BAR_BEING_MOVED'][1])
  adjusted_sound_adjustment_bar = ((sound_adjustment_bar_width, OpenGLTextures['SOUND_ADJUSTMENT_BAR'][0][1]), OpenGLTextures['SOUND_ADJUSTMENT_BAR'][1])
  move_letters_down = screen_height / 11
  adjusted_letters_aspect_x = ((3 / 10) * screen_width) / 99
  adjusted_letters_aspect_y = adjusted_letters_aspect_x
  adjusted_hotkey_outline = (((58 / 100) * screen_width, ((2 * (screen_height / 11)) / 10) + (5 * adjusted_letters_aspect_y)), OpenGLTextures['HOTKEY_OUTLINE'][1])
  adjusted_grapple_portion = ((OpenGLTextures['GRAPPLE_PORTION'][0][0] * (single_upgrade_width_and_height / OpenGLTextures['BUBBLE'][0][0]), OpenGLTextures['GRAPPLE_PORTION'][0][1] * (single_upgrade_width_and_height / OpenGLTextures['BUBBLE'][0][1])), OpenGLTextures['GRAPPLE_PORTION'][1])
  default_menu_option_collision = PyGameTextures['MENU_OPTION_SIZING']
  mouse_collision = PyGameTextures['ACTUAL_MOUSE']
  regular_menu_option = pygame.transform.scale(default_menu_option_collision, (536 * menu_width_aspect, 176 * menu_height_aspect))
  flipped_menu_option = pygame.transform.flip(regular_menu_option, True, False)
  current_scaled_menu_option_collisions = [regular_menu_option, flipped_menu_option, regular_menu_option]
  current_scaled_menu_option_collisions = [pygame.mask.from_surface(x) for x in current_scaled_menu_option_collisions]
  regular_option_menu_collision = pygame.transform.scale(default_menu_option_collision, (536 * menu_width_aspect, 160 * menu_height_aspect))
  flipped_option_menu_collision = pygame.transform.flip(regular_option_menu_collision, True, False)
  option_menu_collisions = [regular_option_menu_collision, flipped_option_menu_collision, regular_option_menu_collision, flipped_option_menu_collision]
  option_menu_collisions = [pygame.mask.from_surface(x) for x in option_menu_collisions]
  mouse_collision = pygame.mask.from_surface(mouse_collision)
  scrolling_toward_continue_options_main_menu = True
  scrolling_away_continue_options_main_menu = False
  showing_continue_options_main_menu = True
  scrolling_toward_options = False
  scrolling_away_option = False
  showing_options = False
  scrolling_toward_screen = False
  scrolling_away_screen = False
  showing_option_menu_screen = False
  scrolling_toward_sound = False
  scrolling_away_sound = False
  showing_sound = False
  scrolling_toward_hotkey = False
  scrolling_away_hotkey = False
  showing_hotkey = False
  allow_another_option_to_scroll_down = True
  option_press_back = False
  option_press_screen = False
  option_press_sound = False
  option_press_hotkey = False
  started_scrolling_time = pygame.time.get_ticks()
  holding_music_bar = False
  holding_sound_bar = False
  allow_full_screen_toggle = True
  touching_Forest = False
  touching_Town = False
  touching_AntHill = False
  touching_Sewer = False
  touching_Forest_region = [math.floor((1 / 3) * screen_width), math.ceil(((1 / 3) * screen_width) + ((3 / 10) * screen_width)), math.floor((1 / 6) * screen_height), math.ceil(((1 / 2) * screen_height))]
  touching_Town_region = [math.floor(((1 / 3) * screen_width) + ((3 / 10) * screen_width)), math.ceil(((1 / 3) * screen_width) + ((3 / 10) * screen_width) + ((3 / 10) * screen_width)), math.floor((1 / 6) * screen_height), math.ceil(((1 / 2) * screen_height))]
  touching_AntHill_region = [math.floor((1 / 3) * screen_width), math.ceil(((1 / 3) * screen_width) + ((3 / 10) * screen_width)), math.floor(((1 / 6) * screen_height) + ((1 / 3) * screen_height)), math.ceil(((1 / 2) * screen_height) + ((1 / 3) * screen_height))]
  touching_Sewer_region = [math.floor(((1 / 3) * screen_width) + ((3 / 10) * screen_width)), math.ceil(((1 / 3) * screen_width) + ((3 / 10) * screen_width) + ((3 / 10) * screen_width)), math.floor(((1 / 6) * screen_height) + ((1 / 3) * screen_height)), math.ceil(((1 / 2) * screen_height) + ((1 / 3) * screen_height))]
  touching_hotkey_region_x = [math.floor(((36 / 100) * screen_width)), math.ceil(((94 / 100) * screen_width))]
  number_of_pixels_to_move = 0
  temporary_current_hotkeys = current_hotkeys.copy()
  time_since_saving_hotkeys = 5000
  global Mouse_x, Mouse_y
  pause_curr_time = pygame.time.get_ticks()
  pause_prev_time = pause_curr_time
  pause_target_delta_milliseconds = 13
  pause_delta_milliseconds = pause_target_delta_milliseconds
  pause_curr_time += pause_target_delta_milliseconds
  pause_menu_timer = 0
  while True:
    for event in pygame.event.get():
      if event.type == pygame.QUIT:
        everything_save_data(True, 83, str(My_cached_info.play_time))
        raise SystemExit
      elif My_cached_info.close_the_game:
        everything_save_data(True, 83, str(My_cached_info.play_time))
        raise SystemExit
    #
    show_select_new_key_message = False
    show_toggle_full_screen = False
    display_resolution_note = False
    last_mouse_x, last_mouse_y = Mouse_x, Mouse_y
    Mouse_x, Mouse_y = pygame.mouse.get_pos()
    keys = pygame.key.get_pressed()
    left_click, weird_click, right_click = pygame.mouse.get_pressed()
    update_pressed_controls()
    if not Currently_pressed_controls.pressed_controls['PAUSE']:
      My_cached_info.allow_pause_change = True
    if Currently_pressed_controls.pressed_controls['PAUSE'] and My_cached_info.allow_pause_change:
      My_cached_info.allow_pause_change = False
      break
    #
    draw_all()
    make_opengl_rect(shady_pixel[0], shady_pixel[1], (0, 0), 0, False, (0, 0, shady_pixel[0][0], shady_pixel[0][1]))
    #
    make_opengl_rect(map_rectangle[0], map_rectangle[1], ((1 / 3) * screen_width, (1 / 6) * screen_height), 0, False, (0, 0, map_rectangle[0][0], map_rectangle[0][1]))
    if all_current_save_data[96][0] == '1':
      make_opengl_rect(map_Forest[0], map_Forest[1], (((1 / 3) * screen_width) + 2, ((1 / 6) * screen_height) + 2), 0, False, (0, 0, map_Forest[0][0], map_Forest[0][1]))
    if all_current_save_data[97][0] == '1':
      make_opengl_rect(map_Town[0], map_Town[1], (((1 / 3) * screen_width) + map_Forest[0][0], ((1 / 6) * screen_height) + 2), 0, False, (0, 0, map_Town[0][0], map_Town[0][1]))
    if all_current_save_data[98][0] == '1':
      make_opengl_rect(map_AntHill[0], map_AntHill[1], (((1 / 3) * screen_width) + 2, ((1 / 6) * screen_height) + map_Forest[0][1]), 0, False, (0, 0, map_AntHill[0][0], map_AntHill[0][1]))
    if all_current_save_data[99][0] == '1':
      make_opengl_rect(map_Sewer[0], map_Sewer[1], (((1 / 3) * screen_width) + map_Forest[0][0], ((1 / 6) * screen_height) + map_Forest[0][1]), 0, False, (0, 0, map_Sewer[0][0], map_Sewer[0][1]))
    touching_a_travel = False
    touching_which_travel = [False for x in range(12)]
    #
    if (all_current_save_data[69][0] == '1') or (all_current_save_data[27][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_the_door[1], (((1 / 3) * screen_width) + TheDoor1_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor1_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    if (all_current_save_data[69][0] == '1') and not (all_current_save_data[27][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_shaded_the_door[1], (((1 / 3) * screen_width) + TheDoor1_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor1_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    #
    if (all_current_save_data[70][0] == '1') or (all_current_save_data[28][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_the_door[1], (((1 / 3) * screen_width) + TheDoor2_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor2_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    if (all_current_save_data[70][0] == '1') and not (all_current_save_data[28][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_shaded_the_door[1], (((1 / 3) * screen_width) + TheDoor2_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor2_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    #
    if (all_current_save_data[71][0] == '1') or (all_current_save_data[29][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_the_door[1], (((1 / 3) * screen_width) + TheDoor3_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor3_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    if (all_current_save_data[71][0] == '1') and not (all_current_save_data[29][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_shaded_the_door[1], (((1 / 3) * screen_width) + TheDoor3_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor3_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    #
    if (all_current_save_data[72][0] == '1') or (all_current_save_data[30][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_the_door[1], (((1 / 3) * screen_width) + TheDoor4_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor4_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    if (all_current_save_data[72][0] == '1') and not (all_current_save_data[30][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_shaded_the_door[1], (((1 / 3) * screen_width) + TheDoor4_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor4_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    #
    if (all_current_save_data[73][0] == '1') or (all_current_save_data[31][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_the_door[1], (((1 / 3) * screen_width) + TheDoor5_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor5_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    if (all_current_save_data[73][0] == '1') and not (all_current_save_data[31][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_shaded_the_door[1], (((1 / 3) * screen_width) + TheDoor5_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor5_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    #
    if (all_current_save_data[74][0] == '1') or (all_current_save_data[32][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_the_door[1], (((1 / 3) * screen_width) + TheDoor7_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor7_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    if (all_current_save_data[74][0] == '1') and not (all_current_save_data[32][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_shaded_the_door[1], (((1 / 3) * screen_width) + TheDoor7_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor7_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    #
    if (all_current_save_data[75][0] == '1') or (all_current_save_data[33][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_the_door[1], (((1 / 3) * screen_width) + TheDoor8_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor8_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    if (all_current_save_data[75][0] == '1') and not (all_current_save_data[33][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_shaded_the_door[1], (((1 / 3) * screen_width) + TheDoor8_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor8_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    #
    if (all_current_save_data[76][0] == '1') or (all_current_save_data[34][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_the_door[1], (((1 / 3) * screen_width) + TheDoor9_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor9_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    if (all_current_save_data[76][0] == '1') and not (all_current_save_data[34][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_shaded_the_door[1], (((1 / 3) * screen_width) + TheDoor9_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor9_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    #
    if (all_current_save_data[77][0] == '1') or (all_current_save_data[35][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_the_door[1], (((1 / 3) * screen_width) + TheDoor10_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor10_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    if (all_current_save_data[77][0] == '1') and not (all_current_save_data[35][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_shaded_the_door[1], (((1 / 3) * screen_width) + TheDoor10_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor10_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    #
    if (all_current_save_data[78][0] == '1') or (all_current_save_data[36][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_the_door[1], (((1 / 3) * screen_width) + TheDoor11_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor11_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    if (all_current_save_data[78][0] == '1') and not (all_current_save_data[36][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_shaded_the_door[1], (((1 / 3) * screen_width) + TheDoor11_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor11_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    #
    if (all_current_save_data[79][0] == '1') or (all_current_save_data[37][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_the_door[1], (((1 / 3) * screen_width) + TheDoor12_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor12_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    if (all_current_save_data[79][0] == '1') and not (all_current_save_data[37][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_shaded_the_door[1], (((1 / 3) * screen_width) + TheDoor12_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor12_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    #
    if (all_current_save_data[80][0] == '1') or (all_current_save_data[38][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_the_door[1], (((1 / 3) * screen_width) + TheDoor13_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor13_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    if (all_current_save_data[80][0] == '1') and not (all_current_save_data[38][0] == '1'):
      make_opengl_rect(adjusted_the_door[0], adjusted_shaded_the_door[1], (((1 / 3) * screen_width) + TheDoor13_pos[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor13_pos[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    #
    #
    allowed_to_fast_travel = (not scrolling_toward_continue_options_main_menu) and (not scrolling_away_continue_options_main_menu) and (not scrolling_toward_options) and (not scrolling_away_option) and (not scrolling_toward_screen) and (not scrolling_away_screen) and (not scrolling_toward_sound) and (not scrolling_away_sound) and (not showing_sound) and (not scrolling_toward_hotkey) and (not scrolling_away_hotkey) and (not showing_hotkey)
    #
    if allowed_to_fast_travel and ((all_current_save_data[69][0] == '1') or (all_current_save_data[27][0] == '1')):
      if ((1 / 3) * screen_width) + TheDoor1_pos[0] - (0.5 * adjusted_the_door[0][0]) <= Mouse_x <= ((1 / 3) * screen_width) + TheDoor1_pos[0] + (0.5 * adjusted_the_door[0][0]):
        if ((1 / 6) * screen_height) + TheDoor1_pos[1] - (0.5 * adjusted_the_door[0][1]) <= Mouse_y <= ((1 / 6) * screen_height) + TheDoor1_pos[1] + (0.5 * adjusted_the_door[0][1]):
          make_opengl_rect(adjusted_outline_the_door[0], adjusted_outline_the_door[1], (((1 / 3) * screen_width) + TheDoor1_pos[0] - (0.5 * adjusted_outline_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor1_pos[1] - (0.5 * adjusted_outline_the_door[0][1])), 0, False, (0, 0, adjusted_outline_the_door[0][0], adjusted_outline_the_door[0][1]))
          make_opengl_rect(OpenGLTextures['TRAVEL'][0], OpenGLTextures['TRAVEL'][1], (Mouse_x - (0.5 * OpenGLTextures['TRAVEL'][0][0]), Mouse_y - (OpenGLTextures['TRAVEL'][0][1]) - 10), 0, False, (0, 0, OpenGLTextures['TRAVEL'][0][0], OpenGLTextures['TRAVEL'][0][1]))
          touching_a_travel = True
          touching_which_travel[0] = True
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            My_cached_info.index_for_changing_regions = 0
            My_cached_info.load_from_previous_location = True
            My_cached_info.teleported = True
            My_cached_info.desired_last_map_region = 'TheDoor1'
            My_cached_info.last_map_region = 'TheDoor1'
            everything_save_data(True, 59, 'TheDoor1')
            everything_save_data(True, 60, str(PLAYER.x_vel))
            everything_save_data(True, 61, str(PLAYER.y_vel))
            everything_save_data(True, 62, 'Forest')
            everything_save_data(True, 63, '0')
            everything_save_data(True, 64, '0')
            everything_save_data(True, 65, str(PLAYER.x_pos))
            everything_save_data(True, 66, str(PLAYER.y_pos))
            changing_region_for_TheDoor6 = True
            break
    #
    if allowed_to_fast_travel and ((all_current_save_data[70][0] == '1') or (all_current_save_data[28][0] == '1')):
      if ((1 / 3) * screen_width) + TheDoor2_pos[0] - (0.5 * adjusted_the_door[0][0]) <= Mouse_x <= ((1 / 3) * screen_width) + TheDoor2_pos[0] + (0.5 * adjusted_the_door[0][0]):
        if ((1 / 6) * screen_height) + TheDoor2_pos[1] - (0.5 * adjusted_the_door[0][1]) <= Mouse_y <= ((1 / 6) * screen_height) + TheDoor2_pos[1] + (0.5 * adjusted_the_door[0][1]):
          make_opengl_rect(adjusted_outline_the_door[0], adjusted_outline_the_door[1], (((1 / 3) * screen_width) + TheDoor2_pos[0] - (0.5 * adjusted_outline_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor2_pos[1] - (0.5 * adjusted_outline_the_door[0][1])), 0, False, (0, 0, adjusted_outline_the_door[0][0], adjusted_outline_the_door[0][1]))
          make_opengl_rect(OpenGLTextures['TRAVEL'][0], OpenGLTextures['TRAVEL'][1], (Mouse_x - (0.5 * OpenGLTextures['TRAVEL'][0][0]), Mouse_y - (OpenGLTextures['TRAVEL'][0][1]) - 10), 0, False, (0, 0, OpenGLTextures['TRAVEL'][0][0], OpenGLTextures['TRAVEL'][0][1]))
          touching_a_travel = True
          touching_which_travel[1] = True
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            My_cached_info.index_for_changing_regions = 0
            My_cached_info.load_from_previous_location = True
            My_cached_info.teleported = True
            My_cached_info.desired_last_map_region = 'TheDoor2'
            My_cached_info.last_map_region = 'TheDoor2'
            everything_save_data(True, 59, 'TheDoor2')
            everything_save_data(True, 60, str(PLAYER.x_vel))
            everything_save_data(True, 61, str(PLAYER.y_vel))
            everything_save_data(True, 62, 'Forest')
            everything_save_data(True, 63, '0')
            everything_save_data(True, 64, '0')
            everything_save_data(True, 65, str(PLAYER.x_pos))
            everything_save_data(True, 66, str(PLAYER.y_pos))
            changing_region_for_TheDoor6 = True
            break
    #
    if allowed_to_fast_travel and ((all_current_save_data[71][0] == '1') or (all_current_save_data[29][0] == '1')):
      if ((1 / 3) * screen_width) + TheDoor3_pos[0] - (0.5 * adjusted_the_door[0][0]) <= Mouse_x <= ((1 / 3) * screen_width) + TheDoor3_pos[0] + (0.5 * adjusted_the_door[0][0]):
        if ((1 / 6) * screen_height) + TheDoor3_pos[1] - (0.5 * adjusted_the_door[0][1]) <= Mouse_y <= ((1 / 6) * screen_height) + TheDoor3_pos[1] + (0.5 * adjusted_the_door[0][1]):
          make_opengl_rect(adjusted_outline_the_door[0], adjusted_outline_the_door[1], (((1 / 3) * screen_width) + TheDoor3_pos[0] - (0.5 * adjusted_outline_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor3_pos[1] - (0.5 * adjusted_outline_the_door[0][1])), 0, False, (0, 0, adjusted_outline_the_door[0][0], adjusted_outline_the_door[0][1]))
          make_opengl_rect(OpenGLTextures['TRAVEL'][0], OpenGLTextures['TRAVEL'][1], (Mouse_x - (0.5 * OpenGLTextures['TRAVEL'][0][0]), Mouse_y - (OpenGLTextures['TRAVEL'][0][1]) - 10), 0, False, (0, 0, OpenGLTextures['TRAVEL'][0][0], OpenGLTextures['TRAVEL'][0][1]))
          touching_a_travel = True
          touching_which_travel[2] = True
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            My_cached_info.index_for_changing_regions = 0
            My_cached_info.load_from_previous_location = True
            My_cached_info.teleported = True
            My_cached_info.desired_last_map_region = 'TheDoor3'
            My_cached_info.last_map_region = 'TheDoor3'
            everything_save_data(True, 59, 'TheDoor3')
            everything_save_data(True, 60, str(PLAYER.x_vel))
            everything_save_data(True, 61, str(PLAYER.y_vel))
            everything_save_data(True, 62, 'Forest')
            everything_save_data(True, 63, '0')
            everything_save_data(True, 64, '0')
            everything_save_data(True, 65, str(PLAYER.x_pos))
            everything_save_data(True, 66, str(PLAYER.y_pos))
            changing_region_for_TheDoor6 = True
            break
    #
    if allowed_to_fast_travel and ((all_current_save_data[72][0] == '1') or (all_current_save_data[30][0] == '1')):
      if ((1 / 3) * screen_width) + TheDoor4_pos[0] - (0.5 * adjusted_the_door[0][0]) <= Mouse_x <= ((1 / 3) * screen_width) + TheDoor4_pos[0] + (0.5 * adjusted_the_door[0][0]):
        if ((1 / 6) * screen_height) + TheDoor4_pos[1] - (0.5 * adjusted_the_door[0][1]) <= Mouse_y <= ((1 / 6) * screen_height) + TheDoor4_pos[1] + (0.5 * adjusted_the_door[0][1]):
          make_opengl_rect(adjusted_outline_the_door[0], adjusted_outline_the_door[1], (((1 / 3) * screen_width) + TheDoor4_pos[0] - (0.5 * adjusted_outline_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor4_pos[1] - (0.5 * adjusted_outline_the_door[0][1])), 0, False, (0, 0, adjusted_outline_the_door[0][0], adjusted_outline_the_door[0][1]))
          make_opengl_rect(OpenGLTextures['TRAVEL'][0], OpenGLTextures['TRAVEL'][1], (Mouse_x - (0.5 * OpenGLTextures['TRAVEL'][0][0]), Mouse_y - (OpenGLTextures['TRAVEL'][0][1]) - 10), 0, False, (0, 0, OpenGLTextures['TRAVEL'][0][0], OpenGLTextures['TRAVEL'][0][1]))
          touching_a_travel = True
          touching_which_travel[3] = True
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            My_cached_info.index_for_changing_regions = 0
            My_cached_info.load_from_previous_location = True
            My_cached_info.teleported = True
            My_cached_info.desired_last_map_region = 'TheDoor4'
            My_cached_info.last_map_region = 'TheDoor4'
            everything_save_data(True, 59, 'TheDoor4')
            everything_save_data(True, 60, str(PLAYER.x_vel))
            everything_save_data(True, 61, str(PLAYER.y_vel))
            everything_save_data(True, 62, 'Forest')
            everything_save_data(True, 63, '0')
            everything_save_data(True, 64, '0')
            everything_save_data(True, 65, str(PLAYER.x_pos))
            everything_save_data(True, 66, str(PLAYER.y_pos))
            changing_region_for_TheDoor6 = True
            break
    #
    if allowed_to_fast_travel and ((all_current_save_data[73][0] == '1') or (all_current_save_data[31][0] == '1')):
      if ((1 / 3) * screen_width) + TheDoor5_pos[0] - (0.5 * adjusted_the_door[0][0]) <= Mouse_x <= ((1 / 3) * screen_width) + TheDoor5_pos[0] + (0.5 * adjusted_the_door[0][0]):
        if ((1 / 6) * screen_height) + TheDoor5_pos[1] - (0.5 * adjusted_the_door[0][1]) <= Mouse_y <= ((1 / 6) * screen_height) + TheDoor5_pos[1] + (0.5 * adjusted_the_door[0][1]):
          make_opengl_rect(adjusted_outline_the_door[0], adjusted_outline_the_door[1], (((1 / 3) * screen_width) + TheDoor5_pos[0] - (0.5 * adjusted_outline_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor5_pos[1] - (0.5 * adjusted_outline_the_door[0][1])), 0, False, (0, 0, adjusted_outline_the_door[0][0], adjusted_outline_the_door[0][1]))
          make_opengl_rect(OpenGLTextures['TRAVEL'][0], OpenGLTextures['TRAVEL'][1], (Mouse_x - (0.5 * OpenGLTextures['TRAVEL'][0][0]), Mouse_y - (OpenGLTextures['TRAVEL'][0][1]) - 10), 0, False, (0, 0, OpenGLTextures['TRAVEL'][0][0], OpenGLTextures['TRAVEL'][0][1]))
          touching_a_travel = True
          touching_which_travel[4] = True
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            My_cached_info.index_for_changing_regions = 0
            My_cached_info.leaving_the_door5 = True
            My_cached_info.teleported = True
            My_cached_info.desired_last_map_region = 'TheDoor5'
            My_cached_info.last_map_region = 'TheDoor5'
            My_cached_info.load_from_previous_location = True
            everything_save_data(True, 59, 'TheDoor5')
            everything_save_data(True, 60, str(PLAYER.x_vel))
            everything_save_data(True, 61, str(PLAYER.y_vel))
            everything_save_data(True, 62, 'Forest')
            everything_save_data(True, 63, '0')
            everything_save_data(True, 64, '0')
            everything_save_data(True, 65, str(PLAYER.x_pos))
            everything_save_data(True, 66, str(PLAYER.y_pos))
            changing_region_for_TheDoor6 = True
            break
    #
    if allowed_to_fast_travel and ((all_current_save_data[74][0] == '1') or (all_current_save_data[32][0] == '1')):
      if ((1 / 3) * screen_width) + TheDoor7_pos[0] - (0.5 * adjusted_the_door[0][0]) <= Mouse_x <= ((1 / 3) * screen_width) + TheDoor7_pos[0] + (0.5 * adjusted_the_door[0][0]):
        if ((1 / 6) * screen_height) + TheDoor7_pos[1] - (0.5 * adjusted_the_door[0][1]) <= Mouse_y <= ((1 / 6) * screen_height) + TheDoor7_pos[1] + (0.5 * adjusted_the_door[0][1]):
          make_opengl_rect(adjusted_outline_the_door[0], adjusted_outline_the_door[1], (((1 / 3) * screen_width) + TheDoor7_pos[0] - (0.5 * adjusted_outline_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor7_pos[1] - (0.5 * adjusted_outline_the_door[0][1])), 0, False, (0, 0, adjusted_outline_the_door[0][0], adjusted_outline_the_door[0][1]))
          make_opengl_rect(OpenGLTextures['TRAVEL'][0], OpenGLTextures['TRAVEL'][1], (Mouse_x - (0.5 * OpenGLTextures['TRAVEL'][0][0]), Mouse_y - (OpenGLTextures['TRAVEL'][0][1]) - 10), 0, False, (0, 0, OpenGLTextures['TRAVEL'][0][0], OpenGLTextures['TRAVEL'][0][1]))
          touching_a_travel = True
          touching_which_travel[5] = True
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            My_cached_info.index_for_changing_regions = 0
            My_cached_info.load_from_previous_location = True
            My_cached_info.teleported = True
            My_cached_info.desired_last_map_region = 'TheDoor7'
            My_cached_info.last_map_region = 'TheDoor7'
            everything_save_data(True, 59, 'TheDoor7')
            everything_save_data(True, 60, str(PLAYER.x_vel))
            everything_save_data(True, 61, str(PLAYER.y_vel))
            everything_save_data(True, 62, 'AntHill')
            everything_save_data(True, 63, '0')
            everything_save_data(True, 64, '0')
            everything_save_data(True, 65, str(PLAYER.x_pos))
            everything_save_data(True, 66, str(PLAYER.y_pos))
            changing_region_for_TheDoor6 = True
            break
    #
    if allowed_to_fast_travel and ((all_current_save_data[75][0] == '1') or (all_current_save_data[33][0] == '1')):
      if ((1 / 3) * screen_width) + TheDoor8_pos[0] - (0.5 * adjusted_the_door[0][0]) <= Mouse_x <= ((1 / 3) * screen_width) + TheDoor8_pos[0] + (0.5 * adjusted_the_door[0][0]):
        if ((1 / 6) * screen_height) + TheDoor8_pos[1] - (0.5 * adjusted_the_door[0][1]) <= Mouse_y <= ((1 / 6) * screen_height) + TheDoor8_pos[1] + (0.5 * adjusted_the_door[0][1]):
          make_opengl_rect(adjusted_outline_the_door[0], adjusted_outline_the_door[1], (((1 / 3) * screen_width) + TheDoor8_pos[0] - (0.5 * adjusted_outline_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor8_pos[1] - (0.5 * adjusted_outline_the_door[0][1])), 0, False, (0, 0, adjusted_outline_the_door[0][0], adjusted_outline_the_door[0][1]))
          make_opengl_rect(OpenGLTextures['TRAVEL'][0], OpenGLTextures['TRAVEL'][1], (Mouse_x - (0.5 * OpenGLTextures['TRAVEL'][0][0]), Mouse_y - (OpenGLTextures['TRAVEL'][0][1]) - 10), 0, False, (0, 0, OpenGLTextures['TRAVEL'][0][0], OpenGLTextures['TRAVEL'][0][1]))
          touching_a_travel = True
          touching_which_travel[6] = True
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            My_cached_info.index_for_changing_regions = 0
            My_cached_info.load_from_previous_location = True
            My_cached_info.teleported = True
            My_cached_info.desired_last_map_region = 'TheDoor8'
            My_cached_info.last_map_region = 'TheDoor8'
            everything_save_data(True, 59, 'TheDoor8')
            everything_save_data(True, 60, str(PLAYER.x_vel))
            everything_save_data(True, 61, str(PLAYER.y_vel))
            everything_save_data(True, 62, 'AntHill')
            everything_save_data(True, 63, '0')
            everything_save_data(True, 64, '0')
            everything_save_data(True, 65, str(PLAYER.x_pos))
            everything_save_data(True, 66, str(PLAYER.y_pos))
            changing_region_for_TheDoor6 = True
            break
    #
    if allowed_to_fast_travel and ((all_current_save_data[76][0] == '1') or (all_current_save_data[34][0] == '1')):
      if ((1 / 3) * screen_width) + TheDoor9_pos[0] - (0.5 * adjusted_the_door[0][0]) <= Mouse_x <= ((1 / 3) * screen_width) + TheDoor9_pos[0] + (0.5 * adjusted_the_door[0][0]):
        if ((1 / 6) * screen_height) + TheDoor9_pos[1] - (0.5 * adjusted_the_door[0][1]) <= Mouse_y <= ((1 / 6) * screen_height) + TheDoor9_pos[1] + (0.5 * adjusted_the_door[0][1]):
          make_opengl_rect(adjusted_outline_the_door[0], adjusted_outline_the_door[1], (((1 / 3) * screen_width) + TheDoor9_pos[0] - (0.5 * adjusted_outline_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor9_pos[1] - (0.5 * adjusted_outline_the_door[0][1])), 0, False, (0, 0, adjusted_outline_the_door[0][0], adjusted_outline_the_door[0][1]))
          make_opengl_rect(OpenGLTextures['TRAVEL'][0], OpenGLTextures['TRAVEL'][1], (Mouse_x - (0.5 * OpenGLTextures['TRAVEL'][0][0]), Mouse_y - (OpenGLTextures['TRAVEL'][0][1]) - 10), 0, False, (0, 0, OpenGLTextures['TRAVEL'][0][0], OpenGLTextures['TRAVEL'][0][1]))
          touching_a_travel = True
          touching_which_travel[7] = True
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            My_cached_info.index_for_changing_regions = 0
            My_cached_info.load_from_previous_location = True
            My_cached_info.teleported = True
            My_cached_info.desired_last_map_region = 'TheDoor9'
            My_cached_info.last_map_region = 'TheDoor9'
            everything_save_data(True, 59, 'TheDoor9')
            everything_save_data(True, 60, str(PLAYER.x_vel))
            everything_save_data(True, 61, str(PLAYER.y_vel))
            everything_save_data(True, 62, 'AntHill')
            everything_save_data(True, 63, '0')
            everything_save_data(True, 64, '0')
            everything_save_data(True, 65, str(PLAYER.x_pos))
            everything_save_data(True, 66, str(PLAYER.y_pos))
            changing_region_for_TheDoor6 = True
            break
    #
    if allowed_to_fast_travel and ((all_current_save_data[77][0] == '1') or (all_current_save_data[35][0] == '1')):
      if ((1 / 3) * screen_width) + TheDoor10_pos[0] - (0.5 * adjusted_the_door[0][0]) <= Mouse_x <= ((1 / 3) * screen_width) + TheDoor10_pos[0] + (0.5 * adjusted_the_door[0][0]):
        if ((1 / 6) * screen_height) + TheDoor10_pos[1] - (0.5 * adjusted_the_door[0][1]) <= Mouse_y <= ((1 / 6) * screen_height) + TheDoor10_pos[1] + (0.5 * adjusted_the_door[0][1]):
          make_opengl_rect(adjusted_outline_the_door[0], adjusted_outline_the_door[1], (((1 / 3) * screen_width) + TheDoor10_pos[0] - (0.5 * adjusted_outline_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor10_pos[1] - (0.5 * adjusted_outline_the_door[0][1])), 0, False, (0, 0, adjusted_outline_the_door[0][0], adjusted_outline_the_door[0][1]))
          make_opengl_rect(OpenGLTextures['TRAVEL'][0], OpenGLTextures['TRAVEL'][1], (Mouse_x - (0.5 * OpenGLTextures['TRAVEL'][0][0]), Mouse_y - (OpenGLTextures['TRAVEL'][0][1]) - 10), 0, False, (0, 0, OpenGLTextures['TRAVEL'][0][0], OpenGLTextures['TRAVEL'][0][1]))
          touching_a_travel = True
          touching_which_travel[8] = True
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            My_cached_info.index_for_changing_regions = 0
            My_cached_info.load_from_previous_location = True
            My_cached_info.teleported = True
            My_cached_info.desired_last_map_region = 'TheDoor10'
            My_cached_info.last_map_region = 'TheDoor10'
            everything_save_data(True, 59, 'TheDoor10')
            everything_save_data(True, 60, str(PLAYER.x_vel))
            everything_save_data(True, 61, str(PLAYER.y_vel))
            everything_save_data(True, 62, 'Sewer')
            everything_save_data(True, 63, '0')
            everything_save_data(True, 64, '0')
            everything_save_data(True, 65, str(PLAYER.x_pos))
            everything_save_data(True, 66, str(PLAYER.y_pos))
            changing_region_for_TheDoor6 = True
            break
    #
    if allowed_to_fast_travel and ((all_current_save_data[78][0] == '1') or (all_current_save_data[36][0] == '1')):
      if ((1 / 3) * screen_width) + TheDoor11_pos[0] - (0.5 * adjusted_the_door[0][0]) <= Mouse_x <= ((1 / 3) * screen_width) + TheDoor11_pos[0] + (0.5 * adjusted_the_door[0][0]):
        if ((1 / 6) * screen_height) + TheDoor11_pos[1] - (0.5 * adjusted_the_door[0][1]) <= Mouse_y <= ((1 / 6) * screen_height) + TheDoor11_pos[1] + (0.5 * adjusted_the_door[0][1]):
          make_opengl_rect(adjusted_outline_the_door[0], adjusted_outline_the_door[1], (((1 / 3) * screen_width) + TheDoor11_pos[0] - (0.5 * adjusted_outline_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor11_pos[1] - (0.5 * adjusted_outline_the_door[0][1])), 0, False, (0, 0, adjusted_outline_the_door[0][0], adjusted_outline_the_door[0][1]))
          make_opengl_rect(OpenGLTextures['TRAVEL'][0], OpenGLTextures['TRAVEL'][1], (Mouse_x - (0.5 * OpenGLTextures['TRAVEL'][0][0]), Mouse_y - (OpenGLTextures['TRAVEL'][0][1]) - 10), 0, False, (0, 0, OpenGLTextures['TRAVEL'][0][0], OpenGLTextures['TRAVEL'][0][1]))
          touching_a_travel = True
          touching_which_travel[9] = True
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            My_cached_info.index_for_changing_regions = 0
            My_cached_info.load_from_previous_location = True
            My_cached_info.teleported = True
            My_cached_info.desired_last_map_region = 'TheDoor11'
            My_cached_info.last_map_region = 'TheDoor11'
            everything_save_data(True, 59, 'TheDoor11')
            everything_save_data(True, 60, str(PLAYER.x_vel))
            everything_save_data(True, 61, str(PLAYER.y_vel))
            everything_save_data(True, 62, 'Sewer')
            everything_save_data(True, 63, '0')
            everything_save_data(True, 64, '0')
            everything_save_data(True, 65, str(PLAYER.x_pos))
            everything_save_data(True, 66, str(PLAYER.y_pos))
            changing_region_for_TheDoor6 = True
            break
    #
    if allowed_to_fast_travel and ((all_current_save_data[79][0] == '1') or (all_current_save_data[37][0] == '1')):
      if ((1 / 3) * screen_width) + TheDoor12_pos[0] - (0.5 * adjusted_the_door[0][0]) <= Mouse_x <= ((1 / 3) * screen_width) + TheDoor12_pos[0] + (0.5 * adjusted_the_door[0][0]):
        if ((1 / 6) * screen_height) + TheDoor12_pos[1] - (0.5 * adjusted_the_door[0][1]) <= Mouse_y <= ((1 / 6) * screen_height) + TheDoor12_pos[1] + (0.5 * adjusted_the_door[0][1]):
          make_opengl_rect(adjusted_outline_the_door[0], adjusted_outline_the_door[1], (((1 / 3) * screen_width) + TheDoor12_pos[0] - (0.5 * adjusted_outline_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor12_pos[1] - (0.5 * adjusted_outline_the_door[0][1])), 0, False, (0, 0, adjusted_outline_the_door[0][0], adjusted_outline_the_door[0][1]))
          make_opengl_rect(OpenGLTextures['TRAVEL'][0], OpenGLTextures['TRAVEL'][1], (Mouse_x - (0.5 * OpenGLTextures['TRAVEL'][0][0]), Mouse_y - (OpenGLTextures['TRAVEL'][0][1]) - 10), 0, False, (0, 0, OpenGLTextures['TRAVEL'][0][0], OpenGLTextures['TRAVEL'][0][1]))
          touching_a_travel = True
          touching_which_travel[10] = True
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            My_cached_info.index_for_changing_regions = 0
            My_cached_info.load_from_previous_location = True
            My_cached_info.teleported = True
            My_cached_info.desired_last_map_region = 'TheDoor12'
            My_cached_info.last_map_region = 'TheDoor12'
            everything_save_data(True, 59, 'TheDoor12')
            everything_save_data(True, 60, str(PLAYER.x_vel))
            everything_save_data(True, 61, str(PLAYER.y_vel))
            everything_save_data(True, 62, 'Sewer')
            everything_save_data(True, 63, '0')
            everything_save_data(True, 64, '0')
            everything_save_data(True, 65, str(PLAYER.x_pos))
            everything_save_data(True, 66, str(PLAYER.y_pos))
            changing_region_for_TheDoor6 = True
            break
    #
    if allowed_to_fast_travel and ((all_current_save_data[80][0] == '1') or (all_current_save_data[38][0] == '1')):
      if ((1 / 3) * screen_width) + TheDoor13_pos[0] - (0.5 * adjusted_the_door[0][0]) <= Mouse_x <= ((1 / 3) * screen_width) + TheDoor13_pos[0] + (0.5 * adjusted_the_door[0][0]):
        if ((1 / 6) * screen_height) + TheDoor13_pos[1] - (0.5 * adjusted_the_door[0][1]) <= Mouse_y <= ((1 / 6) * screen_height) + TheDoor13_pos[1] + (0.5 * adjusted_the_door[0][1]):
          make_opengl_rect(adjusted_outline_the_door[0], adjusted_outline_the_door[1], (((1 / 3) * screen_width) + TheDoor13_pos[0] - (0.5 * adjusted_outline_the_door[0][0]), ((1 / 6) * screen_height) + TheDoor13_pos[1] - (0.5 * adjusted_outline_the_door[0][1])), 0, False, (0, 0, adjusted_outline_the_door[0][0], adjusted_outline_the_door[0][1]))
          make_opengl_rect(OpenGLTextures['TRAVEL'][0], OpenGLTextures['TRAVEL'][1], (Mouse_x - (0.5 * OpenGLTextures['TRAVEL'][0][0]), Mouse_y - (OpenGLTextures['TRAVEL'][0][1]) - 10), 0, False, (0, 0, OpenGLTextures['TRAVEL'][0][0], OpenGLTextures['TRAVEL'][0][1]))
          touching_a_travel = True
          touching_which_travel[11] = True
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            My_cached_info.index_for_changing_regions = 0
            My_cached_info.load_from_previous_location = True
            My_cached_info.teleported = True
            My_cached_info.desired_last_map_region = 'TheDoor13'
            My_cached_info.last_map_region = 'TheDoor13'
            everything_save_data(True, 59, 'TheDoor13')
            everything_save_data(True, 60, str(PLAYER.x_vel))
            everything_save_data(True, 61, str(PLAYER.y_vel))
            everything_save_data(True, 62, 'Town')
            everything_save_data(True, 63, '0')
            everything_save_data(True, 64, '0')
            everything_save_data(True, 65, str(PLAYER.x_pos))
            everything_save_data(True, 66, str(PLAYER.y_pos))
            changing_region_for_TheDoor6 = True
            break
    #
    #
    make_opengl_rect(adjusted_the_door[0], OpenGLTextures['THE_BALL_BACK'][1], (((1 / 3) * screen_width) + mini_hamster[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + mini_hamster[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    make_opengl_rect(adjusted_the_door[0], OpenGLTextures['HAMSTER_WALKING_RIGHT'][int((pause_menu_timer % 600) // 150)][1], (((1 / 3) * screen_width) + mini_hamster[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + mini_hamster[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    make_opengl_rect(adjusted_the_door[0], OpenGLTextures['THE_BALL_FRONT'][1], (((1 / 3) * screen_width) + mini_hamster[0] - (0.5 * adjusted_the_door[0][0]), ((1 / 6) * screen_height) + mini_hamster[1] - (0.5 * adjusted_the_door[0][1])), 0, False, (0, 0, adjusted_the_door[0][0], adjusted_the_door[0][1]))
    #
    #
    #
    if showing_continue_options_main_menu:
      menu_scroll_y = 0
      percent_of_the_way_through_scrolling = (pause_curr_time - started_scrolling_time) / 500
      if scrolling_toward_continue_options_main_menu:
        allow_another_option_to_scroll_down = False
        menu_scroll_y = -abs((1 - percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_toward_continue_options_main_menu = False
      if scrolling_away_continue_options_main_menu:
        allow_another_option_to_scroll_down = False
        menu_scroll_y = -abs((percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_away_continue_options_main_menu = False
          showing_continue_options_main_menu = False
          showing_options = True
          started_scrolling_time = pygame.time.get_ticks()
      if percent_of_the_way_through_scrolling >= 1:
        allow_another_option_to_scroll_down = True
        started_scrolling_time = pygame.time.get_ticks()
      #
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + menu_option_width - OpenGLTextures['CHAIN'][0][0] - ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      #
      if menu_scroll_y == 0:
        touching_continue_points, touching_continue = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - space_between_menu_options)
        if touching_continue:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), space_between_menu_options - (10 * menu_height_aspect)), 0, False, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            My_cached_info.allow_pause_change = False
            break
      make_opengl_rect(adjusted_continue[0], adjusted_continue[1], (empty_menu_width, space_between_menu_options + menu_scroll_y), 0, False, (0, 0, adjusted_continue[0][0], adjusted_continue[0][1]))
      #
      if menu_scroll_y == 0:
        touching_options_points, touching_options = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[1], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - (menu_option_height + (2 * space_between_menu_options)))
        if touching_options:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), menu_option_height + (2 * space_between_menu_options) - (10 * menu_height_aspect)), 0, True, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            started_scrolling_time = pygame.time.get_ticks()
            scrolling_toward_continue_options_main_menu = False
            scrolling_away_continue_options_main_menu = True
            showing_continue_options_main_menu = True
            scrolling_toward_options = True
      make_opengl_rect(adjusted_options[0], adjusted_options[1], (empty_menu_width, menu_option_height + (2 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_options[0][0], adjusted_options[0][1]))
      #
      if menu_scroll_y == 0:
        touching_main_menu_points, touching_main_menu = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - ((2 * menu_option_height) + (3 * space_between_menu_options)))
        if touching_main_menu:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), (2 * menu_option_height) + (3 * space_between_menu_options) - (10 * menu_height_aspect)), 0, False, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            My_cached_info.return_to_main_menu = True
            break
      make_opengl_rect(adjusted_main_menu[0], adjusted_main_menu[1], (empty_menu_width, (2 * menu_option_height) + (3 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_main_menu[0][0], adjusted_main_menu[0][1]))
    #
    #
    if showing_options and allow_another_option_to_scroll_down:
      menu_scroll_y = 0
      percent_of_the_way_through_scrolling = (pause_curr_time - started_scrolling_time) / 500
      if scrolling_toward_options:
        menu_scroll_y = -abs((1 - percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_toward_options = False
      if scrolling_away_option:
        menu_scroll_y = -abs((percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          if option_press_back:
            scrolling_away_option = False
            showing_options = False
            showing_continue_options_main_menu = True
            option_press_back = False
          if option_press_screen:
            scrolling_away_option = False
            showing_options = False
            showing_option_menu_screen = True
            scrolling_toward_screen = True
            option_press_screen = False
          if option_press_sound:
            scrolling_away_option = False
            showing_options = False
            showing_sound = True
            scrolling_toward_sound = True
            option_press_sound = False
          if option_press_hotkey:
            temporary_current_hotkeys = current_hotkeys.copy()
            scrolling_away_option = False
            showing_options = False
            showing_hotkey = True
            scrolling_toward_hotkey = True
            option_press_hotkey = False
          started_scrolling_time = pygame.time.get_ticks()
      if percent_of_the_way_through_scrolling >= 1:
        allow_another_option_to_scroll_down = True
        started_scrolling_time = pygame.time.get_ticks()
      #
      make_opengl_rect(adjusted_options_chain[0], adjusted_options_chain[1], (empty_menu_width + ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_options_chain[0][0], adjusted_options_chain[0][1]))
      make_opengl_rect(adjusted_options_chain[0], adjusted_options_chain[1], (empty_menu_width + menu_option_width - OpenGLTextures['CHAIN'][0][0] - ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_options_chain[0][0], adjusted_options_chain[0][1]))
      #
      if menu_scroll_y == 0:
        touching_back_points, touching_back = find_collisions_with_offsets_pause_menu(mouse_collision, option_menu_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - space_between_option_menu_options)
        if touching_back:
          make_opengl_rect(adjusted_options_shiny_outside[0], adjusted_options_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect * (160 / 176)), space_between_option_menu_options - (10 * menu_height_aspect * (160 / 176))), 0, False, (0, 0, adjusted_options_shiny_outside[0][0], adjusted_options_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            scrolling_away_option = True
            scrolling_toward_continue_options_main_menu = True
            option_press_back = True
            started_scrolling_time = pygame.time.get_ticks()
      make_opengl_rect(adjusted_back[0], adjusted_back[1], (empty_menu_width, space_between_option_menu_options + menu_scroll_y), 0, False, (0, 0, adjusted_back[0][0], adjusted_back[0][1]))
      #
      if menu_scroll_y == 0:
        touching_screen_points, touching_screen = find_collisions_with_offsets_pause_menu(mouse_collision, option_menu_collisions[1], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - (option_menu_height + (2 * space_between_option_menu_options)))
        if touching_screen:
          make_opengl_rect(adjusted_options_shiny_outside[0], adjusted_options_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect * (160 / 176)), option_menu_height + (2 * space_between_option_menu_options) - (10 * menu_height_aspect * (160 / 176))), 0, True, (0, 0, adjusted_options_shiny_outside[0][0], adjusted_options_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            scrolling_away_option = True
            option_press_screen = True
            scrolling_toward_screen = True
            started_scrolling_time = pygame.time.get_ticks()
      make_opengl_rect(adjusted_screen[0], adjusted_screen[1], (empty_menu_width, option_menu_height + (2 * space_between_option_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_screen[0][0], adjusted_screen[0][1]))
      #
      if menu_scroll_y == 0:
        touching_sound_points, touching_sound = find_collisions_with_offsets_pause_menu(mouse_collision, option_menu_collisions[2], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - ((2 * option_menu_height) + (3 * space_between_option_menu_options)))
        if touching_sound:
          make_opengl_rect(adjusted_options_shiny_outside[0], adjusted_options_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect * (160 / 176)), (2 * option_menu_height) + (3 * space_between_option_menu_options) - (10 * menu_height_aspect * (160 / 176))), 0, False, (0, 0, adjusted_options_shiny_outside[0][0], adjusted_options_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            scrolling_away_option = True
            option_press_sound = True
            scrolling_toward_sound = True
            started_scrolling_time = pygame.time.get_ticks()
      make_opengl_rect(adjusted_sound[0], adjusted_sound[1], (empty_menu_width, (2 * option_menu_height) + (3 * space_between_option_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_sound[0][0], adjusted_sound[0][1]))
      #
      if menu_scroll_y == 0:
        touching_hotkeys_points, touching_hotkeys = find_collisions_with_offsets_pause_menu(mouse_collision, option_menu_collisions[3], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - ((3 * option_menu_height) + (4 * space_between_option_menu_options)))
        if touching_hotkeys:
          make_opengl_rect(adjusted_options_shiny_outside[0], adjusted_options_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect * (160 / 176)), (3 * option_menu_height) + (4 * space_between_option_menu_options) - (10 * menu_height_aspect * (160 / 176))), 0, True, (0, 0, adjusted_options_shiny_outside[0][0], adjusted_options_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            scrolling_away_option = True
            option_press_hotkey = True
            scrolling_toward_hotkey = True
            started_scrolling_time = pygame.time.get_ticks()
      make_opengl_rect(adjusted_hotkeys[0], adjusted_hotkeys[1], (empty_menu_width, (3 * option_menu_height) + (4 * space_between_option_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_hotkeys[0][0], adjusted_hotkeys[0][1]))
    #
    #
    #
    if showing_option_menu_screen:
      menu_scroll_y = 0
      percent_of_the_way_through_scrolling = (pause_curr_time - started_scrolling_time) / 500
      if scrolling_toward_screen:
        menu_scroll_y = -abs((1 - percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_toward_screen = False
      if scrolling_away_screen:
        allow_another_option_to_scroll_down = False
        menu_scroll_y = -abs((percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_away_screen = False
          showing_option_menu_screen = False
          showing_options = True
          started_scrolling_time = pygame.time.get_ticks()
      if percent_of_the_way_through_scrolling >= 1:
        allow_another_option_to_scroll_down = True
        started_scrolling_time = pygame.time.get_ticks()
      #
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + menu_option_width - OpenGLTextures['CHAIN'][0][0] - ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      #
      if menu_scroll_y == 0:
        touching_back_points, touching_back = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - space_between_menu_options)
        if touching_back:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), space_between_menu_options - (10 * menu_height_aspect)), 0, False, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            started_scrolling_time = pygame.time.get_ticks()
            scrolling_toward_screen = False
            scrolling_away_screen = True
            showing_options = True
            scrolling_toward_options = True
      make_opengl_rect(adjusted_screen_back[0], adjusted_screen_back[1], (empty_menu_width, space_between_menu_options + menu_scroll_y), 0, False, (0, 0, adjusted_screen_back[0][0], adjusted_screen_back[0][1]))
      #
      if menu_scroll_y == 0:
        touching_resolution_points, touching_resolution = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[1], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - (menu_option_height + (2 * space_between_menu_options)))
        if touching_resolution:
          display_resolution_note = True
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), menu_option_height + (2 * space_between_menu_options) - (10 * menu_height_aspect)), 0, True, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          make_opengl_rect(adjusted_resolution[0], current_resolution_image[1], (empty_menu_width, menu_option_height + (2 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_resolution[0][0], adjusted_resolution[0][1]))
          if not left_click and not Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            allow_screen_left_click = True
          if (left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']) and allow_screen_left_click:
            allow_screen_left_click = False
            temporary_screen_resolution_index += 1
            if temporary_screen_resolution_index >= len(available_screen_resolutions):
              temporary_screen_resolution_index = 0
            current_resolution_image = OpenGLTextures['RESOLUTION_IMAGES'][temporary_screen_resolution_index]
          if keys[pygame.K_RETURN]:
            old_screen_width, old_screen_height = screen_width, screen_height
            screen_width, screen_height = int(available_screen_resolutions[temporary_screen_resolution_index][0] / monitor_scaling_factor), int(available_screen_resolutions[temporary_screen_resolution_index][1] / monitor_scaling_factor)
            os.environ['SDL_VIDEO_CENTERED'] = '1'
            pygame.display.quit()
            pygame.init()
            if vsync_is_working:
              Screen = pygame.display.set_mode((screen_width, screen_height), pygame.HWSURFACE | pygame.DOUBLEBUF | pygame.OPENGL, vsync=1)
            if not vsync_is_working:
              Screen = pygame.display.set_mode((screen_width, screen_height), pygame.HWSURFACE | pygame.DOUBLEBUF | pygame.OPENGL)
            logo_img = pygame.image.load(path + '\Images/Logo.png')
            pygame.display.set_icon(logo_img)
            pygame.display.set_caption(title)
            aspect = screen_width / screen_height
            glEnable(GL_BLEND)
            glBlendEquation(GL_FUNC_ADD)
            glMatrixMode(GL_PROJECTION)
            glLoadIdentity()
            glOrtho(-aspect, aspect, -1, 1, -1, 1)
            glMatrixMode(GL_MODELVIEW)
            glLoadIdentity()
            global LOADING_HAMSTER_FACE_IMAGE
            LOADING_HAMSTER_FACE_IMAGE = loadTexture(path + '\Images/LoadingHamsterFace.png')
            time.sleep(0.25)
            make_opengl_rect((screen_width, screen_height), LOADING_HAMSTER_FACE_IMAGE[1], (0, 0), 0, False, (0, 0, screen_width, screen_height))
            pygame.display.flip()
            for event in pygame.event.get():
              break
            load_OpenGLTextures()
            MAP.GPU_image = loadTexture(MAP_images[MAP.png_name])
            PRETTY_MAP.GPU_image = loadTexture(MAP_images[PRETTY_MAP.png_name])
            pygame.mouse.set_visible(False)
            current_screen_resolution_index = temporary_screen_resolution_index
            readjust_everything_after_resolution_change(old_screen_width, old_screen_height)
            if BACKGROUND != []:
              My_cached_info.leaving_the_door5 = True
              PLAYER.changed_region_last_frame = True
            glEnable(GL_BLEND)
            glBlendEquation(GL_FUNC_ADD)
            glMatrixMode(GL_PROJECTION)
            glLoadIdentity()
            glOrtho(-aspect, aspect, -1, 1, -1, 1)
            glMatrixMode(GL_MODELVIEW)
            glLoadIdentity()
            glClear(GL_COLOR_BUFFER_BIT)
            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
            #
            temporary_screen_resolution_index = current_screen_resolution_index
            current_resolution_image = OpenGLTextures['RESOLUTION_IMAGES'][temporary_screen_resolution_index]
            shady_pixel = OpenGLTextures['SHADY_BLACK_PIXEL']
            shady_size_multiplier_x = screen_width
            shady_size_multiplier_y = screen_height
            shady_pixel = ((shady_pixel[0][0] * screen_width, shady_pixel[0][1] * screen_height), shady_pixel[1])
            map_width_adjustment = screen_width * (3 / 5)
            map_height_adjustment = screen_height * (2 / 3)
            map_rectangle = OpenGLTextures['PAUSE_MENU_RECTANGLE']
            map_rectangle = ((map_width_adjustment, map_height_adjustment), map_rectangle[1])
            map_Forest = (((map_width_adjustment / 2) - 2, (map_height_adjustment / 2) - 2), OpenGLTextures['FOREST_MINI'][1])
            map_Town = (((map_width_adjustment / 2) - 2, (map_height_adjustment / 2) - 2), OpenGLTextures['TOWN_MINI'][1])
            map_AntHill = (((map_width_adjustment / 2) - 2, (map_height_adjustment / 2) - 2), OpenGLTextures['ANTHILL_MINI'][1])
            map_Sewer = (((map_width_adjustment / 2) - 2, (map_height_adjustment / 2) - 2), OpenGLTextures['SEWER_MINI'][1])
            adjust_door_pos_x = map_width_adjustment / 24000
            adjust_door_pos_y = map_height_adjustment / 12000
            TheDoor1_pos = [(9110+42) * adjust_door_pos_x, (4860+42) * adjust_door_pos_y]
            TheDoor2_pos = [(11608+42) * adjust_door_pos_x, (927+42) * adjust_door_pos_y]
            TheDoor3_pos = [(7110+42) * adjust_door_pos_x, (3355+42) * adjust_door_pos_y]
            TheDoor4_pos = [(5952+42) * adjust_door_pos_x, (4843+42) * adjust_door_pos_y]
            TheDoor5_pos = [(2592+42) * adjust_door_pos_x, (212+42) * adjust_door_pos_y]
            TheDoor7_pos = [(4881+42) * adjust_door_pos_x, (1409+42+6000) * adjust_door_pos_y]
            TheDoor8_pos = [(963+42) * adjust_door_pos_x, (849+42+6000) * adjust_door_pos_y]
            TheDoor9_pos = [(3530+42) * adjust_door_pos_x, (2285+42+6000) * adjust_door_pos_y]
            TheDoor10_pos = [(11240+42+12000) * adjust_door_pos_x, (636+42+6000) * adjust_door_pos_y]
            TheDoor11_pos = [(784+42+12000) * adjust_door_pos_x, (5051+42+6000) * adjust_door_pos_y]
            TheDoor12_pos = [(11147+42+12000) * adjust_door_pos_x, (4320+42+6000) * adjust_door_pos_y]
            TheDoor13_pos = [(743+2991+42+12000) * adjust_door_pos_x, (2640+1461+42) * adjust_door_pos_y]
            mini_hamster = [(PLAYER.x_pos) * adjust_door_pos_x, (PLAYER.y_pos) * adjust_door_pos_y]
            if MAP.region == 'TheDoor1':
              mini_hamster = TheDoor1_pos
            if MAP.region == 'TheDoor2':
              mini_hamster = TheDoor2_pos
            if MAP.region == 'TheDoor3':
              mini_hamster = TheDoor3_pos
            if MAP.region == 'TheDoor4':
              mini_hamster = TheDoor4_pos
            if MAP.region == 'TheDoor5':
              mini_hamster = TheDoor5_pos
            if MAP.region == 'TheDoor6':
              mini_hamster = [512 * adjust_door_pos_x, (5776+6000) * adjust_door_pos_y]
            if MAP.region == 'TheDoor7':
              mini_hamster = TheDoor7_pos
            if MAP.region == 'TheDoor8':
              mini_hamster = TheDoor8_pos
            if MAP.region == 'TheDoor9':
              mini_hamster = TheDoor9_pos
            if MAP.region == 'TheDoor10':
              mini_hamster = TheDoor10_pos
            if MAP.region == 'TheDoor11':
              mini_hamster = TheDoor11_pos
            if MAP.region == 'TheDoor12':
              mini_hamster = TheDoor12_pos
            if MAP.region == 'TheDoor13':
              mini_hamster = TheDoor13_pos
            if MAP.region == 'Town':
              mini_hamster = [mini_hamster[0]+((12000+2991) * adjust_door_pos_x), mini_hamster[1]+(1461 * adjust_door_pos_y)]
            if MAP.region == 'AntHill':
              mini_hamster = [mini_hamster[0]+((0) * adjust_door_pos_x), mini_hamster[1]+(6000 * adjust_door_pos_y)]
            if MAP.region == 'Sewer':
              mini_hamster = [mini_hamster[0]+((12000) * adjust_door_pos_x), mini_hamster[1]+(6000 * adjust_door_pos_y)]
            mini_hamster = (mini_hamster[0], mini_hamster[1])
            touching_which_travel = [False for x in range(12)]
            door_size_adjustment = screen_height / 20
            adjusted_the_door = ((door_size_adjustment, door_size_adjustment), OpenGLTextures['THE_DOOR'][1])
            adjusted_shaded_the_door = ((door_size_adjustment, door_size_adjustment), OpenGLTextures['SHADED_THE_DOOR'][1])
            adjusted_outline_the_door = ((door_size_adjustment * (95 / 85), door_size_adjustment * (95 / 85)), OpenGLTextures['OUTLINE_THE_DOOR'][1])
            available_width_for_upgrades = ((3 / 10) * screen_width)
            single_upgrade_width_and_height = available_width_for_upgrades / 7
            single_highlight_width_and_height = single_upgrade_width_and_height * (75 / 69)
            move_highlight_left_and_up = (single_highlight_width_and_height - single_upgrade_width_and_height) / 2
            bottom_total_available_gap_size = available_width_for_upgrades - (4 * single_upgrade_width_and_height)
            single_gap_size = bottom_total_available_gap_size / 5
            piston1_x = single_upgrade_width_and_height * ((69 - 34) / 2) / 69
            piston1_y = single_upgrade_width_and_height * (14 / 69)
            piston1_width = single_upgrade_width_and_height * (34 / 69)
            piston1_height = single_upgrade_width_and_height * (9 / 69)
            piston2_x = single_upgrade_width_and_height * ((69 - 24) / 2) / 69
            piston2_y = single_upgrade_width_and_height * (31 / 69)
            piston2_width = single_upgrade_width_and_height * (24 / 69)
            piston2_height = single_upgrade_width_and_height * (26 / 69)
            upgrade_distance_from_top = ((screen_height * (1 / 6)) - single_upgrade_width_and_height) / 2
            available_menu_width = (1 / 3) * screen_width
            available_menu_height = screen_height
            empty_menu_width = (1 / 54) * screen_width
            actual_menu_width = available_menu_width - (2 * empty_menu_width)
            actual_menu_height = available_menu_height
            original_option_menu_width = 600
            original_option_menu_height = 800
            menu_width_aspect = actual_menu_width / original_option_menu_width
            menu_height_aspect = actual_menu_height / original_option_menu_height
            menu_option_height = 176
            space_between_menu_options = ((original_option_menu_height - (3 * menu_option_height)) / 4) * menu_height_aspect
            menu_option_height = menu_option_height * menu_height_aspect
            adjusted_continue = ((OpenGLTextures['CONTINUE'][0][0] * menu_width_aspect, OpenGLTextures['CONTINUE'][0][1] * menu_height_aspect), OpenGLTextures['CONTINUE'][1])
            adjusted_options = ((OpenGLTextures['OPTIONS'][0][0] * menu_width_aspect, OpenGLTextures['OPTIONS'][0][1] * menu_height_aspect), OpenGLTextures['OPTIONS'][1])
            adjusted_main_menu = ((OpenGLTextures['MAIN_MENU'][0][0] * menu_width_aspect, OpenGLTextures['MAIN_MENU'][0][1] * menu_height_aspect), OpenGLTextures['MAIN_MENU'][1])
            menu_option_width = OpenGLTextures['CONTINUE'][0][0] * menu_width_aspect
            option_menu_height = 160 * menu_height_aspect
            space_between_option_menu_options = 32 * menu_height_aspect
            adjusted_back = ((OpenGLTextures['BACK'][0][0] * menu_width_aspect, option_menu_height), OpenGLTextures['BACK'][1])
            adjusted_screen = ((OpenGLTextures['SCREEN_OPTIONS'][0][0] * menu_width_aspect, option_menu_height), OpenGLTextures['SCREEN_OPTIONS'][1])
            adjusted_sound = ((OpenGLTextures['SOUND'][0][0] * menu_width_aspect, option_menu_height), OpenGLTextures['SOUND'][1])
            adjusted_hotkeys = ((OpenGLTextures['HOTKEYS'][0][0] * menu_width_aspect, option_menu_height), OpenGLTextures['HOTKEYS'][1])
            adjusted_options_shiny_outside = ((OpenGLTextures['SHINY_OUTSIDE'][0][0] * menu_width_aspect, 176 * menu_height_aspect), OpenGLTextures['SHINY_OUTSIDE'][1])
            adjusted_chain = ((OpenGLTextures['CHAIN'][0][0], (2.5 * menu_option_height) + (3 * space_between_menu_options)), OpenGLTextures['CHAIN'][1])
            adjusted_options_chain = ((OpenGLTextures['CHAIN'][0][0], (3.5 * option_menu_height) + (4 * space_between_option_menu_options)), OpenGLTextures['CHAIN'][1])
            adjusted_shiny_outside = ((OpenGLTextures['SHINY_OUTSIDE'][0][0] * menu_width_aspect, OpenGLTextures['SHINY_OUTSIDE'][0][1] * menu_height_aspect), OpenGLTextures['SHINY_OUTSIDE'][1])
            adjusted_screen_back = ((OpenGLTextures['BACK'][0][0] * menu_width_aspect, OpenGLTextures['BACK'][0][1] * menu_height_aspect), OpenGLTextures['BACK'][1])
            adjusted_resolution = ((OpenGLTextures['RESOLUTION'][0][0] * menu_width_aspect, OpenGLTextures['RESOLUTION'][0][1] * menu_height_aspect), OpenGLTextures['RESOLUTION'][1])
            adjusted_full_screen = ((OpenGLTextures['FULL_SCREEN'][0][0] * menu_width_aspect, OpenGLTextures['FULL_SCREEN'][0][1] * menu_height_aspect), OpenGLTextures['FULL_SCREEN'][1])
            adjusted_windowed = ((OpenGLTextures['WINDOWED'][0][0] * menu_width_aspect, OpenGLTextures['WINDOWED'][0][1] * menu_height_aspect), OpenGLTextures['WINDOWED'][1])
            adjusted_screen_back = ((OpenGLTextures['BACK'][0][0] * menu_width_aspect, OpenGLTextures['BACK'][0][1] * menu_height_aspect), OpenGLTextures['BACK'][1])
            change_screen_note_aspect = (screen_width / 1.45) / OpenGLTextures['CHANGE_RESOLUTION_NOTE'][0][0]
            adjusted_resolution_note = ((OpenGLTextures['CHANGE_RESOLUTION_NOTE'][0][0] * change_screen_note_aspect, OpenGLTextures['CHANGE_RESOLUTION_NOTE'][0][1] * change_screen_note_aspect), OpenGLTextures['CHANGE_RESOLUTION_NOTE'][1])
            sound_adjustment_bar_width = (48/100) * screen_width
            adjusted_sound_bar_being_moved = ((OpenGLTextures['SOUND_BAR_BEING_MOVED'][0][0], OpenGLTextures['SOUND_BAR_BEING_MOVED'][0][1]), OpenGLTextures['SOUND_BAR_BEING_MOVED'][1])
            adjusted_sound_adjustment_bar = ((sound_adjustment_bar_width, OpenGLTextures['SOUND_ADJUSTMENT_BAR'][0][1]), OpenGLTextures['SOUND_ADJUSTMENT_BAR'][1])
            move_letters_down = screen_height / 11
            adjusted_letters_aspect_x = ((3 / 10) * screen_width) / 99
            adjusted_letters_aspect_y = adjusted_letters_aspect_x
            adjusted_hotkey_outline = (((58 / 100) * screen_width, ((2 * (screen_height / 11)) / 10) + (5 * adjusted_letters_aspect_y)), OpenGLTextures['HOTKEY_OUTLINE'][1])
            adjusted_grapple_portion = ((OpenGLTextures['GRAPPLE_PORTION'][0][0] * (single_upgrade_width_and_height / OpenGLTextures['BUBBLE'][0][0]), OpenGLTextures['GRAPPLE_PORTION'][0][1] * (single_upgrade_width_and_height / OpenGLTextures['BUBBLE'][0][1])), OpenGLTextures['GRAPPLE_PORTION'][1])
            default_menu_option_collision = PyGameTextures['MENU_OPTION_SIZING']
            mouse_collision = PyGameTextures['ACTUAL_MOUSE']
            regular_menu_option = pygame.transform.scale(default_menu_option_collision, (536 * menu_width_aspect, 176 * menu_height_aspect))
            flipped_menu_option = pygame.transform.flip(regular_menu_option, True, False)
            current_scaled_menu_option_collisions = [regular_menu_option, flipped_menu_option, regular_menu_option]
            current_scaled_menu_option_collisions = [pygame.mask.from_surface(x) for x in current_scaled_menu_option_collisions]
            regular_option_menu_collision = pygame.transform.scale(default_menu_option_collision, (536 * menu_width_aspect, 160 * menu_height_aspect))
            flipped_option_menu_collision = pygame.transform.flip(regular_option_menu_collision, True, False)
            option_menu_collisions = [regular_option_menu_collision, flipped_option_menu_collision, regular_option_menu_collision, flipped_option_menu_collision]
            option_menu_collisions = [pygame.mask.from_surface(x) for x in option_menu_collisions]
            mouse_collision = pygame.mask.from_surface(mouse_collision)
            touching_Forest_region = [math.floor((1 / 3) * screen_width), math.ceil(((1 / 3) * screen_width) + ((3 / 10) * screen_width)), math.floor((1 / 6) * screen_height), math.ceil(((1 / 2) * screen_height))]
            touching_Town_region = [math.floor(((1 / 3) * screen_width) + ((3 / 10) * screen_width)), math.ceil(((1 / 3) * screen_width) + ((3 / 10) * screen_width) + ((3 / 10) * screen_width)), math.floor((1 / 6) * screen_height), math.ceil(((1 / 2) * screen_height))]
            touching_AntHill_region = [math.floor((1 / 3) * screen_width), math.ceil(((1 / 3) * screen_width) + ((3 / 10) * screen_width)), math.floor(((1 / 6) * screen_height) + ((1 / 3) * screen_height)), math.ceil(((1 / 2) * screen_height) + ((1 / 3) * screen_height))]
            touching_Sewer_region = [math.floor(((1 / 3) * screen_width) + ((3 / 10) * screen_width)), math.ceil(((1 / 3) * screen_width) + ((3 / 10) * screen_width) + ((3 / 10) * screen_width)), math.floor(((1 / 6) * screen_height) + ((1 / 3) * screen_height)), math.ceil(((1 / 2) * screen_height) + ((1 / 3) * screen_height))]
            touching_hotkey_region_x = [math.floor(((36 / 100) * screen_width)), math.ceil(((94 / 100) * screen_width))]
            number_of_pixels_to_move = 0
            #break
      if not touching_resolution:
        make_opengl_rect(adjusted_resolution[0], adjusted_resolution[1], (empty_menu_width, menu_option_height + (2 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_resolution[0][0], adjusted_resolution[0][1]))
      #
      if menu_scroll_y == 0:
        touching_main_menu_points, touching_main_menu = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - ((2 * menu_option_height) + (3 * space_between_menu_options)))
        if touching_main_menu:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), (2 * menu_option_height) + (3 * space_between_menu_options) - (10 * menu_height_aspect)), 0, False, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          show_toggle_full_screen = True
          if (left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']) and allow_full_screen_toggle:
            My_cached_info.windowed = not My_cached_info.windowed
            pygame.display.toggle_fullscreen()
            allow_full_screen_toggle = False
          if not left_click and not Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            allow_full_screen_toggle = True
      if My_cached_info.windowed:
        make_opengl_rect(adjusted_full_screen[0], adjusted_full_screen[1], (empty_menu_width, (2 * menu_option_height) + (3 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_full_screen[0][0], adjusted_full_screen[0][1]))
      if not My_cached_info.windowed:
        make_opengl_rect(adjusted_full_screen[0], adjusted_full_screen[1], (empty_menu_width, (2 * menu_option_height) + (3 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_full_screen[0][0], adjusted_full_screen[0][1]))
      if show_toggle_full_screen:
        make_opengl_rect(OpenGLTextures['TOGGLE_FULL_SCREEN'][0], OpenGLTextures['TOGGLE_FULL_SCREEN'][1], (Mouse_x - (0.5 * OpenGLTextures['TOGGLE_FULL_SCREEN'][0][0]), Mouse_y - (OpenGLTextures['TOGGLE_FULL_SCREEN'][0][1]) - 10), 0, False, (0, 0, OpenGLTextures['TOGGLE_FULL_SCREEN'][0][0], OpenGLTextures['TOGGLE_FULL_SCREEN'][0][1]))
    #
    #
    #
    skip_the_rest = False
    touching_Forest = False
    touching_Town = False
    touching_AntHill = False
    touching_Sewer = False
    if touching_Forest_region[0] <= Mouse_x <= touching_Forest_region[1]:
      if touching_Forest_region[2] <= Mouse_y <= touching_Forest_region[3]:
        touching_Forest = True
        skip_the_rest = True
    if not skip_the_rest:
      if touching_Town_region[0] <= Mouse_x <= touching_Town_region[1]:
        if touching_Town_region[2] <= Mouse_y <= touching_Town_region[3]:
          touching_Town = True
          skip_the_rest = True
    if not skip_the_rest:
      if touching_AntHill_region[0] <= Mouse_x <= touching_AntHill_region[1]:
        if touching_AntHill_region[2] <= Mouse_y <= touching_AntHill_region[3]:
          touching_AntHill = True
          skip_the_rest = True
    if not skip_the_rest:
      if touching_Sewer_region[0] <= Mouse_x <= touching_Sewer_region[1]:
        if touching_Sewer_region[2] <= Mouse_y <= touching_Sewer_region[3]:
          touching_Sewer = True
    #
    number_of_pixels_to_move += pause_delta_milliseconds / 6
    piston1_ltwh = [(486 - ((round(number_of_pixels_to_move))%243))%243, 0, 34, 9]
    piston2_ltwh = [0, 0, 24, 26]
    #
    # Forest
    if touching_Forest:
      for _ in range(1):
        if touching_a_travel:
          if not touching_which_travel[0]:
            continue
        make_opengl_rect((single_highlight_width_and_height, single_highlight_width_and_height), OpenGLTextures['HIGHLIGHT_BUBBLE'][1], (((1 / 3) * screen_width) - move_highlight_left_and_up, upgrade_distance_from_top - move_highlight_left_and_up), 0, False, (0, 0, single_highlight_width_and_height, single_highlight_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['BUBBLE'][1], ((1 / 3) * screen_width, upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (((1 / 3) * screen_width) + piston1_x, upgrade_distance_from_top + piston1_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
    make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (((1 / 3) * screen_width) + piston2_x, upgrade_distance_from_top + piston2_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
    if all_current_save_data[27][0] == '0':
      make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['SHADY_BUBBLE'][1], ((1 / 3) * screen_width, upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
#
    if touching_Forest:
      for _ in range(1):
        if touching_a_travel:
          if not touching_which_travel[1]:
            continue
        make_opengl_rect((single_highlight_width_and_height, single_highlight_width_and_height), OpenGLTextures['HIGHLIGHT_BUBBLE'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (6 / 5)) - move_highlight_left_and_up, upgrade_distance_from_top - move_highlight_left_and_up), 0, False, (0, 0, single_highlight_width_and_height, single_highlight_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['BUBBLE'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (6 / 5)), upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (6 / 5)) + piston1_x, upgrade_distance_from_top + piston1_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
    make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (6 / 5)) + piston2_x, upgrade_distance_from_top + piston2_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
    if all_current_save_data[28][0] == '0':
      make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['SHADY_BUBBLE'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (6 / 5)), upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
#
    if touching_Forest:
      for _ in range(1):
        if touching_a_travel:
          if not touching_which_travel[2]:
            continue
        make_opengl_rect((single_highlight_width_and_height, single_highlight_width_and_height), OpenGLTextures['HIGHLIGHT_BUBBLE'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (12 / 5)) - move_highlight_left_and_up, upgrade_distance_from_top - move_highlight_left_and_up), 0, False, (0, 0, single_highlight_width_and_height, single_highlight_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['BUBBLE'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (12 / 5)), upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (12 / 5)) + piston1_x, upgrade_distance_from_top + piston1_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
    make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (12 / 5)) + piston2_x, upgrade_distance_from_top + piston2_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
    if all_current_save_data[29][0] == '0':
      make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['SHADY_BUBBLE'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (12 / 5)), upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
#
    if touching_Forest:
      for _ in range(1):
        if touching_a_travel:
          if not touching_which_travel[3]:
            continue
        make_opengl_rect((single_highlight_width_and_height, single_highlight_width_and_height), OpenGLTextures['HIGHLIGHT_BUBBLE'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (18 / 5)) - move_highlight_left_and_up, upgrade_distance_from_top - move_highlight_left_and_up), 0, False, (0, 0, single_highlight_width_and_height, single_highlight_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['BUBBLE'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (18 / 5)), upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (18 / 5)) + piston1_x, upgrade_distance_from_top + piston1_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
    make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (18 / 5)) + piston2_x, upgrade_distance_from_top + piston2_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
    if all_current_save_data[30][0] == '0':
      make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['SHADY_BUBBLE'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (18 / 5)), upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
#
    if touching_Forest:
      for _ in range(1):
        if touching_a_travel:
          if not touching_which_travel[4]:
            continue
        make_opengl_rect((single_highlight_width_and_height, single_highlight_width_and_height), OpenGLTextures['HIGHLIGHT_BUBBLE'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (24 / 5)) - move_highlight_left_and_up, upgrade_distance_from_top - move_highlight_left_and_up), 0, False, (0, 0, single_highlight_width_and_height, single_highlight_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['BUBBLE'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (24 / 5)), upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (24 / 5)) + piston1_x, upgrade_distance_from_top + piston1_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
    make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (24 / 5)) + piston2_x, upgrade_distance_from_top + piston2_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
    if all_current_save_data[31][0] == '0':
      make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['SHADY_BUBBLE'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (24 / 5)), upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
#
    if touching_Forest:
      for _ in range(1):
        if touching_a_travel:
          continue
        make_opengl_rect((single_highlight_width_and_height, single_highlight_width_and_height), OpenGLTextures['HIGHLIGHT_BUBBLE'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (30 / 5)) - move_highlight_left_and_up, upgrade_distance_from_top - move_highlight_left_and_up), 0, False, (0, 0, single_highlight_width_and_height, single_highlight_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['BUBBLE'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (30 / 5)), upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['SCREW_DRIVER'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (30 / 5)), upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    if all_current_save_data[16][0] == '0':
      make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['SHADY_BUBBLE'][1], (((1 / 3) * screen_width) + (single_upgrade_width_and_height * (30 / 5)), upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    #
    # Town
    if touching_Town:
      for _ in range(1):
        if touching_a_travel:
          if not touching_which_travel[11]:
            continue
        make_opengl_rect((single_highlight_width_and_height, single_highlight_width_and_height), OpenGLTextures['HIGHLIGHT_BUBBLE'][1], (((1 / 3) * screen_width) + ((4.5 / 10) * screen_width) - (single_upgrade_width_and_height / 2) - move_highlight_left_and_up, upgrade_distance_from_top - move_highlight_left_and_up), 0, False, (0, 0, single_highlight_width_and_height, single_highlight_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['BUBBLE'][1], (((1 / 3) * screen_width) + ((4.5 / 10) * screen_width) - (single_upgrade_width_and_height / 2), upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (((1 / 3) * screen_width) + ((4.5 / 10) * screen_width) - (single_upgrade_width_and_height / 2) + piston1_x, upgrade_distance_from_top + piston1_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
    make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (((1 / 3) * screen_width) + ((4.5 / 10) * screen_width) - (single_upgrade_width_and_height / 2) + piston2_x, upgrade_distance_from_top + piston2_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
    if all_current_save_data[38][0] == '0':
      make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['SHADY_BUBBLE'][1], (((1 / 3) * screen_width) + ((4.5 / 10) * screen_width) - (single_upgrade_width_and_height / 2), upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    #
    # AntHill
    if touching_AntHill:
      for _ in range(1):
        if touching_a_travel:
          if not touching_which_travel[5]:
            continue
        make_opengl_rect((single_highlight_width_and_height, single_highlight_width_and_height), OpenGLTextures['HIGHLIGHT_BUBBLE'][1], (((1 / 3) * screen_width) + single_gap_size - move_highlight_left_and_up, ((5 / 6) * screen_height) + upgrade_distance_from_top - move_highlight_left_and_up), 0, False, (0, 0, single_highlight_width_and_height, single_highlight_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['BUBBLE'][1], (((1 / 3) * screen_width) + single_gap_size, ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (((1 / 3) * screen_width) + single_gap_size + piston1_x, ((5 / 6) * screen_height) + upgrade_distance_from_top + piston1_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
    make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (((1 / 3) * screen_width) + single_gap_size + piston2_x, ((5 / 6) * screen_height) + upgrade_distance_from_top + piston2_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
    if all_current_save_data[32][0] == '0':
      make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['SHADY_BUBBLE'][1], (((1 / 3) * screen_width) + single_gap_size, ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    #
    if touching_AntHill:
      for _ in range(1):
        if touching_a_travel:
          if not touching_which_travel[6]:
            continue
        make_opengl_rect((single_highlight_width_and_height, single_highlight_width_and_height), OpenGLTextures['HIGHLIGHT_BUBBLE'][1], (((1 / 3) * screen_width) + (2 * single_gap_size) + single_upgrade_width_and_height - move_highlight_left_and_up, ((5 / 6) * screen_height) + upgrade_distance_from_top - move_highlight_left_and_up), 0, False, (0, 0, single_highlight_width_and_height, single_highlight_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['BUBBLE'][1], (((1 / 3) * screen_width) + (2 * single_gap_size) + single_upgrade_width_and_height, ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (((1 / 3) * screen_width) + (2 * single_gap_size) + single_upgrade_width_and_height + piston1_x, ((5 / 6) * screen_height) + upgrade_distance_from_top + piston1_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
    make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (((1 / 3) * screen_width) + (2 * single_gap_size) + single_upgrade_width_and_height + piston2_x, ((5 / 6) * screen_height) + upgrade_distance_from_top + piston2_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
    if all_current_save_data[33][0] == '0':
      make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['SHADY_BUBBLE'][1], (((1 / 3) * screen_width) + (2 * single_gap_size) + single_upgrade_width_and_height, ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    #
    if touching_AntHill:
      for _ in range(1):
        if touching_a_travel:
          if not touching_which_travel[7]:
            continue
        make_opengl_rect((single_highlight_width_and_height, single_highlight_width_and_height), OpenGLTextures['HIGHLIGHT_BUBBLE'][1], (((1 / 3) * screen_width) + (3 * single_gap_size) + (2 * single_upgrade_width_and_height) - move_highlight_left_and_up, ((5 / 6) * screen_height) + upgrade_distance_from_top - move_highlight_left_and_up), 0, False, (0, 0, single_highlight_width_and_height, single_highlight_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['BUBBLE'][1], (((1 / 3) * screen_width) + (3 * single_gap_size) + (2 * single_upgrade_width_and_height), ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (((1 / 3) * screen_width) + (3 * single_gap_size) + (2 * single_upgrade_width_and_height) + piston1_x, ((5 / 6) * screen_height) + upgrade_distance_from_top + piston1_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
    make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (((1 / 3) * screen_width) + (3 * single_gap_size) + (2 * single_upgrade_width_and_height) + piston2_x, ((5 / 6) * screen_height) + upgrade_distance_from_top + piston2_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
    if all_current_save_data[34][0] == '0':
      make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['SHADY_BUBBLE'][1], (((1 / 3) * screen_width) + (3 * single_gap_size) + (2 * single_upgrade_width_and_height), ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    #
    if touching_AntHill:
      for _ in range(1):
        if touching_a_travel:
          continue
        make_opengl_rect((single_highlight_width_and_height, single_highlight_width_and_height), OpenGLTextures['HIGHLIGHT_BUBBLE'][1], (((1 / 3) * screen_width) + (4 * single_gap_size) + (3 * single_upgrade_width_and_height) - move_highlight_left_and_up, ((5 / 6) * screen_height) + upgrade_distance_from_top - move_highlight_left_and_up), 0, False, (0, 0, single_highlight_width_and_height, single_highlight_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['BUBBLE'][1], (((1 / 3) * screen_width) + (4 * single_gap_size) + (3 * single_upgrade_width_and_height), ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['WIRE_CUTTER'][1], (((1 / 3) * screen_width) + (4 * single_gap_size) + (3 * single_upgrade_width_and_height), ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    if all_current_save_data[17][0] == '0':
      make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['SHADY_BUBBLE'][1], (((1 / 3) * screen_width) + (4 * single_gap_size) + (3 * single_upgrade_width_and_height), ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    #
    # Sewer
    if touching_Sewer:
      for _ in range(1):
        if touching_a_travel:
          if not touching_which_travel[8]:
            continue
        make_opengl_rect((single_highlight_width_and_height, single_highlight_width_and_height), OpenGLTextures['HIGHLIGHT_BUBBLE'][1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + single_gap_size - move_highlight_left_and_up, ((5 / 6) * screen_height) + upgrade_distance_from_top - move_highlight_left_and_up), 0, False, (0, 0, single_highlight_width_and_height, single_highlight_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['BUBBLE'][1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + single_gap_size, ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + single_gap_size + piston1_x, ((5 / 6) * screen_height) + upgrade_distance_from_top + piston1_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
    make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + single_gap_size + piston2_x, ((5 / 6) * screen_height) + upgrade_distance_from_top + piston2_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
    if all_current_save_data[35][0] == '0':
      make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['SHADY_BUBBLE'][1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + single_gap_size, ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    #
    if touching_Sewer:
      for _ in range(1):
        if touching_a_travel:
          if not touching_which_travel[9]:
            continue
        make_opengl_rect((single_highlight_width_and_height, single_highlight_width_and_height), OpenGLTextures['HIGHLIGHT_BUBBLE'][1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + (2 * single_gap_size) + single_upgrade_width_and_height - move_highlight_left_and_up, ((5 / 6) * screen_height - move_highlight_left_and_up) + upgrade_distance_from_top), 0, False, (0, 0, single_highlight_width_and_height, single_highlight_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['BUBBLE'][1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + (2 * single_gap_size) + single_upgrade_width_and_height, ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + (2 * single_gap_size) + single_upgrade_width_and_height + piston1_x, ((5 / 6) * screen_height) + upgrade_distance_from_top + piston1_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
    make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + (2 * single_gap_size) + single_upgrade_width_and_height + piston2_x, ((5 / 6) * screen_height) + upgrade_distance_from_top + piston2_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
    if all_current_save_data[36][0] == '0':
      make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['SHADY_BUBBLE'][1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + (2 * single_gap_size) + single_upgrade_width_and_height, ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    #
    if touching_Sewer:
      for _ in range(1):
        if touching_a_travel:
          if not touching_which_travel[10]:
            continue
        make_opengl_rect((single_highlight_width_and_height, single_highlight_width_and_height), OpenGLTextures['HIGHLIGHT_BUBBLE'][1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + (3 * single_gap_size) + (2 * single_upgrade_width_and_height) - move_highlight_left_and_up, ((5 / 6) * screen_height) + upgrade_distance_from_top - move_highlight_left_and_up), 0, False, (0, 0, single_highlight_width_and_height, single_highlight_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['BUBBLE'][1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + (3 * single_gap_size) + (2 * single_upgrade_width_and_height), ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], OpenGLTextures['PUSH_PISTON_COVER'][1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + (3 * single_gap_size) + (2 * single_upgrade_width_and_height) + piston1_x, ((5 / 6) * screen_height) + upgrade_distance_from_top + piston1_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
    make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + (3 * single_gap_size) + (2 * single_upgrade_width_and_height) + piston2_x, ((5 / 6) * screen_height) + upgrade_distance_from_top + piston2_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
    if all_current_save_data[37][0] == '0':
      make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['SHADY_BUBBLE'][1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + (3 * single_gap_size) + (2 * single_upgrade_width_and_height), ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    #
    if touching_Sewer:
      for _ in range(1):
        if touching_a_travel:
          continue
        make_opengl_rect((single_highlight_width_and_height, single_highlight_width_and_height), OpenGLTextures['HIGHLIGHT_BUBBLE'][1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + (4 * single_gap_size) + (3 * single_upgrade_width_and_height) - move_highlight_left_and_up, ((5 / 6) * screen_height) + upgrade_distance_from_top - move_highlight_left_and_up), 0, False, (0, 0, single_highlight_width_and_height, single_highlight_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['BUBBLE'][1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + (4 * single_gap_size) + (3 * single_upgrade_width_and_height), ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['WRENCH'][1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + (4 * single_gap_size) + (3 * single_upgrade_width_and_height), ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    if all_current_save_data[18][0] == '0':
      make_opengl_rect((single_upgrade_width_and_height, single_upgrade_width_and_height), OpenGLTextures['SHADY_BUBBLE'][1], (((1 / 3) * screen_width) + ((3 / 10) * screen_width) + (4 * single_gap_size) + (3 * single_upgrade_width_and_height), ((5 / 6) * screen_height) + upgrade_distance_from_top), 0, False, (0, 0, single_upgrade_width_and_height, single_upgrade_width_and_height))
    #
    #
    if display_resolution_note:
      make_opengl_rect(adjusted_resolution_note[0], adjusted_resolution_note[1], (screen_width - adjusted_resolution_note[0][0], screen_height - adjusted_resolution_note[0][1]), 0, False, (0, 0, adjusted_resolution_note[0][0], adjusted_resolution_note[0][1]))
      resolution_starting_x = 1110 * change_screen_note_aspect
      resolution_starting_y = 10 * change_screen_note_aspect
      additional_resolution_x = 0
      for SingleCharacter in monitor_string:
        if SingleCharacter == '0':
          OpenGL_character = ((OpenGLTextures['N0'][0][0] * change_screen_note_aspect, OpenGLTextures['N0'][0][1] * change_screen_note_aspect), OpenGLTextures['N0'][1])
        if SingleCharacter == '1':
          OpenGL_character = ((OpenGLTextures['N1'][0][0] * change_screen_note_aspect, OpenGLTextures['N1'][0][1] * change_screen_note_aspect), OpenGLTextures['N1'][1])
        if SingleCharacter == '2':
          OpenGL_character = ((OpenGLTextures['N2'][0][0] * change_screen_note_aspect, OpenGLTextures['N2'][0][1] * change_screen_note_aspect), OpenGLTextures['N2'][1])
        if SingleCharacter == '3':
          OpenGL_character = ((OpenGLTextures['N3'][0][0] * change_screen_note_aspect, OpenGLTextures['N3'][0][1] * change_screen_note_aspect), OpenGLTextures['N3'][1])
        if SingleCharacter == '4':
          OpenGL_character = ((OpenGLTextures['N4'][0][0] * change_screen_note_aspect, OpenGLTextures['N4'][0][1] * change_screen_note_aspect), OpenGLTextures['N4'][1])
        if SingleCharacter == '5':
          OpenGL_character = ((OpenGLTextures['N5'][0][0] * change_screen_note_aspect, OpenGLTextures['N5'][0][1] * change_screen_note_aspect), OpenGLTextures['N5'][1])
        if SingleCharacter == '6':
          OpenGL_character = ((OpenGLTextures['N6'][0][0] * change_screen_note_aspect, OpenGLTextures['N6'][0][1] * change_screen_note_aspect), OpenGLTextures['N6'][1])
        if SingleCharacter == '7':
          OpenGL_character = ((OpenGLTextures['N7'][0][0] * change_screen_note_aspect, OpenGLTextures['N7'][0][1] * change_screen_note_aspect), OpenGLTextures['N7'][1])
        if SingleCharacter == '8':
          OpenGL_character = ((OpenGLTextures['N8'][0][0] * change_screen_note_aspect, OpenGLTextures['N8'][0][1] * change_screen_note_aspect), OpenGLTextures['N8'][1])
        if SingleCharacter == '9':
          OpenGL_character = ((OpenGLTextures['N9'][0][0] * change_screen_note_aspect, OpenGLTextures['N9'][0][1] * change_screen_note_aspect), OpenGLTextures['N9'][1])
        if SingleCharacter == 'x':
          OpenGL_character = ((OpenGLTextures['Nx'][0][0] * change_screen_note_aspect, OpenGLTextures['Nx'][0][1] * change_screen_note_aspect), OpenGLTextures['Nx'][1])
        make_opengl_rect(OpenGL_character[0], OpenGL_character[1], (screen_width - adjusted_resolution_note[0][0] + resolution_starting_x + additional_resolution_x, screen_height - adjusted_resolution_note[0][1] + resolution_starting_y), 0, False, (0, 0, OpenGL_character[0][0], OpenGL_character[0][1]))
        additional_resolution_x += OpenGL_character[0][0] + (10 * change_screen_note_aspect)
    #
    #
    #
    if showing_sound:
      menu_scroll_y = 0
      percent_of_the_way_through_scrolling = (pause_curr_time - started_scrolling_time) / 500
      if scrolling_toward_sound:
        menu_scroll_y = -abs((1 - percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_toward_sound = False
      if scrolling_away_sound:
        allow_another_option_to_scroll_down = False
        menu_scroll_y = -abs((percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_away_sound = False
          scrolling_toward_sound = False
          showing_sound = False
          showing_option_menu_screen = False
          showing_options = True
          started_scrolling_time = pygame.time.get_ticks()
      if percent_of_the_way_through_scrolling >= 1:
        allow_another_option_to_scroll_down = True
        #started_scrolling_time = pygame.time.get_ticks()
      #
      chain_distance_subtracted = -((1.5 * menu_option_height) + (2 * space_between_menu_options))
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + ((2 / 10) * menu_option_width), 0 + menu_scroll_y + chain_distance_subtracted), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + menu_option_width - OpenGLTextures['CHAIN'][0][0] - ((2 / 10) * menu_option_width), 0 + menu_scroll_y + chain_distance_subtracted), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      #
      if menu_scroll_y == 0:
        touching_back_points, touching_back = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - space_between_menu_options)
        if touching_back:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), space_between_menu_options - (10 * menu_height_aspect)), 0, False, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if (left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']) and not holding_sound_bar and not holding_music_bar:
            started_scrolling_time = pygame.time.get_ticks()
            scrolling_toward_sound = False
            scrolling_away_sound = True
            #showing_options = True
            scrolling_toward_options = True
      make_opengl_rect(adjusted_screen_back[0], adjusted_screen_back[1], (empty_menu_width, space_between_menu_options + menu_scroll_y), 0, False, (0, 0, adjusted_screen_back[0][0], adjusted_screen_back[0][1]))
    #
      sound_added_x = 0
      if percent_of_the_way_through_scrolling < 0:
        percent_of_the_way_through_scrolling = 0
      if percent_of_the_way_through_scrolling > 1:
        percent_of_the_way_through_scrolling = 1
      if scrolling_toward_sound and percent_of_the_way_through_scrolling != 1:
        sound_added_x = (68/100) * screen_width * (1 - percent_of_the_way_through_scrolling)
      if scrolling_away_sound:
        sound_added_x = (68/100) * screen_width * (percent_of_the_way_through_scrolling)
        if percent_of_the_way_through_scrolling == 0:
          sound_added_x = (68/100) * screen_width
        if percent_of_the_way_through_scrolling == 1:
          sound_added_x = 0
      if showing_options:
        sound_added_x = (68/100) * screen_width
      adjusted_black_pixel = ((OpenGLTextures['BLACK_PIXEL'][0][0] * screen_width, OpenGLTextures['BLACK_PIXEL'][0][1] * screen_height), OpenGLTextures['BLACK_PIXEL'][1])
      make_opengl_rect(adjusted_black_pixel[0], adjusted_black_pixel[1], (((32/100) * screen_width) + sound_added_x, 0), 0, False, (0, 0, adjusted_black_pixel[0][0], adjusted_black_pixel[0][1]))
      #
      black_pixel_x = ((32/100) * screen_width) + sound_added_x
      black_pixel_y = 0
      blank_area_between = (screen_height - (2 * OpenGLTextures['SOUND_BAR_BEING_MOVED'][0][1])) / 3
      center_bars_x = ((10/100) * screen_width) + sound_added_x
      make_opengl_rect(adjusted_sound_adjustment_bar[0], adjusted_sound_adjustment_bar[1], (black_pixel_x + center_bars_x, blank_area_between + (adjusted_sound_bar_being_moved[0][1] / 2) - (adjusted_sound_adjustment_bar[0][1] / 2)), 0, False, (0, 0, adjusted_sound_adjustment_bar[0][0], adjusted_sound_adjustment_bar[0][1]))
      make_opengl_rect(adjusted_sound_adjustment_bar[0], adjusted_sound_adjustment_bar[1], (black_pixel_x + center_bars_x, (2 * blank_area_between) + ((3 * adjusted_sound_bar_being_moved[0][1]) / 2) - (adjusted_sound_adjustment_bar[0][1] / 2)), 0, False, (0, 0, adjusted_sound_adjustment_bar[0][0], adjusted_sound_adjustment_bar[0][1]))
      #
      total_available_bar_distance_x = adjusted_sound_adjustment_bar[0][0] - adjusted_sound_bar_being_moved[0][0]
      My_cached_info.current_music_loudness = float(everything_sound_data(False, 666, 0)[0])
      move_music_bar_x = total_available_bar_distance_x * My_cached_info.current_music_loudness
      if not left_click and not Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
        holding_music_bar = False
      if (left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']) and not holding_sound_bar and not holding_music_bar:
        if (black_pixel_x + center_bars_x + move_music_bar_x) <= Mouse_x <= (black_pixel_x + center_bars_x + move_music_bar_x + adjusted_sound_bar_being_moved[0][0]):
          if (blank_area_between) <= Mouse_y <= (blank_area_between + adjusted_sound_bar_being_moved[0][1]):
            holding_music_bar = True
      if holding_music_bar:
        My_cached_info.current_music_loudness = (Mouse_x - (black_pixel_x + center_bars_x) - (adjusted_sound_bar_being_moved[0][0] / 2)) / total_available_bar_distance_x
        if My_cached_info.current_music_loudness < 0:
          My_cached_info.current_music_loudness = 0
        if My_cached_info.current_music_loudness > 1:
          My_cached_info.current_music_loudness = 1
        everything_sound_data(True, 0, str(My_cached_info.current_music_loudness))
        update_music_loudness()
      make_opengl_rect(adjusted_sound_bar_being_moved[0], adjusted_sound_bar_being_moved[1], (black_pixel_x + center_bars_x + move_music_bar_x, blank_area_between), 0, False, (0, 0, adjusted_sound_bar_being_moved[0][0], adjusted_sound_bar_being_moved[0][1]))
      #
      StringToBeCreated = 'MUSIC: ' + str(round(My_cached_info.current_music_loudness * 100))
      Music_string_length = 0
      for SingleCharacter in StringToBeCreated:
        if SingleCharacter != ' ':
          Music_string_length += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          Music_string_length += (3 * adjusted_letters_aspect_x)
      music_character_spacing_x = 0
      for SingleCharacter in StringToBeCreated:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (black_pixel_x + center_bars_x + (0.5 * adjusted_sound_adjustment_bar[0][0]) - (0.5 * Music_string_length) + music_character_spacing_x, blank_area_between - (OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y) - 5), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          music_character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          music_character_spacing_x += (3 * adjusted_letters_aspect_x)
      #
      My_cached_info.current_sound_loudness = float(everything_sound_data(False, 666, 0)[1])
      move_sound_bar_x = total_available_bar_distance_x * My_cached_info.current_sound_loudness
      if not left_click and not Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
        holding_sound_bar = False
      if (left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']) and not holding_sound_bar and not holding_music_bar:
        if (black_pixel_x + center_bars_x + move_sound_bar_x) <= Mouse_x <= (black_pixel_x + center_bars_x + move_sound_bar_x + adjusted_sound_bar_being_moved[0][0]):
          if ((2 * blank_area_between) + adjusted_sound_bar_being_moved[0][1]) <= Mouse_y <= ((2 * blank_area_between) + adjusted_sound_bar_being_moved[0][1] + adjusted_sound_bar_being_moved[0][1]):
            holding_sound_bar = True
      if holding_sound_bar:
        My_cached_info.current_sound_loudness = (Mouse_x - (black_pixel_x + center_bars_x) - (adjusted_sound_bar_being_moved[0][0] / 2)) / total_available_bar_distance_x
        if My_cached_info.current_sound_loudness < 0:
          My_cached_info.current_sound_loudness = 0
        if My_cached_info.current_sound_loudness > 1:
          My_cached_info.current_sound_loudness = 1
        everything_sound_data(True, 1, str(My_cached_info.current_sound_loudness))
        update_sound_loudness()
        for SingleRoot in ROOTS:
          SingleRoot.shaky_root_sound.set_volume(My_cached_info.current_sound_loudness * MixerSoundsLoudness['SHAKY_ROOT'])
      make_opengl_rect(adjusted_sound_bar_being_moved[0], adjusted_sound_bar_being_moved[1], (black_pixel_x + center_bars_x + move_sound_bar_x, (2 * blank_area_between) + adjusted_sound_bar_being_moved[0][1]), 0, False, (0, 0, adjusted_sound_bar_being_moved[0][0], adjusted_sound_bar_being_moved[0][1]))
      #
      StringToBeCreated = 'SOUND: ' + str(round(My_cached_info.current_sound_loudness * 100))
      Sound_string_length = 0
      for SingleCharacter in StringToBeCreated:
        if SingleCharacter != ' ':
          Sound_string_length += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          Sound_string_length += (3 * adjusted_letters_aspect_x)
      Sound_character_spacing_x = 0
      for SingleCharacter in StringToBeCreated:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (black_pixel_x + center_bars_x + (0.5 * adjusted_sound_adjustment_bar[0][0]) - (0.5 * Sound_string_length) + Sound_character_spacing_x, (2 * blank_area_between) + adjusted_sound_bar_being_moved[0][1] - (OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y) - 5), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          Sound_character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          Sound_character_spacing_x += (3 * adjusted_letters_aspect_x)
    #
    #
    #
    if showing_hotkey:
      menu_scroll_y = 0
      percent_of_the_way_through_scrolling = (pause_curr_time - started_scrolling_time) / 500
      if scrolling_toward_hotkey:
        menu_scroll_y = -abs((1 - percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_toward_hotkey = False
      if scrolling_away_hotkey:
        allow_another_option_to_scroll_down = False
        menu_scroll_y = -abs((percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_away_hotkey = False
          scrolling_toward_hotkey = False
          showing_hotkey = False
          showing_option_menu_screen = False
          showing_options = True
          started_scrolling_time = pygame.time.get_ticks()
      if percent_of_the_way_through_scrolling >= 1:
        allow_another_option_to_scroll_down = True
        #started_scrolling_time = pygame.time.get_ticks()
      #
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + menu_option_width - OpenGLTextures['CHAIN'][0][0] - ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      #
      if menu_scroll_y == 0:
        touching_back_points, touching_back = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - space_between_menu_options)
        if touching_back:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), space_between_menu_options - (10 * menu_height_aspect)), 0, False, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            started_scrolling_time = pygame.time.get_ticks()
            scrolling_toward_hotkey = False
            scrolling_away_hotkey = True
            #showing_options = True
            scrolling_toward_options = True
      make_opengl_rect(adjusted_screen_back[0], adjusted_screen_back[1], (empty_menu_width, space_between_menu_options + menu_scroll_y), 0, False, (0, 0, adjusted_screen_back[0][0], adjusted_screen_back[0][1]))
      #
      if menu_scroll_y == 0:
        touching_save_points, touching_save = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[1], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - (menu_option_height + (2 * space_between_menu_options)))
        if touching_save:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), menu_option_height + (2 * space_between_menu_options) - (10 * menu_height_aspect)), 0, True, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            time_since_saving_hotkeys = 0
            current_hotkeys = temporary_current_hotkeys.copy()
            all_hotkey_indexes = []
            for k2, v2 in current_hotkeys.items():
              all_hotkey_indexes.append(str(v2) + '\n')
            with open(current_control_path, 'w') as file:
              file.writelines(all_hotkey_indexes)
      if time_since_saving_hotkeys >= 2500:
        make_opengl_rect(adjusted_options[0], OpenGLTextures['SAVE'][1], (empty_menu_width, menu_option_height + (2 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_options[0][0], adjusted_options[0][1]))
      if time_since_saving_hotkeys < 2500:
        make_opengl_rect(adjusted_options[0], OpenGLTextures['SAVED'][1], (empty_menu_width, menu_option_height + (2 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_options[0][0], adjusted_options[0][1]))
      #
      if menu_scroll_y == 0:
        touching_defaults_points, touching_defaults = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - ((2 * menu_option_height) + (3 * space_between_menu_options)))
        if touching_defaults:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), (2 * menu_option_height) + (3 * space_between_menu_options) - (10 * menu_height_aspect)), 0, False, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            with open(default_control_path, 'r') as file:
              hotkey_save_data = file.readlines()
            temporary_current_hotkeys = [int(x) for x in hotkey_save_data]
            temp_hotkey_dict = {}
            return_to_default_hotkeys_index = 0
            for k3, v3 in current_hotkeys.items():
              temp_hotkey_dict[k3] = temporary_current_hotkeys[return_to_default_hotkeys_index]
              return_to_default_hotkeys_index += 1
            temporary_current_hotkeys = temp_hotkey_dict
      make_opengl_rect(adjusted_main_menu[0], OpenGLTextures['DEFAULTS'][1], (empty_menu_width, (2 * menu_option_height) + (3 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_main_menu[0][0], adjusted_main_menu[0][1]))
      #
      hotkeys_added_x = 0
      if percent_of_the_way_through_scrolling < 0:
        percent_of_the_way_through_scrolling = 0
      if percent_of_the_way_through_scrolling > 1:
        percent_of_the_way_through_scrolling = 1
      if scrolling_toward_hotkey and percent_of_the_way_through_scrolling != 1:
        hotkeys_added_x = (68/100) * screen_width * (1 - percent_of_the_way_through_scrolling)
      if scrolling_away_hotkey:
        hotkeys_added_x = (68/100) * screen_width * (percent_of_the_way_through_scrolling)
        if percent_of_the_way_through_scrolling == 0:
          hotkeys_added_x = (68/100) * screen_width
        if percent_of_the_way_through_scrolling == 1:
          hotkeys_added_x = 0
      if showing_options:
        hotkeys_added_x = (68/100) * screen_width
      adjusted_black_pixel = ((OpenGLTextures['BLACK_PIXEL'][0][0] * screen_width, OpenGLTextures['BLACK_PIXEL'][0][1] * screen_height), OpenGLTextures['BLACK_PIXEL'][1])
      make_opengl_rect(adjusted_black_pixel[0], adjusted_black_pixel[1], (((32/100) * screen_width) + hotkeys_added_x, 0), 0, False, (0, 0, adjusted_black_pixel[0][0], adjusted_black_pixel[0][1]))
      empty_space = 2 * (screen_height / 11)
      character_height = 5 * adjusted_letters_aspect_y
      empty_space = screen_height - (9 * 5 * adjusted_letters_aspect_y)
      in_a_change_hotkey_region = False
      #
      all_hotkey_display_strings = []
      for k, v in temporary_current_hotkeys.items():
        if v == 512:
          all_hotkey_display_strings.append('LEFT CLICK')
          continue
        if v == 513:
          all_hotkey_display_strings.append('WEIRD CLICK')
          continue
        if v == 514:
          all_hotkey_display_strings.append('RIGHT CLICK')
          continue
        current_display_string = key_to_pygame_index_dict[str(v)]
        all_hotkey_display_strings.append(current_display_string)
      #
      index_character_pair = []
      for k, v in key_to_pygame_index_dict.items():
        if keys[int(k)]:
          index_character_pair = [k, v]
          break
      if index_character_pair == []:
        for _ in range(1):
          if left_click:
            index_character_pair = [512, 'left_click']
            continue
          if weird_click:
            index_character_pair = [513, 'weird_click']
            continue
          if right_click:
            index_character_pair = [514, 'right_click']
            continue
      #
      #
      character_spacing_x = 0
      for SingleCharacter in 'MOVE LEFT:':
        character_y_pos = (1 * (empty_space / 10)) + (0 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['MOVE_LEFT']) != str(current_hotkeys['MOVE_LEFT']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[0]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['MOVE_LEFT'] = index_character_pair[0]
      #
      character_spacing_x = 0
      for SingleCharacter in 'MOVE RIGHT:':
        character_y_pos = (2 * (empty_space / 10)) + (1 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['MOVE_RIGHT']) != str(current_hotkeys['MOVE_RIGHT']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[1]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['MOVE_RIGHT'] = index_character_pair[0]
      #
      character_spacing_x = 0
      for SingleCharacter in 'FLOAT UP:':
        character_y_pos = (3 * (empty_space / 10)) + (2 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['FLOAT_UP']) != str(current_hotkeys['FLOAT_UP']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[2]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['FLOAT_UP'] = index_character_pair[0]
      #
      character_spacing_x = 0
      for SingleCharacter in 'SINK DOWN:':
        character_y_pos = (4 * (empty_space / 10)) + (3 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['SINK_DOWN']) != str(current_hotkeys['SINK_DOWN']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[3]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['SINK_DOWN'] = index_character_pair[0]
      #
      character_spacing_x = 0
      for SingleCharacter in 'INTERACT:':
        character_y_pos = (5 * (empty_space / 10)) + (4 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['INTERACT']) != str(current_hotkeys['INTERACT']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[4]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['INTERACT'] = index_character_pair[0]
      #
      character_spacing_x = 0
      for SingleCharacter in 'EXTEND WATER JET:':
        character_y_pos = (6 * (empty_space / 10)) + (5 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['EXTEND_WATER_JET']) != str(current_hotkeys['EXTEND_WATER_JET']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[5]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['EXTEND_WATER_JET'] = index_character_pair[0]
      #
      character_spacing_x = 0
      for SingleCharacter in 'EXTEND GRAPPLING HOOK:':
        character_y_pos = (7 * (empty_space / 10)) + (6 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['EXTEND_GRAPPLING_HOOK']) != str(current_hotkeys['EXTEND_GRAPPLING_HOOK']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[6]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['EXTEND_GRAPPLING_HOOK'] = index_character_pair[0]
      #
      character_spacing_x = 0
      for SingleCharacter in 'DETACH GRAPPLING HOOK:':
        character_y_pos = (8 * (empty_space / 10)) + (7 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['DETACH_GRAPPLING_HOOK']) != str(current_hotkeys['DETACH_GRAPPLING_HOOK']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[7]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['DETACH_GRAPPLING_HOOK'] = index_character_pair[0]
      #
      character_spacing_x = 0
      for SingleCharacter in 'PAUSE:':
        character_y_pos = (9 * (empty_space / 10)) + (8 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['PAUSE']) != str(current_hotkeys['PAUSE']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[8]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['PAUSE'] = index_character_pair[0]
    #
    if show_select_new_key_message:
      make_opengl_rect(OpenGLTextures['SELECT_NEW_KEY'][0], OpenGLTextures['SELECT_NEW_KEY'][1], (Mouse_x - (0.5 * OpenGLTextures['SELECT_NEW_KEY'][0][0]), Mouse_y - (OpenGLTextures['SELECT_NEW_KEY'][0][1]) - 10), 0, False, (0, 0, OpenGLTextures['SELECT_NEW_KEY'][0][0], OpenGLTextures['SELECT_NEW_KEY'][0][1]))
    #
    #
    #
    cur_mouse_x, cur_mouse_y = Mouse_x - (OpenGLTextures['ACTUAL_MOUSE'][0][0]/2), Mouse_y - (OpenGLTextures['ACTUAL_MOUSE'][0][1]/2)
    make_opengl_rect(OpenGLTextures['ACTUAL_MOUSE'][0], OpenGLTextures['ACTUAL_MOUSE'][1], (cur_mouse_x, cur_mouse_y), 0, False, (0, 0, OpenGLTextures['ACTUAL_MOUSE'][0][0], OpenGLTextures['ACTUAL_MOUSE'][0][1]))
    glFlush()
    pygame.display.flip()
    #
    clock.tick(60)
    pause_curr_time = pygame.time.get_ticks()
    pause_fps = (1 / (pause_curr_time - pause_prev_time))*1000
    pause_delta_milliseconds = pause_curr_time - pause_prev_time
    time_since_saving_hotkeys += pause_delta_milliseconds
    pause_prev_time = pause_curr_time
    pause_menu_timer += pause_delta_milliseconds
  if changing_region_for_TheDoor6:
    if MAP.region == 'TheDoor6':
      My_cached_info.load_from_previous_location = True


def loadingLoop(new_region):
  start_loading_time = pygame.time.get_ticks()
  specific_area = new_region
  for _ in range(1):
    if specific_area == 'Forest' or specific_area == 'TheDoor1' or specific_area == 'TheDoor2' or specific_area == 'TheDoor3' or specific_area == 'TheDoor4' or specific_area == 'TheDoor5':
      current_region = 'LOADING_FOREST_BG'
      continue
    elif specific_area == 'AntHill' or specific_area == 'TheDoor6' or specific_area == 'TheDoor7' or specific_area == 'TheDoor8' or specific_area == 'TheDoor9':
      current_region = 'LOADING_ANTHILL_BG'
      continue
    elif specific_area == 'Sewer' or specific_area == 'TheDoor10' or specific_area == 'TheDoor11' or specific_area == 'TheDoor12':
      current_region = 'LOADING_SEWER_BG_MIDDLE'
      continue
    elif specific_area == 'Town' or specific_area == 'TheDoor13':
      current_region = 'LOADING_FOREST_BG'
      continue
    else:
      current_region = 'LOADING_FOREST_BG'
      continue
  #
  for _ in range(1):
    if current_region == 'LOADING_FOREST_BG':
      current_animal = random.choice(['HAMSTER_WALKING_RIGHT', 'SQUIRREL', 'HAWK', 'Forest_BGDEER'])
      continue
    elif current_region == 'LOADING_ANTHILL_BG':
      current_animal = random.choice(['HAMSTER_WALKING_RIGHT', 'ANT1', 'ANT2', 'QUEEN_ANT', 'BEETLE_WALK_RIGHT'])
      continue
    elif current_region == 'LOADING_SEWER_BG_MIDDLE':
      current_animal = random.choice(['HAMSTER_WALKING_RIGHT', 'SURFING_RAT_STANDING', 'EATING_RAT_STANDING', 'GOLDFISH'])
      continue
    elif current_region == 'Town':
      current_animal = random.choice(['HAMSTER_WALKING_RIGHT'])
      continue
    else:
      current_animal = 'HAMSTER_WALKING_RIGHT'
  #
  if current_region != 'LOADING_SEWER_BG_MIDDLE':
    BG_img_top = OpenGLTextures[current_region + '_TOP']
    BG_img = OpenGLTextures[current_region]
    BG_img_bottom = OpenGLTextures[current_region + '_BOTTOM']
  if current_region == 'LOADING_SEWER_BG_MIDDLE':
    if current_animal != 'GOLDFISH':
      BG_img_top = OpenGLTextures['LOADING_SEWER_BG_TOPBOTTOM']
      BG_img = OpenGLTextures['LOADING_SEWER_BG_MIDDLE']
      BG_img_bottom = OpenGLTextures['LOADING_SEWER_BG_TOPBOTTOM']
    if current_animal == 'GOLDFISH':
      BG_img_top = OpenGLTextures['LOADING_SEWER_BG_TOPBOTTOM']
      BG_img = OpenGLTextures['LOADING_SEWER_BG_WATER_MIDDLE']
      BG_img_bottom = OpenGLTextures['LOADING_SEWER_BG_TOPBOTTOM']
  animal_images = OpenGLTextures[current_animal]
  animal_image_index = 0
  current_animal_image = animal_images[animal_image_index]
  added_y_pos = 0
  image_rotation = 0
  loading_screen_scrolling_speed = 1
  milliseconds_to_update_image = 150
  if current_animal == 'HAMSTER_WALKING_RIGHT':
    added_y_pos = 0
    image_rotation = 347
  if current_animal == 'SQUIRREL':
    added_y_pos = 4
    image_rotation = 287
    milliseconds_to_update_image = 100
  if current_animal == 'HAWK':
    added_y_pos = -150
    animal_images = [animal_images[2], animal_images[3]]
    current_animal_image = animal_images[animal_image_index]
  if current_animal == 'Forest_BGDEER':
    added_y_pos = 0
  if current_animal == 'ANT1' or current_animal == 'ANT2':
    added_y_pos = -120
  if current_animal == 'QUEEN_ANT':
    added_y_pos = 15
    loading_screen_scrolling_speed = 0
  if current_animal == 'BEETLE_WALK_RIGHT':
    added_y_pos = -5
    image_rotation = 6
  if current_animal == 'SURFING_RAT_STANDING':
    loading_screen_scrolling_speed = 0
  if current_animal == 'EATING_RAT_STANDING':
    loading_screen_scrolling_speed = 0
  if current_animal == 'GOLDFISH':
    added_y_pos = 150
    pass
  #
  iterations = 0
  current_BG_offset = 0
  height_on_each_side = ((screen_height - BG_img[0][1])/2)
  number_high = round((height_on_each_side // BG_img[0][1]) + 1)
  loading_time = pygame.time.get_ticks()
  time_since_update_image = loading_time
  if current_region == 'LOADING_ANTHILL_BG' or current_region == 'LOADING_SEWER_BG_MIDDLE':
    loading_texts = OpenGLTextures['LOADING_TEXT']
  if current_region == 'LOADING_FOREST_BG':
    loading_texts = OpenGLTextures['LOADING_TEXT_PINK']
  current_loading_text_index = 0
  current_milliseconds_before_next_loading_text_image = 0
  milliseconds_needed_before_loading_next_text_image = 400
  while My_cached_info.on_a_loading_screen:
    for event in pygame.event.get():
      if event.type == pygame.QUIT:
        everything_save_data(True, 83, str(My_cached_info.play_time))
        raise SystemExit
    Mouse_x, Mouse_y = pygame.mouse.get_pos()
    glClear(GL_COLOR_BUFFER_BIT)
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
    #
    middle = current_BG_offset
    middle_index = 0
    while middle < screen_width:
      for i in range(number_high):
        make_opengl_rect(BG_img_top[0], BG_img_top[1], (middle, height_on_each_side - (BG_img_top[0][1] * (i+1))), 0, False, (0, 0, BG_img_top[0][0], BG_img_top[0][1]))
        make_opengl_rect(BG_img_bottom[0], BG_img_bottom[1], (middle, height_on_each_side + (BG_img_bottom[0][1] * (i+1))), 0, False, (0, 0, BG_img_bottom[0][0], BG_img_bottom[0][1]))
      make_opengl_rect(BG_img[0], BG_img[1], (middle, height_on_each_side), 0, False, (0, 0, BG_img[0][0], BG_img[0][1]))
      middle += BG_img[0][1]
      middle_index += 1
    #
    make_opengl_rect(loading_texts[current_loading_text_index][0], loading_texts[current_loading_text_index][1], (loading_texts[current_loading_text_index][0][1], screen_height - (2*loading_texts[current_loading_text_index][0][1])), 0, False, (0, 0, loading_texts[current_loading_text_index][0][0], loading_texts[current_loading_text_index][0][1]))
    make_opengl_rect(current_animal_image[0], current_animal_image[1], ((screen_width/2) - (current_animal_image[0][0] / 2), ((screen_height/2) + 100) - (current_animal_image[0][1]) + added_y_pos), image_rotation, False, (0, 0, current_animal_image[0][0], current_animal_image[0][1]))
    if My_cached_info.show_play_time:
      draw_play_timer()
    make_opengl_rect(OpenGLTextures['ACTUAL_MOUSE'][0], OpenGLTextures['ACTUAL_MOUSE'][1], (Mouse_x - (OpenGLTextures['ACTUAL_MOUSE'][0][0]/2), Mouse_y - (OpenGLTextures['ACTUAL_MOUSE'][0][1]/2)), 0, False, (0, 0, OpenGLTextures['ACTUAL_MOUSE'][0][0], OpenGLTextures['ACTUAL_MOUSE'][0][1]))
    glFlush()
    pygame.display.flip()
    iterations += 1
    last_loading_time = loading_time
    loading_time = pygame.time.get_ticks()
    difference_in_loading_times = (loading_time - last_loading_time) / 10
    time_since_update_image += (loading_time - last_loading_time)
    current_milliseconds_before_next_loading_text_image += (loading_time - last_loading_time)
    if current_milliseconds_before_next_loading_text_image >= milliseconds_needed_before_loading_next_text_image:
      current_milliseconds_before_next_loading_text_image %= milliseconds_needed_before_loading_next_text_image
      current_loading_text_index += 1
      current_loading_text_index %= len(loading_texts)
    if time_since_update_image >= milliseconds_to_update_image:
      time_since_update_image %= milliseconds_to_update_image
      animal_image_index += 1
      animal_image_index %= len(animal_images)
      current_animal_image = animal_images[animal_image_index]
    current_BG_offset -= loading_screen_scrolling_speed * difference_in_loading_times
    current_BG_offset %= BG_img[0][1]
    current_BG_offset -= BG_img[0][1]
  My_cached_info.loading_time = pygame.time.get_ticks() - start_loading_time
  return


def GameLoop():
  global Screen, fps, curr_time, target_delta_milliseconds, delta_milliseconds, frame_counter, PRETTY_MAP, MAP, BACKGROUND, PLAYER, GRASSES, BUBBLES, keys, Mouse_x, Mouse_y, WATER_REGIONS, WATER_SURFACES, WATER_COVERS, IRREGULARLY_SHAPED_WATER, SEWER_PUMP_WATER, LEAKS, GRATES, GOLDFISH, TRANSPORT_PIPES, SURF_BOARDS, SURFING_RAT, EATING_RAT, SURFING_CLOCK, SURFING_PROGRESS_BAR, NUMBERS_ABOVE_HAMSTER, WAVES, BUCKETS, FOOD, GARBAGE_CAN, THE_MACHINE, TOOLS, HAMSTER_BOX, HUMAN, HAMSTER_PELLET, SUB_LEVEL_DIFFICULTIES, TRASH, SewerPumpWaterDroplets, SPINNY_OBJECTS, MY_VINES, CLOUDS, TEETERTOTTERS, ALLKEYS, DOORS, DOORS_WITH_KNOB, ANTS, PLAYER_MOVER_ANTS, SQUIRRELS, BOUNCIES, MOVING_BOUNCIES, ELEVATORS, LEAVES, ROOTS, DRIPDROPS, UPGRADES, TV, PROPELLERS, LEVERS, Hawk, QueenAnt, BEETLE_FRIEND, collisions_with_ball, collision_happened, collisions_with_bottom_ball, collison_with_bottom_ball_happened,  collisions_with_top_ball, collison_with_top_ball_happened, collisions_with_left_ball, collison_with_left_ball_happened, collisions_with_right_ball, collison_with_right_ball_happened, collisions_with_bottom_ball_inner, collison_with_bottom_ball_inner_happened, collisions_with_top_ball_inner, collison_with_top_ball_inner_happened, collisions_with_left_ball_inner, collison_with_left_ball_inner_happened, collisions_with_right_ball, collison_with_right_ball_happened, prev_time, avg_impact_x, avg_impact_y, avg_impact_angle, normal_force_angle, current_motion, cur_VFx, cur_VFy, leaving_a_wall, KEy, left_click, weird_click, right_click, cur_col_grapple_points, cur_col_grapple_happened, STANDING_ON_CLOUD, STANDING_ON_WHICH_CLOUD, STANDING_ON_TEETERTOTTER, STANDING_ON_WHICH_TEETERTOTTER, KEY_GRABBED_BY_PLAYER, BOX_GRABBED_BY_PLAYER, GRAPPLED_TO_PLATFORM, SUPER_BOUNCY, PREVIOUS_PUSH_PISTON, RELEASED_GRAPPLE_LAST_FRAME, ON_AN_ELEVATOR, ON_A_GARBAGE_CAN, ON_A_BUCKET, ON_THE_MACHINE, IN_A_BUCKET, ON_A_BUCKET_LAST_FRAME, CANT_REENTER_PIPE, TIME_SINCE_EXITING_PIPE, PLAY_UPGRADE_CUTSCENE, PLAY_UPGRADE_CUTSCENE_start_frame, PLAY_UPGRADE_CUTSCENE_end_frame, TOUCHED_ROOT, DRAWING_FUNCTIONS
  curr_time = pygame.time.get_ticks()
  target_delta_milliseconds = 13
  delta_milliseconds = target_delta_milliseconds
  My_cached_info.on_a_loading_screen = True
  threading.Thread(target=change_region, args = [('', '', 'MAP12', 0, False)]).start()
  loadingLoop('')
  MAP.GPU_image = ((MAP.GPU_image[0][0], MAP.GPU_image[0][1]), loadTexture_only_OpenGL_stuff(MAP.GPU_image[0][0], MAP.GPU_image[0][1], MAP.GPU_image[1]))
  PRETTY_MAP.GPU_image = ((PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1]), loadTexture_only_OpenGL_stuff(PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1], PRETTY_MAP.GPU_image[1]))
  get_drawing_functions()
  glDeleteTextures(My_cached_info.number_of_textures_to_delete, np.array(My_cached_info.texture_IDs_to_delete))
  My_cached_info.number_of_textures_to_delete += 2
  My_cached_info.texture_IDs_to_delete.append(MAP.GPU_image[1])
  My_cached_info.texture_IDs_to_delete.append(PRETTY_MAP.GPU_image[1])
  find_all_possible_ball_collisions(PLAYER, my_AllBall)
  cur_col_grapple_points, cur_col_grapple_happened = [], False
  SewerPumpWaterDroplets = []
  BUBBLES = []
  STANDING_ON_CLOUD = False
  STANDING_ON_WHICH_CLOUD = 666
  STANDING_ON_TEETERTOTTER = False
  KEY_GRABBED_BY_PLAYER = False
  BOX_GRABBED_BY_PLAYER = False
  reduce_KEy = False
  GRAPPLED_TO_PLATFORM = False
  SUPER_BOUNCY = False
  PREVIOUS_PUSH_PISTON = ['Nothing' for x in range(20)]
  RELEASED_GRAPPLE_LAST_FRAME = False
  ON_AN_ELEVATOR = False
  ON_A_GARBAGE_CAN = False
  ON_A_BUCKET = False
  ON_THE_MACHINE = False
  IN_A_BUCKET = False
  CANT_REENTER_PIPE = False
  TIME_SINCE_EXITING_PIPE = 0
  TOUCHED_ROOT = False
  PLAY_UPGRADE_CUTSCENE = False
  PLAY_UPGRADE_CUTSCENE_start_frame = 0
  PLAY_UPGRADE_CUTSCENE_end_frame = 0
  prev_time = pygame.time.get_ticks() - delta_milliseconds
  fps = (1 / 13)*1000
  #pygame.display.toggle_fullscreen()
  global clock
  clock = pygame.time.Clock()
  while running:
###
    for event in pygame.event.get():
      if event.type == pygame.QUIT:
        if My_cached_info.play_intro_sequence:
          My_cached_info.play_time = 0
        everything_save_data(True, 83, str(My_cached_info.play_time))
        raise SystemExit
###
    frame_counter += 1
    if PLAY_UPGRADE_CUTSCENE:
      if frame_counter > PLAY_UPGRADE_CUTSCENE_end_frame:
        PLAY_UPGRADE_CUTSCENE_start_frame = frame_counter
        PLAY_UPGRADE_CUTSCENE_end_frame = frame_counter + 270
      if frame_counter == PLAY_UPGRADE_CUTSCENE_end_frame:
        PLAY_UPGRADE_CUTSCENE = False
###
    keys = pygame.key.get_pressed()
    Mouse_x, Mouse_y = pygame.mouse.get_pos()
    left_click, weird_click, right_click = pygame.mouse.get_pressed()
    update_pressed_controls()
###
    #if keys[pygame.K_c]:
    #  PLAYER.movement_Fy -= 600
###
###
### force from gravity
    KEy = Kinetic_energy()
    gravity()
###
###
### force from movement
    if not STANDING_ON_TEETERTOTTER:
      #collisions_with_ball, collision_happened = find_collisions(MAP, PLAYER)
      collisions_with_ball, collision_happened = find_ball_collisions_exhaustive(MAP, PLAYER)
      if collision_happened:
        if PLAYER.y_vel < 0:
          collisions_with_ball = list(set(collisions_with_ball))
          absolute_collision_points = [(i+PLAYER.x_pos, j+PLAYER.y_pos) for [i, j] in collisions_with_ball]
          pixel_colors = check_pixels_for_color_exhaustive(absolute_collision_points, (255, 255, 0, 255))
          non_yellow_points = list(set(absolute_collision_points) - set(pixel_colors))
          if non_yellow_points == []:
            collisions_with_ball = []
            collision_happened = False
          if non_yellow_points != []:
            collisions_with_ball = [(i - PLAYER.x_pos, j - PLAYER.y_pos) for (i, j) in non_yellow_points]
      #
        if PLAYER.y_vel >= 0:
          collisions_with_ball = list(set(collisions_with_ball))
          absolute_collision_points = [(i+PLAYER.x_pos, j+PLAYER.y_pos) for [i, j] in collisions_with_ball]
          pixel_colors = check_pixels_for_color_exhaustive(absolute_collision_points, (255, 255, 0, 255))
          if pixel_colors != []:
            if abs(PLAYER.y_vel) < 50:
              reduce_KEy = True
            relative_yellow_points = [(int(i - PLAYER.x_pos), int(j - PLAYER.y_pos)) for (i, j) in pixel_colors]
            ylist = [j for [i,j] in relative_yellow_points]
            max_ylist = max(ylist)
            if max_ylist < 65:
              non_yellow_points = list(set(absolute_collision_points) - set(pixel_colors))
              collisions_with_ball = [(i - PLAYER.x_pos, j - PLAYER.y_pos) for (i, j) in non_yellow_points]
              if collisions_with_ball == []:
                collision_happened = False
            if max_ylist >= 65 and max_ylist != 68:
              PLAYER.y_pos += max_ylist - 68
      #
      if collision_happened:
        collisions_with_bottom_ball, collison_with_bottom_ball_happened = find_collisions(MAP, my_bottom_ball)
        collisions_with_top_ball, collison_with_top_ball_happened = find_collisions(MAP, my_top_ball)
        collisions_with_left_ball, collison_with_left_ball_happened = find_collisions(MAP, my_left_ball)
        collisions_with_right_ball, collison_with_right_ball_happened = find_collisions(MAP, my_right_ball)
        if PLAYER.x_vel > 0 and not Currently_pressed_controls.pressed_controls['MOVE_RIGHT'] and collison_with_bottom_ball_happened and not collison_with_right_ball_happened:
          PLAYER.Hamster_activities_during_frame.append('Walk_Right')
        if PLAYER.x_vel < 0 and not Currently_pressed_controls.pressed_controls['MOVE_LEFT'] and collison_with_bottom_ball_happened and not collison_with_left_ball_happened:
          PLAYER.Hamster_activities_during_frame.append('Walk_Left')
        if Currently_pressed_controls.pressed_controls['MOVE_LEFT'] and collison_with_bottom_ball_happened and not collison_with_left_ball_happened:
          PLAYER.Hamster_activities_during_frame.append('Walk_Left')
          PLAYER.movement_Fx -= 300
        if Currently_pressed_controls.pressed_controls['MOVE_RIGHT'] and collison_with_bottom_ball_happened and not collison_with_right_ball_happened:
          PLAYER.Hamster_activities_during_frame.append('Walk_Right')
          PLAYER.movement_Fx += 300
        collisions_with_bottom_ball_inner, collison_with_bottom_ball_inner_happened = find_collisions(MAP, my_bottom_ball_inner)
        if collison_with_bottom_ball_inner_happened:
          PLAYER.y_pos -= 1
        collisions_with_top_ball_inner, collison_with_top_ball_inner_happened = find_collisions(MAP, my_top_ball_inner)
        if collison_with_top_ball_inner_happened:
          PLAYER.y_pos += 1
        collisions_with_left_ball_inner, collison_with_left_ball_inner_happened = find_collisions(MAP, my_left_ball_inner)
        if collison_with_left_ball_inner_happened:
          PLAYER.x_pos += 1
        collisions_with_right_ball_inner, collison_with_right_ball_inner_happened = find_collisions(MAP, my_right_ball_inner)
        if collison_with_right_ball_inner_happened:
          PLAYER.x_pos -= 1
        if ON_AN_ELEVATOR:
          if Currently_pressed_controls.pressed_controls['MOVE_RIGHT']:
            PLAYER.Hamster_activities_during_frame.append('Walk_Right')
            PLAYER.x_pos += 2
          if Currently_pressed_controls.pressed_controls['MOVE_LEFT']:
            PLAYER.Hamster_activities_during_frame.append('Walk_Left')
            PLAYER.x_pos -= 2
###
###
###
###
### force from piston
    if Currently_pressed_controls.pressed_controls['DETACH_GRAPPLING_HOOK'] and not PLAYER.in_a_pipe:
      if not RELEASED_GRAPPLE_LAST_FRAME:
        for i in range(len(MY_VINES)):
          if MY_VINES[i].is_the_player_swinging:
            if Marker.x_pos != 0:
              PLAYER.x_vel += ((Marker.x_pos - Marker.prev_x_pos) / (1 / fps)) * 3
              PLAYER.y_vel += ((Marker.y_pos - Marker.prev_y_pos) / (1 / fps)) * 1.8
          MY_VINES[i].is_the_player_swinging = False
        my_piston2.connected_to_map = False
        my_piston2.connected_to_vine = False
        KEY_GRABBED_BY_PLAYER = False
        if BOX_GRABBED_BY_PLAYER:
          HAMSTER_BOX[0].current_milliseconds_before_picking_up_again = HAMSTER_BOX[0].milliseconds_before_picking_up_again
        if HUMAN != []:
          if HUMAN[0].following_hamster:
            HUMAN[0].moving_toward_HamsterOs = True
            HUMAN[0].following_hamster = False
        BOX_GRABBED_BY_PLAYER = False
        for ACloud in CLOUDS:
          ACloud.connected_to_cloud = False
          ACloud.is_the_player_swinging = False
        for SingleKey in ALLKEYS:
          if SingleKey.key_type == 3:
            if SingleKey.is_grabbed_by_player:
              SingleKey.key_type = 1
          SingleKey.is_grabbed_by_player = False
          SingleKey.cooldown_before_grabbing_again = 8
          if SingleKey.key_type == 2:
            SingleKey.rotation = find_relative_key_rotation(SingleKey)%360
        for SingleSquirrel in SQUIRRELS:
          if SingleSquirrel.player_grappled_to_squirrel:
            PLAYER.x_vel += ((Marker.x_pos - Marker.prev_x_pos) / (1 / fps)) * 3
            PLAYER.y_vel += ((Marker.y_pos - Marker.prev_y_pos) / (1 / fps)) * 1.8
            SingleSquirrel.player_grappled_to_squirrel = False
        for SingleLeaf in LEAVES:
          SingleLeaf.player_grappled_to_leaf = False
        for SingleRoot in ROOTS:
          SingleRoot.grapple_connected = False
        GRAPPLED_TO_PLATFORM = False
        my_piston2.connected_to_lever = False
        if PLAYER.on_a_surf_board:
          if SURF_BOARDS[PLAYER.on_which_surf_board].currently_flipping_image:
            PLAYER.x_vel = 100 + SURF_BOARDS[PLAYER.on_which_surf_board].x_vel
            PLAYER.y_vel = -200 + SURF_BOARDS[PLAYER.on_which_surf_board].y_vel
          if not SURF_BOARDS[PLAYER.on_which_surf_board].currently_flipping_image:
            PLAYER.x_vel = -100 + SURF_BOARDS[PLAYER.on_which_surf_board].x_vel
            PLAYER.y_vel = -200 + SURF_BOARDS[PLAYER.on_which_surf_board].y_vel
          if PLAYER.surfing_check_points:
            PLAYER.time_since_leaving_board += delta_milliseconds
          PLAYER.allow_catch_the_board_points = True
        PLAYER.not_yet_on_the_board = False
        PLAYER.on_a_surf_board = False
        PLAYER.connected_to_door_with_knob = False
        PLAYER.connected_to_which_door_with_knob = 666
        my_piston2.connected_to_which_lever = 666
        PLAYER.carrying_food = False
        PLAYER.carrying_which_food = 666
        for SingleFood in FOOD:
          SingleFood.being_carried = False
          SingleFood.current_milliseconds_before_being_allowed_to_hold_food_again = 400
        Marker.x_pos, Marker.y_pos, Marker.prev_x_pos, Marker.prev_y_pos, my_piston2.grapple_claw_x_pos, my_piston2.grapple_claw_y_pos = 0, 0, 0, 0, 0, 0
        regular_piston_sheath_update()
        regular_update_GrapplePiston(my_piston2)
        RELEASED_GRAPPLE_LAST_FRAME = True
    else:
      RELEASED_GRAPPLE_LAST_FRAME = False
    my_piston1.x_pos, my_piston1.y_pos = PLAYER.x_pos - 241, PLAYER.y_pos - 241
    my_piston2.x_pos, my_piston2.y_pos = PLAYER.x_pos - 241, PLAYER.y_pos - 241
###
    if PLAYER.piston1_type == 'BLANK' and PLAYER.piston2_type == 'BLANK' or my_piston1.extension == 0 and my_piston2.extension == 0:
      regular_piston_sheath_update()
###
    if PLAYER.piston1_type != 'BLANK' and PLAYER.piston2_type != 'BLANK':
###
      if not Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET'] and my_piston2.extension == 0 and my_piston1.extension > 0: # retract my_piston1
        my_piston1.extension_float -= my_piston1.extension_float_added
        regular_piston_sheath_update()
        regular_update_PushPiston(my_piston1)
###
      if not Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK'] and my_piston1.extension == 0 and my_piston2.extension > 0 and my_piston2.grapple_claw_x_pos == 0 and my_piston2.grapple_claw_y_pos == 0: # retract my_piston2
        my_piston2.extension_float -= my_piston2.extension_float_added
        regular_piston_sheath_update()
        if my_piston2.extension > my_piston2.maximum_extension:
          my_piston2.extension = my_piston2.maximum_extension
        if my_piston2.extension < 0:
          my_piston2.extension = 0
        regular_update_GrapplePiston(my_piston2)
        if not My_cached_info.play_retract_grapple:
          MixerSounds['RETRACT'].play(-1)
          My_cached_info.play_retract_grapple = True
          MixerSounds['EXTEND'].stop()
          My_cached_info.playing_extend_grapple = False
###
      for _ in range(1):
        if Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET'] and my_piston2.extension == 0 and my_piston2.grapple_claw_x_pos == 0 and PLAYER.has_piston1: # piston1 is active
          PREVIOUS_PUSH_PISTON = do_everything_push_piston(my_piston1, PREVIOUS_PUSH_PISTON)
        else:
          if My_cached_info.playing_quiet_water_jet:
            My_cached_info.playing_quiet_water_jet = False
            MixerSounds['QUIET_WATER_JET'].fadeout(500)
###
      for _ in range(1):
        if (Currently_pressed_controls.pressed_controls['EXTEND_GRAPPLING_HOOK'] and my_piston1.extension == 0 or my_piston2.grapple_claw_x_pos != 0 or my_piston2.grapple_claw_y_pos != 0) and PLAYER.has_piston2: # piston2 is active
          starting_hook_length = my_piston2.extension
          cur_col_grapple_points, cur_col_grapple_happened = do_everything_grapple_piston(my_piston2)
          ending_hook_length = my_piston2.extension
          if starting_hook_length + (0.5 * my_piston2.extension_float_added) < ending_hook_length:
            if my_piston2.grapple_claw_x_pos == 0 and my_piston2.grapple_claw_y_pos == 0:
              My_cached_info.play_retract_grapple = False
              MixerSounds['RETRACT'].stop()
            if My_cached_info.playing_extend_grapple:
              continue
            else:
              MixerSounds['EXTEND'].play(-1)
              My_cached_info.playing_extend_grapple = True
              continue
          elif starting_hook_length > ending_hook_length:
            My_cached_info.playing_extend_grapple = False
            MixerSounds['EXTEND'].stop()
            if not My_cached_info.play_retract_grapple:
              MixerSounds['RETRACT'].play(-1)
              My_cached_info.play_retract_grapple = True
            continue
          elif (my_piston2.last_five_extensions[0] == my_piston2.last_five_extensions[1] == my_piston2.last_five_extensions[2] == my_piston2.last_five_extensions[3] == my_piston2.last_five_extensions[4]):
            MixerSounds['EXTEND'].stop()
            MixerSounds['RETRACT'].stop()
            My_cached_info.playing_extend_grapple = False
            My_cached_info.play_retract_grapple = False
            continue
          else:
            My_cached_info.playing_extend_grapple = False
            MixerSounds['EXTEND'].stop()
###
###
    for i in range(len(TEETERTOTTERS)):
      update_teetertotter(TEETERTOTTERS[i])
###
###
### force from water
    if WATER_REGIONS != []:
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for i in range(len(WATER_REGIONS)):
        if not PLAYER.skip_the_rest_of_the_water:
          if len(WATER_REGIONS[i]) == 6:
            find_water_force(WATER_REGIONS[i][0], WATER_REGIONS[i][1], WATER_REGIONS[i][2], WATER_REGIONS[i][3], WATER_REGIONS[i][4], WATER_REGIONS[i][5], False)
          else:
            find_water_force(WATER_REGIONS[i][0], WATER_REGIONS[i][1], WATER_REGIONS[i][2], WATER_REGIONS[i][3], WATER_REGIONS[i][4], WATER_REGIONS[i][5], True)
    #
    if MAP.region == 'TheDoor11':
      #
      if (PLAYER.x_pos <= 8317):
        distance_from_big_water_x = abs(PLAYER.x_pos - 8317)
      if (8317 <= PLAYER.x_pos <= 9918):
        distance_from_big_water_x = 0
      if (9918 <= PLAYER.x_pos):
        distance_from_big_water_x = abs(PLAYER.x_pos - 9918)
      if (PLAYER.y_pos <= 1923):
        distance_from_big_water_y = abs(PLAYER.y_pos - 1923)
      if (1923 <= PLAYER.y_pos <= 5487):
        distance_from_big_water_y = 0
      if (5487 <= PLAYER.y_pos):
        distance_from_big_water_y = abs(PLAYER.y_pos - 5487)
      closest_irregularly_shaped_water = find_hypotnuse(distance_from_big_water_x, distance_from_big_water_y)
      if closest_irregularly_shaped_water < 1200:
        irregularly_shaped_water_loudness = My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER'] * ((1200 - closest_irregularly_shaped_water) / 1200)
        if irregularly_shaped_water_loudness > (My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER']):
          irregularly_shaped_water_loudness = (My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER'])
        if irregularly_shaped_water_loudness < 0:
          irregularly_shaped_water_loudness = 0
        MixerSounds['IRREGULARLY_SHAPED_WATER'].set_volume(irregularly_shaped_water_loudness)
        if not My_cached_info.playing_irregularly_shaped_water_sound:
          MixerSounds['IRREGULARLY_SHAPED_WATER'].play(-1)
          My_cached_info.playing_irregularly_shaped_water_sound = True
      if closest_irregularly_shaped_water >= 1200:
        MixerSounds['IRREGULARLY_SHAPED_WATER'].stop()
        My_cached_info.playing_irregularly_shaped_water_sound = False
      #
      try:
        if (8317 <= PLAYER.x_pos <= 9918) and (1923 <= PLAYER.y_pos <= 5487):
          current_width_index = round((PLAYER.x_pos - Irregular_water.permanent_added_x) // Irregular_water.subimage_width)
          if current_width_index < 0:
            current_width_index = 0
          if current_width_index > 3:
            current_width_index = 3
          current_height_index = round((PLAYER.y_pos - Irregular_water.permanent_added_y) // Irregular_water.subimage_height)
          if current_height_index < 0:
            current_height_index = 0
          if current_height_index > 8:
            current_height_index = 8
          irregular_water_collision_points, irregular_water_collision_happened = find_special_water_collisions_with_offsets_mask(Irregular_water.all_masks[current_height_index][current_width_index], Irregular_water.all_positions[current_height_index][current_width_index][0], Irregular_water.all_positions[current_height_index][current_width_index][1], PLAYER, 0, 0)
          if irregular_water_collision_happened:
            PLAYER.water_Fx += Irregular_water.all_forces[current_height_index][current_width_index][0]
            PLAYER.water_Fy += Irregular_water.all_forces[current_height_index][current_width_index][1]
          if my_piston1.extension > 0:
            if PLAYER.piston_Fx == 0 and PLAYER.piston_Fy == 0:
              irregular_water_collision_points, irregular_water_collision_happened = find_special_water_collisions_with_offsets_mask(Irregular_water.all_masks[current_height_index][current_width_index], Irregular_water.all_positions[current_height_index][current_width_index][0], Irregular_water.all_positions[current_height_index][current_width_index][1], my_piston1, my_piston1.cur_offset_x, my_piston1.cur_offset_y)
              if irregular_water_collision_happened:
                for _ in range(My_cached_info.whole_number_of_frames_this_frame):
                  my_piston1.is_touching_wall.append(True)
                  my_piston1.is_touching_wall = my_piston1.is_touching_wall[1:]
                if my_piston1.extension_float > my_piston1.extension_float_added:
                  my_piston1.extension_float -= my_piston1.extension_float_added
                if my_piston1.extension_float > my_piston1.extension_float_added:
                  my_piston1.extension_float -= my_piston1.extension_float_added
                my_piston1_normal_force_angle = find_normal_force_angle(MAP, PLAYER, my_sheath.rotation%360)
                change_direction_from_push_piston(MAP, PLAYER, my_piston1_normal_force_angle, 1000)
                regular_piston_sheath_update()
                regular_update_PushPiston(my_piston1)
      except:
        Irregular_water = SpecialIrregularlyShapedWater()
    #
    if IRREGULARLY_SHAPED_WATER != []:
      closest_irregularly_shaped_water = 99999
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for SingleIrregularlyShapedWater in IRREGULARLY_SHAPED_WATER:
        if not PLAYER.skip_the_rest_of_the_water:
          distance_between_player_and_water = find_hypotnuse(abs(absolute_center_of_player_x - (SingleIrregularlyShapedWater.x_pos - ((1/2)*screen_width) + (SingleIrregularlyShapedWater.rect[2]/2))), abs(absolute_center_of_player_y - (SingleIrregularlyShapedWater.y_pos - ((1/2)*screen_height) + (SingleIrregularlyShapedWater.rect[3]/2))))
          if distance_between_player_and_water < closest_irregularly_shaped_water:
            closest_irregularly_shaped_water = distance_between_player_and_water
          if distance_between_player_and_water <= (34 + SingleIrregularlyShapedWater.radius + 5):
            water_collision_happened = find_point_collision_with_offsets(SingleIrregularlyShapedWater, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
            if water_collision_happened:
              water_collision_points, water_collision_happened = find_collisions_with_offsets(SingleIrregularlyShapedWater, my_middle_ball, (1/2) * screen_width, (1/2) * screen_height)
              if not water_collision_happened:
                water_collision_points = [(0, 69 - PLAYER.how_submerged)]
              find_irregular_water_force(SingleIrregularlyShapedWater, water_collision_points)
              PLAYER.skip_the_rest_of_the_water = True
            else:
              PLAYER.how_submerged = 0
      if closest_irregularly_shaped_water < 1200:
        irregularly_shaped_water_loudness = My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER'] * ((1200 - closest_irregularly_shaped_water) / 1200)
        if irregularly_shaped_water_loudness > (My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER']):
          irregularly_shaped_water_loudness = (My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER'])
        if irregularly_shaped_water_loudness < 0:
          irregularly_shaped_water_loudness = 0
        MixerSounds['IRREGULARLY_SHAPED_WATER'].set_volume(irregularly_shaped_water_loudness)
        if not My_cached_info.playing_irregularly_shaped_water_sound:
          MixerSounds['IRREGULARLY_SHAPED_WATER'].play(-1)
          My_cached_info.playing_irregularly_shaped_water_sound = True
      if closest_irregularly_shaped_water >= 1200:
        MixerSounds['IRREGULARLY_SHAPED_WATER'].stop()
        My_cached_info.playing_irregularly_shaped_water_sound = False
    #
    if LEAKS != []:
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for SingleLeak in LEAKS:
        distance_between_player_and_leak = find_hypotnuse(abs(absolute_center_of_player_x - (SingleLeak.x_pos - ((1/2)*screen_width) + (SingleLeak.rect[2]/2))), abs(absolute_center_of_player_y - (SingleLeak.y_pos - ((1/2)*screen_height) + (SingleLeak.rect[3]/2))))
        if distance_between_player_and_leak <= ((find_hypotnuse(SingleLeak.rect[2] / 2, SingleLeak.rect[3] / 2)) + 34):
          leak_collision_happened = find_point_collision_with_offsets(SingleLeak, PLAYER, (1/2)*screen_width, (1/2)*screen_height)
          if leak_collision_happened:
            PLAYER.water_Fx += 1300
            if my_piston2.extension_float >= my_piston2.maximum_extension - 2*my_piston2.extension_float_added:
              for i in range(len(MY_VINES)):
                if MY_VINES[i].is_the_player_swinging:
                  if Marker.x_pos != 0:
                    PLAYER.x_vel += ((Marker.x_pos - Marker.prev_x_pos) / (1 / fps)) * 3
                    PLAYER.y_vel += ((Marker.y_pos - Marker.prev_y_pos) / (1 / fps)) * 1.8
                MY_VINES[i].is_the_player_swinging = False
              my_piston2.connected_to_map = False
              my_piston2.connected_to_vine = False
              KEY_GRABBED_BY_PLAYER = False
              for ACloud in CLOUDS:
                ACloud.connected_to_cloud = False
                ACloud.is_the_player_swinging = False
              for SingleKey in ALLKEYS:
                if SingleKey.key_type == 3:
                  if SingleKey.is_grabbed_by_player:
                    SingleKey.key_type = 1
                SingleKey.is_grabbed_by_player = False
                SingleKey.cooldown_before_grabbing_again = 8
                if SingleKey.key_type == 2:
                  SingleKey.rotation = find_relative_key_rotation(SingleKey)%360
              for SingleSquirrel in SQUIRRELS:
                if SingleSquirrel.player_grappled_to_squirrel:
                  PLAYER.x_vel += ((Marker.x_pos - Marker.prev_x_pos) / (1 / fps)) * 3
                  PLAYER.y_vel += ((Marker.y_pos - Marker.prev_y_pos) / (1 / fps)) * 1.8
                  SingleSquirrel.player_grappled_to_squirrel = False
              for SingleLeaf in LEAVES:
                SingleLeaf.player_grappled_to_leaf = False
              for SingleRoot in ROOTS:
                SingleRoot.grapple_connected = False
              GRAPPLED_TO_PLATFORM = False
              Marker.x_pos, Marker.y_pos, Marker.prev_x_pos, Marker.prev_y_pos, my_piston2.grapple_claw_x_pos, my_piston2.grapple_claw_y_pos = 0, 0, 0, 0, 0, 0
              regular_piston_sheath_update()
              regular_update_GrapplePiston(my_piston2)
              RELEASED_GRAPPLE_LAST_FRAME = True
    #
    if SEWER_PUMP_WATER != []:
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for SingleSewerPumpWater in SEWER_PUMP_WATER:
        distance_between_player_and_water = find_hypotnuse(abs(absolute_center_of_player_x - (SingleSewerPumpWater.x_pos - ((1/2)*screen_width) + (SingleSewerPumpWater.current_rect[2]/2))), abs(absolute_center_of_player_y - (SingleSewerPumpWater.y_pos - ((1/2)*screen_height) + (SingleSewerPumpWater.current_rect[3]/2))))
        if distance_between_player_and_water <= ((find_hypotnuse(SingleSewerPumpWater.current_rect[2] / 2, SingleSewerPumpWater.current_rect[3] / 2)) + 34):
          water_collision_happened = find_point_collision_with_offsets(SingleSewerPumpWater, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          if water_collision_happened:
            water_collision_points, water_collision_happened = find_collisions_with_offsets(SingleSewerPumpWater, my_middle_ball, (1/2) * screen_width, (1/2) * screen_height)
            if not water_collision_happened:
              water_collision_points = [(0, 69 - PLAYER.how_submerged)]
            find_SewerPumpWater_force(SingleSewerPumpWater)
            if my_piston2.extension_float >= my_piston2.maximum_extension - my_piston2.extension_float_added:
              for i in range(len(MY_VINES)):
                if MY_VINES[i].is_the_player_swinging:
                  if Marker.x_pos != 0:
                    PLAYER.x_vel += ((Marker.x_pos - Marker.prev_x_pos) / (1 / fps)) * 3
                    PLAYER.y_vel += ((Marker.y_pos - Marker.prev_y_pos) / (1 / fps)) * 1.8
                MY_VINES[i].is_the_player_swinging = False
              my_piston2.connected_to_map = False
              my_piston2.connected_to_vine = False
              KEY_GRABBED_BY_PLAYER = False
              for ACloud in CLOUDS:
                ACloud.connected_to_cloud = False
                ACloud.is_the_player_swinging = False
              for SingleKey in ALLKEYS:
                if SingleKey.key_type == 3:
                  if SingleKey.is_grabbed_by_player:
                    SingleKey.key_type = 1
                SingleKey.is_grabbed_by_player = False
                SingleKey.cooldown_before_grabbing_again = 8
                if SingleKey.key_type == 2:
                  SingleKey.rotation = find_relative_key_rotation(SingleKey)%360
              for SingleSquirrel in SQUIRRELS:
                if SingleSquirrel.player_grappled_to_squirrel:
                  PLAYER.x_vel += ((Marker.x_pos - Marker.prev_x_pos) / (1 / fps)) * 3
                  PLAYER.y_vel += ((Marker.y_pos - Marker.prev_y_pos) / (1 / fps)) * 1.8
                  SingleSquirrel.player_grappled_to_squirrel = False
              for SingleLeaf in LEAVES:
                SingleLeaf.player_grappled_to_leaf = False
              for SingleRoot in ROOTS:
                SingleRoot.grapple_connected = False
              GRAPPLED_TO_PLATFORM = False
              Marker.x_pos, Marker.y_pos, Marker.prev_x_pos, Marker.prev_y_pos, my_piston2.grapple_claw_x_pos, my_piston2.grapple_claw_y_pos = 0, 0, 0, 0, 0, 0
              regular_piston_sheath_update()
              regular_update_GrapplePiston(my_piston2)
              RELEASED_GRAPPLE_LAST_FRAME = True
###
###
### force from normal force
    if ROOTS != []:
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for SingleRoot in ROOTS:
        if SingleRoot.is_solid:
          distance_between_player_and_SingleRoot = find_hypotnuse(abs(absolute_center_of_player_x - (SingleRoot.x_pos - ((1/2)*screen_width) + (SingleRoot.rect[2]/2))), abs(absolute_center_of_player_y - (SingleRoot.y_pos - ((1/2)*screen_height) + (SingleRoot.rect[3]/2))))
          if distance_between_player_and_SingleRoot < (34 + SingleRoot.radius):
            SingleRoot_col_points, SingleRoot_col_happened = find_collisions_with_offsets(SingleRoot, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
            if SingleRoot_col_happened:
              TOUCHED_ROOT = True
              if not SingleRoot.damaged_this_frame:
                SingleRoot.accumulated_damage += 2 * My_cached_info.target_fps_over_fps
              SingleRoot.damaged_this_frame = True
              SingleRoot.currently_falling = True
              if (SingleRoot.time_of_contact + SingleRoot.time_to_finish_regrowth) < My_cached_info.fake_frame_counter:
                SingleRoot.time_of_contact = My_cached_info.fake_frame_counter
              if not collison_with_bottom_ball_happened:
                collisions_with_bottom_ball, collison_with_bottom_ball_happened = find_collisions_with_offsets(SingleRoot, my_bottom_ball, (1/2) * screen_width, (1/2) * screen_height)
              avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleRoot_col_points)
              avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
              normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
              if collison_with_bottom_ball_happened:
                normal_force_angle = 90
                if PLAYER.x_vel > 0 and not Currently_pressed_controls.pressed_controls['MOVE_RIGHT']:
                  PLAYER.Hamster_activities_during_frame.append('Walk_Right')
                if PLAYER.x_vel < 0 and not Currently_pressed_controls.pressed_controls['MOVE_LEFT']:
                  PLAYER.Hamster_activities_during_frame.append('Walk_Left')
                if Currently_pressed_controls.pressed_controls['MOVE_RIGHT']:
                  PLAYER.Hamster_activities_during_frame.append('Walk_Right')
                  if collison_with_left_ball_happened:
                    PLAYER.movement_Fx += 300
                if Currently_pressed_controls.pressed_controls['MOVE_LEFT']:
                  PLAYER.Hamster_activities_during_frame.append('Walk_Left')
                  if collison_with_right_ball_happened:
                    PLAYER.movement_Fx -= 300
              current_motion = find_motion_angle(MAP, PLAYER)
              cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
#
    if DRIPDROPS != []:
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for SingleDripDrop in DRIPDROPS:
        if SingleDripDrop.stage_in_dripdrop == 1:
          distance_between_player_and_SingleDripDrop = find_hypotnuse(abs(absolute_center_of_player_x - (SingleDripDrop.x_pos - ((1/2)*screen_width) + (SingleDripDrop.rect[2]/2))), abs(absolute_center_of_player_y - (SingleDripDrop.y_pos - ((1/2)*screen_height) + (SingleDripDrop.rect[3]/2))))
          if distance_between_player_and_SingleDripDrop < (34 + SingleDripDrop.radius + 5):
            SingleDripDrop_col_points, SingleDripDrop_col_happened = find_collisions_with_offsets(SingleDripDrop, PLAYER, (1/2)*screen_width, (1/2)*screen_height)
            if SingleDripDrop_col_happened:
              PLAYER.y_vel += SingleDripDrop.vel
              SingleDripDrop.y_pos = PLAYER.y_pos + ((1/2)*screen_height) - 72 + min([y for (x,y) in SingleDripDrop_col_points])
              SingleDripDrop.stage_in_dripdrop = 2
              SingleDripDrop.phantom_dropping = True
              SingleDripDrop.substep = 0
              SingleDripDrop.phantom_y_pos = SingleDripDrop.y_pos
              SingleDripDrop.phantom_vel = SingleDripDrop.vel
#
    if collision_happened:
      avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, collisions_with_ball)
      avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
      normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
      current_motion = find_motion_angle(MAP, PLAYER)
      if reduce_KEy:
        KEy = 0
      cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
    if cur_col_grapple_happened and not GRAPPLED_TO_PLATFORM:
      avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, cur_col_grapple_points)
      avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
      normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
      current_motion = find_motion_angle(MAP, PLAYER)
      cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
#
    if DOORS != []:
      for SingleDoor in DOORS:
        if SingleDoor.door_type == 1 or SingleDoor.door_type == 3:
          SingleDoor_col_points, SingleDoor_col_happened = find_collisions_with_offsets(SingleDoor, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          if SingleDoor_col_happened:
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleDoor_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            collisions_with_left_ball, collison_with_left_ball_happened = find_collisions_with_offsets(SingleDoor, my_left_ball, (1/2) * screen_width, (1/2) * screen_height)
            collisions_with_right_ball, collison_with_right_ball_happened = find_collisions_with_offsets(SingleDoor, my_right_ball, (1/2) * screen_width, (1/2) * screen_height)
            left_in_col_points, left_in_col_happened = find_collisions_with_offsets(SingleDoor, my_left_ball_inner, (1/2) * screen_width, (1/2) * screen_height)
            if left_in_col_happened:
              PLAYER.x_pos += 1
            right_in_col_points, right_in_col_happened = find_collisions_with_offsets(SingleDoor, my_right_ball_inner, (1/2) * screen_width, (1/2) * screen_height)
            if right_in_col_happened:
              PLAYER.x_pos -= 1
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if SingleDoor.door_type == 2:
          if SingleDoor.rotation == 0:
            SingleDoor_col_points, SingleDoor_col_happened = find_collisions_with_offsets(SingleDoor, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
            if SingleDoor_col_happened:
              collison_with_bottom_ball_happened = True
              my_bottom_ball_inner.x_pos, my_bottom_ball_inner.y_pos = PLAYER.x_pos, PLAYER.y_pos
              col_points, collison_with_bottom_ball_inner_happened = find_collisions_with_offsets(SingleDoor, my_bottom_ball_inner, (1/2) * screen_width, (1/2) * screen_height)
              if collison_with_bottom_ball_inner_happened:
                PLAYER.y_pos -= 2
              avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleDoor_col_points)
              avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
              normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
              current_motion = find_motion_angle(MAP, PLAYER)
              cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
              if Currently_pressed_controls.pressed_controls['MOVE_LEFT']:
                PLAYER.Hamster_activities_during_frame.append('Walk_Left')
                if collision_happened:
                  PLAYER.x_pos -= 2
              if Currently_pressed_controls.pressed_controls['MOVE_RIGHT']:
                PLAYER.Hamster_activities_during_frame.append('Walk_Right')
                if collision_happened:
                  PLAYER.x_pos += 2
#
    if SQUIRRELS != []:
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for SingleSquirrel in SQUIRRELS:
        distance_between_player_and_Squirrel = find_hypotnuse(abs(absolute_center_of_player_x - (SingleSquirrel.x_pos - ((1/2)*screen_width) + (SingleSquirrel.rect[2]/2))), abs(absolute_center_of_player_y - (SingleSquirrel.y_pos - ((1/2)*screen_height) + (SingleSquirrel.rect[3]/2))))
        for _ in range(1):
          if 0 <= distance_between_player_and_Squirrel <= 500:
            if SingleSquirrel.currently_playing_sound:
              squirrel_loudness_distance_multiplier = ((500 - distance_between_player_and_Squirrel) / 500)
              if squirrel_loudness_distance_multiplier > 1:
                squirrel_loudness_distance_multiplier = 1
              if squirrel_loudness_distance_multiplier < 0:
                squirrel_loudness_distance_multiplier = 0
              SingleSquirrel.sound_to_play.set_volume(My_cached_info.current_sound_loudness * MixerSoundsLoudness['SQUIRREL_CLIMB'] * squirrel_loudness_distance_multiplier)
              continue
            else:
              SingleSquirrel.currently_playing_sound = True
              SingleSquirrel.sound_to_play.play(-1)
          else:
            SingleSquirrel.currently_playing_sound = False
            SingleSquirrel.sound_to_play.stop()
        if SingleSquirrel.current_cooldown_counter < SingleSquirrel.cooldown_before_moving_again:
          SingleSquirrel.sound_to_play.stop()
          SingleSquirrel.currently_playing_sound = False
        SingleSquirrel_col_points, SingleSquirrel_col_happened = find_collisions_with_offsets(SingleSquirrel, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
        if SingleSquirrel_col_happened:
          avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleSquirrel_col_points)
          avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
          normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
          current_motion = find_motion_angle(MAP, PLAYER)
          cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
#
    if CLOUDS != []:
      My_cached_info.got_boost_milliseconds -= delta_milliseconds
      got_boost = False
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      cur_cloud_index = -1
      for SingleCloud in CLOUDS:
        cur_cloud_index += 1
        update_cloud(SingleCloud)
        added_x_pos = (SingleCloud.x_pos - SingleCloud.prev_x_pos)
        added_y_pos = (SingleCloud.y_pos - SingleCloud.prev_y_pos)
        if not STANDING_ON_CLOUD:
          distance_between_player_and_SingleCloud = find_hypotnuse(abs(absolute_center_of_player_x - (SingleCloud.x_pos - ((1/2)*screen_width) + (SingleCloud.rect[2]/2))), abs(absolute_center_of_player_y - (SingleCloud.y_pos - ((1/2)*screen_height) + (SingleCloud.rect[3]/2))))
          if distance_between_player_and_SingleCloud <= (SingleCloud.radius + 34):
            SingleCloud_collision_points, SingleCloud_collision_happened = find_collisions_with_offsets(SingleCloud, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
            if SingleCloud_collision_happened:
              avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleCloud_collision_points)
              avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
              normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
              current_motion = find_motion_angle(MAP, PLAYER)
              if (60 <= normal_force_angle <= 120):
                highest_ball_point = min([y for (x, y) in SingleCloud_collision_points])
                PLAYER.y_pos -= 68 - highest_ball_point
                collison_with_bottom_ball_happened = True
                normal_force_angle = 90
                KEy = 0
                STANDING_ON_CLOUD = True
                STANDING_ON_WHICH_CLOUD = cur_cloud_index
                if Currently_pressed_controls.pressed_controls['MOVE_RIGHT']:
                  PLAYER.Hamster_activities_during_frame.append('Walk_Right')
                  PLAYER.movement_Fx += 300
                if Currently_pressed_controls.pressed_controls['MOVE_LEFT']:
                  PLAYER.Hamster_activities_during_frame.append('Walk_Left')
                  PLAYER.movement_Fx -= 300
                current_player_speed = find_hypotnuse(PLAYER.x_vel, PLAYER.y_vel)
                cloud_volume_loudness = My_cached_info.current_sound_loudness * MixerSoundsLoudness['CLOUD_LANDING'] * (current_player_speed / 300)
                if cloud_volume_loudness > (My_cached_info.current_sound_loudness * MixerSoundsLoudness['CLOUD_LANDING']):
                  cloud_volume_loudness = My_cached_info.current_sound_loudness * MixerSoundsLoudness['CLOUD_LANDING']
                if cloud_volume_loudness < 0:
                  cloud_volume_loudness = 0
                MixerSounds['CLOUD_LANDING'].set_volume(cloud_volume_loudness)
                MixerSounds['CLOUD_LANDING'].play()
                orig_cloud_x_pos = PLAYER.x_pos - SingleCloud.x_pos
              PLAYER.x_pos += added_x_pos
              PLAYER.y_pos += added_y_pos
              cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
              if STANDING_ON_CLOUD:
                if my_piston2.grapple_claw_x_pos != 0:
                  PLAYER.FNy -= PLAYER.piston_Fy - 400
                PLAYER.x_vel *= 0.5
                PLAYER.y_vel = 0
              continue
        if STANDING_ON_CLOUD and (STANDING_ON_WHICH_CLOUD == cur_cloud_index):
          if not (SingleCloud.x_pos + SingleCloud.fall_off_left <= absolute_center_of_player_x + (0.5 * screen_width) <= SingleCloud.x_pos + SingleCloud.rect[2] - SingleCloud.fall_off_right):
            SingleCloud_collision_points, SingleCloud_collision_happened = find_collisions_with_offsets(SingleCloud, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
            if not SingleCloud_collision_happened:
              if My_cached_info.got_boost_milliseconds <= 0:
                PLAYER.x_vel += (SingleCloud.x_pos - SingleCloud.prev_x_pos) / (1 / fps)
                PLAYER.y_vel += (SingleCloud.y_pos - SingleCloud.prev_y_pos) / (1 / fps)
              STANDING_ON_CLOUD = False
              STANDING_ON_WHICH_CLOUD = 666
              My_cached_info.got_boost_milliseconds = 100
              continue
          PLAYER.x_pos += added_x_pos
          PLAYER.y_pos += added_y_pos
          orig_cloud_x_pos = PLAYER.x_pos - SingleCloud.x_pos
          KEy = 0
          collison_with_bottom_ball_happened = True
          normal_force_angle = 90
          current_motion = find_motion_angle(MAP, PLAYER)
          if Currently_pressed_controls.pressed_controls['MOVE_RIGHT']:
            PLAYER.Hamster_activities_during_frame.append('Walk_Right')
            PLAYER.movement_Fx += 300
          if Currently_pressed_controls.pressed_controls['MOVE_LEFT']:
            PLAYER.Hamster_activities_during_frame.append('Walk_Left')
            PLAYER.movement_Fx -= 300
          cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
          if my_piston2.grapple_claw_x_pos != 0:
            PLAYER.FNy -= PLAYER.piston_Fy - 400
          PLAYER.y_vel = 0
          if PLAYER.FNy == 0:
            PLAYER.FNy = -400
          continue
#
    if SPINNY_OBJECTS != []:
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for SingleSpinny in SPINNY_OBJECTS:
        distance_between_player_and_SingleSpinny = find_hypotnuse(abs(absolute_center_of_player_x - (SingleSpinny.x_pos - ((1/2)*screen_width) + (SingleSpinny.rect[2]/2))), abs(absolute_center_of_player_y - (SingleSpinny.y_pos - ((1/2)*screen_height) + (SingleSpinny.rect[3]/2))))
        if distance_between_player_and_SingleSpinny <= (SingleSpinny.radius + 34):
          SingleSpinny_collision_points, SingleSpinny_collision_happened = find_collisions_with_offsets(SingleSpinny, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          if SingleSpinny_collision_happened:
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleSpinny_collision_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
    #
    if GARBAGE_CAN != []:
      ON_A_GARBAGE_CAN = False
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for SingleGarbageCan in GARBAGE_CAN:
        if SingleGarbageCan.player_is_inside or SingleGarbageCan.player_is_tentatively_inside:
          distance_between_player_and_SingleGarbageCan = find_hypotnuse(abs(absolute_center_of_player_x - (SingleGarbageCan.x_pos - ((1/2)*screen_width) + (SingleGarbageCan.rect[2]/2))), abs(absolute_center_of_player_y - (SingleGarbageCan.y_pos - ((1/2)*screen_height) + (SingleGarbageCan.rect[3]/2))))
          if distance_between_player_and_SingleGarbageCan <= (SingleGarbageCan.radius + 34):
            SingleGarbageCan_collision_points, SingleGarbageCan_collision_happened = find_collisions_with_offsets(SingleGarbageCan, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
            if SingleGarbageCan_collision_happened:
              ON_A_GARBAGE_CAN = True
              left_col_points, left_col_happened = find_collisions_with_offsets(SingleGarbageCan, my_left_ball, (1/2) * screen_width, (1/2) * screen_height)
              if left_col_happened:
                collison_with_left_ball_happened = True
              right_col_points, right_col_happened = find_collisions_with_offsets(SingleGarbageCan, my_right_ball, (1/2) * screen_width, (1/2) * screen_height)
              if right_col_happened:
                collison_with_right_ball_happened = True
              bottom_col_points, bottom_col_happened = find_collisions_with_offsets(SingleGarbageCan, my_bottom_ball, (1/2) * screen_width, (1/2) * screen_height)
              if bottom_col_happened:
                collison_with_bottom_ball_happened = True
              avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleGarbageCan_collision_points)
              avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
              normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
              current_motion = find_motion_angle(MAP, PLAYER)
              cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
              if Currently_pressed_controls.pressed_controls['MOVE_LEFT'] and collison_with_bottom_ball_happened:
                PLAYER.movement_Fx -= 300
              if Currently_pressed_controls.pressed_controls['MOVE_RIGHT'] and collison_with_bottom_ball_happened:
                PLAYER.movement_Fx += 300
              if Currently_pressed_controls.pressed_controls['MOVE_LEFT'] and collison_with_bottom_ball_happened and collison_with_left_ball_happened:
                PLAYER.movement_Fx = 0
                if abs(PLAYER.x_vel) < 10:
                  PLAYER.FNx = 0
                  PLAYER.x_vel = 0
              if Currently_pressed_controls.pressed_controls['MOVE_RIGHT'] and collison_with_bottom_ball_happened and collison_with_right_ball_happened:
                PLAYER.movement_Fx = 0
                if abs(PLAYER.x_vel) < 10:
                  PLAYER.FNx = 0
                  PLAYER.x_vel = 0
              if bottom_col_happened:
                if Currently_pressed_controls.pressed_controls['MOVE_RIGHT']:
                  PLAYER.Hamster_activities_during_frame.append('Walk_Right')
                  continue
                if Currently_pressed_controls.pressed_controls['MOVE_LEFT']:
                  PLAYER.Hamster_activities_during_frame.append('Walk_Left')
                  continue
                if PLAYER.x_vel > 0:
                  PLAYER.Hamster_activities_during_frame.append('Walk_Right')
                  continue
                if PLAYER.x_vel < 0:
                  PLAYER.Hamster_activities_during_frame.append('Walk_Left')
                  continue
    #
    if GOLDFISH != []:
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for SingleGoldfish in GOLDFISH:
        distance_between_player_and_fish = find_hypotnuse(abs(absolute_center_of_player_x - (SingleGoldfish.x_pos - ((1/2)*screen_width) + (SingleGoldfish.rect[2]/2))), abs(absolute_center_of_player_y - (SingleGoldfish.y_pos - ((1/2)*screen_height) + (SingleGoldfish.rect[3]/2))))
        if distance_between_player_and_fish <= (SingleGoldfish.radius + 34):
          fish_collision_points, fish_collision_happened = find_collisions_with_offsets(SingleGoldfish, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          if fish_collision_happened:
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, fish_collision_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            goldfish_force_on_player(normal_force_angle)
            #current_motion = find_motion_angle(MAP, PLAYER)
            #cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
    #
    if TRANSPORT_PIPES != []:
      My_cached_info.milliseconds_can_go_back_in_transport_pipe += delta_milliseconds
      if not PLAYER.in_a_pipe and not CANT_REENTER_PIPE and (My_cached_info.milliseconds_can_go_back_in_transport_pipe > 100):
        absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
        pipe_index = 0
        for SingleTransportPipe in TRANSPORT_PIPES:
          distance_between_player_and_pipe = find_hypotnuse(abs(absolute_center_of_player_x - (SingleTransportPipe.x_pos - ((1/2)*screen_width) + (SingleTransportPipe.rect[2]/2))), abs(absolute_center_of_player_y - (SingleTransportPipe.y_pos - ((1/2)*screen_height) + (SingleTransportPipe.rect[3]/2))))
          if distance_between_player_and_pipe <= (SingleTransportPipe.radius + 34):
            pipe_collision_points, pipe_collision_happened = find_collisions_with_offsets(SingleTransportPipe, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
            if pipe_collision_happened:
              PLAYER.x_vel, PLAYER.y_vel = 0, 0
              PLAYER.in_a_pipe = True
              PLAYER.got_centered_in_pipe = False
              PLAYER.in_which_pipe = pipe_index
              PLAYER.initial_pipe_adjustment_to_center_x = (SingleTransportPipe.x_pos - ((1/2)*screen_width) + ((1/2)*SingleTransportPipe.rect[2])) - absolute_center_of_player_x
              PLAYER.initial_pipe_adjustment_to_center_y = (SingleTransportPipe.y_pos - ((1/2)*screen_height) + ((1/2)*SingleTransportPipe.rect[3])) - absolute_center_of_player_y
              PLAYER.initial_player_position_when_touching_pipe_x = PLAYER.x_pos
              PLAYER.initial_player_position_when_touching_pipe_y = PLAYER.y_pos
              PLAYER.final_desired_pipe_position_x = PLAYER.x_pos + PLAYER.initial_pipe_adjustment_to_center_x
              PLAYER.final_desired_pipe_position_y = PLAYER.y_pos + PLAYER.initial_pipe_adjustment_to_center_y
          pipe_index += 1
    #
    if TEETERTOTTERS != []:
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for curTotter in range(len(TEETERTOTTERS)):
        distance_between_player_and_curTotter = find_hypotnuse(abs(absolute_center_of_player_x - TEETERTOTTERS[curTotter].collision_circle_x), abs(absolute_center_of_player_y - TEETERTOTTERS[curTotter].collision_circle_y))
        if distance_between_player_and_curTotter < (34 + TEETERTOTTERS[curTotter].collision_circle_radius):
          teeter_totter_collision_points, teeter_totter_collision_happened = find_collisions_with_offsets(TEETERTOTTERS[curTotter], PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          if TEETERTOTTERS[curTotter].is_the_player_on and not teeter_totter_collision_happened:
            STANDING_ON_TEETERTOTTER = False
            TEETERTOTTERS[curTotter].is_the_player_on = False
            STANDING_ON_WHICH_TEETERTOTTER = -666
          if teeter_totter_collision_happened:
            My_cached_info.play_special_collision_sound = True
            My_cached_info.play_teetertotter_collision = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, teeter_totter_collision_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            if 45 <= normal_force_angle <= 135:
              STANDING_ON_TEETERTOTTER = True
              TEETERTOTTERS[curTotter].is_the_player_on = True
              STANDING_ON_WHICH_TEETERTOTTER = curTotter
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
    #
    if BOUNCIES != []:
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for SingleBouncy in BOUNCIES:
        distance_between_player_and_SingleBouncy = find_hypotnuse(abs(absolute_center_of_player_x - SingleBouncy.collision_circle_x), abs(absolute_center_of_player_y - SingleBouncy.collision_circle_y))
        if distance_between_player_and_SingleBouncy < (34 + SingleBouncy.collision_circle_radius):
          SingleBouncy_col_points, SingleBouncy_col_happened = find_collisions_with_offsets(SingleBouncy, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          if SingleBouncy_col_happened:
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleBouncy_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            SUPER_BOUNCY = True
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, SingleBouncy.elasticity_x, SingleBouncy.elasticity_y, SingleBouncy.max_x_vel, SingleBouncy.max_y_vel)
    #
    if WAVES != []:
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      skip_the_rest = False
      closest_wave = 999999
      for SingleWave in WAVES:
        if not skip_the_rest:
          distance_between_player_and_wave = find_hypotnuse(abs(absolute_center_of_player_x - (SingleWave.x_pos - ((1/2)*screen_width) + (SingleWave.rect[2]/2))), abs(absolute_center_of_player_y - (SingleWave.y_pos - ((1/2)*screen_height) + (SingleWave.rect[3]/2))))
          if distance_between_player_and_wave < closest_wave:
            closest_wave = distance_between_player_and_wave
          if distance_between_player_and_wave <= (SingleWave.radius + 34):
            SingleWave_col_points, SingleWave_col_happened = find_collisions_with_offsets(SingleWave, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
            if SingleWave_col_happened:
              if not PLAYER.not_yet_on_the_board:
                PLAYER.allow_catch_the_board_points = False
              skip_the_rest = True
              PLAYER.x_vel += SingleWave.x_vel * 10 * My_cached_info.target_fps_over_fps
      if closest_wave < 1000:
        irregularly_shaped_water_loudness = My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER3'] * ((1000 - closest_wave) / 1000)
        if irregularly_shaped_water_loudness > (My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER3']):
          irregularly_shaped_water_loudness = (My_cached_info.current_sound_loudness * MixerSoundsLoudness['IRREGULARLY_SHAPED_WATER3'])
        if irregularly_shaped_water_loudness < 0:
          irregularly_shaped_water_loudness = 0
        MixerSounds['IRREGULARLY_SHAPED_WATER3'].set_volume(irregularly_shaped_water_loudness)
        if not My_cached_info.playing_wave_sound:
          MixerSounds['IRREGULARLY_SHAPED_WATER3'].play(-1)
          My_cached_info.playing_wave_sound = True
      if closest_wave >= 1000:
        MixerSounds['IRREGULARLY_SHAPED_WATER3'].stop()
        My_cached_info.playing_wave_sound = False
    #
    if DOORS_WITH_KNOB != []:
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for SingleDoorWithKnob in DOORS_WITH_KNOB:
        if SingleDoorWithKnob.door_png_name == 'DOOR_WITH_KNOB':
          if SingleDoorWithKnob.current_door_opening == 4:
            orig_img = SingleDoorWithKnob.current_image
            SingleDoorWithKnob.current_image = PyGameTextures[SingleDoorWithKnob.door_png_name][SingleDoorWithKnob.current_door_opening]
            distance_between_player_and_SingleDoorWithKnob = find_hypotnuse(abs(absolute_center_of_player_x - (SingleDoorWithKnob.x_pos - ((1/2)*screen_width) + (SingleDoorWithKnob.rect[2]/2))), abs(absolute_center_of_player_y - (SingleDoorWithKnob.y_pos - ((1/2)*screen_height) + (SingleDoorWithKnob.rect[3]/2))))
            if distance_between_player_and_SingleDoorWithKnob <= (SingleDoorWithKnob.radius + 34):
              SingleDoorWithKnob_col_points, SingleDoorWithKnob_col_happened = find_collisions_with_offsets(SingleDoorWithKnob, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
              if SingleDoorWithKnob_col_happened:
                temp_collisions_with_left_ball, temp_collison_with_left_ball_happened = find_collisions_with_offsets(SingleDoorWithKnob, my_left_ball, (1/2) * screen_width, (1/2) * screen_height)
                temp_collisions_with_right_ball, temp_collison_with_right_ball_happened = find_collisions_with_offsets(SingleDoorWithKnob, my_right_ball, (1/2) * screen_width, (1/2) * screen_height)
                if temp_collison_with_left_ball_happened:
                  collison_with_left_ball_happened = True
                if temp_collison_with_right_ball_happened:
                  collison_with_right_ball_happened = True
                avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleDoorWithKnob_col_points)
                avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
                normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
                current_motion = find_motion_angle(MAP, PLAYER)
                cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
                if SingleDoorWithKnob.last_door_opening != SingleDoorWithKnob.current_door_opening:
                  if SingleDoorWithKnob.last_door_opening > SingleDoorWithKnob.current_door_opening:
                    PLAYER.FNx += 200000
                    PLAYER.FNy -= 15000
                    PLAYER.x_vel += 100
                  if SingleDoorWithKnob.last_door_opening < SingleDoorWithKnob.current_door_opening:
                    PLAYER.FNx -= 200000
                    PLAYER.FNy -= 15000
                    PLAYER.x_vel -= 100
            SingleDoorWithKnob.current_image = orig_img
    #
    if BUCKETS != []:
      ON_A_BUCKET_LAST_FRAME = ON_A_BUCKET
      ON_A_BUCKET = False
      IN_A_BUCKET = False
      current_bucket = 0
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for SingleBucket in BUCKETS:
        distance_between_player_and_bucket = find_hypotnuse(abs(absolute_center_of_player_x - (SingleBucket.x_pos - ((1/2)*screen_width) + (SingleBucket.rect[2]/2))), abs(absolute_center_of_player_y - (SingleBucket.y_pos - ((1/2)*screen_height) + (SingleBucket.rect[3]/2))))
        if distance_between_player_and_bucket <= (SingleBucket.radius + 34):
          if (SingleBucket.x_pos + 32) <= (absolute_center_of_player_x + ((1/2)*screen_width)) <= (SingleBucket.x_pos + 217):
            if (SingleBucket.y_pos + 38+34) <= (absolute_center_of_player_y + ((1/2)*screen_height)) <= (SingleBucket.y_pos + 379):
              ON_A_BUCKET = True
              PLAYER.on_which_bucket = current_bucket
          SingleBucket.water_region = [SingleBucket.x_pos + 17 - ((1/2)*screen_width), SingleBucket.x_pos + 233 - ((1/2)*screen_width), (SingleBucket.y_pos + 38) - ((1/2)*screen_height), (SingleBucket.y_pos + 420) - ((1/2)*screen_height)]
          low_x = SingleBucket.x_pos + 17 - ((1/2)*screen_width)
          high_x = SingleBucket.x_pos + 233 - ((1/2)*screen_width)
          low_y = (SingleBucket.y_pos + 38) - ((1/2)*screen_height)
          high_y = (SingleBucket.y_pos + 420) - ((1/2)*screen_height)
          if low_x <= PLAYER.x_pos <= high_x and low_y <= PLAYER.y_pos <= high_y:
            IN_A_BUCKET = True
          find_water_force(low_x, high_x, low_y, high_y, 0, 0, False)
          SingleBucket_col_points, SingleBucket_col_happened = find_collisions_with_offsets(SingleBucket, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          if SingleBucket_col_happened:
            bottom_col_points, bottom_col_happened = find_collisions_with_offsets(SingleBucket, my_bottom_ball, (1/2) * screen_width, (1/2) * screen_height)
            if bottom_col_happened:
              collison_with_bottom_ball_happened = True
            left_col_points, left_col_happened = find_collisions_with_offsets(SingleBucket, my_left_ball, (1/2) * screen_width, (1/2) * screen_height)
            if left_col_happened:
              collison_with_left_ball_happened = True
            right_col_points, right_col_happened = find_collisions_with_offsets(SingleBucket, my_right_ball, (1/2) * screen_width, (1/2) * screen_height)
            if right_col_happened:
              collison_with_right_ball_happened = True
            #ON_A_BUCKET = True
            PLAYER.on_which_bucket = current_bucket
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleBucket_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        current_bucket += 1
      if PLAYER.on_which_bucket < len(BUCKETS):
        if BUCKETS[PLAYER.on_which_bucket].stage_in_bucket_movement == 2: # moving up
          if not ON_A_BUCKET_LAST_FRAME and ON_A_BUCKET:
            PLAYER.y_vel += (BUCKETS[PLAYER.on_which_bucket].vel * My_cached_info.target_fps_over_fps) / (1 / fps)
          if ON_A_BUCKET_LAST_FRAME and not ON_A_BUCKET:
            PLAYER.y_vel -= (BUCKETS[PLAYER.on_which_bucket].vel * My_cached_info.target_fps_over_fps) / (1 / fps)
        if BUCKETS[PLAYER.on_which_bucket].stage_in_bucket_movement == 4: # moving down
          if not ON_A_BUCKET_LAST_FRAME and ON_A_BUCKET:
            pass
            PLAYER.y_vel -= ((BUCKETS[PLAYER.on_which_bucket].vel * My_cached_info.target_fps_over_fps) / (1 / fps)) / 2
          if ON_A_BUCKET_LAST_FRAME and not ON_A_BUCKET:
            pass
            PLAYER.y_vel += ((BUCKETS[PLAYER.on_which_bucket].vel * My_cached_info.target_fps_over_fps) / (1 / fps)) / 2
    #
    if MOVING_BOUNCIES != []:
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for SingleBouncy in MOVING_BOUNCIES:
        distance_between_player_and_SingleBouncy = find_hypotnuse(abs(absolute_center_of_player_x - SingleBouncy.collision_circle_x), abs(absolute_center_of_player_y - SingleBouncy.collision_circle_y))
        if distance_between_player_and_SingleBouncy < (34 + SingleBouncy.collision_circle_radius):
          SingleBouncy_col_points, SingleBouncy_col_happened = find_collisions_with_offsets(SingleBouncy, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          if SingleBouncy_col_happened:
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleBouncy_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            SUPER_BOUNCY = True
            if 20 < normal_force_angle < 160:
              normal_force_angle = 90
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, SingleBouncy.elasticity_x, SingleBouncy.elasticity_y, SingleBouncy.max_x_vel, SingleBouncy.max_y_vel)
    #
    if THE_MACHINE != []:
      skip_updating_themachine_collision_this_frame = False
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for SingleMachine in THE_MACHINE:
        distance_between_player_and_SingleMachine = find_hypotnuse(abs(absolute_center_of_player_x - (SingleMachine.x_pos - ((1/2)*screen_width) + (SingleMachine.rect[2]/2))), abs(absolute_center_of_player_y - (SingleMachine.y_pos - ((1/2)*screen_height) + (SingleMachine.rect[3]/2))))
        if distance_between_player_and_SingleMachine <= (SingleMachine.radius + 34):
          starting_collision_image_index = SingleMachine.collision_image_index
          if not SingleMachine.player_in_left_side and not SingleMachine.player_in_right_side:
            SingleMachine.collision_image_index = 2
          if SingleMachine.player_in_left_side or SingleMachine.player_in_right_side:
            SingleMachine.current_image = SingleMachine.collision_images[1]
            SingleMachine_col_points, SingleMachine_col_happened = find_collisions_with_offsets(SingleMachine, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
            if not SingleMachine_col_happened:
              SingleMachine.collision_image_index = 1
          if SingleMachine.collision_happened_last_frame and SingleMachine.collision_image_index == 1:
            SingleMachine.current_image = SingleMachine.collision_images[3]
            SingleMachine_col_points, SingleMachine_col_happened = find_collisions_with_offsets(SingleMachine, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
            if not SingleMachine_col_happened:
              SingleMachine.collision_image_index = 0
          if My_cached_info.won_the_game:
            SingleMachine.collision_image_index = 0
          SingleMachine.current_image = SingleMachine.collision_images[SingleMachine.collision_image_index]
          SingleMachine_col_happened = False
          SingleMachine_col_points, SingleMachine_col_happened = find_collisions_with_offsets(SingleMachine, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          if SingleMachine_col_happened:
            ON_THE_MACHINE = True
            SingleMachine.collision_happened_last_frame = True
            skip_updating_themachine_collision_this_frame = True
            temp_collisions_with_bottom_ball, temp_collison_with_bottom_ball_happened = find_collisions_with_offsets(SingleMachine, my_bottom_ball, (1/2) * screen_width, (1/2) * screen_height)
            temp_collisions_with_top_ball, temp_collison_with_top_ball_happened = find_collisions_with_offsets(SingleMachine, my_top_ball, (1/2) * screen_width, (1/2) * screen_height)
            temp_collisions_with_left_ball, temp_collison_with_left_ball_happened = find_collisions_with_offsets(SingleMachine, my_left_ball, (1/2) * screen_width, (1/2) * screen_height)
            temp_collisions_with_right_ball, temp_collison_with_right_ball_happened = find_collisions_with_offsets(SingleMachine, my_right_ball, (1/2) * screen_width, (1/2) * screen_height)
            if temp_collison_with_bottom_ball_happened:
              collisions_with_bottom_ball, collison_with_bottom_ball_happened = temp_collisions_with_bottom_ball, temp_collison_with_bottom_ball_happened
            if temp_collison_with_top_ball_happened:
              collisions_with_top_ball, collison_with_top_ball_happened = temp_collisions_with_top_ball, temp_collison_with_top_ball_happened
            if temp_collison_with_left_ball_happened:
              collisions_with_left_ball, collison_with_left_ball_happened = temp_collisions_with_left_ball, temp_collison_with_left_ball_happened
            if temp_collison_with_right_ball_happened:
              collisions_with_right_ball, collison_with_right_ball_happened = temp_collisions_with_right_ball, temp_collison_with_right_ball_happened
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleMachine_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
            if Currently_pressed_controls.pressed_controls['MOVE_LEFT'] and collison_with_bottom_ball_happened:
              PLAYER.Hamster_activities_during_frame.append('Walk_Left')
              PLAYER.movement_Fx -= 300
            if Currently_pressed_controls.pressed_controls['MOVE_RIGHT'] and collison_with_bottom_ball_happened:
              PLAYER.Hamster_activities_during_frame.append('Walk_Right')
              PLAYER.movement_Fx += 300
            if Currently_pressed_controls.pressed_controls['MOVE_LEFT'] and collison_with_bottom_ball_happened and collison_with_left_ball_happened:
              PLAYER.movement_Fx = 0
              if abs(PLAYER.x_vel) < 10:
                PLAYER.FNx = 0
                PLAYER.x_vel = 0
            if Currently_pressed_controls.pressed_controls['MOVE_RIGHT'] and collison_with_bottom_ball_happened and collison_with_right_ball_happened:
              PLAYER.movement_Fx = 0
              if abs(PLAYER.x_vel) < 10:
                PLAYER.FNx = 0
                PLAYER.x_vel = 0
      if not skip_updating_themachine_collision_this_frame:
        SingleMachine.collision_happened_last_frame = False
        ON_THE_MACHINE = False
    #
    ON_AN_ELEVATOR = False
    if ELEVATORS != [] and MAP.region != 'TheDoor7':
      absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
      for SingleElevator in ELEVATORS:
        distance_between_player_and_SingleElevator = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.x_pos + ((1/2)*screen_width) - (SingleElevator.rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.y_pos + ((1/2)*screen_height) - (SingleElevator.rect[3]/2)))
        if distance_between_player_and_SingleElevator < (34 + find_hypotnuse(SingleElevator.rect[2]/2, SingleElevator.rect[3])):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets(SingleElevator, PLAYER, (1/2) * screen_width, (1/2) * screen_height)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            collisions_with_bottom_ball, collison_with_bottom_ball_happened = find_collisions_with_offsets(SingleElevator, my_bottom_ball, (1/2) * screen_width, (1/2) * screen_height)
            collisions_with_top_ball, collison_with_top_ball_happened = find_collisions_with_offsets(SingleElevator, my_top_ball, (1/2) * screen_width, (1/2) * screen_height)
            collisions_with_left_ball, collison_with_left_ball_happened = find_collisions_with_offsets(SingleElevator, my_left_ball, (1/2) * screen_width, (1/2) * screen_height)
            collisions_with_right_ball, collison_with_right_ball_happened = find_collisions_with_offsets(SingleElevator, my_right_ball, (1/2) * screen_width, (1/2) * screen_height)
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            if Currently_pressed_controls.pressed_controls['MOVE_LEFT']:
              PLAYER.Hamster_activities_during_frame.append('Walk_Left')
              PLAYER.movement_Fx -= 300
            if Currently_pressed_controls.pressed_controls['MOVE_RIGHT']:
              PLAYER.Hamster_activities_during_frame.append('Walk_Right')
              PLAYER.movement_Fx += 300
            if Currently_pressed_controls.pressed_controls['MOVE_LEFT'] and collison_with_bottom_ball_happened and collison_with_left_ball_happened:
              PLAYER.movement_Fx = 0
            if Currently_pressed_controls.pressed_controls['MOVE_RIGHT'] and collison_with_bottom_ball_happened and collison_with_right_ball_happened:
              PLAYER.movement_Fx = 0
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
    if MAP.region == 'TheDoor7':
      for SingleElevator in ELEVATORS:
        absolute_center_of_player_x, absolute_center_of_player_y = PLAYER.x_pos + 34, PLAYER.y_pos + 34
        distance_between_player_and_PlatformLeftTop = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformLeftTop_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformLeftTop_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformLeftTop_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformLeftTop_rect[3]/2)))
        distance_between_player_and_PlatformMiddleTop = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformMiddleTop_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformMiddleTop_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformMiddleTop_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformMiddleTop_rect[3]/2)))
        distance_between_player_and_PlatformRightTop = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformRightTop_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformRightTop_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformRightTop_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformRightTop_rect[3]/2)))
        distance_between_player_and_PlatformLeftBottom = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformLeftBottom_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformLeftBottom_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformLeftBottom_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformLeftBottom_rect[3]/2)))
        distance_between_player_and_PlatformMiddleBottom = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformMiddleBottom_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformMiddleBottom_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformMiddleBottom_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformMiddleBottom_rect[3]/2)))
        distance_between_player_and_PlatformRightBottom = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.PlatformRightBottom_x_pos + ((1/2)*screen_width) - (SingleElevator.PlatformRightBottom_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.PlatformRightBottom_y_pos + ((1/2)*screen_height) - (SingleElevator.PlatformRightBottom_rect[3]/2)))
        distance_between_player_and_LeftMiddlePlatform = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.LeftMiddlePlatform_x_pos + ((1/2)*screen_width) - (SingleElevator.LeftMiddlePlatform_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.LeftMiddlePlatform_y_pos + ((1/2)*screen_height) - (SingleElevator.LeftMiddlePlatform_rect[3]/2)))
        distance_between_player_and_RightMiddlePlatform = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.RightMiddlePlatform_x_pos + ((1/2)*screen_width) - (SingleElevator.RightMiddlePlatform_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.RightMiddlePlatform_y_pos + ((1/2)*screen_height) - (SingleElevator.RightMiddlePlatform_rect[3]/2)))
        distance_between_player_and_DownPeg1 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.DownPeg1_x_pos + ((1/2)*screen_width) - (SingleElevator.DownPeg1_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.DownPeg1_y_pos + ((1/2)*screen_height) - (SingleElevator.DownPeg1_rect[3]/2)))
        distance_between_player_and_DownPeg2 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.DownPeg2_x_pos + ((1/2)*screen_width) - (SingleElevator.DownPeg2_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.DownPeg2_y_pos + ((1/2)*screen_height) - (SingleElevator.DownPeg2_rect[3]/2)))
        distance_between_player_and_DownPeg3 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.DownPeg3_x_pos + ((1/2)*screen_width) - (SingleElevator.DownPeg3_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.DownPeg3_y_pos + ((1/2)*screen_height) - (SingleElevator.DownPeg3_rect[3]/2)))
        distance_between_player_and_UpPeg1 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.UpPeg1_x_pos + ((1/2)*screen_width) - (SingleElevator.UpPeg1_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.UpPeg1_y_pos + ((1/2)*screen_height) - (SingleElevator.UpPeg1_rect[3]/2)))
        distance_between_player_and_UpPeg2 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.UpPeg2_x_pos + ((1/2)*screen_width) - (SingleElevator.UpPeg2_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.UpPeg2_y_pos + ((1/2)*screen_height) - (SingleElevator.UpPeg2_rect[3]/2)))
        distance_between_player_and_UpPeg3 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.UpPeg3_x_pos + ((1/2)*screen_width) - (SingleElevator.UpPeg3_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.UpPeg3_y_pos + ((1/2)*screen_height) - (SingleElevator.UpPeg3_rect[3]/2)))
        distance_between_player_and_UpPeg4 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.UpPeg4_x_pos + ((1/2)*screen_width) - (SingleElevator.UpPeg4_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.UpPeg4_y_pos + ((1/2)*screen_height) - (SingleElevator.UpPeg4_rect[3]/2)))
        distance_between_player_and_UpPeg5 = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.UpPeg5_x_pos + ((1/2)*screen_width) - (SingleElevator.UpPeg5_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.UpPeg5_y_pos + ((1/2)*screen_height) - (SingleElevator.UpPeg5_rect[3]/2)))
        distance_between_player_and_LeftDoor = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.LeftDoor_x_pos + ((1/2)*screen_width) - (SingleElevator.LeftDoor_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.LeftDoor_y_pos + ((1/2)*screen_height) - (SingleElevator.LeftDoor_rect[3]/2)))
        distance_between_player_and_RightDoor = find_hypotnuse(abs(absolute_center_of_player_x - SingleElevator.RightDoor_x_pos + ((1/2)*screen_width) - (SingleElevator.RightDoor_rect[2]/2)), abs(absolute_center_of_player_y - SingleElevator.RightDoor_y_pos + ((1/2)*screen_height) - (SingleElevator.RightDoor_rect[3]/2)))
        if distance_between_player_and_PlatformLeftTop < (34 + 302):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.PlatformLeftTop_image), PLAYER, (1/2) * screen_width - 1, (1/2) * screen_height)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            collison_with_top_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if distance_between_player_and_PlatformMiddleTop < (34 + 302):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.PlatformMiddleTop_image), PLAYER, (1/2) * screen_width - 601, (1/2) * screen_height)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            collison_with_top_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if distance_between_player_and_PlatformRightTop < (34 + 302):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.PlatformRightTop_image), PLAYER, (1/2) * screen_width - 1201, (1/2) * screen_height)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            collison_with_top_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if distance_between_player_and_PlatformLeftBottom < (34 + 302):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.PlatformLeftBottom_image), PLAYER, (1/2) * screen_width - 1, (1/2) * screen_height - 495)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            bottom_inner_col_points, bottom_inner_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.PlatformLeftBottom_image), my_bottom_ball_inner, (1/2) * screen_width - 1, (1/2) * screen_height - 495)
            if bottom_inner_col_happened:
              PLAYER.y_pos -= 1
            collison_with_bottom_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            normal_force_angle = 90
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if distance_between_player_and_PlatformMiddleBottom < (34 + 302):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.PlatformMiddleBottom_image), PLAYER, (1/2) * screen_width - 601, (1/2) * screen_height - 495)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            bottom_inner_col_points, bottom_inner_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.PlatformMiddleBottom_image), my_bottom_ball_inner, (1/2) * screen_width - 601, (1/2) * screen_height - 495)
            if bottom_inner_col_happened:
              PLAYER.y_pos -= 1
            collison_with_bottom_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            normal_force_angle = 90
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if distance_between_player_and_PlatformRightBottom < (34 + 302):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.PlatformRightBottom_image), PLAYER, (1/2) * screen_width - 1201, (1/2) * screen_height - 495)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            bottom_inner_col_points, bottom_inner_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.PlatformRightBottom_image), my_bottom_ball_inner, (1/2) * screen_width - 1201, (1/2) * screen_height - 495)
            if bottom_inner_col_happened:
              PLAYER.y_pos -= 1
            collison_with_bottom_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            normal_force_angle = 90
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if distance_between_player_and_LeftMiddlePlatform < (34 + 245):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.LeftMiddlePlatform_image), PLAYER, (1/2) * screen_width - 357, (1/2) * screen_height - 248)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            bottom_inner_col_points, bottom_inner_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.LeftMiddlePlatform_image), my_bottom_ball_inner, (1/2) * screen_width - 357, (1/2) * screen_height - 248)
            if bottom_inner_col_happened:
              PLAYER.y_pos -= 1
            left_col_points, left_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.LeftMiddlePlatform_image), my_left_ball, (1/2) * screen_width - 357, (1/2) * screen_height - 248)
            if left_col_happened:
              collison_with_left_ball_happened = True
            right_col_points, right_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.LeftMiddlePlatform_image), my_right_ball, (1/2) * screen_width - 357, (1/2) * screen_height - 248)
            if right_col_happened:
              collison_with_right_ball_happened = True
            bottom_col_points, bottom_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.LeftMiddlePlatform_image), my_bottom_ball, (1/2) * screen_width - 357, (1/2) * screen_height - 248)
            if bottom_col_happened:
              collison_with_bottom_ball_happened = True
            top_col_points, top_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.LeftMiddlePlatform_image), my_top_ball, (1/2) * screen_width - 357, (1/2) * screen_height - 248)
            if top_col_happened:
              collison_with_top_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if distance_between_player_and_RightMiddlePlatform < (34 + 245):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.RightMiddlePlatform_image), PLAYER, (1/2) * screen_width - 967, (1/2) * screen_height - 248)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            bottom_inner_col_points, bottom_inner_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.RightMiddlePlatform_image), my_bottom_ball_inner, (1/2) * screen_width - 967, (1/2) * screen_height - 248)
            if bottom_inner_col_happened:
              PLAYER.y_pos -= 1
            left_col_points, left_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.RightMiddlePlatform_image), my_left_ball, (1/2) * screen_width - 967, (1/2) * screen_height - 248)
            if left_col_happened:
              collison_with_left_ball_happened = True
            right_col_points, right_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.RightMiddlePlatform_image), my_right_ball, (1/2) * screen_width - 967, (1/2) * screen_height - 248)
            if right_col_happened:
              collison_with_right_ball_happened = True
            bottom_col_points, bottom_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.RightMiddlePlatform_image), my_bottom_ball, (1/2) * screen_width - 967, (1/2) * screen_height - 248)
            if bottom_col_happened:
              collison_with_bottom_ball_happened = True
            top_col_points, top_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.RightMiddlePlatform_image), my_top_ball, (1/2) * screen_width - 967, (1/2) * screen_height - 248)
            if top_col_happened:
              collison_with_top_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if distance_between_player_and_DownPeg1 < (34 + 28):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.DownPeg1_image), PLAYER, (1/2) * screen_width - 894, (1/2) * screen_height - 48)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            left_col_points, left_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.DownPeg1_image), my_left_ball, (1/2) * screen_width - 894, (1/2) * screen_height - 48)
            if left_col_happened:
              collison_with_left_ball_happened = True
            right_col_points, right_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.DownPeg1_image), my_right_ball, (1/2) * screen_width - 894, (1/2) * screen_height - 48)
            if right_col_happened:
              collison_with_right_ball_happened = True
            top_col_points, top_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.DownPeg1_image), my_top_ball, (1/2) * screen_width - 894, (1/2) * screen_height - 48)
            if top_col_happened:
              collison_with_top_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if distance_between_player_and_DownPeg2 < (34 + 28):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.DownPeg2_image), PLAYER, (1/2) * screen_width - 680, (1/2) * screen_height - 295)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            left_col_points, left_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.DownPeg2_image), my_left_ball, (1/2) * screen_width - 680, (1/2) * screen_height - 295)
            if left_col_happened:
              collison_with_left_ball_happened = True
            right_col_points, right_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.DownPeg2_image), my_right_ball, (1/2) * screen_width - 680, (1/2) * screen_height - 295)
            if right_col_happened:
              collison_with_right_ball_happened = True
            top_col_points, top_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.DownPeg2_image), my_top_ball, (1/2) * screen_width - 680, (1/2) * screen_height - 295)
            if top_col_happened:
              collison_with_top_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if distance_between_player_and_DownPeg3 < (34 + 28):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.DownPeg3_image), PLAYER, (1/2) * screen_width - 1108, (1/2) * screen_height - 295)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            left_col_points, left_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.DownPeg3_image), my_left_ball, (1/2) * screen_width - 1108, (1/2) * screen_height - 295)
            if left_col_happened:
              collison_with_left_ball_happened = True
            right_col_points, right_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.DownPeg3_image), my_right_ball, (1/2) * screen_width - 1108, (1/2) * screen_height - 295)
            if right_col_happened:
              collison_with_right_ball_happened = True
            top_col_points, top_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.DownPeg3_image), my_top_ball, (1/2) * screen_width - 1108, (1/2) * screen_height - 295)
            if top_col_happened:
              collison_with_top_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if distance_between_player_and_UpPeg1 < (34 + 28):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg1_image), PLAYER, (1/2) * screen_width - 497, (1/2) * screen_height - 220 + 20)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            left_col_points, left_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg1_image), my_left_ball, (1/2) * screen_width - 497, (1/2) * screen_height - 220 + 20)
            if left_col_happened:
              collison_with_left_ball_happened = True
            right_col_points, right_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg1_image), my_right_ball, (1/2) * screen_width - 497, (1/2) * screen_height - 220 + 20)
            if right_col_happened:
              collison_with_right_ball_happened = True
            bottom_col_points, bottom_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg1_image), my_bottom_ball, (1/2) * screen_width - 497, (1/2) * screen_height - 220 + 20)
            if bottom_col_happened:
              collison_with_bottom_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if distance_between_player_and_UpPeg2 < (34 + 28):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg2_image), PLAYER, (1/2) * screen_width - 1291, (1/2) * screen_height - 220 + 20)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            left_col_points, left_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg2_image), my_left_ball, (1/2) * screen_width - 1291, (1/2) * screen_height - 220 + 20)
            if left_col_happened:
              collison_with_left_ball_happened = True
            right_col_points, right_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg2_image), my_right_ball, (1/2) * screen_width - 1291, (1/2) * screen_height - 220 + 20)
            if right_col_happened:
              collison_with_right_ball_happened = True
            bottom_col_points, bottom_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg2_image), my_bottom_ball, (1/2) * screen_width - 1291, (1/2) * screen_height - 220 + 20)
            if bottom_col_happened:
              collison_with_bottom_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if distance_between_player_and_UpPeg3 < (34 + 28):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg3_image), PLAYER, (1/2) * screen_width - 466, (1/2) * screen_height - 467 + 20)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            left_col_points, left_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg3_image), my_left_ball, (1/2) * screen_width - 466, (1/2) * screen_height - 467 + 20)
            if left_col_happened:
              collison_with_left_ball_happened = True
            right_col_points, right_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg3_image), my_right_ball, (1/2) * screen_width - 466, (1/2) * screen_height - 467 + 20)
            if right_col_happened:
              collison_with_right_ball_happened = True
            bottom_col_points, bottom_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg3_image), my_bottom_ball, (1/2) * screen_width - 466, (1/2) * screen_height - 467 + 20)
            if bottom_col_happened:
              collison_with_bottom_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if distance_between_player_and_UpPeg4 < (34 + 28):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg4_image), PLAYER, (1/2) * screen_width - 894, (1/2) * screen_height - 467 + 20)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            left_col_points, left_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg4_image), my_left_ball, (1/2) * screen_width - 894, (1/2) * screen_height - 467 + 20)
            if left_col_happened:
              collison_with_left_ball_happened = True
            right_col_points, right_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg4_image), my_right_ball, (1/2) * screen_width - 894, (1/2) * screen_height - 467 + 20)
            if right_col_happened:
              collison_with_right_ball_happened = True
            bottom_col_points, bottom_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg4_image), my_bottom_ball, (1/2) * screen_width - 894, (1/2) * screen_height - 467 + 20)
            if bottom_col_happened:
              collison_with_bottom_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if distance_between_player_and_UpPeg5 < (34 + 28):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg5_image), PLAYER, (1/2) * screen_width - 1322, (1/2) * screen_height - 467 + 20)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            left_col_points, left_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg5_image), my_left_ball, (1/2) * screen_width - 1322, (1/2) * screen_height - 467 + 20)
            if left_col_happened:
              collison_with_left_ball_happened = True
            right_col_points, right_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg5_image), my_right_ball, (1/2) * screen_width - 1322, (1/2) * screen_height - 467 + 20)
            if right_col_happened:
              collison_with_right_ball_happened = True
            bottom_col_points, bottom_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.UpPeg5_image), my_bottom_ball, (1/2) * screen_width - 1322, (1/2) * screen_height - 467 + 20)
            if bottom_col_happened:
              collison_with_bottom_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if distance_between_player_and_LeftDoor < (34 + 225):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.LeftDoor_current_image), PLAYER, (1/2) * screen_width - 17, (1/2) * screen_height - 48)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            left_inner_col_points, left_inner_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.LeftDoor_current_image), my_left_ball_inner, (1/2) * screen_width - 17, (1/2) * screen_height - 48)
            if left_inner_col_happened:
              PLAYER.x_pos += 1
            right_inner_col_points, right_inner_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.LeftDoor_current_image), my_right_ball_inner, (1/2) * screen_width - 17, (1/2) * screen_height - 48)
            if right_inner_col_happened:
              PLAYER.x_pos -= 1
            left_col_points, left_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.LeftDoor_current_image), my_left_ball, (1/2) * screen_width - 17, (1/2) * screen_height - 48)
            if left_col_happened:
              collison_with_left_ball_happened = True
            right_col_points, right_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.LeftDoor_current_image), my_right_ball, (1/2) * screen_width - 17, (1/2) * screen_height - 48)
            if right_col_happened:
              collison_with_right_ball_happened = True
            top_col_points, top_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.LeftDoor_current_image), my_top_ball, (1/2) * screen_width - 17, (1/2) * screen_height - 48)
            if top_col_happened:
              collison_with_top_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
        if distance_between_player_and_RightDoor < (34 + 225):
          SingleElevator_col_points, SingleElevator_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.RightDoor_current_image), PLAYER, (1/2) * screen_width - 1750, (1/2) * screen_height - 48)
          if SingleElevator_col_happened:
            ON_AN_ELEVATOR = True
            left_inner_col_points, left_inner_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.RightDoor_current_image), my_left_ball_inner, (1/2) * screen_width - 1750, (1/2) * screen_height - 48)
            if left_inner_col_happened:
              PLAYER.x_pos += 1
            right_inner_col_points, right_inner_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.RightDoor_current_image), my_right_ball_inner, (1/2) * screen_width - 1750, (1/2) * screen_height - 48)
            if right_inner_col_happened:
              PLAYER.x_pos -= 1
            left_col_points, left_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.RightDoor_current_image), my_left_ball, (1/2) * screen_width - 1750, (1/2) * screen_height - 48)
            if left_col_happened:
              collison_with_left_ball_happened = True
            right_col_points, right_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.RightDoor_current_image), my_right_ball, (1/2) * screen_width - 1750, (1/2) * screen_height - 48)
            if right_col_happened:
              collison_with_right_ball_happened = True
            top_col_points, top_col_happened = find_collisions_with_offsets_BigElevator(SingleElevator, pygame.mask.from_surface(SingleElevator.RightDoor_current_image), my_top_ball, (1/2) * screen_width - 1750, (1/2) * screen_height - 48)
            if top_col_happened:
              collison_with_top_ball_happened = True
            avg_impact_x, avg_impact_y = find_avg_impact_point(MAP, PLAYER, SingleElevator_col_points)
            avg_impact_angle = find_avg_impact_angle(MAP, PLAYER, avg_impact_x, avg_impact_y)
            normal_force_angle = find_normal_force_angle(MAP, PLAYER, avg_impact_angle)
            current_motion = find_motion_angle(MAP, PLAYER)
            cur_VFx, cur_VFy, leaving_a_wall = normal_force(normal_force_angle, current_motion, 0, 0, 0, 0)
      if ON_AN_ELEVATOR:
        if Currently_pressed_controls.pressed_controls['MOVE_LEFT'] and collison_with_bottom_ball_happened:
          PLAYER.Hamster_activities_during_frame.append('Walk_Left')
          PLAYER.movement_Fx -= 300
        if Currently_pressed_controls.pressed_controls['MOVE_RIGHT'] and collison_with_bottom_ball_happened:
          PLAYER.Hamster_activities_during_frame.append('Walk_Right')
          PLAYER.movement_Fx += 300
        if Currently_pressed_controls.pressed_controls['MOVE_LEFT'] and collison_with_bottom_ball_happened and collison_with_left_ball_happened:
          PLAYER.movement_Fx = 0
          if abs(PLAYER.x_vel) < 10:
            PLAYER.FNx = 0
            PLAYER.x_vel = 0
        if Currently_pressed_controls.pressed_controls['MOVE_RIGHT'] and collison_with_bottom_ball_happened and collison_with_right_ball_happened:
          PLAYER.movement_Fx = 0
          if abs(PLAYER.x_vel) < 10:
            PLAYER.FNx = 0
            PLAYER.x_vel = 0
###
###
###
    check_events()
  #
    stay_in_bounds()
    update_physics()
    if CLOUDS != []:
      try:
        PLAYER.cloud_change_in_x_pos = -5*(((PLAYER.x_pos - CLOUDS[STANDING_ON_WHICH_CLOUD].x_pos) - orig_cloud_x_pos) / (1 / fps))
      except:
        pass
    if BUBBLES != []:
      update_bubbles()
    if PLAYER.surfing_check_points:
      update_surfing_points()
    PLAYER.change_in_x_pos = -5*((PLAYER.prev_x_pos[-1] - PLAYER.prev_x_pos[-2]) / (1 / fps))
    PLAYER.change_in_y_pos = -5*((PLAYER.prev_y_pos[-1] - PLAYER.prev_y_pos[-2]) / (1 / fps))
    glClear(GL_COLOR_BUFFER_BIT)
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
    blit_change_player()
    update_hamster_animation()
    specific_animation_rules()
    draw_all()
    glFlush()
    pygame.display.flip()
###
    PLAYER.Fx, PLAYER.Fy = PLAYER.forces_for_next_frame_x, PLAYER.forces_for_next_frame_y
    PLAYER.Fgx, PLAYER.Fgy = 0, 0
    PLAYER.movement_Fx, PLAYER.movement_Fy = 0, 0
    PLAYER.piston_Fx, PLAYER.piston_Fy = 0, 0
    PLAYER.water_Fx, PLAYER.water_Fy = 0, 0
    PLAYER.FNx, PLAYER.FNy = 0, 0
    PLAYER.x_accel, PLAYER.y_accel = 0, 0
    my_bottom_ball.x_pos, my_bottom_ball.y_pos = PLAYER.x_pos + my_bottom_ball.offset_x, PLAYER.y_pos + my_bottom_ball.offset_y
    my_top_ball.x_pos, my_top_ball.y_pos = PLAYER.x_pos + my_top_ball.offset_x, PLAYER.y_pos + my_top_ball.offset_y
    my_left_ball.x_pos, my_left_ball.y_pos = PLAYER.x_pos + my_left_ball.offset_x, PLAYER.y_pos + my_left_ball.offset_y
    my_right_ball.x_pos, my_right_ball.y_pos = PLAYER.x_pos + my_right_ball.offset_x, PLAYER.y_pos + my_right_ball.offset_y
    my_bottom_ball_inner.x_pos, my_bottom_ball_inner.y_pos = PLAYER.x_pos + my_bottom_ball_inner.offset_x, PLAYER.y_pos + my_bottom_ball_inner.offset_y
    my_top_ball_inner.x_pos, my_top_ball_inner.y_pos = PLAYER.x_pos + my_top_ball_inner.offset_x, PLAYER.y_pos + my_top_ball_inner.offset_y
    my_left_ball_inner.x_pos, my_left_ball_inner.y_pos = PLAYER.x_pos + my_left_ball_inner.offset_x, PLAYER.y_pos + my_left_ball_inner.offset_y
    my_right_ball_inner.x_pos, my_right_ball_inner.y_pos = PLAYER.x_pos + my_right_ball_inner.offset_x, PLAYER.y_pos + my_right_ball_inner.offset_y
    my_middle_ball.x_pos, my_middle_ball.y_pos = PLAYER.x_pos + my_middle_ball.offset_x, PLAYER.y_pos + my_middle_ball.offset_y
    collisions_with_bottom_ball, collison_with_bottom_ball_happened = False, False
    collisions_with_top_ball, collison_with_top_ball_happened = False, False
    collisions_with_left_ball, collison_with_left_ball_happened = False, False
    collisions_with_right_ball, collison_with_right_ball_happened = False, False
    collisions_with_bottom_ball_inner, collison_with_bottom_ball_inner_happened = False, False
    collisions_with_top_ball_inner, collison_with_top_ball_inner_happened = False, False
    collisions_with_left_ball_inner, collison_with_left_ball_inner_happened = False, False
    collisions_with_right_ball_inner, collison_with_right_ball_inner_happened = False, False
    My_cached_info.grass_updates_this_frame = 0
    cur_col_grapple_happened = False
    TOUCHED_ROOT = False
    normal_force_angle = 500
    leaving_a_wall = False
    for i in range(len(MY_VINES)):
      MY_VINES[i].angular_accel = 0
    PLAYER.erroring = 0
    my_piston1.prev_extension = my_piston1.extension
    reduce_KEy = False
    SUPER_BOUNCY = False
    if my_piston2.extension == 0:
      for SingleKey in ALLKEYS:
        SingleKey.cooldown_before_grabbing_again = 0
    PLAYER.Hamster_activities_during_previous_frames.insert(0, PLAYER.Hamster_activities_during_frame)
    PLAYER.Hamster_activities_during_previous_frames = PLAYER.Hamster_activities_during_previous_frames[:-1]
    PLAYER.Hamster_activities_during_frame = []
    PLAYER.adjust_x_pos, PLAYER.adjust_y_pos = 0, 0
    for _ in range(My_cached_info.whole_number_of_frames_this_frame):
      my_piston1.is_touching_wall.append(False)
      my_piston1.is_touching_wall = my_piston1.is_touching_wall[1:]
    PLAYER.skip_the_rest_of_the_water = False
    PLAYER.changed_region_last_frame = False
    PLAYER.Hamster_forced_spin = False
    if my_piston1.extension != 0 and my_piston2.extension != 0:
      my_piston1.extension = 0
      my_piston2.extension = 0
    PLAYER.changed_region_last_frame = False
    PLAYER.in_pipe_wind = False
    if PLAY_UPGRADE_CUTSCENE_end_frame != 0:
      if frame_counter > PLAY_UPGRADE_CUTSCENE_end_frame:
        #UPGRADES = []
        pass
    My_cached_info.loaded_in_last_frame = False
    My_cached_info.pause_happened_this_frame = False
    my_piston2.last_extension = my_piston2.extension
    for _ in range(My_cached_info.whole_number_of_frames_this_frame):
      my_piston2.last_five_extensions.append(my_piston2.extension)
      my_piston2.last_five_extensions = my_piston2.last_five_extensions[1:]
    if (my_piston2.last_grapple_claw_x == 0 and my_piston2.grapple_claw_x_pos != 0):
      MixerSounds['ATTACH'].play()
    my_piston2.last_grapple_claw_x, my_piston2.last_grapple_claw_y = my_piston2.grapple_claw_x_pos, my_piston2.grapple_claw_y_pos
    My_cached_info.play_special_collision_sound = False
    if My_cached_info.last_submersion == 0 and PLAYER.how_submerged > 0:
      speed_multiplier = PLAYER.y_vel / 800
      if speed_multiplier < 0:
        speed_multiplier = 0
      if speed_multiplier > 1:
        speed_multiplier = 1
      splash_volume_loudness = My_cached_info.current_sound_loudness * MixerSoundsLoudness['SPLASH'] * speed_multiplier
      MixerSounds['SPLASH'].set_volume(splash_volume_loudness)
      MixerSounds['SPLASH'].play()
    My_cached_info.last_submersion = PLAYER.how_submerged
###
    if my_piston2.extension <= 0:
      My_cached_info.playing_extend_grapple = False
      My_cached_info.play_retract_grapple = False
      MixerSounds['EXTEND'].stop()
      MixerSounds['RETRACT'].stop()
###
    if not Currently_pressed_controls.pressed_controls['PAUSE']: # pause
      My_cached_info.allow_pause_change = True
    if Currently_pressed_controls.pressed_controls['PAUSE'] and My_cached_info.allow_pause_change and not My_cached_info.played_intro_sequence_last_frame:
      if (PLAYER.x_pos != 1168 and PLAYER.y_pos != 352) or MAP.region != 'Town':
        My_cached_info.allow_pause_change = False
        My_cached_info.pause_happened_this_frame = True
        time_before_pause = pygame.time.get_ticks()
        My_cached_info.currently_pausing = True
        pause_menu()
        My_cached_info.currently_pausing = False
        time_after_pause = pygame.time.get_ticks()
        pause_time = time_after_pause - time_before_pause
        if My_cached_info.return_to_main_menu:
          glDeleteTextures(My_cached_info.number_of_textures_to_delete, np.array(My_cached_info.texture_IDs_to_delete))
          everything_save_data(True, 83, str(My_cached_info.play_time))
          break
#
    if My_cached_info.won_the_game:
      My_cached_info.time_since_winning_game += delta_milliseconds
      regular_piston_sheath_update()
      PLAYER.has_piston1 = False
      PLAYER.has_piston2 = False
      if my_piston1.extension > 0:
        my_piston1.extension_float -= my_piston1.extension_float_added
        my_piston1.extension = int(my_piston1.extension_float)
        if my_piston1.extension <= 0:
          my_piston1.extension = 0
          my_piston1.extension_float = 0
      if my_piston2.extension > 0:
        my_piston2.extension_float -= my_piston2.extension_float_added
        my_piston2.extension = int(my_piston2.extension_float)
        if my_piston2.extension <= 0:
          my_piston2.extension = 0
          my_piston2.extension_float = 0
        my_piston2.grapple_claw_x_pos = 0
        my_piston2.grapple_claw_y_pos = 0
        regular_update_GrapplePiston(my_piston2)
      if my_piston1.extension == 0:
        MixerSounds['QUIET_WATER_JET'].stop()
        MixerSounds['LOUD_WATER_JET'].stop()
      if my_piston1.extension == 0:
        MixerSounds['ATTACH'].stop()
        MixerSounds['EXTEND'].stop()
        MixerSounds['RETRACT'].stop()
      if My_cached_info.time_since_winning_game >= 800:
        if My_cached_info.play_intro_machine_sound:
          My_cached_info.play_intro_machine_sound = False
          MixerSounds['THE_MACHINE1'].play(loops = -1, fade_ms = 400)
          MixerSounds['THE_MACHINE2'].play(loops = -1, fade_ms = 400)
          MixerSounds['THE_MACHINE3'].play(loops = -1, fade_ms = 400)
      if My_cached_info.time_since_winning_game >= 1200:
        everything_save_data(True, 87, '1')
        My_cached_info.play_intro_machine_sound = True
        play_won_the_game_sequence()
        if My_cached_info.return_to_main_menu:
          everything_save_data(True, 83, str(My_cached_info.play_time))
          glDeleteTextures(My_cached_info.number_of_textures_to_delete, np.array(My_cached_info.texture_IDs_to_delete))
          break
###
    My_cached_info.played_intro_sequence_last_frame = My_cached_info.play_intro_sequence
    if My_cached_info.playing_upgrade_sequence:
      if My_cached_info.milliseconds_into_upgrade_sequence >= My_cached_info.milliseconds_to_complete_upgrade_sequence:
        My_cached_info.playing_upgrade_sequence = False
        My_cached_info.milliseconds_into_upgrade_sequence = 0
        My_cached_info.milliseconds_into_upgrade_flying_around_player = 0
        My_cached_info.upgrade_finished_flying_around_player = False
###
    if My_cached_info.load_from_previous_location:
      PLAY_UPGRADE_CUTSCENE = False
      PLAY_UPGRADE_CUTSCENE_start_frame = 0
      PLAY_UPGRADE_CUTSCENE_end_frame = 0
      if MAP.region != 'TheDoor6':
        PLAYER.region = MAP.new_regions[My_cached_info.index_for_changing_regions][0]
      if MAP.region == 'TheDoor6':
        PLAYER.region = everything_save_data(False, 0, '')[62][0:-1]
      My_cached_info.last_map_region = MAP.region
      if MAP.region != 'TheDoor6':
        MAP.region = MAP.new_regions[My_cached_info.index_for_changing_regions][0]
      if MAP.region == 'TheDoor6':
        MAP.region = everything_save_data(False, 0, '')[62][0:-1]
      glDeleteTextures(My_cached_info.number_of_textures_to_delete, np.array(My_cached_info.texture_IDs_to_delete))
      My_cached_info.on_a_loading_screen = True
      threading.Thread(target=change_region, args = [(MAP, PLAYER, MAP.region, My_cached_info.index_for_changing_regions, False)]).start()
      loadingLoop(MAP.region)
      MAP.GPU_image = ((MAP.GPU_image[0][0], MAP.GPU_image[0][1]), loadTexture_only_OpenGL_stuff(MAP.GPU_image[0][0], MAP.GPU_image[0][1], MAP.GPU_image[1]))
      PRETTY_MAP.GPU_image = ((PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1]), loadTexture_only_OpenGL_stuff(PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1], PRETTY_MAP.GPU_image[1]))
      My_cached_info.number_of_textures_to_delete += 2
      My_cached_info.texture_IDs_to_delete.append(MAP.GPU_image[1])
      My_cached_info.texture_IDs_to_delete.append(PRETTY_MAP.GPU_image[1])
      get_drawing_functions()
###
    if Currently_pressed_controls.pressed_controls['INTERACT'] and PLAYER.allowed_door_privileges:
      for i in range(len(MAP.change_region_points)):
        if (MAP.change_region_points[i][0] <= PLAYER.x_pos <= MAP.change_region_points[i][1]) and (MAP.change_region_points[i][2] <= PLAYER.y_pos <= MAP.change_region_points[i][3]):
          if MAP.region != 'Town':
            PLAY_UPGRADE_CUTSCENE = False
            PLAY_UPGRADE_CUTSCENE_start_frame = 0
            PLAY_UPGRADE_CUTSCENE_end_frame = 0
            exiting_squirrel_level = False
            if PLAYER.region == 'TheDoor5':
              exiting_squirrel_level = True
            PLAYER.region = MAP.new_regions[i][0]
            My_cached_info.last_map_region = MAP.region
            MAP.region = MAP.new_regions[i][0]
            glDeleteTextures(My_cached_info.number_of_textures_to_delete, np.array(My_cached_info.texture_IDs_to_delete))
            My_cached_info.on_a_loading_screen = True
            threading.Thread(target=change_region, args = [(MAP, PLAYER, MAP.region, i, False)]).start()
            loadingLoop(MAP.region)
            MAP.GPU_image = ((MAP.GPU_image[0][0], MAP.GPU_image[0][1]), loadTexture_only_OpenGL_stuff(MAP.GPU_image[0][0], MAP.GPU_image[0][1], MAP.GPU_image[1]))
            PRETTY_MAP.GPU_image = ((PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1]), loadTexture_only_OpenGL_stuff(PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1], PRETTY_MAP.GPU_image[1]))
            My_cached_info.number_of_textures_to_delete += 2
            My_cached_info.texture_IDs_to_delete.append(MAP.GPU_image[1])
            My_cached_info.texture_IDs_to_delete.append(PRETTY_MAP.GPU_image[1])
            get_drawing_functions()
            if PLAYER.region == 'Forest' and exiting_squirrel_level:
              My_cached_info.leaving_the_door5 = True
            exiting_squirrel_level = False
            break
          else:
            if GARBAGE_CAN[0].player_is_inside:
              PLAY_UPGRADE_CUTSCENE = False
              PLAY_UPGRADE_CUTSCENE_start_frame = 0
              PLAY_UPGRADE_CUTSCENE_end_frame = 0
              PLAYER.region = MAP.new_regions[i][0]
              My_cached_info.last_map_region = MAP.region
              MAP.region = MAP.new_regions[i][0]
              glDeleteTextures(My_cached_info.number_of_textures_to_delete, np.array(My_cached_info.texture_IDs_to_delete))
              My_cached_info.on_a_loading_screen = True
              threading.Thread(target=change_region, args = [(MAP, PLAYER, MAP.region, i, False)]).start()
              loadingLoop(MAP.region)
              MAP.GPU_image = ((MAP.GPU_image[0][0], MAP.GPU_image[0][1]), loadTexture_only_OpenGL_stuff(MAP.GPU_image[0][0], MAP.GPU_image[0][1], MAP.GPU_image[1]))
              PRETTY_MAP.GPU_image = ((PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1]), loadTexture_only_OpenGL_stuff(PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1], PRETTY_MAP.GPU_image[1]))
              My_cached_info.number_of_textures_to_delete += 2
              My_cached_info.texture_IDs_to_delete.append(MAP.GPU_image[1])
              My_cached_info.texture_IDs_to_delete.append(PRETTY_MAP.GPU_image[1])
              get_drawing_functions()
              break
#
    if My_cached_info.leaving_intro:
      i = 0
      PLAY_UPGRADE_CUTSCENE = False
      PLAY_UPGRADE_CUTSCENE_start_frame = 0
      PLAY_UPGRADE_CUTSCENE_end_frame = 0
      PLAYER.region = MAP.new_regions[i][0]
      My_cached_info.last_map_region = MAP.region
      MAP.region = MAP.new_regions[i][0]
      glDeleteTextures(My_cached_info.number_of_textures_to_delete, np.array(My_cached_info.texture_IDs_to_delete))
      My_cached_info.on_a_loading_screen = True
      threading.Thread(target=change_region, args = [(MAP, PLAYER, MAP.region, i, False)]).start()
      loadingLoop(MAP.region)
      MAP.GPU_image = ((MAP.GPU_image[0][0], MAP.GPU_image[0][1]), loadTexture_only_OpenGL_stuff(MAP.GPU_image[0][0], MAP.GPU_image[0][1], MAP.GPU_image[1]))
      PRETTY_MAP.GPU_image = ((PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1]), loadTexture_only_OpenGL_stuff(PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1], PRETTY_MAP.GPU_image[1]))
      My_cached_info.number_of_textures_to_delete += 2
      My_cached_info.texture_IDs_to_delete.append(MAP.GPU_image[1])
      My_cached_info.texture_IDs_to_delete.append(PRETTY_MAP.GPU_image[1])
      get_drawing_functions()
      My_cached_info.leaving_intro = False
#
    if MAP.forced_exit:
      for i in range(len(MAP.forced_exit_points)):
        if ((MAP.forced_exit_points[i][0] <= PLAYER.x_pos <= MAP.forced_exit_points[i][1]) and (MAP.forced_exit_points[i][2] <= PLAYER.y_pos <= MAP.forced_exit_points[i][3])):
          PLAY_UPGRADE_CUTSCENE = False
          PLAY_UPGRADE_CUTSCENE_start_frame = 0
          PLAY_UPGRADE_CUTSCENE_end_frame = 0
          PLAYER.region = MAP.forced_exit_next_map[i][0]
          My_cached_info.last_map_region = MAP.region
          MAP.region = MAP.forced_exit_next_map[i][0]
          glDeleteTextures(My_cached_info.number_of_textures_to_delete, np.array(My_cached_info.texture_IDs_to_delete))
          My_cached_info.on_a_loading_screen = True
          threading.Thread(target=change_region, args = [(MAP, PLAYER, MAP.region, i, True)]).start()
          loadingLoop(MAP.region)
          MAP.GPU_image = ((MAP.GPU_image[0][0], MAP.GPU_image[0][1]), loadTexture_only_OpenGL_stuff(MAP.GPU_image[0][0], MAP.GPU_image[0][1], MAP.GPU_image[1]))
          PRETTY_MAP.GPU_image = ((PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1]), loadTexture_only_OpenGL_stuff(PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1], PRETTY_MAP.GPU_image[1]))
          My_cached_info.number_of_textures_to_delete += 2
          My_cached_info.texture_IDs_to_delete.append(MAP.GPU_image[1])
          My_cached_info.texture_IDs_to_delete.append(PRETTY_MAP.GPU_image[1])
          get_drawing_functions()
          break
        if QueenAnt != []:
          if QueenAnt.frames_since_entering > 200:
            PLAY_UPGRADE_CUTSCENE = False
            PLAY_UPGRADE_CUTSCENE_start_frame = 0
            PLAY_UPGRADE_CUTSCENE_end_frame = 0
            PLAYER.region = MAP.forced_exit_next_map[0][0]
            My_cached_info.last_map_region = MAP.region
            MAP.region = MAP.forced_exit_next_map[0][0]
            glDeleteTextures(My_cached_info.number_of_textures_to_delete, np.array(My_cached_info.texture_IDs_to_delete))
            My_cached_info.on_a_loading_screen = True
            threading.Thread(target=change_region, args = [(MAP, PLAYER, MAP.region, i, True)]).start()
            loadingLoop(MAP.region)
            MAP.GPU_image = ((MAP.GPU_image[0][0], MAP.GPU_image[0][1]), loadTexture_only_OpenGL_stuff(MAP.GPU_image[0][0], MAP.GPU_image[0][1], MAP.GPU_image[1]))
            PRETTY_MAP.GPU_image = ((PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1]), loadTexture_only_OpenGL_stuff(PRETTY_MAP.GPU_image[0][0], PRETTY_MAP.GPU_image[0][1], PRETTY_MAP.GPU_image[1]))
            My_cached_info.number_of_textures_to_delete += 2
            My_cached_info.texture_IDs_to_delete.append(MAP.GPU_image[1])
            My_cached_info.texture_IDs_to_delete.append(PRETTY_MAP.GPU_image[1])
            get_drawing_functions()
            break
###
    if my_piston1.extension == 0:
      for _ in range(My_cached_info.whole_number_of_frames_this_frame):
        PREVIOUS_PUSH_PISTON.append('NOTHING')
        PREVIOUS_PUSH_PISTON = PREVIOUS_PUSH_PISTON[1:]
###
    clock.tick(60)
    curr_time = pygame.time.get_ticks()
    if My_cached_info.pause_happened_this_frame:
      prev_time += pause_time
    if PLAYER.changed_region_last_frame:
      prev_time = curr_time - 13
    fps = (1 / (curr_time - prev_time))*1000
    delta_milliseconds = curr_time - prev_time
    if delta_milliseconds > 30:
      curr_time = pygame.time.get_ticks()
      prev_time = curr_time - 30
      delta_milliseconds = curr_time - prev_time
      fps = (1 / (curr_time - prev_time))*1000
    My_cached_info.play_time += delta_milliseconds
    prev_time = curr_time
    pygame.display.set_caption("{0}".format(title))
    fps /= 1.282
    My_cached_info.target_fps_over_fps = (target_fps / fps)
    My_cached_info.fake_frame_counter_float += My_cached_info.target_fps_over_fps
    My_cached_info.fake_frame_counter = round(My_cached_info.fake_frame_counter_float)
    My_cached_info.whole_number_of_frames_this_frame = math.floor(My_cached_info.target_fps_over_fps)
    My_cached_info.remainder_number_of_frames_for_next_frame += My_cached_info.target_fps_over_fps % 1
    if My_cached_info.remainder_number_of_frames_for_next_frame >= 1:
      My_cached_info.remainder_number_of_frames_for_next_frame -= 1
      My_cached_info.whole_number_of_frames_this_frame += 1
    my_piston1.extension_float_added = int(my_piston1.maximum_extension / 20) * My_cached_info.target_fps_over_fps
    my_piston2.extension_float_added = int(my_piston2.maximum_extension / 20) * My_cached_info.target_fps_over_fps
    My_cached_info.teleported = False

#GameLoop()


def main_pause_menu():
  global clock
  global aspect, screen_width, screen_height, Screen, available_screen_resolutions, current_screen_resolution_index, current_hotkeys, keys
  global current_music_loudness, current_sound_loudness
  global left_click, weird_click, right_click
  global My_cached_info
  global currently_playing_movie_index, movie_paths, movie_path, video
  movie_path = movie_paths[currently_playing_movie_index]
  My_cached_info = CachedInfo()
  pygame.mixer.stop()
  temporary_screen_resolution_index = current_screen_resolution_index
  current_resolution_image = OpenGLTextures['RESOLUTION_IMAGES'][temporary_screen_resolution_index]
  allow_screen_left_click = True
  touching_resolution = False
  shady_pixel = OpenGLTextures['SHADY_BLACK_PIXEL']
  shady_size_multiplier_x = screen_width
  shady_size_multiplier_y = screen_height
  shady_pixel = ((shady_pixel[0][0] * screen_width, shady_pixel[0][1] * screen_height), shady_pixel[1])
  map_width_adjustment = screen_width * (3 / 5)
  map_height_adjustment = screen_height * (2 / 3)
  map_rectangle = OpenGLTextures['PAUSE_MENU_RECTANGLE']
  map_rectangle = ((map_width_adjustment, map_height_adjustment), map_rectangle[1])
  map_Forest = (((map_width_adjustment / 2) - 2, (map_height_adjustment / 2) - 2), OpenGLTextures['FOREST_MINI'][1])
  map_Town = (((map_width_adjustment / 2) - 2, (map_height_adjustment / 2) - 2), OpenGLTextures['TOWN_MINI'][1])
  map_AntHill = (((map_width_adjustment / 2) - 2, (map_height_adjustment / 2) - 2), OpenGLTextures['ANTHILL_MINI'][1])
  map_Sewer = (((map_width_adjustment / 2) - 2, (map_height_adjustment / 2) - 2), OpenGLTextures['SEWER_MINI'][1])
  adjust_door_pos_x = map_width_adjustment / 24000
  adjust_door_pos_y = map_height_adjustment / 12000
  mini_hamster = (0, 0)
  touching_a_travel = False
  touching_which_travel = [False for x in range(12)]
  door_size_adjustment = screen_height / 20
  adjusted_the_door = ((door_size_adjustment, door_size_adjustment), OpenGLTextures['THE_DOOR'][1])
  adjusted_shaded_the_door = ((door_size_adjustment, door_size_adjustment), OpenGLTextures['SHADED_THE_DOOR'][1])
  adjusted_outline_the_door = ((door_size_adjustment * (95 / 85), door_size_adjustment * (95 / 85)), OpenGLTextures['OUTLINE_THE_DOOR'][1])
  available_width_for_upgrades = ((3 / 10) * screen_width)
  single_upgrade_width_and_height = available_width_for_upgrades / 7
  single_highlight_width_and_height = single_upgrade_width_and_height * (75 / 69)
  move_highlight_left_and_up = (single_highlight_width_and_height - single_upgrade_width_and_height) / 2
  bottom_total_available_gap_size = available_width_for_upgrades - (4 * single_upgrade_width_and_height)
  single_gap_size = bottom_total_available_gap_size / 5
  piston1_x = single_upgrade_width_and_height * ((69 - 34) / 2) / 69
  piston1_y = single_upgrade_width_and_height * (14 / 69)
  piston1_width = single_upgrade_width_and_height * (34 / 69)
  piston1_height = single_upgrade_width_and_height * (9 / 69)
  piston2_x = single_upgrade_width_and_height * ((69 - 24) / 2) / 69
  piston2_y = single_upgrade_width_and_height * (31 / 69)
  piston2_width = single_upgrade_width_and_height * (24 / 69)
  piston2_height = single_upgrade_width_and_height * (26 / 69)
  upgrade_distance_from_top = ((screen_height * (1 / 6)) - single_upgrade_width_and_height) / 2
  available_menu_width = (1 / 3) * screen_width
  available_menu_height = screen_height
  empty_menu_width = (1 / 54) * screen_width
  actual_menu_width = available_menu_width - (2 * empty_menu_width)
  actual_menu_height = available_menu_height
  original_option_menu_width = 600
  original_option_menu_height = 800
  menu_width_aspect = actual_menu_width / original_option_menu_width
  menu_height_aspect = actual_menu_height / original_option_menu_height
  menu_option_height = 176
  show_toggle_full_screen = False
  space_between_menu_options = ((original_option_menu_height - (3 * menu_option_height)) / 4) * menu_height_aspect
  menu_option_height = menu_option_height * menu_height_aspect
  adjusted_continue = ((OpenGLTextures['CONTINUE'][0][0] * menu_width_aspect, OpenGLTextures['CONTINUE'][0][1] * menu_height_aspect), OpenGLTextures['CONTINUE'][1])
  adjusted_options = ((OpenGLTextures['OPTIONS'][0][0] * menu_width_aspect, OpenGLTextures['OPTIONS'][0][1] * menu_height_aspect), OpenGLTextures['OPTIONS'][1])
  adjusted_main_menu = ((OpenGLTextures['MAIN_MENU'][0][0] * menu_width_aspect, OpenGLTextures['MAIN_MENU'][0][1] * menu_height_aspect), OpenGLTextures['MAIN_MENU'][1])
  menu_option_width = OpenGLTextures['CONTINUE'][0][0] * menu_width_aspect
  option_menu_height = 160 * menu_height_aspect
  space_between_option_menu_options = 32 * menu_height_aspect
  adjusted_back = ((OpenGLTextures['BACK'][0][0] * menu_width_aspect, option_menu_height), OpenGLTextures['BACK'][1])
  adjusted_screen = ((OpenGLTextures['SCREEN_OPTIONS'][0][0] * menu_width_aspect, option_menu_height), OpenGLTextures['SCREEN_OPTIONS'][1])
  adjusted_sound = ((OpenGLTextures['SOUND'][0][0] * menu_width_aspect, option_menu_height), OpenGLTextures['SOUND'][1])
  adjusted_hotkeys = ((OpenGLTextures['HOTKEYS'][0][0] * menu_width_aspect, option_menu_height), OpenGLTextures['HOTKEYS'][1])
  adjusted_options_shiny_outside = ((OpenGLTextures['SHINY_OUTSIDE'][0][0] * menu_width_aspect, 176 * menu_height_aspect), OpenGLTextures['SHINY_OUTSIDE'][1])
  adjusted_chain = ((OpenGLTextures['CHAIN'][0][0], (2.5 * menu_option_height) + (3 * space_between_menu_options)), OpenGLTextures['CHAIN'][1])
  adjusted_options_chain = ((OpenGLTextures['CHAIN'][0][0], (3.5 * option_menu_height) + (4 * space_between_option_menu_options)), OpenGLTextures['CHAIN'][1])
  adjusted_shiny_outside = ((OpenGLTextures['SHINY_OUTSIDE'][0][0] * menu_width_aspect, OpenGLTextures['SHINY_OUTSIDE'][0][1] * menu_height_aspect), OpenGLTextures['SHINY_OUTSIDE'][1])
  adjusted_screen_back = ((OpenGLTextures['BACK'][0][0] * menu_width_aspect, OpenGLTextures['BACK'][0][1] * menu_height_aspect), OpenGLTextures['BACK'][1])
  adjusted_resolution = ((OpenGLTextures['RESOLUTION'][0][0] * menu_width_aspect, OpenGLTextures['RESOLUTION'][0][1] * menu_height_aspect), OpenGLTextures['RESOLUTION'][1])
  adjusted_full_screen = ((OpenGLTextures['FULL_SCREEN'][0][0] * menu_width_aspect, OpenGLTextures['FULL_SCREEN'][0][1] * menu_height_aspect), OpenGLTextures['FULL_SCREEN'][1])
  adjusted_windowed = ((OpenGLTextures['WINDOWED'][0][0] * menu_width_aspect, OpenGLTextures['WINDOWED'][0][1] * menu_height_aspect), OpenGLTextures['WINDOWED'][1])
  adjusted_screen_back = ((OpenGLTextures['BACK'][0][0] * menu_width_aspect, OpenGLTextures['BACK'][0][1] * menu_height_aspect), OpenGLTextures['BACK'][1])
  change_screen_note_aspect = (screen_width / 1.45) / OpenGLTextures['CHANGE_RESOLUTION_NOTE'][0][0]
  adjusted_resolution_note = ((OpenGLTextures['CHANGE_RESOLUTION_NOTE'][0][0] * change_screen_note_aspect, OpenGLTextures['CHANGE_RESOLUTION_NOTE'][0][1] * change_screen_note_aspect), OpenGLTextures['CHANGE_RESOLUTION_NOTE'][1])
  sound_adjustment_bar_width = (48/100) * screen_width
  adjusted_sound_bar_being_moved = ((OpenGLTextures['SOUND_BAR_BEING_MOVED'][0][0], OpenGLTextures['SOUND_BAR_BEING_MOVED'][0][1]), OpenGLTextures['SOUND_BAR_BEING_MOVED'][1])
  adjusted_sound_adjustment_bar = ((sound_adjustment_bar_width, OpenGLTextures['SOUND_ADJUSTMENT_BAR'][0][1]), OpenGLTextures['SOUND_ADJUSTMENT_BAR'][1])
  move_letters_down = screen_height / 11
  adjusted_letters_aspect_x = ((3 / 10) * screen_width) / 99
  adjusted_letters_aspect_y = adjusted_letters_aspect_x
  adjusted_hotkey_outline = (((58 / 100) * screen_width, ((2 * (screen_height / 11)) / 10) + (5 * adjusted_letters_aspect_y)), OpenGLTextures['HOTKEY_OUTLINE'][1])
  adjusted_grapple_portion = ((OpenGLTextures['GRAPPLE_PORTION'][0][0] * (single_upgrade_width_and_height / OpenGLTextures['BUBBLE'][0][0]), OpenGLTextures['GRAPPLE_PORTION'][0][1] * (single_upgrade_width_and_height / OpenGLTextures['BUBBLE'][0][1])), OpenGLTextures['GRAPPLE_PORTION'][1])
  default_menu_option_collision = PyGameTextures['MENU_OPTION_SIZING']
  mouse_collision = PyGameTextures['ACTUAL_MOUSE']
  regular_menu_option = pygame.transform.scale(default_menu_option_collision, (536 * menu_width_aspect, 176 * menu_height_aspect))
  flipped_menu_option = pygame.transform.flip(regular_menu_option, True, False)
  current_scaled_menu_option_collisions = [regular_menu_option, flipped_menu_option, regular_menu_option]
  current_scaled_menu_option_collisions = [pygame.mask.from_surface(x) for x in current_scaled_menu_option_collisions]
  regular_option_menu_collision = pygame.transform.scale(default_menu_option_collision, (536 * menu_width_aspect, 160 * menu_height_aspect))
  flipped_option_menu_collision = pygame.transform.flip(regular_option_menu_collision, True, False)
  option_menu_collisions = [regular_option_menu_collision, flipped_option_menu_collision, regular_option_menu_collision, flipped_option_menu_collision]
  option_menu_collisions = [pygame.mask.from_surface(x) for x in option_menu_collisions]
  mouse_collision = pygame.mask.from_surface(mouse_collision)
  scrolling_toward_continue_options_main_menu = False
  scrolling_away_continue_options_main_menu = False
  showing_continue_options_main_menu = False
  scrolling_toward_options = True
  scrolling_away_option = False
  showing_options = True
  scrolling_toward_screen = False
  scrolling_away_screen = False
  showing_option_menu_screen = False
  scrolling_toward_sound = False
  scrolling_away_sound = False
  showing_sound = False
  scrolling_toward_hotkey = False
  scrolling_away_hotkey = False
  showing_hotkey = False
  allow_another_option_to_scroll_down = True
  option_press_back = False
  option_press_screen = False
  option_press_sound = False
  option_press_hotkey = False
  started_scrolling_time = pygame.time.get_ticks()
  holding_music_bar = False
  holding_sound_bar = False
  allow_full_screen_toggle = True
  touching_Forest = False
  touching_Town = False
  touching_AntHill = False
  touching_Sewer = False
  touching_Forest_region = [math.floor((1 / 3) * screen_width), math.ceil(((1 / 3) * screen_width) + ((3 / 10) * screen_width)), math.floor((1 / 6) * screen_height), math.ceil(((1 / 2) * screen_height))]
  touching_Town_region = [math.floor(((1 / 3) * screen_width) + ((3 / 10) * screen_width)), math.ceil(((1 / 3) * screen_width) + ((3 / 10) * screen_width) + ((3 / 10) * screen_width)), math.floor((1 / 6) * screen_height), math.ceil(((1 / 2) * screen_height))]
  touching_AntHill_region = [math.floor((1 / 3) * screen_width), math.ceil(((1 / 3) * screen_width) + ((3 / 10) * screen_width)), math.floor(((1 / 6) * screen_height) + ((1 / 3) * screen_height)), math.ceil(((1 / 2) * screen_height) + ((1 / 3) * screen_height))]
  touching_Sewer_region = [math.floor(((1 / 3) * screen_width) + ((3 / 10) * screen_width)), math.ceil(((1 / 3) * screen_width) + ((3 / 10) * screen_width) + ((3 / 10) * screen_width)), math.floor(((1 / 6) * screen_height) + ((1 / 3) * screen_height)), math.ceil(((1 / 2) * screen_height) + ((1 / 3) * screen_height))]
  touching_hotkey_region_x = [math.floor(((36 / 100) * screen_width)), math.ceil(((94 / 100) * screen_width))]
  number_of_pixels_to_move = 0
  temporary_current_hotkeys = current_hotkeys.copy()
  time_since_saving_hotkeys = 5000
  global Mouse_x, Mouse_y
  pause_curr_time = pygame.time.get_ticks()
  pause_prev_time = pause_curr_time
  pause_target_delta_milliseconds = 13
  pause_delta_milliseconds = pause_target_delta_milliseconds
  pause_curr_time += pause_target_delta_milliseconds
  pause_menu_timer = 0
  Mouse_x, Mouse_y = pygame.mouse.get_pos()
  elapsed_fps_float = 1
  frames_this_frame = 1
  frames_this_frame_remainder = 0
  while True:
    for event in pygame.event.get():
      if event.type == pygame.QUIT:
        everything_save_data(True, 83, str(My_cached_info.play_time))
        raise SystemExit
      elif My_cached_info.close_the_game:
        everything_save_data(True, 83, str(My_cached_info.play_time))
        raise SystemExit
    #
    show_select_new_key_message = False
    show_toggle_full_screen = False
    display_resolution_note = False
    last_mouse_x, last_mouse_y = Mouse_x, Mouse_y
    Mouse_x, Mouse_y = pygame.mouse.get_pos()
    keys = pygame.key.get_pressed()
    left_click, weird_click, right_click = pygame.mouse.get_pressed()
    update_pressed_controls()
    if not Currently_pressed_controls.pressed_controls['PAUSE']:
      My_cached_info.allow_pause_change = True
    if Currently_pressed_controls.pressed_controls['PAUSE'] and My_cached_info.allow_pause_change:
      My_cached_info.allow_pause_change = False
      break
    if showing_continue_options_main_menu:
      break
    #
    #
    try:
      temp_frames_this_frame = frames_this_frame
      if temp_frames_this_frame > 2:
        temp_frames_this_frame = 2
      for _ in range(temp_frames_this_frame):
        ret = video.grab()
      ret, video_textData = video.retrieve()
      video_textData = cv2.cvtColor(video_textData, cv2.COLOR_BGR2RGB)
      loaded_texture = loadTexture_movie(video_textData)
    except:
      originally_playing_movie_index = currently_playing_movie_index
      while True:
        if originally_playing_movie_index != currently_playing_movie_index:
          break
        currently_playing_movie_index = random.randint(0, 2)
      movie_path = movie_paths[currently_playing_movie_index]
      video = cv2.VideoCapture(movie_path)
      success, video_textData = video.read()
      video_textData = cv2.cvtColor(video_textData, cv2.COLOR_BGR2RGB)
      loaded_texture = loadTexture_movie(video_textData)
    make_opengl_rect((1920, 1080), loaded_texture[1], (-(1920 - screen_width) / 2, -(1080 - screen_height) / 2), 0, False, (0, 0, 1920, 1080))
    glDeleteTextures(1, np.array([loaded_texture[1]]))
    #
    #make_opengl_rect(shady_pixel[0], shady_pixel[1], (0, 0), 0, False, (0, 0, shady_pixel[0][0], shady_pixel[0][1]))
    #
    touching_a_travel = False
    touching_which_travel = [False for x in range(12)]
    #
    #
    #
    #
    if showing_continue_options_main_menu:
      menu_scroll_y = 0
      percent_of_the_way_through_scrolling = (pause_curr_time - started_scrolling_time) / 500
      if scrolling_toward_continue_options_main_menu:
        allow_another_option_to_scroll_down = False
        menu_scroll_y = -abs((1 - percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_toward_continue_options_main_menu = False
      if scrolling_away_continue_options_main_menu:
        allow_another_option_to_scroll_down = False
        menu_scroll_y = -abs((percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_away_continue_options_main_menu = False
          showing_continue_options_main_menu = False
          showing_options = True
          started_scrolling_time = pygame.time.get_ticks()
      if percent_of_the_way_through_scrolling >= 1:
        allow_another_option_to_scroll_down = True
        started_scrolling_time = pygame.time.get_ticks()
      #
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + menu_option_width - OpenGLTextures['CHAIN'][0][0] - ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      #
      if menu_scroll_y == 0:
        touching_continue_points, touching_continue = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - space_between_menu_options)
        if touching_continue:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), space_between_menu_options - (10 * menu_height_aspect)), 0, False, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            My_cached_info.allow_pause_change = False
            break
      make_opengl_rect(adjusted_continue[0], adjusted_continue[1], (empty_menu_width, space_between_menu_options + menu_scroll_y), 0, False, (0, 0, adjusted_continue[0][0], adjusted_continue[0][1]))
      #
      if menu_scroll_y == 0:
        touching_options_points, touching_options = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[1], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - (menu_option_height + (2 * space_between_menu_options)))
        if touching_options:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), menu_option_height + (2 * space_between_menu_options) - (10 * menu_height_aspect)), 0, True, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            started_scrolling_time = pygame.time.get_ticks()
            scrolling_toward_continue_options_main_menu = False
            scrolling_away_continue_options_main_menu = True
            showing_continue_options_main_menu = True
            scrolling_toward_options = True
      make_opengl_rect(adjusted_options[0], adjusted_options[1], (empty_menu_width, menu_option_height + (2 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_options[0][0], adjusted_options[0][1]))
      #
      if menu_scroll_y == 0:
        touching_main_menu_points, touching_main_menu = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - ((2 * menu_option_height) + (3 * space_between_menu_options)))
        if touching_main_menu:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), (2 * menu_option_height) + (3 * space_between_menu_options) - (10 * menu_height_aspect)), 0, False, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            My_cached_info.return_to_main_menu = True
            break
      make_opengl_rect(adjusted_main_menu[0], adjusted_main_menu[1], (empty_menu_width, (2 * menu_option_height) + (3 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_main_menu[0][0], adjusted_main_menu[0][1]))
    #
    #
    if showing_options and allow_another_option_to_scroll_down:
      menu_scroll_y = 0
      percent_of_the_way_through_scrolling = (pause_curr_time - started_scrolling_time) / 500
      if scrolling_toward_options:
        menu_scroll_y = -abs((1 - percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_toward_options = False
      if scrolling_away_option:
        menu_scroll_y = -abs((percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          if option_press_back:
            scrolling_away_option = False
            showing_options = False
            showing_continue_options_main_menu = True
            option_press_back = False
          if option_press_screen:
            scrolling_away_option = False
            showing_options = False
            showing_option_menu_screen = True
            scrolling_toward_screen = True
            option_press_screen = False
          if option_press_sound:
            scrolling_away_option = False
            showing_options = False
            showing_sound = True
            scrolling_toward_sound = True
            option_press_sound = False
          if option_press_hotkey:
            temporary_current_hotkeys = current_hotkeys.copy()
            scrolling_away_option = False
            showing_options = False
            showing_hotkey = True
            scrolling_toward_hotkey = True
            option_press_hotkey = False
          started_scrolling_time = pygame.time.get_ticks()
      if percent_of_the_way_through_scrolling >= 1:
        allow_another_option_to_scroll_down = True
        started_scrolling_time = pygame.time.get_ticks()
      #
      make_opengl_rect(adjusted_options_chain[0], adjusted_options_chain[1], (empty_menu_width + ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_options_chain[0][0], adjusted_options_chain[0][1]))
      make_opengl_rect(adjusted_options_chain[0], adjusted_options_chain[1], (empty_menu_width + menu_option_width - OpenGLTextures['CHAIN'][0][0] - ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_options_chain[0][0], adjusted_options_chain[0][1]))
      #
      if menu_scroll_y == 0:
        touching_back_points, touching_back = find_collisions_with_offsets_pause_menu(mouse_collision, option_menu_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - space_between_option_menu_options)
        if touching_back:
          make_opengl_rect(adjusted_options_shiny_outside[0], adjusted_options_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect * (160 / 176)), space_between_option_menu_options - (10 * menu_height_aspect * (160 / 176))), 0, False, (0, 0, adjusted_options_shiny_outside[0][0], adjusted_options_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            scrolling_away_option = True
            scrolling_toward_continue_options_main_menu = True
            option_press_back = True
            started_scrolling_time = pygame.time.get_ticks()
      make_opengl_rect(adjusted_back[0], adjusted_back[1], (empty_menu_width, space_between_option_menu_options + menu_scroll_y), 0, False, (0, 0, adjusted_back[0][0], adjusted_back[0][1]))
      #
      if menu_scroll_y == 0:
        touching_screen_points, touching_screen = find_collisions_with_offsets_pause_menu(mouse_collision, option_menu_collisions[1], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - (option_menu_height + (2 * space_between_option_menu_options)))
        if touching_screen:
          make_opengl_rect(adjusted_options_shiny_outside[0], adjusted_options_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect * (160 / 176)), option_menu_height + (2 * space_between_option_menu_options) - (10 * menu_height_aspect * (160 / 176))), 0, True, (0, 0, adjusted_options_shiny_outside[0][0], adjusted_options_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            scrolling_away_option = True
            option_press_screen = True
            scrolling_toward_screen = True
            started_scrolling_time = pygame.time.get_ticks()
      make_opengl_rect(adjusted_screen[0], adjusted_screen[1], (empty_menu_width, option_menu_height + (2 * space_between_option_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_screen[0][0], adjusted_screen[0][1]))
      #
      if menu_scroll_y == 0:
        touching_sound_points, touching_sound = find_collisions_with_offsets_pause_menu(mouse_collision, option_menu_collisions[2], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - ((2 * option_menu_height) + (3 * space_between_option_menu_options)))
        if touching_sound:
          make_opengl_rect(adjusted_options_shiny_outside[0], adjusted_options_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect * (160 / 176)), (2 * option_menu_height) + (3 * space_between_option_menu_options) - (10 * menu_height_aspect * (160 / 176))), 0, False, (0, 0, adjusted_options_shiny_outside[0][0], adjusted_options_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            scrolling_away_option = True
            option_press_sound = True
            scrolling_toward_sound = True
            started_scrolling_time = pygame.time.get_ticks()
      make_opengl_rect(adjusted_sound[0], adjusted_sound[1], (empty_menu_width, (2 * option_menu_height) + (3 * space_between_option_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_sound[0][0], adjusted_sound[0][1]))
      #
      if menu_scroll_y == 0:
        touching_hotkeys_points, touching_hotkeys = find_collisions_with_offsets_pause_menu(mouse_collision, option_menu_collisions[3], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - ((3 * option_menu_height) + (4 * space_between_option_menu_options)))
        if touching_hotkeys:
          make_opengl_rect(adjusted_options_shiny_outside[0], adjusted_options_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect * (160 / 176)), (3 * option_menu_height) + (4 * space_between_option_menu_options) - (10 * menu_height_aspect * (160 / 176))), 0, True, (0, 0, adjusted_options_shiny_outside[0][0], adjusted_options_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            scrolling_away_option = True
            option_press_hotkey = True
            scrolling_toward_hotkey = True
            started_scrolling_time = pygame.time.get_ticks()
      make_opengl_rect(adjusted_hotkeys[0], adjusted_hotkeys[1], (empty_menu_width, (3 * option_menu_height) + (4 * space_between_option_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_hotkeys[0][0], adjusted_hotkeys[0][1]))
    #
    #
    #
    if showing_option_menu_screen:
      menu_scroll_y = 0
      percent_of_the_way_through_scrolling = (pause_curr_time - started_scrolling_time) / 500
      if scrolling_toward_screen:
        menu_scroll_y = -abs((1 - percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_toward_screen = False
      if scrolling_away_screen:
        allow_another_option_to_scroll_down = False
        menu_scroll_y = -abs((percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_away_screen = False
          showing_option_menu_screen = False
          showing_options = True
          started_scrolling_time = pygame.time.get_ticks()
      if percent_of_the_way_through_scrolling >= 1:
        allow_another_option_to_scroll_down = True
        started_scrolling_time = pygame.time.get_ticks()
      #
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + menu_option_width - OpenGLTextures['CHAIN'][0][0] - ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      #
      if menu_scroll_y == 0:
        touching_back_points, touching_back = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - space_between_menu_options)
        if touching_back:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), space_between_menu_options - (10 * menu_height_aspect)), 0, False, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            started_scrolling_time = pygame.time.get_ticks()
            scrolling_toward_screen = False
            scrolling_away_screen = True
            showing_options = True
            scrolling_toward_options = True
      make_opengl_rect(adjusted_screen_back[0], adjusted_screen_back[1], (empty_menu_width, space_between_menu_options + menu_scroll_y), 0, False, (0, 0, adjusted_screen_back[0][0], adjusted_screen_back[0][1]))
      #
      if menu_scroll_y == 0:
        touching_resolution_points, touching_resolution = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[1], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - (menu_option_height + (2 * space_between_menu_options)))
        if touching_resolution:
          display_resolution_note = True
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), menu_option_height + (2 * space_between_menu_options) - (10 * menu_height_aspect)), 0, True, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          make_opengl_rect(adjusted_resolution[0], current_resolution_image[1], (empty_menu_width, menu_option_height + (2 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_resolution[0][0], adjusted_resolution[0][1]))
          if not left_click and not Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            allow_screen_left_click = True
          if (left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']) and allow_screen_left_click:
            allow_screen_left_click = False
            temporary_screen_resolution_index += 1
            if temporary_screen_resolution_index >= len(available_screen_resolutions):
              temporary_screen_resolution_index = 0
            current_resolution_image = OpenGLTextures['RESOLUTION_IMAGES'][temporary_screen_resolution_index]
          if keys[pygame.K_RETURN]:
            old_screen_width, old_screen_height = screen_width, screen_height
            screen_width, screen_height = int(available_screen_resolutions[temporary_screen_resolution_index][0] / monitor_scaling_factor), int(available_screen_resolutions[temporary_screen_resolution_index][1] / monitor_scaling_factor)
            os.environ['SDL_VIDEO_CENTERED'] = '1'
            pygame.display.quit()
            pygame.init()
            if vsync_is_working:
              Screen = pygame.display.set_mode((screen_width, screen_height), pygame.HWSURFACE | pygame.DOUBLEBUF | pygame.OPENGL, vsync=1)
            if not vsync_is_working:
              Screen = pygame.display.set_mode((screen_width, screen_height), pygame.HWSURFACE | pygame.DOUBLEBUF | pygame.OPENGL)
            #pygame.display.toggle_fullscreen()
            logo_img = pygame.image.load(path + '\Images/Logo.png')
            pygame.display.set_icon(logo_img)
            pygame.display.set_caption(title)
            aspect = screen_width / screen_height
            glEnable(GL_BLEND)
            glBlendEquation(GL_FUNC_ADD)
            glMatrixMode(GL_PROJECTION)
            glLoadIdentity()
            glOrtho(-aspect, aspect, -1, 1, -1, 1)
            glMatrixMode(GL_MODELVIEW)
            glLoadIdentity()
            glClear(GL_COLOR_BUFFER_BIT)
            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
            global LOADING_HAMSTER_FACE_IMAGE
            LOADING_HAMSTER_FACE_IMAGE = loadTexture(path + '\Images/LoadingHamsterFace.png')
            time.sleep(0.25)
            make_opengl_rect((screen_width, screen_height), LOADING_HAMSTER_FACE_IMAGE[1], (0, 0), 0, False, (0, 0, screen_width, screen_height))
            pygame.display.flip()
            for event in pygame.event.get():
              break
            load_OpenGLTextures()
            pygame.mouse.set_visible(False)
            current_screen_resolution_index = temporary_screen_resolution_index
            #
            temporary_screen_resolution_index = current_screen_resolution_index
            current_resolution_image = OpenGLTextures['RESOLUTION_IMAGES'][temporary_screen_resolution_index]
            shady_pixel = OpenGLTextures['SHADY_BLACK_PIXEL']
            shady_size_multiplier_x = screen_width
            shady_size_multiplier_y = screen_height
            shady_pixel = ((shady_pixel[0][0] * screen_width, shady_pixel[0][1] * screen_height), shady_pixel[1])
            map_width_adjustment = screen_width * (3 / 5)
            map_height_adjustment = screen_height * (2 / 3)
            map_rectangle = OpenGLTextures['PAUSE_MENU_RECTANGLE']
            map_rectangle = ((map_width_adjustment, map_height_adjustment), map_rectangle[1])
            map_Forest = (((map_width_adjustment / 2) - 2, (map_height_adjustment / 2) - 2), OpenGLTextures['FOREST_MINI'][1])
            map_Town = (((map_width_adjustment / 2) - 2, (map_height_adjustment / 2) - 2), OpenGLTextures['TOWN_MINI'][1])
            map_AntHill = (((map_width_adjustment / 2) - 2, (map_height_adjustment / 2) - 2), OpenGLTextures['ANTHILL_MINI'][1])
            map_Sewer = (((map_width_adjustment / 2) - 2, (map_height_adjustment / 2) - 2), OpenGLTextures['SEWER_MINI'][1])
            adjust_door_pos_x = map_width_adjustment / 24000
            adjust_door_pos_y = map_height_adjustment / 12000
            mini_hamster = (0, 0)
            touching_which_travel = [False for x in range(12)]
            door_size_adjustment = screen_height / 20
            adjusted_the_door = ((door_size_adjustment, door_size_adjustment), OpenGLTextures['THE_DOOR'][1])
            adjusted_shaded_the_door = ((door_size_adjustment, door_size_adjustment), OpenGLTextures['SHADED_THE_DOOR'][1])
            adjusted_outline_the_door = ((door_size_adjustment * (95 / 85), door_size_adjustment * (95 / 85)), OpenGLTextures['OUTLINE_THE_DOOR'][1])
            available_width_for_upgrades = ((3 / 10) * screen_width)
            single_upgrade_width_and_height = available_width_for_upgrades / 7
            single_highlight_width_and_height = single_upgrade_width_and_height * (75 / 69)
            move_highlight_left_and_up = (single_highlight_width_and_height - single_upgrade_width_and_height) / 2
            bottom_total_available_gap_size = available_width_for_upgrades - (4 * single_upgrade_width_and_height)
            single_gap_size = bottom_total_available_gap_size / 5
            piston1_x = single_upgrade_width_and_height * ((69 - 34) / 2) / 69
            piston1_y = single_upgrade_width_and_height * (14 / 69)
            piston1_width = single_upgrade_width_and_height * (34 / 69)
            piston1_height = single_upgrade_width_and_height * (9 / 69)
            piston2_x = single_upgrade_width_and_height * ((69 - 24) / 2) / 69
            piston2_y = single_upgrade_width_and_height * (31 / 69)
            piston2_width = single_upgrade_width_and_height * (24 / 69)
            piston2_height = single_upgrade_width_and_height * (26 / 69)
            upgrade_distance_from_top = ((screen_height * (1 / 6)) - single_upgrade_width_and_height) / 2
            available_menu_width = (1 / 3) * screen_width
            available_menu_height = screen_height
            empty_menu_width = (1 / 54) * screen_width
            actual_menu_width = available_menu_width - (2 * empty_menu_width)
            actual_menu_height = available_menu_height
            original_option_menu_width = 600
            original_option_menu_height = 800
            menu_width_aspect = actual_menu_width / original_option_menu_width
            menu_height_aspect = actual_menu_height / original_option_menu_height
            menu_option_height = 176
            space_between_menu_options = ((original_option_menu_height - (3 * menu_option_height)) / 4) * menu_height_aspect
            menu_option_height = menu_option_height * menu_height_aspect
            adjusted_continue = ((OpenGLTextures['CONTINUE'][0][0] * menu_width_aspect, OpenGLTextures['CONTINUE'][0][1] * menu_height_aspect), OpenGLTextures['CONTINUE'][1])
            adjusted_options = ((OpenGLTextures['OPTIONS'][0][0] * menu_width_aspect, OpenGLTextures['OPTIONS'][0][1] * menu_height_aspect), OpenGLTextures['OPTIONS'][1])
            adjusted_main_menu = ((OpenGLTextures['MAIN_MENU'][0][0] * menu_width_aspect, OpenGLTextures['MAIN_MENU'][0][1] * menu_height_aspect), OpenGLTextures['MAIN_MENU'][1])
            menu_option_width = OpenGLTextures['CONTINUE'][0][0] * menu_width_aspect
            option_menu_height = 160 * menu_height_aspect
            space_between_option_menu_options = 32 * menu_height_aspect
            adjusted_back = ((OpenGLTextures['BACK'][0][0] * menu_width_aspect, option_menu_height), OpenGLTextures['BACK'][1])
            adjusted_screen = ((OpenGLTextures['SCREEN_OPTIONS'][0][0] * menu_width_aspect, option_menu_height), OpenGLTextures['SCREEN_OPTIONS'][1])
            adjusted_sound = ((OpenGLTextures['SOUND'][0][0] * menu_width_aspect, option_menu_height), OpenGLTextures['SOUND'][1])
            adjusted_hotkeys = ((OpenGLTextures['HOTKEYS'][0][0] * menu_width_aspect, option_menu_height), OpenGLTextures['HOTKEYS'][1])
            adjusted_options_shiny_outside = ((OpenGLTextures['SHINY_OUTSIDE'][0][0] * menu_width_aspect, 176 * menu_height_aspect), OpenGLTextures['SHINY_OUTSIDE'][1])
            adjusted_chain = ((OpenGLTextures['CHAIN'][0][0], (2.5 * menu_option_height) + (3 * space_between_menu_options)), OpenGLTextures['CHAIN'][1])
            adjusted_options_chain = ((OpenGLTextures['CHAIN'][0][0], (3.5 * option_menu_height) + (4 * space_between_option_menu_options)), OpenGLTextures['CHAIN'][1])
            adjusted_shiny_outside = ((OpenGLTextures['SHINY_OUTSIDE'][0][0] * menu_width_aspect, OpenGLTextures['SHINY_OUTSIDE'][0][1] * menu_height_aspect), OpenGLTextures['SHINY_OUTSIDE'][1])
            adjusted_screen_back = ((OpenGLTextures['BACK'][0][0] * menu_width_aspect, OpenGLTextures['BACK'][0][1] * menu_height_aspect), OpenGLTextures['BACK'][1])
            adjusted_resolution = ((OpenGLTextures['RESOLUTION'][0][0] * menu_width_aspect, OpenGLTextures['RESOLUTION'][0][1] * menu_height_aspect), OpenGLTextures['RESOLUTION'][1])
            adjusted_full_screen = ((OpenGLTextures['FULL_SCREEN'][0][0] * menu_width_aspect, OpenGLTextures['FULL_SCREEN'][0][1] * menu_height_aspect), OpenGLTextures['FULL_SCREEN'][1])
            adjusted_windowed = ((OpenGLTextures['WINDOWED'][0][0] * menu_width_aspect, OpenGLTextures['WINDOWED'][0][1] * menu_height_aspect), OpenGLTextures['WINDOWED'][1])
            adjusted_screen_back = ((OpenGLTextures['BACK'][0][0] * menu_width_aspect, OpenGLTextures['BACK'][0][1] * menu_height_aspect), OpenGLTextures['BACK'][1])
            change_screen_note_aspect = (screen_width / 1.45) / OpenGLTextures['CHANGE_RESOLUTION_NOTE'][0][0]
            adjusted_resolution_note = ((OpenGLTextures['CHANGE_RESOLUTION_NOTE'][0][0] * change_screen_note_aspect, OpenGLTextures['CHANGE_RESOLUTION_NOTE'][0][1] * change_screen_note_aspect), OpenGLTextures['CHANGE_RESOLUTION_NOTE'][1])
            sound_adjustment_bar_width = (48/100) * screen_width
            adjusted_sound_bar_being_moved = ((OpenGLTextures['SOUND_BAR_BEING_MOVED'][0][0], OpenGLTextures['SOUND_BAR_BEING_MOVED'][0][1]), OpenGLTextures['SOUND_BAR_BEING_MOVED'][1])
            adjusted_sound_adjustment_bar = ((sound_adjustment_bar_width, OpenGLTextures['SOUND_ADJUSTMENT_BAR'][0][1]), OpenGLTextures['SOUND_ADJUSTMENT_BAR'][1])
            move_letters_down = screen_height / 11
            adjusted_letters_aspect_x = ((3 / 10) * screen_width) / 99
            adjusted_letters_aspect_y = adjusted_letters_aspect_x
            adjusted_hotkey_outline = (((58 / 100) * screen_width, ((2 * (screen_height / 11)) / 10) + (5 * adjusted_letters_aspect_y)), OpenGLTextures['HOTKEY_OUTLINE'][1])
            adjusted_grapple_portion = ((OpenGLTextures['GRAPPLE_PORTION'][0][0] * (single_upgrade_width_and_height / OpenGLTextures['BUBBLE'][0][0]), OpenGLTextures['GRAPPLE_PORTION'][0][1] * (single_upgrade_width_and_height / OpenGLTextures['BUBBLE'][0][1])), OpenGLTextures['GRAPPLE_PORTION'][1])
            default_menu_option_collision = PyGameTextures['MENU_OPTION_SIZING']
            mouse_collision = PyGameTextures['ACTUAL_MOUSE']
            regular_menu_option = pygame.transform.scale(default_menu_option_collision, (536 * menu_width_aspect, 176 * menu_height_aspect))
            flipped_menu_option = pygame.transform.flip(regular_menu_option, True, False)
            current_scaled_menu_option_collisions = [regular_menu_option, flipped_menu_option, regular_menu_option]
            current_scaled_menu_option_collisions = [pygame.mask.from_surface(x) for x in current_scaled_menu_option_collisions]
            regular_option_menu_collision = pygame.transform.scale(default_menu_option_collision, (536 * menu_width_aspect, 160 * menu_height_aspect))
            flipped_option_menu_collision = pygame.transform.flip(regular_option_menu_collision, True, False)
            option_menu_collisions = [regular_option_menu_collision, flipped_option_menu_collision, regular_option_menu_collision, flipped_option_menu_collision]
            option_menu_collisions = [pygame.mask.from_surface(x) for x in option_menu_collisions]
            mouse_collision = pygame.mask.from_surface(mouse_collision)
            touching_Forest_region = [math.floor((1 / 3) * screen_width), math.ceil(((1 / 3) * screen_width) + ((3 / 10) * screen_width)), math.floor((1 / 6) * screen_height), math.ceil(((1 / 2) * screen_height))]
            touching_Town_region = [math.floor(((1 / 3) * screen_width) + ((3 / 10) * screen_width)), math.ceil(((1 / 3) * screen_width) + ((3 / 10) * screen_width) + ((3 / 10) * screen_width)), math.floor((1 / 6) * screen_height), math.ceil(((1 / 2) * screen_height))]
            touching_AntHill_region = [math.floor((1 / 3) * screen_width), math.ceil(((1 / 3) * screen_width) + ((3 / 10) * screen_width)), math.floor(((1 / 6) * screen_height) + ((1 / 3) * screen_height)), math.ceil(((1 / 2) * screen_height) + ((1 / 3) * screen_height))]
            touching_Sewer_region = [math.floor(((1 / 3) * screen_width) + ((3 / 10) * screen_width)), math.ceil(((1 / 3) * screen_width) + ((3 / 10) * screen_width) + ((3 / 10) * screen_width)), math.floor(((1 / 6) * screen_height) + ((1 / 3) * screen_height)), math.ceil(((1 / 2) * screen_height) + ((1 / 3) * screen_height))]
            touching_hotkey_region_x = [math.floor(((36 / 100) * screen_width)), math.ceil(((94 / 100) * screen_width))]
            number_of_pixels_to_move = 0
            #break
      if not touching_resolution:
        make_opengl_rect(adjusted_resolution[0], adjusted_resolution[1], (empty_menu_width, menu_option_height + (2 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_resolution[0][0], adjusted_resolution[0][1]))
      #
      if menu_scroll_y == 0:
        touching_main_menu_points, touching_main_menu = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - ((2 * menu_option_height) + (3 * space_between_menu_options)))
        if touching_main_menu:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), (2 * menu_option_height) + (3 * space_between_menu_options) - (10 * menu_height_aspect)), 0, False, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          show_toggle_full_screen = True
          if (left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']) and allow_full_screen_toggle:
            My_cached_info.windowed = not My_cached_info.windowed
            pygame.display.toggle_fullscreen()
            allow_full_screen_toggle = False
          if not left_click and not Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            allow_full_screen_toggle = True
      if My_cached_info.windowed:
        make_opengl_rect(adjusted_full_screen[0], adjusted_full_screen[1], (empty_menu_width, (2 * menu_option_height) + (3 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_full_screen[0][0], adjusted_full_screen[0][1]))
      if not My_cached_info.windowed:
        make_opengl_rect(adjusted_full_screen[0], adjusted_full_screen[1], (empty_menu_width, (2 * menu_option_height) + (3 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_full_screen[0][0], adjusted_full_screen[0][1]))
      if show_toggle_full_screen:
        make_opengl_rect(OpenGLTextures['TOGGLE_FULL_SCREEN'][0], OpenGLTextures['TOGGLE_FULL_SCREEN'][1], (Mouse_x - (0.5 * OpenGLTextures['TOGGLE_FULL_SCREEN'][0][0]), Mouse_y - (OpenGLTextures['TOGGLE_FULL_SCREEN'][0][1]) - 10), 0, False, (0, 0, OpenGLTextures['TOGGLE_FULL_SCREEN'][0][0], OpenGLTextures['TOGGLE_FULL_SCREEN'][0][1]))
    #
    #
    #
    skip_the_rest = False
    touching_Forest = False
    touching_Town = False
    touching_AntHill = False
    touching_Sewer = False
    if touching_Forest_region[0] <= Mouse_x <= touching_Forest_region[1]:
      if touching_Forest_region[2] <= Mouse_y <= touching_Forest_region[3]:
        touching_Forest = True
        skip_the_rest = True
    if not skip_the_rest:
      if touching_Town_region[0] <= Mouse_x <= touching_Town_region[1]:
        if touching_Town_region[2] <= Mouse_y <= touching_Town_region[3]:
          touching_Town = True
          skip_the_rest = True
    if not skip_the_rest:
      if touching_AntHill_region[0] <= Mouse_x <= touching_AntHill_region[1]:
        if touching_AntHill_region[2] <= Mouse_y <= touching_AntHill_region[3]:
          touching_AntHill = True
          skip_the_rest = True
    if not skip_the_rest:
      if touching_Sewer_region[0] <= Mouse_x <= touching_Sewer_region[1]:
        if touching_Sewer_region[2] <= Mouse_y <= touching_Sewer_region[3]:
          touching_Sewer = True
    #
    number_of_pixels_to_move += pause_delta_milliseconds / 6
    piston1_ltwh = [(486 - ((round(number_of_pixels_to_move))%243))%243, 0, 34, 9]
    piston2_ltwh = [0, 0, 24, 26]
    #
    #
    #
    if display_resolution_note:
      make_opengl_rect(adjusted_resolution_note[0], adjusted_resolution_note[1], (screen_width - adjusted_resolution_note[0][0], screen_height - adjusted_resolution_note[0][1]), 0, False, (0, 0, adjusted_resolution_note[0][0], adjusted_resolution_note[0][1]))
      resolution_starting_x = 1110 * change_screen_note_aspect
      resolution_starting_y = 10 * change_screen_note_aspect
      additional_resolution_x = 0
      for SingleCharacter in monitor_string:
        if SingleCharacter == '0':
          OpenGL_character = ((OpenGLTextures['N0'][0][0] * change_screen_note_aspect, OpenGLTextures['N0'][0][1] * change_screen_note_aspect), OpenGLTextures['N0'][1])
        if SingleCharacter == '1':
          OpenGL_character = ((OpenGLTextures['N1'][0][0] * change_screen_note_aspect, OpenGLTextures['N1'][0][1] * change_screen_note_aspect), OpenGLTextures['N1'][1])
        if SingleCharacter == '2':
          OpenGL_character = ((OpenGLTextures['N2'][0][0] * change_screen_note_aspect, OpenGLTextures['N2'][0][1] * change_screen_note_aspect), OpenGLTextures['N2'][1])
        if SingleCharacter == '3':
          OpenGL_character = ((OpenGLTextures['N3'][0][0] * change_screen_note_aspect, OpenGLTextures['N3'][0][1] * change_screen_note_aspect), OpenGLTextures['N3'][1])
        if SingleCharacter == '4':
          OpenGL_character = ((OpenGLTextures['N4'][0][0] * change_screen_note_aspect, OpenGLTextures['N4'][0][1] * change_screen_note_aspect), OpenGLTextures['N4'][1])
        if SingleCharacter == '5':
          OpenGL_character = ((OpenGLTextures['N5'][0][0] * change_screen_note_aspect, OpenGLTextures['N5'][0][1] * change_screen_note_aspect), OpenGLTextures['N5'][1])
        if SingleCharacter == '6':
          OpenGL_character = ((OpenGLTextures['N6'][0][0] * change_screen_note_aspect, OpenGLTextures['N6'][0][1] * change_screen_note_aspect), OpenGLTextures['N6'][1])
        if SingleCharacter == '7':
          OpenGL_character = ((OpenGLTextures['N7'][0][0] * change_screen_note_aspect, OpenGLTextures['N7'][0][1] * change_screen_note_aspect), OpenGLTextures['N7'][1])
        if SingleCharacter == '8':
          OpenGL_character = ((OpenGLTextures['N8'][0][0] * change_screen_note_aspect, OpenGLTextures['N8'][0][1] * change_screen_note_aspect), OpenGLTextures['N8'][1])
        if SingleCharacter == '9':
          OpenGL_character = ((OpenGLTextures['N9'][0][0] * change_screen_note_aspect, OpenGLTextures['N9'][0][1] * change_screen_note_aspect), OpenGLTextures['N9'][1])
        if SingleCharacter == 'x':
          OpenGL_character = ((OpenGLTextures['Nx'][0][0] * change_screen_note_aspect, OpenGLTextures['Nx'][0][1] * change_screen_note_aspect), OpenGLTextures['Nx'][1])
        make_opengl_rect(OpenGL_character[0], OpenGL_character[1], (screen_width - adjusted_resolution_note[0][0] + resolution_starting_x + additional_resolution_x, screen_height - adjusted_resolution_note[0][1] + resolution_starting_y), 0, False, (0, 0, OpenGL_character[0][0], OpenGL_character[0][1]))
        additional_resolution_x += OpenGL_character[0][0] + (10 * change_screen_note_aspect)
    #
    #
    #
    if showing_sound:
      menu_scroll_y = 0
      percent_of_the_way_through_scrolling = (pause_curr_time - started_scrolling_time) / 500
      if scrolling_toward_sound:
        menu_scroll_y = -abs((1 - percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_toward_sound = False
      if scrolling_away_sound:
        allow_another_option_to_scroll_down = False
        menu_scroll_y = -abs((percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_away_sound = False
          scrolling_toward_sound = False
          showing_sound = False
          showing_option_menu_screen = False
          showing_options = True
          started_scrolling_time = pygame.time.get_ticks()
      if percent_of_the_way_through_scrolling >= 1:
        allow_another_option_to_scroll_down = True
        #started_scrolling_time = pygame.time.get_ticks()
      #
      chain_distance_subtracted = -((1.5 * menu_option_height) + (2 * space_between_menu_options))
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + ((2 / 10) * menu_option_width), 0 + menu_scroll_y + chain_distance_subtracted), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + menu_option_width - OpenGLTextures['CHAIN'][0][0] - ((2 / 10) * menu_option_width), 0 + menu_scroll_y + chain_distance_subtracted), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      #
      if menu_scroll_y == 0:
        touching_back_points, touching_back = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - space_between_menu_options)
        if touching_back:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), space_between_menu_options - (10 * menu_height_aspect)), 0, False, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if (left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']) and not holding_sound_bar and not holding_music_bar:
            started_scrolling_time = pygame.time.get_ticks()
            scrolling_toward_sound = False
            scrolling_away_sound = True
            #showing_options = True
            scrolling_toward_options = True
      make_opengl_rect(adjusted_screen_back[0], adjusted_screen_back[1], (empty_menu_width, space_between_menu_options + menu_scroll_y), 0, False, (0, 0, adjusted_screen_back[0][0], adjusted_screen_back[0][1]))
    #
      sound_added_x = 0
      if percent_of_the_way_through_scrolling < 0:
        percent_of_the_way_through_scrolling = 0
      if percent_of_the_way_through_scrolling > 1:
        percent_of_the_way_through_scrolling = 1
      if scrolling_toward_sound and percent_of_the_way_through_scrolling != 1:
        sound_added_x = (68/100) * screen_width * (1 - percent_of_the_way_through_scrolling)
      if scrolling_away_sound:
        sound_added_x = (68/100) * screen_width * (percent_of_the_way_through_scrolling)
        if percent_of_the_way_through_scrolling == 0:
          sound_added_x = (68/100) * screen_width
        if percent_of_the_way_through_scrolling == 1:
          sound_added_x = 0
      if showing_options:
        sound_added_x = (68/100) * screen_width
      adjusted_black_pixel = ((OpenGLTextures['BLACK_PIXEL'][0][0] * screen_width, OpenGLTextures['BLACK_PIXEL'][0][1] * screen_height), OpenGLTextures['BLACK_PIXEL'][1])
      make_opengl_rect(adjusted_black_pixel[0], adjusted_black_pixel[1], (((32/100) * screen_width) + sound_added_x, 0), 0, False, (0, 0, adjusted_black_pixel[0][0], adjusted_black_pixel[0][1]))
      #
      black_pixel_x = ((32/100) * screen_width) + sound_added_x
      black_pixel_y = 0
      blank_area_between = (screen_height - (2 * OpenGLTextures['SOUND_BAR_BEING_MOVED'][0][1])) / 3
      center_bars_x = ((10/100) * screen_width) + sound_added_x
      make_opengl_rect(adjusted_sound_adjustment_bar[0], adjusted_sound_adjustment_bar[1], (black_pixel_x + center_bars_x, blank_area_between + (adjusted_sound_bar_being_moved[0][1] / 2) - (adjusted_sound_adjustment_bar[0][1] / 2)), 0, False, (0, 0, adjusted_sound_adjustment_bar[0][0], adjusted_sound_adjustment_bar[0][1]))
      make_opengl_rect(adjusted_sound_adjustment_bar[0], adjusted_sound_adjustment_bar[1], (black_pixel_x + center_bars_x, (2 * blank_area_between) + ((3 * adjusted_sound_bar_being_moved[0][1]) / 2) - (adjusted_sound_adjustment_bar[0][1] / 2)), 0, False, (0, 0, adjusted_sound_adjustment_bar[0][0], adjusted_sound_adjustment_bar[0][1]))
      #
      total_available_bar_distance_x = adjusted_sound_adjustment_bar[0][0] - adjusted_sound_bar_being_moved[0][0]
      My_cached_info.current_music_loudness = float(everything_sound_data(False, 666, 0)[0])
      move_music_bar_x = total_available_bar_distance_x * My_cached_info.current_music_loudness
      if not left_click and not Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
        holding_music_bar = False
      if (left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']) and not holding_sound_bar and not holding_music_bar:
        if (black_pixel_x + center_bars_x + move_music_bar_x) <= Mouse_x <= (black_pixel_x + center_bars_x + move_music_bar_x + adjusted_sound_bar_being_moved[0][0]):
          if (blank_area_between) <= Mouse_y <= (blank_area_between + adjusted_sound_bar_being_moved[0][1]):
            holding_music_bar = True
      if holding_music_bar:
        My_cached_info.current_music_loudness = (Mouse_x - (black_pixel_x + center_bars_x) - (adjusted_sound_bar_being_moved[0][0] / 2)) / total_available_bar_distance_x
        if My_cached_info.current_music_loudness < 0:
          My_cached_info.current_music_loudness = 0
        if My_cached_info.current_music_loudness > 1:
          My_cached_info.current_music_loudness = 1
        everything_sound_data(True, 0, str(My_cached_info.current_music_loudness))
        update_music_loudness()
      make_opengl_rect(adjusted_sound_bar_being_moved[0], adjusted_sound_bar_being_moved[1], (black_pixel_x + center_bars_x + move_music_bar_x, blank_area_between), 0, False, (0, 0, adjusted_sound_bar_being_moved[0][0], adjusted_sound_bar_being_moved[0][1]))
      #
      StringToBeCreated = 'MUSIC: ' + str(round(My_cached_info.current_music_loudness * 100))
      Music_string_length = 0
      for SingleCharacter in StringToBeCreated:
        if SingleCharacter != ' ':
          Music_string_length += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          Music_string_length += (3 * adjusted_letters_aspect_x)
      music_character_spacing_x = 0
      for SingleCharacter in StringToBeCreated:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (black_pixel_x + center_bars_x + (0.5 * adjusted_sound_adjustment_bar[0][0]) - (0.5 * Music_string_length) + music_character_spacing_x, blank_area_between - (OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y) - 5), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          music_character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          music_character_spacing_x += (3 * adjusted_letters_aspect_x)
      #
      My_cached_info.current_sound_loudness = float(everything_sound_data(False, 666, 0)[1])
      move_sound_bar_x = total_available_bar_distance_x * My_cached_info.current_sound_loudness
      if not left_click and not Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
        holding_sound_bar = False
      if (left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']) and not holding_sound_bar and not holding_music_bar:
        if (black_pixel_x + center_bars_x + move_sound_bar_x) <= Mouse_x <= (black_pixel_x + center_bars_x + move_sound_bar_x + adjusted_sound_bar_being_moved[0][0]):
          if ((2 * blank_area_between) + adjusted_sound_bar_being_moved[0][1]) <= Mouse_y <= ((2 * blank_area_between) + adjusted_sound_bar_being_moved[0][1] + adjusted_sound_bar_being_moved[0][1]):
            holding_sound_bar = True
      if holding_sound_bar:
        My_cached_info.current_sound_loudness = (Mouse_x - (black_pixel_x + center_bars_x) - (adjusted_sound_bar_being_moved[0][0] / 2)) / total_available_bar_distance_x
        if My_cached_info.current_sound_loudness < 0:
          My_cached_info.current_sound_loudness = 0
        if My_cached_info.current_sound_loudness > 1:
          My_cached_info.current_sound_loudness = 1
        everything_sound_data(True, 1, str(My_cached_info.current_sound_loudness))
        update_sound_loudness()
      make_opengl_rect(adjusted_sound_bar_being_moved[0], adjusted_sound_bar_being_moved[1], (black_pixel_x + center_bars_x + move_sound_bar_x, (2 * blank_area_between) + adjusted_sound_bar_being_moved[0][1]), 0, False, (0, 0, adjusted_sound_bar_being_moved[0][0], adjusted_sound_bar_being_moved[0][1]))
      #
      StringToBeCreated = 'SOUND: ' + str(round(My_cached_info.current_sound_loudness * 100))
      Sound_string_length = 0
      for SingleCharacter in StringToBeCreated:
        if SingleCharacter != ' ':
          Sound_string_length += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          Sound_string_length += (3 * adjusted_letters_aspect_x)
      Sound_character_spacing_x = 0
      for SingleCharacter in StringToBeCreated:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (black_pixel_x + center_bars_x + (0.5 * adjusted_sound_adjustment_bar[0][0]) - (0.5 * Sound_string_length) + Sound_character_spacing_x, (2 * blank_area_between) + adjusted_sound_bar_being_moved[0][1] - (OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y) - 5), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          Sound_character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          Sound_character_spacing_x += (3 * adjusted_letters_aspect_x)
    #
    #
    #
    if showing_hotkey:
      menu_scroll_y = 0
      percent_of_the_way_through_scrolling = (pause_curr_time - started_scrolling_time) / 500
      if scrolling_toward_hotkey:
        menu_scroll_y = -abs((1 - percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_toward_hotkey = False
      if scrolling_away_hotkey:
        allow_another_option_to_scroll_down = False
        menu_scroll_y = -abs((percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_away_hotkey = False
          scrolling_toward_hotkey = False
          showing_hotkey = False
          showing_option_menu_screen = False
          showing_options = True
          started_scrolling_time = pygame.time.get_ticks()
      if percent_of_the_way_through_scrolling >= 1:
        allow_another_option_to_scroll_down = True
        #started_scrolling_time = pygame.time.get_ticks()
      #
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + menu_option_width - OpenGLTextures['CHAIN'][0][0] - ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      #
      if menu_scroll_y == 0:
        touching_back_points, touching_back = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - space_between_menu_options)
        if touching_back:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), space_between_menu_options - (10 * menu_height_aspect)), 0, False, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            started_scrolling_time = pygame.time.get_ticks()
            scrolling_toward_hotkey = False
            scrolling_away_hotkey = True
            #showing_options = True
            scrolling_toward_options = True
      make_opengl_rect(adjusted_screen_back[0], adjusted_screen_back[1], (empty_menu_width, space_between_menu_options + menu_scroll_y), 0, False, (0, 0, adjusted_screen_back[0][0], adjusted_screen_back[0][1]))
      #
      if menu_scroll_y == 0:
        touching_save_points, touching_save = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[1], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - (menu_option_height + (2 * space_between_menu_options)))
        if touching_save:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), menu_option_height + (2 * space_between_menu_options) - (10 * menu_height_aspect)), 0, True, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            time_since_saving_hotkeys = 0
            current_hotkeys = temporary_current_hotkeys.copy()
            all_hotkey_indexes = []
            for k2, v2 in current_hotkeys.items():
              all_hotkey_indexes.append(str(v2) + '\n')
            with open(current_control_path, 'w') as file:
              file.writelines(all_hotkey_indexes)
      if time_since_saving_hotkeys >= 2500:
        make_opengl_rect(adjusted_options[0], OpenGLTextures['SAVE'][1], (empty_menu_width, menu_option_height + (2 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_options[0][0], adjusted_options[0][1]))
      if time_since_saving_hotkeys < 2500:
        make_opengl_rect(adjusted_options[0], OpenGLTextures['SAVED'][1], (empty_menu_width, menu_option_height + (2 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_options[0][0], adjusted_options[0][1]))
      #
      if menu_scroll_y == 0:
        touching_defaults_points, touching_defaults = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - ((2 * menu_option_height) + (3 * space_between_menu_options)))
        if touching_defaults:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), (2 * menu_option_height) + (3 * space_between_menu_options) - (10 * menu_height_aspect)), 0, False, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            with open(default_control_path, 'r') as file:
              hotkey_save_data = file.readlines()
            temporary_current_hotkeys = [int(x) for x in hotkey_save_data]
            temp_hotkey_dict = {}
            return_to_default_hotkeys_index = 0
            for k3, v3 in current_hotkeys.items():
              temp_hotkey_dict[k3] = temporary_current_hotkeys[return_to_default_hotkeys_index]
              return_to_default_hotkeys_index += 1
            temporary_current_hotkeys = temp_hotkey_dict
      make_opengl_rect(adjusted_main_menu[0], OpenGLTextures['DEFAULTS'][1], (empty_menu_width, (2 * menu_option_height) + (3 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_main_menu[0][0], adjusted_main_menu[0][1]))
      #
      hotkeys_added_x = 0
      if percent_of_the_way_through_scrolling < 0:
        percent_of_the_way_through_scrolling = 0
      if percent_of_the_way_through_scrolling > 1:
        percent_of_the_way_through_scrolling = 1
      if scrolling_toward_hotkey and percent_of_the_way_through_scrolling != 1:
        hotkeys_added_x = (68/100) * screen_width * (1 - percent_of_the_way_through_scrolling)
      if scrolling_away_hotkey:
        hotkeys_added_x = (68/100) * screen_width * (percent_of_the_way_through_scrolling)
        if percent_of_the_way_through_scrolling == 0:
          hotkeys_added_x = (68/100) * screen_width
        if percent_of_the_way_through_scrolling == 1:
          hotkeys_added_x = 0
      if showing_options:
        hotkeys_added_x = (68/100) * screen_width
      adjusted_black_pixel = ((OpenGLTextures['BLACK_PIXEL'][0][0] * screen_width, OpenGLTextures['BLACK_PIXEL'][0][1] * screen_height), OpenGLTextures['BLACK_PIXEL'][1])
      make_opengl_rect(adjusted_black_pixel[0], adjusted_black_pixel[1], (((32/100) * screen_width) + hotkeys_added_x, 0), 0, False, (0, 0, adjusted_black_pixel[0][0], adjusted_black_pixel[0][1]))
      empty_space = 2 * (screen_height / 11)
      character_height = 5 * adjusted_letters_aspect_y
      empty_space = screen_height - (9 * 5 * adjusted_letters_aspect_y)
      in_a_change_hotkey_region = False
      #
      all_hotkey_display_strings = []
      for k, v in temporary_current_hotkeys.items():
        if v == 512:
          all_hotkey_display_strings.append('LEFT CLICK')
          continue
        if v == 513:
          all_hotkey_display_strings.append('WEIRD CLICK')
          continue
        if v == 514:
          all_hotkey_display_strings.append('RIGHT CLICK')
          continue
        current_display_string = key_to_pygame_index_dict[str(v)]
        all_hotkey_display_strings.append(current_display_string)
      #
      index_character_pair = []
      for k, v in key_to_pygame_index_dict.items():
        if keys[int(k)]:
          index_character_pair = [k, v]
          break
      if index_character_pair == []:
        for _ in range(1):
          if left_click:
            index_character_pair = [512, 'left_click']
            continue
          if weird_click:
            index_character_pair = [513, 'weird_click']
            continue
          if right_click:
            index_character_pair = [514, 'right_click']
            continue
      #
      #
      character_spacing_x = 0
      for SingleCharacter in 'MOVE LEFT:':
        character_y_pos = (1 * (empty_space / 10)) + (0 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['MOVE_LEFT']) != str(current_hotkeys['MOVE_LEFT']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[0]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['MOVE_LEFT'] = index_character_pair[0]
      #
      character_spacing_x = 0
      for SingleCharacter in 'MOVE RIGHT:':
        character_y_pos = (2 * (empty_space / 10)) + (1 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['MOVE_RIGHT']) != str(current_hotkeys['MOVE_RIGHT']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[1]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['MOVE_RIGHT'] = index_character_pair[0]
      #
      character_spacing_x = 0
      for SingleCharacter in 'FLOAT UP:':
        character_y_pos = (3 * (empty_space / 10)) + (2 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['FLOAT_UP']) != str(current_hotkeys['FLOAT_UP']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[2]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['FLOAT_UP'] = index_character_pair[0]
      #
      character_spacing_x = 0
      for SingleCharacter in 'SINK DOWN:':
        character_y_pos = (4 * (empty_space / 10)) + (3 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['SINK_DOWN']) != str(current_hotkeys['SINK_DOWN']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[3]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['SINK_DOWN'] = index_character_pair[0]
      #
      character_spacing_x = 0
      for SingleCharacter in 'INTERACT:':
        character_y_pos = (5 * (empty_space / 10)) + (4 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['INTERACT']) != str(current_hotkeys['INTERACT']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[4]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['INTERACT'] = index_character_pair[0]
      #
      character_spacing_x = 0
      for SingleCharacter in 'EXTEND WATER JET:':
        character_y_pos = (6 * (empty_space / 10)) + (5 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['EXTEND_WATER_JET']) != str(current_hotkeys['EXTEND_WATER_JET']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[5]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['EXTEND_WATER_JET'] = index_character_pair[0]
      #
      character_spacing_x = 0
      for SingleCharacter in 'EXTEND GRAPPLING HOOK:':
        character_y_pos = (7 * (empty_space / 10)) + (6 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['EXTEND_GRAPPLING_HOOK']) != str(current_hotkeys['EXTEND_GRAPPLING_HOOK']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[6]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['EXTEND_GRAPPLING_HOOK'] = index_character_pair[0]
      #
      character_spacing_x = 0
      for SingleCharacter in 'DETACH GRAPPLING HOOK:':
        character_y_pos = (8 * (empty_space / 10)) + (7 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['DETACH_GRAPPLING_HOOK']) != str(current_hotkeys['DETACH_GRAPPLING_HOOK']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[7]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['DETACH_GRAPPLING_HOOK'] = index_character_pair[0]
      #
      character_spacing_x = 0
      for SingleCharacter in 'PAUSE:':
        character_y_pos = (9 * (empty_space / 10)) + (8 * character_height)
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      character_spacing_x = 0
      if str(temporary_current_hotkeys['PAUSE']) != str(current_hotkeys['PAUSE']):
        make_opengl_rect((OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y), OpenGLTextures['*'][1], (((2 / 5) * screen_width) + hotkeys_added_x + character_spacing_x - ((OpenGLTextures['*'][0][0] + 1) * adjusted_letters_aspect_x), character_y_pos - (0.5 * character_height)), 0, False, (0, 0, OpenGLTextures['*'][0][0] * adjusted_letters_aspect_x, OpenGLTextures['*'][0][1] * adjusted_letters_aspect_y))
      for SingleCharacter in all_hotkey_display_strings[8]:
        if SingleCharacter != ' ':
          make_opengl_rect((OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y), OpenGLTextures[SingleCharacter][1], (((72 / 100) * screen_width) + hotkeys_added_x + character_spacing_x, character_y_pos), 0, False, (0, 0, OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x, OpenGLTextures[SingleCharacter][0][1] * adjusted_letters_aspect_y))
          character_spacing_x += (OpenGLTextures[SingleCharacter][0][0] * adjusted_letters_aspect_x) + (1 * adjusted_letters_aspect_x)
        if SingleCharacter == ' ':
          character_spacing_x += (3 * adjusted_letters_aspect_x)
      if not in_a_change_hotkey_region:
        if touching_hotkey_region_x[0] <= Mouse_x <= touching_hotkey_region_x[1]:
          if (character_y_pos - (0.5 * (empty_space / 10))) <= Mouse_y <= (character_y_pos + character_height + (0.5 * (empty_space / 10))):
            in_a_change_hotkey_region = True
            make_opengl_rect((OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2), OpenGLTextures['WHITE_PIXEL'][1], (((2 / 5) * screen_width) + hotkeys_added_x, character_y_pos + character_height + 2), 0, False, (0, 0, OpenGLTextures['WHITE_PIXEL'][0][0] * ((58 / 100) * screen_width), OpenGLTextures['WHITE_PIXEL'][0][1] * 2))
            show_select_new_key_message = True
            if index_character_pair != []:
              allow_the_hotkey_to_change = True
              for k, v in temporary_current_hotkeys.items():
                if str(v) == str(index_character_pair[0]):
                  allow_the_hotkey_to_change = False
              if allow_the_hotkey_to_change:
                temporary_current_hotkeys['PAUSE'] = index_character_pair[0]
    #
    if show_select_new_key_message:
      make_opengl_rect(OpenGLTextures['SELECT_NEW_KEY'][0], OpenGLTextures['SELECT_NEW_KEY'][1], (Mouse_x - (0.5 * OpenGLTextures['SELECT_NEW_KEY'][0][0]), Mouse_y - (OpenGLTextures['SELECT_NEW_KEY'][0][1]) - 10), 0, False, (0, 0, OpenGLTextures['SELECT_NEW_KEY'][0][0], OpenGLTextures['SELECT_NEW_KEY'][0][1]))
    #
    #
    #
    cur_mouse_x, cur_mouse_y = Mouse_x - (OpenGLTextures['ACTUAL_MOUSE'][0][0]/2), Mouse_y - (OpenGLTextures['ACTUAL_MOUSE'][0][1]/2)
    make_opengl_rect(OpenGLTextures['ACTUAL_MOUSE'][0], OpenGLTextures['ACTUAL_MOUSE'][1], (cur_mouse_x, cur_mouse_y), 0, False, (0, 0, OpenGLTextures['ACTUAL_MOUSE'][0][0], OpenGLTextures['ACTUAL_MOUSE'][0][1]))
    glFlush()
    pygame.display.flip()
    #
    clock.tick(60)
    pause_curr_time = pygame.time.get_ticks()
    pause_fps = (1 / (pause_curr_time - pause_prev_time))*1000
    pause_delta_milliseconds = pause_curr_time - pause_prev_time
    time_since_saving_hotkeys += pause_delta_milliseconds
    pause_prev_time = pause_curr_time
    pause_menu_timer += pause_delta_milliseconds
    frames_this_frame_float = (60 / pause_fps)
    frames_this_frame_remainder += frames_this_frame_float - int(frames_this_frame_float)
    elapsed_fps_float += frames_this_frame_float
    frames_this_frame = int(frames_this_frame_float)
    if frames_this_frame_remainder >= 1:
      frames_this_frame_remainder %= 1
      frames_this_frame += 1


def loadTexture_movie(textData):
  image_height = len(textData)
  image_width = len(textData[0])
  textID = glGenTextures(1)
  glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
  glBindTexture(GL_TEXTURE_2D, textID)
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER)
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER)
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0)
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0)
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, image_width, image_height, 0, GL_RGB, GL_UNSIGNED_BYTE, textData)
  del textData
  return (image_width, image_height), textID


def Main_menu():
  global clock
  global My_cached_info, save_data_path
  global movie_path, video, currently_playing_movie_index, movie_paths
  global keys, left_click, weird_click, right_click
  update_music_loudness()
  update_sound_loudness()
  ForestThemePath = path + '\Music\Forest\Forest_Theme.mp3'
  SewerThemePath = path + '\Music\Sewer\Sewer_Theme.mp3'
  PlayingForestTheme = False
  PlayingSewerTheme = False
  which_song = random.randint(1,2)
  if which_song == 1:
    PlayingForestTheme = True
    pygame.mixer.music.load(ForestThemePath)
    pygame.mixer.music.play(-1)
  if which_song == 2:
    PlayingSewerTheme = True
    pygame.mixer.music.load(SewerThemePath)
    pygame.mixer.music.play(-1)
  movie_paths = [path + '\Movies\ForestClip.mp4', path + '\Movies\AntHillClip.mp4', path + '\Movies\SewerClip.mp4']
  currently_playing_movie_index = random.randint(0, 2)
  movie_path = movie_paths[currently_playing_movie_index]
  video = cv2.VideoCapture(movie_path)
  main_curr_time = 0
  main_prev_time = 0
  main_fps = 0
  main_delta_milliseconds = 0
  elapsed_fps_float = 1
  frames_this_frame = 1
  frames_this_frame_remainder = 0
  starter_path = path + '/Movies\TestMovie2/'
  starting_img_number = '1'
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
  available_menu_width = (1 / 3) * screen_width
  available_menu_height = screen_height
  empty_menu_width = (1 / 54) * screen_width
  actual_menu_width = available_menu_width - (2 * empty_menu_width)
  actual_menu_height = available_menu_height
  original_option_menu_width = 600
  original_option_menu_height = 800
  menu_width_aspect = actual_menu_width / original_option_menu_width
  menu_height_aspect = actual_menu_height / original_option_menu_height
  menu_option_height = 176
  menu_option_width = OpenGLTextures['PLAY'][0][0] * menu_width_aspect
  space_between_menu_options = ((original_option_menu_height - (3 * menu_option_height)) / 4) * menu_height_aspect
  menu_option_height = menu_option_height * menu_height_aspect
  adjusted_play = ((OpenGLTextures['PLAY'][0][0] * menu_width_aspect, OpenGLTextures['PLAY'][0][1] * menu_height_aspect), OpenGLTextures['PLAY'][1])
  adjusted_options = ((OpenGLTextures['OPTIONS'][0][0] * menu_width_aspect, OpenGLTextures['OPTIONS'][0][1] * menu_height_aspect), OpenGLTextures['OPTIONS'][1])
  adjusted_exit = ((OpenGLTextures['EXIT'][0][0] * menu_width_aspect, OpenGLTextures['EXIT'][0][1] * menu_height_aspect), OpenGLTextures['EXIT'][1])
  adjusted_back = ((OpenGLTextures['BACK'][0][0] * menu_width_aspect, OpenGLTextures['BACK'][0][1] * menu_height_aspect), OpenGLTextures['BACK'][1])
  save_file_size_x = ((2 / 3) * screen_width) - ((1 / 54) * screen_width)
  save_file_size_y = ((1 / 4) * screen_height)
  save_file_x_pos = ((1 / 3) * screen_width)
  empty_space_between_save_files = ((1 / 4) * screen_height) / 4
  adjusted_save_file = ((save_file_size_x, save_file_size_y), OpenGLTextures['SAVE_FILE'][1])
  save_file_aspect_x = adjusted_save_file[0][0] / OpenGLTextures['SAVE_FILE'][0][0]
  save_file_aspect_y = adjusted_save_file[0][1] / OpenGLTextures['SAVE_FILE'][0][1]
  adjusted_hamster_size = ((OpenGLTextures['THE_BALL_BACK'][0][0] * (save_file_size_y * 1.5 / OpenGLTextures['SAVE_FILE'][0][1]), OpenGLTextures['THE_BALL_BACK'][0][1] * (save_file_size_y * 1.5 / OpenGLTextures['SAVE_FILE'][0][1])), OpenGLTextures['THE_BALL_BACK'][1])
  hamster_down_save_file = ((adjusted_save_file[0][1] - adjusted_hamster_size[0][1]) / 2)
  hamster_right_save_file = adjusted_save_file[0][0] * (101 / 1440)
  adjusted_save_file_highlight = ((save_file_size_x * (1460 / 1440), save_file_size_y * (290 / 270)), OpenGLTextures['SAVE_FILE_HIGHLIGHT'][1])
  adjusted_chain = ((OpenGLTextures['CHAIN'][0][0], (2.5 * menu_option_height) + (3 * space_between_menu_options)), OpenGLTextures['CHAIN'][1])
  adjusted_shiny_outside = ((OpenGLTextures['SHINY_OUTSIDE'][0][0] * menu_width_aspect, OpenGLTextures['SHINY_OUTSIDE'][0][1] * menu_height_aspect), OpenGLTextures['SHINY_OUTSIDE'][1])
  tan_area_distance_x = adjusted_save_file[0][0] * (92 / 1440)
  tan_area_distance_y = adjusted_save_file[0][1] * (92 / 270)
  blue_area_distance_x = adjusted_save_file[0][0] * (1348 / 1440)
  blue_area_distance_y = adjusted_save_file[0][1] * (178 / 270)
  adjusted_checkmark1 = ((33, 33), OpenGLTextures['CHECK_MARK1'][1])
  adjusted_checkmark2 = ((33, 33), OpenGLTextures['CHECK_MARK2'][1])
  available_distance_between_timer_words = blue_area_distance_y - 15 - 15 - 33
  upgrades_and_tools_x = (save_file_x_pos + hamster_right_save_file + adjusted_hamster_size[0][0])
  space_for_upgrades_and_tools_x = abs(upgrades_and_tools_x - (save_file_x_pos + (adjusted_save_file[0][0] * (1371 / 1440)) - 123))
  space_for_upgrades_and_tools_y = adjusted_save_file[0][1] * (178 / 270)
  bubble_size_for_x = space_for_upgrades_and_tools_x / 8
  bubble_size_for_y = space_for_upgrades_and_tools_y / 2
  x_is_limiting = False
  y_is_limiting = False
  if bubble_size_for_x >= bubble_size_for_y:
    bubble_size_max = bubble_size_for_y
    y_is_limiting = True
  if bubble_size_for_x < bubble_size_for_y:
    bubble_size_max = bubble_size_for_x
    x_is_limiting = True
  bubble_size = bubble_size_max - 6
  adjusted_bubble = ((bubble_size, bubble_size), OpenGLTextures['BUBBLE'][1])
  adjusted_water_portion = ((OpenGLTextures['PUSH_PISTON_COVER'][0][0] * (bubble_size / OpenGLTextures['BUBBLE'][0][0]), OpenGLTextures['PUSH_PISTON_COVER'][0][1] * (bubble_size / OpenGLTextures['BUBBLE'][0][0])), OpenGLTextures['PUSH_PISTON_COVER'][1])
  adjusted_grapple_portion = ((OpenGLTextures['GRAPPLE_PORTION'][0][0] * (bubble_size / OpenGLTextures['BUBBLE'][0][0]), OpenGLTextures['GRAPPLE_PORTION'][0][1] * (bubble_size / OpenGLTextures['BUBBLE'][0][1])), OpenGLTextures['GRAPPLE_PORTION'][1])
  number_of_pixels_to_move = 0
  piston1_width = bubble_size * (34 / 69)
  piston1_height = bubble_size * (9 / 69)
  adjust_water_in_bubble_x = 17 * (bubble_size / OpenGLTextures['BUBBLE'][0][0])
  adjust_water_in_bubble_y = 14 * (bubble_size / OpenGLTextures['BUBBLE'][0][1])
  adjust_grapple_in_bubble_x = 22 * (bubble_size / OpenGLTextures['BUBBLE'][0][0])
  adjust_grapple_in_bubble_y = 31 * (bubble_size / OpenGLTextures['BUBBLE'][0][1])
  adjusted_star = ((OpenGLTextures['STAR'][0][0] * 0.75 * (screen_width / 1360), OpenGLTextures['STAR'][0][1] * 0.75 * (screen_height / 768)), OpenGLTextures['STAR'][1])
  bubble_added_x = 0
  bubble_added_y = 0
  if x_is_limiting:
    bubble_added_y = (space_for_upgrades_and_tools_y - (2 * adjusted_bubble[0][1]) - (3 * 4)) / 2
  if y_is_limiting:
    bubble_added_x = (space_for_upgrades_and_tools_x - (8 * adjusted_bubble[0][0]) - (48)) / 2
  allow_interacting_with_files = True
  allowed_to_left_click = True
  allow_another_option_to_scroll_down = False
  showing_main = True
  scrolling_toward_main = True
  scrolling_away_main = False
  showing_file_select = False
  scrolling_toward_file_select = False
  scrolling_away_file_select = False
  about_to_open_options_menu = False
  started_scrolling_time = pygame.time.get_ticks()
  main_millisecond_counter = 0
  #
  save_data_file1 = read_save_file(save_data_paths[0])
  save_data_file2 = read_save_file(save_data_paths[1])
  save_data_file3 = read_save_file(save_data_paths[2])
  save_file1_time_string = milliseconds_to_time_string(int(save_data_file1[83]))
  save_file2_time_string = milliseconds_to_time_string(int(save_data_file2[83]))
  save_file3_time_string = milliseconds_to_time_string(int(save_data_file3[83]))
  tentatively_delete_file1 = False
  tentatively_delete_file2 = False
  tentatively_delete_file3 = False
  tentatively_start_playing_file1 = False
  tentatively_start_playing_file2 = False
  tentatively_start_playing_file3 = False
  #
  default_menu_option_collision = PyGameTextures['MENU_OPTION_SIZING']
  regular_menu_option = pygame.transform.scale(default_menu_option_collision, (536 * menu_width_aspect, 176 * menu_height_aspect))
  flipped_menu_option = pygame.transform.flip(regular_menu_option, True, False)
  current_scaled_menu_option_collisions = [regular_menu_option, flipped_menu_option, regular_menu_option]
  current_scaled_menu_option_collisions = [pygame.mask.from_surface(x) for x in current_scaled_menu_option_collisions]
  mouse_collision = PyGameTextures['ACTUAL_MOUSE']
  mouse_collision = pygame.mask.from_surface(mouse_collision)
  pygame.mixer.set_num_channels(21)
  #
  #while True:
  #  try:
  #    loaded_texture = loadTexture_movie(starter_path + starting_img_number + '.png')
  #  except:
  #    starting_img_number = '0' + starting_img_number
  #    continue
  #  glDeleteTextures(1, np.array([loaded_texture[1]]))
  #  break
  #current_img_frame = starting_img_number
  #
  #
  clock = pygame.time.Clock()
  while True:
    for event in pygame.event.get():
      if event.type == pygame.QUIT:
        raise SystemExit
    #
    #try:
    #  loaded_texture = loadTexture_movie(starter_path + current_img_frame + '.png')
    #except:
    #  loaded_texture = loadTexture_movie(starter_path + starting_img_number + '.png')
    #  current_img_frame = starting_img_number
    try:
      temp_frames_this_frame = frames_this_frame
      if temp_frames_this_frame > 2:
        temp_frames_this_frame = 2
      for _ in range(temp_frames_this_frame):
        ret = video.grab()
      ret, video_textData = video.retrieve()
      video_textData = cv2.cvtColor(video_textData, cv2.COLOR_BGR2RGB)
      loaded_texture = loadTexture_movie(video_textData)
    except:
      originally_playing_movie_index = currently_playing_movie_index
      while True:
        if originally_playing_movie_index != currently_playing_movie_index:
          break
        currently_playing_movie_index = random.randint(0, 2)
      movie_path = movie_paths[currently_playing_movie_index]
      video = cv2.VideoCapture(movie_path)
      success, video_textData = video.read()
      video_textData = cv2.cvtColor(video_textData, cv2.COLOR_BGR2RGB)
      loaded_texture = loadTexture_movie(video_textData)
    make_opengl_rect((1920, 1080), loaded_texture[1], (-(1920 - screen_width) / 2, -(1080 - screen_height) / 2), 0, False, (0, 0, 1920, 1080))
    #
    Mouse_x, Mouse_y = pygame.mouse.get_pos()
    keys = pygame.key.get_pressed()
    left_click, weird_click, right_click = pygame.mouse.get_pressed()
    update_pressed_controls()
    if not left_click and not Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
      allowed_to_left_click = True
    #
    #
    if showing_main:
      menu_scroll_y = 0
      percent_of_the_way_through_scrolling = (main_curr_time - started_scrolling_time) / 500
      if percent_of_the_way_through_scrolling > 1:
        percent_of_the_way_through_scrolling = 1
      if scrolling_toward_main:
        allow_another_option_to_scroll_down = False
        menu_scroll_y = -abs((1 - percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_toward_main = False
      if scrolling_away_main:
        allow_another_option_to_scroll_down = False
        menu_scroll_y = -abs((percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_away_main = False
          showing_main = False
          if about_to_open_options_menu:
            main_pause_menu()
            scrolling_away_file_select = False
            showing_file_select = False
            showing_main = True
            scrolling_toward_main = True
            started_scrolling_time = pygame.time.get_ticks()
            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
            available_menu_width = (1 / 3) * screen_width
            available_menu_height = screen_height
            empty_menu_width = (1 / 54) * screen_width
            actual_menu_width = available_menu_width - (2 * empty_menu_width)
            actual_menu_height = available_menu_height
            original_option_menu_width = 600
            original_option_menu_height = 800
            menu_width_aspect = actual_menu_width / original_option_menu_width
            menu_height_aspect = actual_menu_height / original_option_menu_height
            menu_option_height = 176
            menu_option_width = OpenGLTextures['PLAY'][0][0] * menu_width_aspect
            space_between_menu_options = ((original_option_menu_height - (3 * menu_option_height)) / 4) * menu_height_aspect
            menu_option_height = menu_option_height * menu_height_aspect
            adjusted_play = ((OpenGLTextures['PLAY'][0][0] * menu_width_aspect, OpenGLTextures['PLAY'][0][1] * menu_height_aspect), OpenGLTextures['PLAY'][1])
            adjusted_options = ((OpenGLTextures['OPTIONS'][0][0] * menu_width_aspect, OpenGLTextures['OPTIONS'][0][1] * menu_height_aspect), OpenGLTextures['OPTIONS'][1])
            adjusted_exit = ((OpenGLTextures['EXIT'][0][0] * menu_width_aspect, OpenGLTextures['EXIT'][0][1] * menu_height_aspect), OpenGLTextures['EXIT'][1])
            adjusted_back = ((OpenGLTextures['BACK'][0][0] * menu_width_aspect, OpenGLTextures['BACK'][0][1] * menu_height_aspect), OpenGLTextures['BACK'][1])
            save_file_size_x = ((2 / 3) * screen_width) - ((1 / 54) * screen_width)
            save_file_size_y = ((1 / 4) * screen_height)
            save_file_x_pos = ((1 / 3) * screen_width)
            empty_space_between_save_files = ((1 / 4) * screen_height) / 4
            adjusted_save_file = ((save_file_size_x, save_file_size_y), OpenGLTextures['SAVE_FILE'][1])
            save_file_aspect_x = adjusted_save_file[0][0] / OpenGLTextures['SAVE_FILE'][0][0]
            save_file_aspect_y = adjusted_save_file[0][1] / OpenGLTextures['SAVE_FILE'][0][1]
            adjusted_hamster_size = ((OpenGLTextures['THE_BALL_BACK'][0][0] * (save_file_size_y * 1.5 / OpenGLTextures['SAVE_FILE'][0][1]), OpenGLTextures['THE_BALL_BACK'][0][1] * (save_file_size_y * 1.5 / OpenGLTextures['SAVE_FILE'][0][1])), OpenGLTextures['THE_BALL_BACK'][1])
            hamster_down_save_file = ((adjusted_save_file[0][1] - adjusted_hamster_size[0][1]) / 2)
            hamster_right_save_file = adjusted_save_file[0][0] * (101 / 1440)
            adjusted_save_file_highlight = ((save_file_size_x * (1460 / 1440), save_file_size_y * (290 / 270)), OpenGLTextures['SAVE_FILE_HIGHLIGHT'][1])
            adjusted_chain = ((OpenGLTextures['CHAIN'][0][0], (2.5 * menu_option_height) + (3 * space_between_menu_options)), OpenGLTextures['CHAIN'][1])
            adjusted_shiny_outside = ((OpenGLTextures['SHINY_OUTSIDE'][0][0] * menu_width_aspect, OpenGLTextures['SHINY_OUTSIDE'][0][1] * menu_height_aspect), OpenGLTextures['SHINY_OUTSIDE'][1])
            tan_area_distance_x = adjusted_save_file[0][0] * (92 / 1440)
            tan_area_distance_y = adjusted_save_file[0][1] * (92 / 270)
            blue_area_distance_x = adjusted_save_file[0][0] * (1348 / 1440)
            blue_area_distance_y = adjusted_save_file[0][1] * (178 / 270)
            adjusted_checkmark1 = ((33, 33), OpenGLTextures['CHECK_MARK1'][1])
            adjusted_checkmark2 = ((33, 33), OpenGLTextures['CHECK_MARK2'][1])
            available_distance_between_timer_words = blue_area_distance_y - 15 - 15 - 33
            upgrades_and_tools_x = (save_file_x_pos + hamster_right_save_file + adjusted_hamster_size[0][0])
            space_for_upgrades_and_tools_x = abs(upgrades_and_tools_x - (save_file_x_pos + (adjusted_save_file[0][0] * (1371 / 1440)) - 123))
            space_for_upgrades_and_tools_y = adjusted_save_file[0][1] * (178 / 270)
            bubble_size_for_x = space_for_upgrades_and_tools_x / 8
            bubble_size_for_y = space_for_upgrades_and_tools_y / 2
            x_is_limiting = False
            y_is_limiting = False
            if bubble_size_for_x >= bubble_size_for_y:
              bubble_size_max = bubble_size_for_y
              y_is_limiting = True
            if bubble_size_for_x < bubble_size_for_y:
              bubble_size_max = bubble_size_for_x
              x_is_limiting = True
            bubble_size = bubble_size_max - 6
            adjusted_bubble = ((bubble_size, bubble_size), OpenGLTextures['BUBBLE'][1])
            adjusted_water_portion = ((OpenGLTextures['PUSH_PISTON_COVER'][0][0] * (bubble_size / OpenGLTextures['BUBBLE'][0][0]), OpenGLTextures['PUSH_PISTON_COVER'][0][1] * (bubble_size / OpenGLTextures['BUBBLE'][0][0])), OpenGLTextures['PUSH_PISTON_COVER'][1])
            adjusted_grapple_portion = ((OpenGLTextures['GRAPPLE_PORTION'][0][0] * (bubble_size / OpenGLTextures['BUBBLE'][0][0]), OpenGLTextures['GRAPPLE_PORTION'][0][1] * (bubble_size / OpenGLTextures['BUBBLE'][0][1])), OpenGLTextures['GRAPPLE_PORTION'][1])
            number_of_pixels_to_move = 0
            piston1_width = bubble_size * (34 / 69)
            piston1_height = bubble_size * (9 / 69)
            adjust_water_in_bubble_x = 17 * (bubble_size / OpenGLTextures['BUBBLE'][0][0])
            adjust_water_in_bubble_y = 14 * (bubble_size / OpenGLTextures['BUBBLE'][0][1])
            adjust_grapple_in_bubble_x = 22 * (bubble_size / OpenGLTextures['BUBBLE'][0][0])
            adjust_grapple_in_bubble_y = 31 * (bubble_size / OpenGLTextures['BUBBLE'][0][1])
            adjusted_star = ((OpenGLTextures['STAR'][0][0] * 0.75 * (screen_width / 1360), OpenGLTextures['STAR'][0][1] * 0.75 * (screen_height / 768)), OpenGLTextures['STAR'][1])
            bubble_added_x = 0
            bubble_added_y = 0
            if x_is_limiting:
              bubble_added_y = (space_for_upgrades_and_tools_y - (2 * adjusted_bubble[0][1]) - (3 * 4)) / 2
            if y_is_limiting:
              bubble_added_x = (space_for_upgrades_and_tools_x - (8 * adjusted_bubble[0][0]) - (48)) / 2
            #
            default_menu_option_collision = PyGameTextures['MENU_OPTION_SIZING']
            regular_menu_option = pygame.transform.scale(default_menu_option_collision, (536 * menu_width_aspect, 176 * menu_height_aspect))
            flipped_menu_option = pygame.transform.flip(regular_menu_option, True, False)
            current_scaled_menu_option_collisions = [regular_menu_option, flipped_menu_option, regular_menu_option]
            current_scaled_menu_option_collisions = [pygame.mask.from_surface(x) for x in current_scaled_menu_option_collisions]
            mouse_collision = PyGameTextures['ACTUAL_MOUSE']
            mouse_collision = pygame.mask.from_surface(mouse_collision)
            #
            tentatively_start_playing_file1 = False
            tentatively_start_playing_file2 = False
            tentatively_start_playing_file3 = False
          if not about_to_open_options_menu:
            showing_file_select = True
            scrolling_toward_file_select = True
          about_to_open_options_menu = False
          started_scrolling_time = pygame.time.get_ticks()
      if percent_of_the_way_through_scrolling >= 1:
        allow_another_option_to_scroll_down = True
        started_scrolling_time = pygame.time.get_ticks()
      #
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + menu_option_width - OpenGLTextures['CHAIN'][0][0] - ((2 / 10) * menu_option_width), 0 + menu_scroll_y), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      #
      if menu_scroll_y == 0:
        touching_play_points, touching_play = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - space_between_menu_options)
        if touching_play:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), space_between_menu_options - (10 * menu_height_aspect)), 0, False, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            scrolling_away_main = True
            started_scrolling_time = pygame.time.get_ticks()
      make_opengl_rect(adjusted_play[0], adjusted_play[1], (empty_menu_width, space_between_menu_options + menu_scroll_y), 0, False, (0, 0, adjusted_play[0][0], adjusted_play[0][1]))
      #
      if menu_scroll_y == 0:
        touching_option_points, touching_option = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[1], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - (menu_option_height + (2 * space_between_menu_options)))
        if touching_option:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), menu_option_height + (2 * space_between_menu_options) - (10 * menu_height_aspect)), 0, True, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            about_to_open_options_menu = True
            scrolling_away_main = True
            started_scrolling_time = pygame.time.get_ticks()
            #main_pause_menu()
      make_opengl_rect(adjusted_options[0], adjusted_options[1], (empty_menu_width, menu_option_height + (2 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_options[0][0], adjusted_options[0][1]))
      #
      if menu_scroll_y == 0:
        touching_exit_points, touching_exit = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[1], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - ((2 * menu_option_height) + (3 * space_between_menu_options)))
        if touching_exit:
          make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), (2 * menu_option_height) + (3 * space_between_menu_options) - (10 * menu_height_aspect)), 0, False, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
          if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
            raise SystemExit
      make_opengl_rect(adjusted_exit[0], adjusted_exit[1], (empty_menu_width, (2 * menu_option_height) + (3 * space_between_menu_options) + menu_scroll_y), 0, False, (0, 0, adjusted_exit[0][0], adjusted_exit[0][1]))
    #
    #
    number_of_pixels_to_move += main_delta_milliseconds / 6
    piston1_ltwh = [(486 - ((round(number_of_pixels_to_move))%243))%243, 0, 34, 9]
    #
    #
    cant_select_file1 = False
    cant_select_file2 = False
    cant_select_file3 = False
    if showing_file_select:
      menu_scroll_y = 0
      percent_of_the_way_through_scrolling = (main_curr_time - started_scrolling_time) / 500
      if percent_of_the_way_through_scrolling > 1:
        percent_of_the_way_through_scrolling = 1
      if scrolling_toward_file_select:
        allow_another_option_to_scroll_down = False
        menu_scroll_y = -abs((1 - percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_toward_file_select = False
      if scrolling_away_file_select:
        allow_another_option_to_scroll_down = False
        menu_scroll_y = -abs((percent_of_the_way_through_scrolling) * screen_height)
        if percent_of_the_way_through_scrolling >= 1:
          scrolling_away_file_select = False
          showing_file_select = False
          showing_main = True
          scrolling_toward_main = True
          started_scrolling_time = pygame.time.get_ticks()
      if percent_of_the_way_through_scrolling >= 1:
        allow_another_option_to_scroll_down = True
        started_scrolling_time = pygame.time.get_ticks()
      #
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + ((2 / 10) * menu_option_width), 0 + menu_scroll_y - ((2 * menu_option_height) + (3 * space_between_menu_options))), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      make_opengl_rect(adjusted_chain[0], adjusted_chain[1], (empty_menu_width + menu_option_width - OpenGLTextures['CHAIN'][0][0] - ((2 / 10) * menu_option_width), 0 + menu_scroll_y - ((2 * menu_option_height) + (3 * space_between_menu_options))), 0, False, (0, 0, adjusted_chain[0][0], adjusted_chain[0][1]))
      #
      make_opengl_rect((adjusted_chain[0][0], (3 * empty_space_between_save_files) + (2.5 * adjusted_save_file[0][1])), adjusted_chain[1], (save_file_x_pos + (adjusted_save_file[0][0] * 0.1) - (adjusted_chain[0][0] / 2), menu_scroll_y), 0, False, (0, 0, adjusted_chain[0][0], (3 * empty_space_between_save_files) + (2.5 * adjusted_save_file[0][1])))
      make_opengl_rect((adjusted_chain[0][0], (3 * empty_space_between_save_files) + (2.5 * adjusted_save_file[0][1])), adjusted_chain[1], (save_file_x_pos + (adjusted_save_file[0][0] * 0.9) - (adjusted_chain[0][0] / 2), menu_scroll_y), 0, False, (0, 0, adjusted_chain[0][0], (3 * empty_space_between_save_files) + (2.5 * adjusted_save_file[0][1])))
      #
      if menu_scroll_y == 0:
        touching_play_points, touching_play = find_collisions_with_offsets_pause_menu(mouse_collision, current_scaled_menu_option_collisions[0], Mouse_x - 8 - empty_menu_width, Mouse_y - 8 - space_between_menu_options)
        if touching_play:
          if not tentatively_start_playing_file1 and not tentatively_start_playing_file2 and not tentatively_start_playing_file3 and not tentatively_delete_file1 and not tentatively_delete_file2 and not tentatively_delete_file3:
            make_opengl_rect(adjusted_shiny_outside[0], adjusted_shiny_outside[1], (empty_menu_width - (10 * menu_width_aspect), space_between_menu_options - (10 * menu_height_aspect)), 0, False, (0, 0, adjusted_shiny_outside[0][0], adjusted_shiny_outside[0][1]))
            if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
              scrolling_away_file_select = True
              started_scrolling_time = pygame.time.get_ticks()
      make_opengl_rect(adjusted_back[0], adjusted_back[1], (empty_menu_width, space_between_menu_options + menu_scroll_y), 0, False, (0, 0, adjusted_back[0][0], adjusted_back[0][1]))
      if not scrolling_away_file_select and not scrolling_toward_file_select:
        if Currently_pressed_controls.pressed_controls['PAUSE']:
          if not tentatively_start_playing_file1 and not tentatively_start_playing_file2 and not tentatively_start_playing_file3 and not tentatively_delete_file1 and not tentatively_delete_file2 and not tentatively_delete_file3:
            scrolling_away_file_select = True
            started_scrolling_time = pygame.time.get_ticks()
      #
      shading_file1 = True
      if menu_scroll_y == 0:
        if allow_interacting_with_files:
          if save_file_x_pos <= Mouse_x <= save_file_x_pos + adjusted_save_file[0][0]:
            if empty_space_between_save_files <= Mouse_y <= empty_space_between_save_files + adjusted_save_file[0][1]:
              make_opengl_rect(adjusted_save_file_highlight[0], adjusted_save_file_highlight[1], (save_file_x_pos - (abs(adjusted_save_file_highlight[0][0] - adjusted_save_file[0][0]) / 2), empty_space_between_save_files + menu_scroll_y - (abs(adjusted_save_file_highlight[0][1] - adjusted_save_file[0][1]) / 2)), 0, False, (0, 0, adjusted_save_file_highlight[0][0], adjusted_save_file_highlight[0][1]))
              shading_file1 = False
      make_opengl_rect(adjusted_save_file[0], adjusted_save_file[1], (save_file_x_pos, empty_space_between_save_files + menu_scroll_y), 0, False, (0, 0, adjusted_save_file[0][0], adjusted_save_file[0][1]))
      make_opengl_rect(adjusted_hamster_size[0], OpenGLTextures['THE_BALL_BACK'][1], (save_file_x_pos + hamster_right_save_file, empty_space_between_save_files + menu_scroll_y + hamster_down_save_file), 0, False, (0, 0, adjusted_hamster_size[0][0], adjusted_hamster_size[0][1]))
      if shading_file1:
        make_opengl_rect(adjusted_hamster_size[0], OpenGLTextures['HAMSTER_WALKING_RIGHT'][1][1], (save_file_x_pos + hamster_right_save_file, empty_space_between_save_files + menu_scroll_y + hamster_down_save_file), 0, False, (0, 0, adjusted_hamster_size[0][0], adjusted_hamster_size[0][1]))
      if not shading_file1:
        make_opengl_rect(adjusted_hamster_size[0], OpenGLTextures['HAMSTER_WALKING_RIGHT'][int((main_millisecond_counter % 800) // 200)][1], (save_file_x_pos + hamster_right_save_file, empty_space_between_save_files + menu_scroll_y + hamster_down_save_file), 0, False, (0, 0, adjusted_hamster_size[0][0], adjusted_hamster_size[0][1]))
      make_opengl_rect(adjusted_hamster_size[0], OpenGLTextures['THE_BALL_FRONT'][1], (save_file_x_pos + hamster_right_save_file, empty_space_between_save_files + menu_scroll_y + hamster_down_save_file), 0, False, (0, 0, adjusted_hamster_size[0][0], adjusted_hamster_size[0][1]))
      character_spacing_x = 0
      for SingleCharacter in save_file1_time_string:
        if SingleCharacter != ' ':
          SingleCharacter = 'B' + SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3, OpenGLTextures[SingleCharacter][0][1] * 3), OpenGLTextures[SingleCharacter][1])
          make_opengl_rect(current_character_image[0], current_character_image[1], (save_file_x_pos + (adjusted_save_file[0][0] * (1371 / 1440)) - 123 + character_spacing_x, (adjusted_save_file[0][1] * (60 / 270)) + empty_space_between_save_files + menu_scroll_y), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          character_spacing_x += current_character_image[0][0] + 3
        if SingleCharacter == ' ':
          character_spacing_x += 9
      left_of_character = save_file_x_pos + (adjusted_save_file[0][0] * (1371 / 1440)) - 123
      make_opengl_rect(OpenGLTextures['DISPLAY_PLAYTIME'][0], OpenGLTextures['DISPLAY_PLAYTIME'][1], (left_of_character, (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + empty_space_between_save_files + menu_scroll_y), 0, False, (0, 0, OpenGLTextures['DISPLAY_PLAYTIME'][0][0], OpenGLTextures['DISPLAY_PLAYTIME'][0][1]))
      if allow_interacting_with_files:
        if left_of_character + OpenGLTextures['DISPLAY_PLAYTIME'][0][0] - 3 <= Mouse_x <= left_of_character + OpenGLTextures['DISPLAY_PLAYTIME'][0][0] + adjusted_checkmark2[0][0] + 3:
          if (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + empty_space_between_save_files + menu_scroll_y - 3 <= Mouse_y <= (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + empty_space_between_save_files + menu_scroll_y + adjusted_checkmark1[0][1] + 3:
            cant_select_file1 = True
            make_opengl_rect(adjusted_checkmark1[0], OpenGLTextures['CHECK_MARK_HIGHLIGHT'][1], (left_of_character + OpenGLTextures['DISPLAY_PLAYTIME'][0][0], (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + empty_space_between_save_files + menu_scroll_y), 0, False, (0, 0, adjusted_checkmark1[0][0], adjusted_checkmark1[0][1]))
            if allowed_to_left_click:
              if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
                allowed_to_left_click = False
                for _ in range(1):
                  if save_data_file1[84][0] == '0':
                    everything_save_data_with_path(True, 84, '1', save_data_paths[0])
                    continue
                  if save_data_file1[84][0] == '1':
                    everything_save_data_with_path(True, 84, '0', save_data_paths[0])
                    continue
                save_data_file1 = read_save_file(save_data_paths[0])
      if save_data_file1[84][0] == '0':
        make_opengl_rect(adjusted_checkmark1[0], adjusted_checkmark1[1], (left_of_character + OpenGLTextures['DISPLAY_PLAYTIME'][0][0], (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + empty_space_between_save_files + menu_scroll_y), 0, False, (0, 0, adjusted_checkmark1[0][0], adjusted_checkmark1[0][1]))
      if save_data_file1[84][0] == '1':
        make_opengl_rect(adjusted_checkmark2[0], adjusted_checkmark2[1], (left_of_character + OpenGLTextures['DISPLAY_PLAYTIME'][0][0], (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + empty_space_between_save_files + menu_scroll_y), 0, False, (0, 0, adjusted_checkmark2[0][0], adjusted_checkmark2[0][1]))
      make_opengl_rect((OpenGLTextures['DELETE'][0][0] * 3, OpenGLTextures['DELETE'][0][1] * 3), OpenGLTextures['DELETE'][1], (left_of_character, (tan_area_distance_y / 2) + (available_distance_between_timer_words * 3 / 4) + 15 + 33 + empty_space_between_save_files + menu_scroll_y), 0, False, (0, 0, OpenGLTextures['DELETE'][0][0] * 3, OpenGLTextures['DELETE'][0][1] * 3))
      if allow_interacting_with_files:
        if left_of_character - 3 <= Mouse_x <= left_of_character + (OpenGLTextures['DELETE'][0][0] * 3) + 3:
          if (tan_area_distance_y / 2) + (available_distance_between_timer_words * 3 / 4) + 15 + 33 + empty_space_between_save_files + menu_scroll_y - 3 <= Mouse_y <= (tan_area_distance_y / 2) + (available_distance_between_timer_words * 3 / 4) + 15 + 33 + empty_space_between_save_files + menu_scroll_y + (OpenGLTextures['DELETE'][0][1] * 3) + 3:
            cant_select_file1 = True
            make_opengl_rect(OpenGLTextures['DELETE_HIGHLIGHT'][0], OpenGLTextures['DELETE_HIGHLIGHT'][1], (left_of_character - 10, (tan_area_distance_y / 2) + (available_distance_between_timer_words * 3 / 4) + 15 + 33 + empty_space_between_save_files + menu_scroll_y - 10), 0, False, (0, 0, OpenGLTextures['DELETE_HIGHLIGHT'][0][0], OpenGLTextures['DELETE_HIGHLIGHT'][0][1]))
            if allowed_to_left_click:
              if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
                allowed_to_left_click = False
                tentatively_delete_file1 = True
      top_left_bubble_x = save_file_x_pos + hamster_right_save_file + adjusted_hamster_size[0][0] + bubble_added_x
      top_left_bubble_y = empty_space_between_save_files + (tan_area_distance_y / 2) + menu_scroll_y + bubble_added_y
      make_opengl_rect(adjusted_bubble[0], OpenGLTextures['SCREW_DRIVER'][1], (top_left_bubble_x + (((adjusted_bubble[0][0] * 2) + 5) / 2) - (adjusted_bubble[0][0] / 2) + 5, top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], OpenGLTextures['WIRE_CUTTER'][1], (top_left_bubble_x + 5, top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], OpenGLTextures['WRENCH'][1], (top_left_bubble_x + adjusted_bubble[0][0] + (5 * 2), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + (((adjusted_bubble[0][0] * 2) + 5) / 2) - (adjusted_bubble[0][0] / 2) + 5, top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 5, top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + adjusted_bubble[0][0] + (5 * 2), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file1[16][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + (((adjusted_bubble[0][0] * 2) + 5) / 2) - (adjusted_bubble[0][0] / 2) + 5, top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file1[17][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 5, top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file1[18][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + adjusted_bubble[0][0] + (5 * 2), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file1[27][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file1[32][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file1[28][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file1[33][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file1[29][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file1[34][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file1[30][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file1[35][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file1[31][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file1[36][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file1[38][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file1[37][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      for _ in range(1):
        if shading_file1 or not allow_interacting_with_files:
          make_opengl_rect(adjusted_save_file[0], OpenGLTextures['SAVE_FILE_SHADE'][1], (save_file_x_pos, empty_space_between_save_files + menu_scroll_y), 0, False, (0, 0, adjusted_save_file[0][0], adjusted_save_file[0][1]))
        else:
          if not cant_select_file1:
            if allowed_to_left_click:
              if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
                tentatively_start_playing_file1 = True
                allowed_to_left_click = False
      if save_data_file1[87][0] == '1':
        make_opengl_rect(adjusted_star[0], adjusted_star[1], (save_file_x_pos + adjusted_save_file[0][0] - (3 * adjusted_star[0][0] / 4), empty_space_between_save_files + menu_scroll_y  - (adjusted_star[0][1] / 2)), 0, False, (0, 0, adjusted_star[0][0], adjusted_star[0][1]))
        if shading_file1 or not allow_interacting_with_files:
          make_opengl_rect(adjusted_star[0], OpenGLTextures['SHADY_STAR'][1], (save_file_x_pos + adjusted_save_file[0][0] - (3 * adjusted_star[0][0] / 4), empty_space_between_save_files + menu_scroll_y  - (adjusted_star[0][1] / 2)), 0, False, (0, 0, adjusted_star[0][0], adjusted_star[0][1]))
      #
      shading_file2 = True
      if menu_scroll_y == 0:
        if allow_interacting_with_files:
          if save_file_x_pos <= Mouse_x <= save_file_x_pos + adjusted_save_file[0][0]:
            if (2 * empty_space_between_save_files) + adjusted_save_file[0][1] <= Mouse_y <= (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + adjusted_save_file[0][1]:
              make_opengl_rect(adjusted_save_file_highlight[0], adjusted_save_file_highlight[1], (save_file_x_pos - (abs(adjusted_save_file_highlight[0][0] - adjusted_save_file[0][0]) / 2), (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y - (abs(adjusted_save_file_highlight[0][1] - adjusted_save_file[0][1]) / 2)), 0, False, (0, 0, adjusted_save_file_highlight[0][0], adjusted_save_file_highlight[0][1]))
              shading_file2 = False
      make_opengl_rect(adjusted_save_file[0], adjusted_save_file[1], (save_file_x_pos, (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y), 0, False, (0, 0, adjusted_save_file[0][0], adjusted_save_file[0][1]))
      make_opengl_rect(adjusted_hamster_size[0], OpenGLTextures['THE_BALL_BACK'][1], (save_file_x_pos + hamster_right_save_file, (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y + hamster_down_save_file), 0, False, (0, 0, adjusted_hamster_size[0][0], adjusted_hamster_size[0][1]))
      if shading_file2:
        make_opengl_rect(adjusted_hamster_size[0], OpenGLTextures['HAMSTER_WALKING_RIGHT'][1][1], (save_file_x_pos + hamster_right_save_file, (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y + hamster_down_save_file), 0, False, (0, 0, adjusted_hamster_size[0][0], adjusted_hamster_size[0][1]))
      if not shading_file2:
        make_opengl_rect(adjusted_hamster_size[0], OpenGLTextures['HAMSTER_WALKING_RIGHT'][int((main_millisecond_counter % 800) // 200)][1], (save_file_x_pos + hamster_right_save_file, (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y + hamster_down_save_file), 0, False, (0, 0, adjusted_hamster_size[0][0], adjusted_hamster_size[0][1]))
      make_opengl_rect(adjusted_hamster_size[0], OpenGLTextures['THE_BALL_FRONT'][1], (save_file_x_pos + hamster_right_save_file, (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y + hamster_down_save_file), 0, False, (0, 0, adjusted_hamster_size[0][0], adjusted_hamster_size[0][1]))
      character_spacing_x = 0
      for SingleCharacter in save_file2_time_string:
        if SingleCharacter != ' ':
          SingleCharacter = 'B' + SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3, OpenGLTextures[SingleCharacter][0][1] * 3), OpenGLTextures[SingleCharacter][1])
          make_opengl_rect(current_character_image[0], current_character_image[1], (save_file_x_pos + (adjusted_save_file[0][0] * (1371 / 1440)) - 123 + character_spacing_x, (adjusted_save_file[0][1] * (60 / 270)) + (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          character_spacing_x += current_character_image[0][0] + 3
        if SingleCharacter == ' ':
          character_spacing_x += 9
      left_of_character = save_file_x_pos + (adjusted_save_file[0][0] * (1371 / 1440)) - 123
      make_opengl_rect(OpenGLTextures['DISPLAY_PLAYTIME'][0], OpenGLTextures['DISPLAY_PLAYTIME'][1], (left_of_character, (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y), 0, False, (0, 0, OpenGLTextures['DISPLAY_PLAYTIME'][0][0], OpenGLTextures['DISPLAY_PLAYTIME'][0][1]))
      if allow_interacting_with_files:
        if left_of_character + OpenGLTextures['DISPLAY_PLAYTIME'][0][0] - 3 <= Mouse_x <= left_of_character + OpenGLTextures['DISPLAY_PLAYTIME'][0][0] + adjusted_checkmark2[0][0] + 3:
          if (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y - 3 <= Mouse_y <= (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y + adjusted_checkmark1[0][1] + 3:
            cant_select_file2 = True
            make_opengl_rect(adjusted_checkmark1[0], OpenGLTextures['CHECK_MARK_HIGHLIGHT'][1], (left_of_character + OpenGLTextures['DISPLAY_PLAYTIME'][0][0], (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y), 0, False, (0, 0, adjusted_checkmark1[0][0], adjusted_checkmark1[0][1]))
            if allowed_to_left_click:
              if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
                allowed_to_left_click = False
                for _ in range(1):
                  if save_data_file2[84][0] == '0':
                    everything_save_data_with_path(True, 84, '1', save_data_paths[1])
                    continue
                  if save_data_file2[84][0] == '1':
                    everything_save_data_with_path(True, 84, '0', save_data_paths[1])
                    continue
                save_data_file2 = read_save_file(save_data_paths[1])
      if save_data_file2[84][0] == '0':
        make_opengl_rect(adjusted_checkmark1[0], adjusted_checkmark1[1], (left_of_character + OpenGLTextures['DISPLAY_PLAYTIME'][0][0], (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y), 0, False, (0, 0, adjusted_checkmark1[0][0], adjusted_checkmark1[0][1]))
      if save_data_file2[84][0] == '1':
        make_opengl_rect(adjusted_checkmark2[0], adjusted_checkmark2[1], (left_of_character + OpenGLTextures['DISPLAY_PLAYTIME'][0][0], (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y), 0, False, (0, 0, adjusted_checkmark2[0][0], adjusted_checkmark2[0][1]))
      make_opengl_rect((OpenGLTextures['DELETE'][0][0] * 3, OpenGLTextures['DELETE'][0][1] * 3), OpenGLTextures['DELETE'][1], (left_of_character, (tan_area_distance_y / 2) + (available_distance_between_timer_words * 3 / 4) + 15 + 33 + (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y), 0, False, (0, 0, OpenGLTextures['DELETE'][0][0] * 3, OpenGLTextures['DELETE'][0][1] * 3))
      if allow_interacting_with_files:
        if left_of_character - 3 <= Mouse_x <= left_of_character + (OpenGLTextures['DELETE'][0][0] * 3) + 3:
          if (tan_area_distance_y / 2) + (available_distance_between_timer_words * 3 / 4) + 15 + 33 + (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y - 3 <= Mouse_y <= (tan_area_distance_y / 2) + (available_distance_between_timer_words * 3 / 4) + 15 + 33 + (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y + (OpenGLTextures['DELETE'][0][1] * 3) + 3:
            cant_select_file2 = True
            make_opengl_rect(OpenGLTextures['DELETE_HIGHLIGHT'][0], OpenGLTextures['DELETE_HIGHLIGHT'][1], (left_of_character - 10, (tan_area_distance_y / 2) + (available_distance_between_timer_words * 3 / 4) + 15 + 33 + (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y - 10), 0, False, (0, 0, OpenGLTextures['DELETE_HIGHLIGHT'][0][0], OpenGLTextures['DELETE_HIGHLIGHT'][0][1]))
            if allowed_to_left_click:
              if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
                allowed_to_left_click = False
                tentatively_delete_file2 = True
      top_left_bubble_x = save_file_x_pos + hamster_right_save_file + adjusted_hamster_size[0][0] + bubble_added_x
      top_left_bubble_y = (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + (tan_area_distance_y / 2) + menu_scroll_y + bubble_added_y
      make_opengl_rect(adjusted_bubble[0], OpenGLTextures['SCREW_DRIVER'][1], (top_left_bubble_x + (((adjusted_bubble[0][0] * 2) + 5) / 2) - (adjusted_bubble[0][0] / 2) + 5, top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], OpenGLTextures['WIRE_CUTTER'][1], (top_left_bubble_x + 5, top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], OpenGLTextures['WRENCH'][1], (top_left_bubble_x + adjusted_bubble[0][0] + (5 * 2), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + (((adjusted_bubble[0][0] * 2) + 5) / 2) - (adjusted_bubble[0][0] / 2) + 5, top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 5, top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + adjusted_bubble[0][0] + (5 * 2), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file2[16][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + (((adjusted_bubble[0][0] * 2) + 5) / 2) - (adjusted_bubble[0][0] / 2) + 5, top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file2[17][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 5, top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file2[18][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + adjusted_bubble[0][0] + (5 * 2), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file2[27][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file2[32][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file2[28][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file2[33][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file2[29][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file2[34][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file2[30][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file2[35][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file2[31][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file2[36][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file2[38][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file2[37][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      for _ in range(1):
        if shading_file2 or not allow_interacting_with_files:
          make_opengl_rect(adjusted_save_file[0], OpenGLTextures['SAVE_FILE_SHADE'][1], (save_file_x_pos, (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y), 0, False, (0, 0, adjusted_save_file[0][0], adjusted_save_file[0][1]))
        else:
          if not cant_select_file2:
            if allowed_to_left_click:
              if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
                tentatively_start_playing_file2 = True
                allowed_to_left_click = False
      if save_data_file2[87][0] == '1':
        make_opengl_rect(adjusted_star[0], adjusted_star[1], (save_file_x_pos + adjusted_save_file[0][0] - (3 * adjusted_star[0][0] / 4), (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y  - (adjusted_star[0][1] / 2)), 0, False, (0, 0, adjusted_star[0][0], adjusted_star[0][1]))
        if shading_file2 or not allow_interacting_with_files:
          make_opengl_rect(adjusted_star[0], OpenGLTextures['SHADY_STAR'][1], (save_file_x_pos + adjusted_save_file[0][0] - (3 * adjusted_star[0][0] / 4), (2 * empty_space_between_save_files) + adjusted_save_file[0][1] + menu_scroll_y  - (adjusted_star[0][1] / 2)), 0, False, (0, 0, adjusted_star[0][0], adjusted_star[0][1]))
      #
      shading_file3 = True
      if menu_scroll_y == 0:
        if allow_interacting_with_files:
          if save_file_x_pos <= Mouse_x <= save_file_x_pos + adjusted_save_file[0][0]:
            if (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) <= Mouse_y <= (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + adjusted_save_file[0][1]:
              make_opengl_rect(adjusted_save_file_highlight[0], adjusted_save_file_highlight[1], (save_file_x_pos - (abs(adjusted_save_file_highlight[0][0] - adjusted_save_file[0][0]) / 2), (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y - (abs(adjusted_save_file_highlight[0][1] - adjusted_save_file[0][1]) / 2)), 0, False, (0, 0, adjusted_save_file_highlight[0][0], adjusted_save_file_highlight[0][1]))
              shading_file3 = False
      make_opengl_rect(adjusted_save_file[0], adjusted_save_file[1], (save_file_x_pos, (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y), 0, False, (0, 0, adjusted_save_file[0][0], adjusted_save_file[0][1]))
      make_opengl_rect(adjusted_hamster_size[0], OpenGLTextures['THE_BALL_BACK'][1], (save_file_x_pos + hamster_right_save_file, (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y + hamster_down_save_file), 0, False, (0, 0, adjusted_hamster_size[0][0], adjusted_hamster_size[0][1]))
      if shading_file3:
        make_opengl_rect(adjusted_hamster_size[0], OpenGLTextures['HAMSTER_WALKING_RIGHT'][1][1], (save_file_x_pos + hamster_right_save_file, (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y + hamster_down_save_file), 0, False, (0, 0, adjusted_hamster_size[0][0], adjusted_hamster_size[0][1]))
      if not shading_file3:
        make_opengl_rect(adjusted_hamster_size[0], OpenGLTextures['HAMSTER_WALKING_RIGHT'][int((main_millisecond_counter % 800) // 200)][1], (save_file_x_pos + hamster_right_save_file, (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y + hamster_down_save_file), 0, False, (0, 0, adjusted_hamster_size[0][0], adjusted_hamster_size[0][1]))
      make_opengl_rect(adjusted_hamster_size[0], OpenGLTextures['THE_BALL_FRONT'][1], (save_file_x_pos + hamster_right_save_file, (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y + hamster_down_save_file), 0, False, (0, 0, adjusted_hamster_size[0][0], adjusted_hamster_size[0][1]))
      character_spacing_x = 0
      for SingleCharacter in save_file3_time_string:
        if SingleCharacter != ' ':
          SingleCharacter = 'B' + SingleCharacter
          current_character_image = ((OpenGLTextures[SingleCharacter][0][0] * 3, OpenGLTextures[SingleCharacter][0][1] * 3), OpenGLTextures[SingleCharacter][1])
          make_opengl_rect(current_character_image[0], current_character_image[1], (save_file_x_pos + (adjusted_save_file[0][0] * (1371 / 1440)) - 123 + character_spacing_x, (adjusted_save_file[0][1] * (60 / 270)) + (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y), 0, False, (0, 0, current_character_image[0][0], current_character_image[0][1]))
          character_spacing_x += current_character_image[0][0] + 3
        if SingleCharacter == ' ':
          character_spacing_x += 9
      left_of_character = save_file_x_pos + (adjusted_save_file[0][0] * (1371 / 1440)) - 123
      make_opengl_rect(OpenGLTextures['DISPLAY_PLAYTIME'][0], OpenGLTextures['DISPLAY_PLAYTIME'][1], (left_of_character, (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y), 0, False, (0, 0, OpenGLTextures['DISPLAY_PLAYTIME'][0][0], OpenGLTextures['DISPLAY_PLAYTIME'][0][1]))
      if allow_interacting_with_files:
        if left_of_character + OpenGLTextures['DISPLAY_PLAYTIME'][0][0] - 3 <= Mouse_x <= left_of_character + OpenGLTextures['DISPLAY_PLAYTIME'][0][0] + adjusted_checkmark2[0][0] + 3:
          if (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y - 3 <= Mouse_y <= (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y + adjusted_checkmark1[0][1] + 3:
            cant_select_file3 = True
            make_opengl_rect(adjusted_checkmark1[0], OpenGLTextures['CHECK_MARK_HIGHLIGHT'][1], (left_of_character + OpenGLTextures['DISPLAY_PLAYTIME'][0][0], (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y), 0, False, (0, 0, adjusted_checkmark1[0][0], adjusted_checkmark1[0][1]))
            if allowed_to_left_click:
              if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
                allowed_to_left_click = False
                for _ in range(1):
                  if save_data_file3[84][0] == '0':
                    everything_save_data_with_path(True, 84, '1', save_data_paths[2])
                    continue
                  if save_data_file3[84][0] == '1':
                    everything_save_data_with_path(True, 84, '0', save_data_paths[2])
                    continue
                save_data_file3 = read_save_file(save_data_paths[2])
      if save_data_file3[84][0] == '0':
        make_opengl_rect(adjusted_checkmark1[0], adjusted_checkmark1[1], (left_of_character + OpenGLTextures['DISPLAY_PLAYTIME'][0][0], (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y), 0, False, (0, 0, adjusted_checkmark1[0][0], adjusted_checkmark1[0][1]))
      if save_data_file3[84][0] == '1':
        make_opengl_rect(adjusted_checkmark2[0], adjusted_checkmark2[1], (left_of_character + OpenGLTextures['DISPLAY_PLAYTIME'][0][0], (tan_area_distance_y / 2) + (available_distance_between_timer_words * 2 / 4) + 15 + (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y), 0, False, (0, 0, adjusted_checkmark2[0][0], adjusted_checkmark2[0][1]))
      make_opengl_rect((OpenGLTextures['DELETE'][0][0] * 3, OpenGLTextures['DELETE'][0][1] * 3), OpenGLTextures['DELETE'][1], (left_of_character, (tan_area_distance_y / 2) + (available_distance_between_timer_words * 3 / 4) + 15 + 33 + (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y), 0, False, (0, 0, OpenGLTextures['DELETE'][0][0] * 3, OpenGLTextures['DELETE'][0][1] * 3))
      if allow_interacting_with_files:
        if left_of_character - 3 <= Mouse_x <= left_of_character + (OpenGLTextures['DELETE'][0][0] * 3) + 3:
          if (tan_area_distance_y / 2) + (available_distance_between_timer_words * 3 / 4) + 15 + 33 + (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y - 3 <= Mouse_y <= (tan_area_distance_y / 2) + (available_distance_between_timer_words * 3 / 4) + 15 + 33 + (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y + (OpenGLTextures['DELETE'][0][1] * 3) + 3:
            cant_select_file3 = True
            make_opengl_rect(OpenGLTextures['DELETE_HIGHLIGHT'][0], OpenGLTextures['DELETE_HIGHLIGHT'][1], (left_of_character - 10, (tan_area_distance_y / 2) + (available_distance_between_timer_words * 3 / 4) + 15 + 33 + (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y - 10), 0, False, (0, 0, OpenGLTextures['DELETE_HIGHLIGHT'][0][0], OpenGLTextures['DELETE_HIGHLIGHT'][0][1]))
            if allowed_to_left_click:
              if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
                allowed_to_left_click = False
                tentatively_delete_file3 = True
      top_left_bubble_x = save_file_x_pos + hamster_right_save_file + adjusted_hamster_size[0][0] + bubble_added_x
      top_left_bubble_y = (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + (tan_area_distance_y / 2) + menu_scroll_y + bubble_added_y
      make_opengl_rect(adjusted_bubble[0], OpenGLTextures['SCREW_DRIVER'][1], (top_left_bubble_x + (((adjusted_bubble[0][0] * 2) + 5) / 2) - (adjusted_bubble[0][0] / 2) + 5, top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], OpenGLTextures['WIRE_CUTTER'][1], (top_left_bubble_x + 5, top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], OpenGLTextures['WRENCH'][1], (top_left_bubble_x + adjusted_bubble[0][0] + (5 * 2), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7) + adjust_water_in_bubble_x, top_left_bubble_y + 4 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(OpenGLTextures['PUSH_PISTON_COVER'][0], adjusted_water_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7) + adjust_water_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_water_in_bubble_y), 0, False, (piston1_ltwh[0], 0, piston1_ltwh[0]+piston1_width, piston1_height))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7) + adjust_grapple_in_bubble_x, top_left_bubble_y + 4 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_grapple_portion[0], adjusted_grapple_portion[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7) + adjust_grapple_in_bubble_x, top_left_bubble_y + adjusted_bubble[0][1] + 8 + adjust_grapple_in_bubble_y), 0, False, (0, 0, adjusted_grapple_portion[0][0], adjusted_grapple_portion[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + (((adjusted_bubble[0][0] * 2) + 5) / 2) - (adjusted_bubble[0][0] / 2) + 5, top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 5, top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + adjusted_bubble[0][0] + (5 * 2), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      make_opengl_rect(adjusted_bubble[0], adjusted_bubble[1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file3[16][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + (((adjusted_bubble[0][0] * 2) + 5) / 2) - (adjusted_bubble[0][0] / 2) + 5, top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file3[17][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 5, top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file3[18][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + adjusted_bubble[0][0] + (5 * 2), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file3[27][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file3[32][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 2) + (5 * 2), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file3[28][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file3[33][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 3) + (5 * 3), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file3[29][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file3[34][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 4) + (5 * 4), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file3[30][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file3[35][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 5) + (5 * 5), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file3[31][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file3[36][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 6) + (5 * 6), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file3[38][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7), top_left_bubble_y + 4), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      if save_data_file3[37][0] == '0':
        make_opengl_rect(adjusted_bubble[0], OpenGLTextures['LESS_SHADY_BUBBLE'][1], (top_left_bubble_x + 8 + (adjusted_bubble[0][0] * 7) + (5 * 7), top_left_bubble_y + adjusted_bubble[0][1] + 8), 0, False, (0, 0, adjusted_bubble[0][0], adjusted_bubble[0][1]))
      for _ in range(1):
        if shading_file3 or not allow_interacting_with_files:
          make_opengl_rect(adjusted_save_file[0], OpenGLTextures['SAVE_FILE_SHADE'][1], (save_file_x_pos, (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y), 0, False, (0, 0, adjusted_save_file[0][0], adjusted_save_file[0][1]))
        else:
          if not cant_select_file3:
            if allowed_to_left_click:
              if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
                tentatively_start_playing_file3 = True
                allowed_to_left_click = False
      if save_data_file3[87][0] == '1':
        make_opengl_rect(adjusted_star[0], adjusted_star[1], (save_file_x_pos + adjusted_save_file[0][0] - (3 * adjusted_star[0][0] / 4), (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y  - (adjusted_star[0][1] / 2)), 0, False, (0, 0, adjusted_star[0][0], adjusted_star[0][1]))
        if shading_file3 or not allow_interacting_with_files:
          make_opengl_rect(adjusted_star[0], OpenGLTextures['SHADY_STAR'][1], (save_file_x_pos + adjusted_save_file[0][0] - (3 * adjusted_star[0][0] / 4), (3 * empty_space_between_save_files) + (2 * adjusted_save_file[0][1]) + menu_scroll_y  - (adjusted_star[0][1] / 2)), 0, False, (0, 0, adjusted_star[0][0], adjusted_star[0][1]))
    #
    #
    allow_interacting_with_files = True
    if tentatively_delete_file1 or tentatively_delete_file2 or tentatively_delete_file3:
      allow_interacting_with_files = False
      make_opengl_rect((screen_width, screen_height), OpenGLTextures['SHADY_BLACK_PIXEL'][1], (0, 0), 0, False, (0, 0, screen_width, screen_height))
      confirm_deletion_x = (screen_width - OpenGLTextures['CONFIRM_DELETION'][0][0]) / 2
      confirm_deletion_y = (screen_height - OpenGLTextures['CONFIRM_DELETION'][0][1]) / 2
      make_opengl_rect(OpenGLTextures['CONFIRM_DELETION'][0], OpenGLTextures['CONFIRM_DELETION'][1], (confirm_deletion_x, confirm_deletion_y), 0, False, (0, 0, OpenGLTextures['CONFIRM_DELETION'][0][0], OpenGLTextures['CONFIRM_DELETION'][0][1]))
      available_width_for_yesno = 306 - OpenGLTextures['YES'][0][0] - OpenGLTextures['NO'][0][0]
      make_opengl_rect(OpenGLTextures['YES'][0], OpenGLTextures['YES'][1], (confirm_deletion_x + 98, confirm_deletion_y + 257), 0, False, (0, 0, OpenGLTextures['YES'][0][0], OpenGLTextures['YES'][0][1]))
      make_opengl_rect(OpenGLTextures['NO'][0], OpenGLTextures['NO'][1], (confirm_deletion_x + 257, confirm_deletion_y + 257), 0, False, (0, 0, OpenGLTextures['NO'][0][0], OpenGLTextures['NO'][0][1]))
      if confirm_deletion_x + 98 - 3 <= Mouse_x <= confirm_deletion_x + 98 + OpenGLTextures['YES'][0][0] + 3:
        if confirm_deletion_y + 257 - 3 <= Mouse_y <= confirm_deletion_y + 257 + OpenGLTextures['YES'][0][1] + 3:
          make_opengl_rect(OpenGLTextures['YES_HIGHLIGHT'][0], OpenGLTextures['YES_HIGHLIGHT'][1], (confirm_deletion_x + 98 - 10, confirm_deletion_y + 257 - 10), 0, False, (0, 0, OpenGLTextures['YES_HIGHLIGHT'][0][0], OpenGLTextures['YES_HIGHLIGHT'][0][1]))
          if allowed_to_left_click:
            if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
              allowed_to_left_click = False
              if tentatively_delete_file1:
                tentatively_delete_file1 = False
                start_a_new_save_with_path(save_data_paths[0])
                save_data_file1 = read_save_file(save_data_paths[0])
                save_file1_time_string = milliseconds_to_time_string(int(save_data_file1[83]))
              if tentatively_delete_file2:
                tentatively_delete_file2 = False
                start_a_new_save_with_path(save_data_paths[1])
                save_data_file2 = read_save_file(save_data_paths[1])
                save_file2_time_string = milliseconds_to_time_string(int(save_data_file2[83]))
              if tentatively_delete_file3:
                tentatively_delete_file3 = False
                start_a_new_save_with_path(save_data_paths[2])
                save_data_file3 = read_save_file(save_data_paths[2])
                save_file3_time_string = milliseconds_to_time_string(int(save_data_file3[83]))
      if confirm_deletion_x + 257 <= Mouse_x <= confirm_deletion_x + 257 + OpenGLTextures['NO'][0][0]:
        if confirm_deletion_y + 257 <= Mouse_y <= confirm_deletion_y + 257 + OpenGLTextures['NO'][0][1]:
          make_opengl_rect(OpenGLTextures['NO_HIGHLIGHT'][0], OpenGLTextures['NO_HIGHLIGHT'][1], (confirm_deletion_x + 257 - 10, confirm_deletion_y + 257 - 10), 0, False, (0, 0, OpenGLTextures['NO_HIGHLIGHT'][0][0], OpenGLTextures['NO_HIGHLIGHT'][0][1]))
          if allowed_to_left_click:
            if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
              allowed_to_left_click = False
              tentatively_delete_file1 = False
              tentatively_delete_file2 = False
              tentatively_delete_file3 = False
    #
    #
    if tentatively_start_playing_file1 or tentatively_start_playing_file2 or tentatively_start_playing_file3:
      allow_interacting_with_files = False
      confirm_deletion_x = (screen_width - OpenGLTextures['CONFIRM_PLAY'][0][0]) / 2
      confirm_deletion_y = (screen_height - OpenGLTextures['CONFIRM_PLAY'][0][1]) / 2
      make_opengl_rect(OpenGLTextures['CONFIRM_PLAY'][0], OpenGLTextures['CONFIRM_PLAY'][1], (confirm_deletion_x, confirm_deletion_y), 0, False, (0, 0, OpenGLTextures['CONFIRM_PLAY'][0][0], OpenGLTextures['CONFIRM_PLAY'][0][1]))
      available_width_for_yesno = 306 - OpenGLTextures['YES'][0][0] - OpenGLTextures['NO'][0][0]
      make_opengl_rect(OpenGLTextures['YES'][0], OpenGLTextures['YES'][1], (confirm_deletion_x + 98, confirm_deletion_y + 257), 0, False, (0, 0, OpenGLTextures['YES'][0][0], OpenGLTextures['YES'][0][1]))
      make_opengl_rect(OpenGLTextures['NO'][0], OpenGLTextures['NO'][1], (confirm_deletion_x + 257, confirm_deletion_y + 257), 0, False, (0, 0, OpenGLTextures['NO'][0][0], OpenGLTextures['NO'][0][1]))
      if confirm_deletion_x + 98 - 3 <= Mouse_x <= confirm_deletion_x + 98 + OpenGLTextures['YES'][0][0] + 3:
        if confirm_deletion_y + 257 - 3 <= Mouse_y <= confirm_deletion_y + 257 + OpenGLTextures['YES'][0][1] + 3:
          make_opengl_rect(OpenGLTextures['YES_HIGHLIGHT'][0], OpenGLTextures['YES_HIGHLIGHT'][1], (confirm_deletion_x + 98 - 10, confirm_deletion_y + 257 - 10), 0, False, (0, 0, OpenGLTextures['YES_HIGHLIGHT'][0][0], OpenGLTextures['YES_HIGHLIGHT'][0][1]))
          if allowed_to_left_click:
            if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
              allowed_to_left_click = False
              #
              if tentatively_start_playing_file1:
                save_data_path = save_data_paths[0]
                My_cached_info = CachedInfo()
                if save_data_file1[46][0] == '1':
                  My_cached_info.load_from_previous_location = True
                area_entering_into = save_data_file1[62][0:-1]
                for _ in range(1):
                  if area_entering_into == 'Forest' or area_entering_into == 'Town' or area_entering_into == 'TheDoor1' or area_entering_into == 'TheDoor2' or area_entering_into == 'TheDoor3' or area_entering_into == 'TheDoor4' or area_entering_into == 'TheDoor5' or area_entering_into == 'TheDoor13':
                    if PlayingSewerTheme:
                      pygame.mixer.music.load(ForestThemePath)
                      pygame.mixer.music.play(-1)
                    PlayingForestTheme = True
                    PlayingSewerTheme = False
                  else:
                    if PlayingForestTheme:
                      pygame.mixer.music.load(SewerThemePath)
                      pygame.mixer.music.play(-1)
                    PlayingForestTheme = False
                    PlayingSewerTheme = True
                My_cached_info.PlayingForestTheme = PlayingForestTheme
                My_cached_info.PlayingSewerTheme = PlayingSewerTheme
                GameLoop()
                PlayingForestTheme = My_cached_info.PlayingForestTheme
                PlayingSewerTheme = My_cached_info.PlayingSewerTheme
                save_data_file1 = read_save_file(save_data_paths[0])
                save_file1_time_string = milliseconds_to_time_string(int(save_data_file1[83]))
              #
              if tentatively_start_playing_file2:
                save_data_path = save_data_paths[1]
                My_cached_info = CachedInfo()
                if save_data_file2[46][0] == '1':
                  My_cached_info.load_from_previous_location = True
                area_entering_into = save_data_file2[62][0:-1]
                for _ in range(1):
                  if area_entering_into == 'Forest' or area_entering_into == 'Town' or area_entering_into == 'TheDoor1' or area_entering_into == 'TheDoor2' or area_entering_into == 'TheDoor3' or area_entering_into == 'TheDoor4' or area_entering_into == 'TheDoor5' or area_entering_into == 'TheDoor13':
                    if PlayingSewerTheme:
                      pygame.mixer.music.load(ForestThemePath)
                      pygame.mixer.music.play(-1)
                    PlayingForestTheme = True
                    PlayingSewerTheme = False
                  else:
                    if PlayingForestTheme:
                      pygame.mixer.music.load(SewerThemePath)
                      pygame.mixer.music.play(-1)
                    PlayingForestTheme = False
                    PlayingSewerTheme = True
                My_cached_info.PlayingForestTheme = PlayingForestTheme
                My_cached_info.PlayingSewerTheme = PlayingSewerTheme
                GameLoop()
                PlayingForestTheme = My_cached_info.PlayingForestTheme
                PlayingSewerTheme = My_cached_info.PlayingSewerTheme
                save_data_file2 = read_save_file(save_data_paths[1])
                save_file2_time_string = milliseconds_to_time_string(int(save_data_file2[83]))
              #
              if tentatively_start_playing_file3:
                save_data_path = save_data_paths[2]
                My_cached_info = CachedInfo()
                if save_data_file3[46][0] == '1':
                  My_cached_info.load_from_previous_location = True
                area_entering_into = save_data_file3[62][0:-1]
                for _ in range(1):
                  if area_entering_into == 'Forest' or area_entering_into == 'Town' or area_entering_into == 'TheDoor1' or area_entering_into == 'TheDoor2' or area_entering_into == 'TheDoor3' or area_entering_into == 'TheDoor4' or area_entering_into == 'TheDoor5' or area_entering_into == 'TheDoor13':
                    if PlayingSewerTheme:
                      pygame.mixer.music.load(ForestThemePath)
                      pygame.mixer.music.play(-1)
                    PlayingForestTheme = True
                    PlayingSewerTheme = False
                  else:
                    if PlayingForestTheme:
                      pygame.mixer.music.load(SewerThemePath)
                      pygame.mixer.music.play(-1)
                    PlayingForestTheme = False
                    PlayingSewerTheme = True
                My_cached_info.PlayingForestTheme = PlayingForestTheme
                My_cached_info.PlayingSewerTheme = PlayingSewerTheme
                GameLoop()
                PlayingForestTheme = My_cached_info.PlayingForestTheme
                PlayingSewerTheme = My_cached_info.PlayingSewerTheme
                save_data_file3 = read_save_file(save_data_paths[2])
                save_file3_time_string = milliseconds_to_time_string(int(save_data_file3[83]))
                #
              glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
              available_menu_width = (1 / 3) * screen_width
              available_menu_height = screen_height
              empty_menu_width = (1 / 54) * screen_width
              actual_menu_width = available_menu_width - (2 * empty_menu_width)
              actual_menu_height = available_menu_height
              original_option_menu_width = 600
              original_option_menu_height = 800
              menu_width_aspect = actual_menu_width / original_option_menu_width
              menu_height_aspect = actual_menu_height / original_option_menu_height
              menu_option_height = 176
              menu_option_width = OpenGLTextures['PLAY'][0][0] * menu_width_aspect
              space_between_menu_options = ((original_option_menu_height - (3 * menu_option_height)) / 4) * menu_height_aspect
              menu_option_height = menu_option_height * menu_height_aspect
              adjusted_play = ((OpenGLTextures['PLAY'][0][0] * menu_width_aspect, OpenGLTextures['PLAY'][0][1] * menu_height_aspect), OpenGLTextures['PLAY'][1])
              adjusted_options = ((OpenGLTextures['OPTIONS'][0][0] * menu_width_aspect, OpenGLTextures['OPTIONS'][0][1] * menu_height_aspect), OpenGLTextures['OPTIONS'][1])
              adjusted_exit = ((OpenGLTextures['EXIT'][0][0] * menu_width_aspect, OpenGLTextures['EXIT'][0][1] * menu_height_aspect), OpenGLTextures['EXIT'][1])
              adjusted_back = ((OpenGLTextures['BACK'][0][0] * menu_width_aspect, OpenGLTextures['BACK'][0][1] * menu_height_aspect), OpenGLTextures['BACK'][1])
              save_file_size_x = ((2 / 3) * screen_width) - ((1 / 54) * screen_width)
              save_file_size_y = ((1 / 4) * screen_height)
              save_file_x_pos = ((1 / 3) * screen_width)
              empty_space_between_save_files = ((1 / 4) * screen_height) / 4
              adjusted_save_file = ((save_file_size_x, save_file_size_y), OpenGLTextures['SAVE_FILE'][1])
              save_file_aspect_x = adjusted_save_file[0][0] / OpenGLTextures['SAVE_FILE'][0][0]
              save_file_aspect_y = adjusted_save_file[0][1] / OpenGLTextures['SAVE_FILE'][0][1]
              adjusted_hamster_size = ((OpenGLTextures['THE_BALL_BACK'][0][0] * (save_file_size_y * 1.5 / OpenGLTextures['SAVE_FILE'][0][1]), OpenGLTextures['THE_BALL_BACK'][0][1] * (save_file_size_y * 1.5 / OpenGLTextures['SAVE_FILE'][0][1])), OpenGLTextures['THE_BALL_BACK'][1])
              hamster_down_save_file = ((adjusted_save_file[0][1] - adjusted_hamster_size[0][1]) / 2)
              hamster_right_save_file = adjusted_save_file[0][0] * (101 / 1440)
              adjusted_save_file_highlight = ((save_file_size_x * (1460 / 1440), save_file_size_y * (290 / 270)), OpenGLTextures['SAVE_FILE_HIGHLIGHT'][1])
              adjusted_chain = ((OpenGLTextures['CHAIN'][0][0], (2.5 * menu_option_height) + (3 * space_between_menu_options)), OpenGLTextures['CHAIN'][1])
              adjusted_shiny_outside = ((OpenGLTextures['SHINY_OUTSIDE'][0][0] * menu_width_aspect, OpenGLTextures['SHINY_OUTSIDE'][0][1] * menu_height_aspect), OpenGLTextures['SHINY_OUTSIDE'][1])
              tan_area_distance_x = adjusted_save_file[0][0] * (92 / 1440)
              tan_area_distance_y = adjusted_save_file[0][1] * (92 / 270)
              blue_area_distance_x = adjusted_save_file[0][0] * (1348 / 1440)
              blue_area_distance_y = adjusted_save_file[0][1] * (178 / 270)
              adjusted_checkmark1 = ((33, 33), OpenGLTextures['CHECK_MARK1'][1])
              adjusted_checkmark2 = ((33, 33), OpenGLTextures['CHECK_MARK2'][1])
              available_distance_between_timer_words = blue_area_distance_y - 15 - 15 - 33
              upgrades_and_tools_x = (save_file_x_pos + hamster_right_save_file + adjusted_hamster_size[0][0])
              space_for_upgrades_and_tools_x = abs(upgrades_and_tools_x - (save_file_x_pos + (adjusted_save_file[0][0] * (1371 / 1440)) - 123))
              space_for_upgrades_and_tools_y = adjusted_save_file[0][1] * (178 / 270)
              bubble_size_for_x = space_for_upgrades_and_tools_x / 8
              bubble_size_for_y = space_for_upgrades_and_tools_y / 2
              x_is_limiting = False
              y_is_limiting = False
              if bubble_size_for_x >= bubble_size_for_y:
                bubble_size_max = bubble_size_for_y
                y_is_limiting = True
              if bubble_size_for_x < bubble_size_for_y:
                bubble_size_max = bubble_size_for_x
                x_is_limiting = True
              bubble_size = bubble_size_max - 6
              adjusted_bubble = ((bubble_size, bubble_size), OpenGLTextures['BUBBLE'][1])
              adjusted_water_portion = ((OpenGLTextures['PUSH_PISTON_COVER'][0][0] * (bubble_size / OpenGLTextures['BUBBLE'][0][0]), OpenGLTextures['PUSH_PISTON_COVER'][0][1] * (bubble_size / OpenGLTextures['BUBBLE'][0][0])), OpenGLTextures['PUSH_PISTON_COVER'][1])
              adjusted_grapple_portion = ((OpenGLTextures['GRAPPLE_PORTION'][0][0] * (bubble_size / OpenGLTextures['BUBBLE'][0][0]), OpenGLTextures['GRAPPLE_PORTION'][0][1] * (bubble_size / OpenGLTextures['BUBBLE'][0][1])), OpenGLTextures['GRAPPLE_PORTION'][1])
              number_of_pixels_to_move = 0
              piston1_width = bubble_size * (34 / 69)
              piston1_height = bubble_size * (9 / 69)
              adjust_water_in_bubble_x = 17 * (bubble_size / OpenGLTextures['BUBBLE'][0][0])
              adjust_water_in_bubble_y = 14 * (bubble_size / OpenGLTextures['BUBBLE'][0][1])
              adjust_grapple_in_bubble_x = 22 * (bubble_size / OpenGLTextures['BUBBLE'][0][0])
              adjust_grapple_in_bubble_y = 31 * (bubble_size / OpenGLTextures['BUBBLE'][0][1])
              adjusted_star = ((OpenGLTextures['STAR'][0][0] * 0.75 * (screen_width / 1360), OpenGLTextures['STAR'][0][1] * 0.75 * (screen_height / 768)), OpenGLTextures['STAR'][1])
              bubble_added_x = 0
              bubble_added_y = 0
              if x_is_limiting:
                bubble_added_y = (space_for_upgrades_and_tools_y - (2 * adjusted_bubble[0][1]) - (3 * 4)) / 2
              if y_is_limiting:
                bubble_added_x = (space_for_upgrades_and_tools_x - (8 * adjusted_bubble[0][0]) - (48)) / 2
              #
              default_menu_option_collision = PyGameTextures['MENU_OPTION_SIZING']
              regular_menu_option = pygame.transform.scale(default_menu_option_collision, (536 * menu_width_aspect, 176 * menu_height_aspect))
              flipped_menu_option = pygame.transform.flip(regular_menu_option, True, False)
              current_scaled_menu_option_collisions = [regular_menu_option, flipped_menu_option, regular_menu_option]
              current_scaled_menu_option_collisions = [pygame.mask.from_surface(x) for x in current_scaled_menu_option_collisions]
              mouse_collision = PyGameTextures['ACTUAL_MOUSE']
              mouse_collision = pygame.mask.from_surface(mouse_collision)
              #
              tentatively_start_playing_file1 = False
              tentatively_start_playing_file2 = False
              tentatively_start_playing_file3 = False
      if confirm_deletion_x + 257 <= Mouse_x <= confirm_deletion_x + 257 + OpenGLTextures['NO'][0][0]:
        if confirm_deletion_y + 257 <= Mouse_y <= confirm_deletion_y + 257 + OpenGLTextures['NO'][0][1]:
          make_opengl_rect(OpenGLTextures['NO_HIGHLIGHT'][0], OpenGLTextures['NO_HIGHLIGHT'][1], (confirm_deletion_x + 257 - 10, confirm_deletion_y + 257 - 10), 0, False, (0, 0, OpenGLTextures['NO_HIGHLIGHT'][0][0], OpenGLTextures['NO_HIGHLIGHT'][0][1]))
          if allowed_to_left_click:
            if left_click or Currently_pressed_controls.pressed_controls['EXTEND_WATER_JET']:
              allowed_to_left_click = False
              tentatively_start_playing_file1 = False
              tentatively_start_playing_file2 = False
              tentatively_start_playing_file3 = False
    #
    #
    cur_mouse_x, cur_mouse_y = Mouse_x - (OpenGLTextures['ACTUAL_MOUSE'][0][0]/2), Mouse_y - (OpenGLTextures['ACTUAL_MOUSE'][0][1]/2)
    make_opengl_rect(OpenGLTextures['ACTUAL_MOUSE'][0], OpenGLTextures['ACTUAL_MOUSE'][1], (cur_mouse_x, cur_mouse_y), 0, False, (0, 0, OpenGLTextures['ACTUAL_MOUSE'][0][0], OpenGLTextures['ACTUAL_MOUSE'][0][1]))
    #
    #
    glFlush()
    pygame.display.flip()
    glDeleteTextures(1, np.array([loaded_texture[1]]))
    #
    #
    clock.tick(60)
    main_curr_time = pygame.time.get_ticks()
    main_fps = (1 / (main_curr_time - main_prev_time))*1000
    pygame.display.set_caption("{0}".format(title))
    main_delta_milliseconds = main_curr_time - main_prev_time
    main_millisecond_counter += main_delta_milliseconds
    main_prev_time = main_curr_time
    frames_this_frame_float = (60 / main_fps)
    frames_this_frame_remainder += frames_this_frame_float - int(frames_this_frame_float)
    elapsed_fps_float += frames_this_frame_float
    frames_this_frame = int(frames_this_frame_float)
    if frames_this_frame_remainder >= 1:
      frames_this_frame_remainder %= 1
      frames_this_frame += 1

Main_menu()



try:
  everything_save_data(True, 83, str(My_cached_info.play_time))
except:
  pass







